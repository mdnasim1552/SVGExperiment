/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@joint/core/dist/joint.js"
/*!************************************************!*\
  !*** ./node_modules/@joint/core/dist/joint.js ***!
  \************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

eval("{/*! JointJS v4.2.4 (2026-02-13) - JavaScript diagramming library\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n*/\n\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n})(this, (function (exports) { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n\tfunction commonjsRequire () {\n\t\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n\t}\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n['default'] || n;\n\t}\n\n\tvar check = function (it) {\n\t  return it && it.Math == Math && it;\n\t};\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global_1 =\n\t  // eslint-disable-next-line no-undef\n\t  check(typeof globalThis == 'object' && globalThis) ||\n\t  check(typeof window == 'object' && window) ||\n\t  check(typeof self == 'object' && self) ||\n\t  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n\t  // eslint-disable-next-line no-new-func\n\t  (function () { return this; })() || Function('return this')();\n\n\tvar fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t};\n\n\t// Detect IE8's incomplete defineProperty implementation\n\tvar descriptors = !fails(function () {\n\t  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n\t});\n\n\t'use strict';\n\tvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n\tvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n\t// Nashorn ~ JDK8 bug\n\tvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n\t// `Object.prototype.propertyIsEnumerable` method implementation\n\t// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n\tvar f$4 = NASHORN_BUG ? function propertyIsEnumerable(V) {\n\t  var descriptor = getOwnPropertyDescriptor$2(this, V);\n\t  return !!descriptor && descriptor.enumerable;\n\t} : nativePropertyIsEnumerable;\n\n\tvar objectPropertyIsEnumerable = {\n\t\tf: f$4\n\t};\n\n\tvar createPropertyDescriptor = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar toString = {}.toString;\n\n\tvar classofRaw = function (it) {\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n\tvar split = ''.split;\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar indexedObject = fails(function () {\n\t  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n\t  // eslint-disable-next-line no-prototype-builtins\n\t  return !Object('z').propertyIsEnumerable(0);\n\t}) ? function (it) {\n\t  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n\t} : Object;\n\n\t// `RequireObjectCoercible` abstract operation\n\t// https://tc39.es/ecma262/#sec-requireobjectcoercible\n\tvar requireObjectCoercible = function (it) {\n\t  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n\t  return it;\n\t};\n\n\t// toObject with fallback for non-array-like ES3 strings\n\n\n\n\tvar toIndexedObject = function (it) {\n\t  return indexedObject(requireObjectCoercible(it));\n\t};\n\n\tvar isObject$1 = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\t// `ToPrimitive` abstract operation\n\t// https://tc39.es/ecma262/#sec-toprimitive\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar toPrimitive = function (input, PREFERRED_STRING) {\n\t  if (!isObject$1(input)) return input;\n\t  var fn, val;\n\t  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$1(val = fn.call(input))) return val;\n\t  if (typeof (fn = input.valueOf) == 'function' && !isObject$1(val = fn.call(input))) return val;\n\t  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$1(val = fn.call(input))) return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar hasOwnProperty$1 = {}.hasOwnProperty;\n\n\tvar has$2 = function (it, key) {\n\t  return hasOwnProperty$1.call(it, key);\n\t};\n\n\tvar document$2 = global_1.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar EXISTS = isObject$1(document$2) && isObject$1(document$2.createElement);\n\n\tvar documentCreateElement = function (it) {\n\t  return EXISTS ? document$2.createElement(it) : {};\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar ie8DomDefine = !descriptors && !fails(function () {\n\t  return Object.defineProperty(documentCreateElement('div'), 'a', {\n\t    get: function () { return 7; }\n\t  }).a != 7;\n\t});\n\n\tvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// `Object.getOwnPropertyDescriptor` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n\tvar f$3 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n\t  O = toIndexedObject(O);\n\t  P = toPrimitive(P, true);\n\t  if (ie8DomDefine) try {\n\t    return nativeGetOwnPropertyDescriptor(O, P);\n\t  } catch (error) { /* empty */ }\n\t  if (has$2(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n\t};\n\n\tvar objectGetOwnPropertyDescriptor = {\n\t\tf: f$3\n\t};\n\n\tvar anObject = function (it) {\n\t  if (!isObject$1(it)) {\n\t    throw TypeError(String(it) + ' is not an object');\n\t  } return it;\n\t};\n\n\tvar nativeDefineProperty = Object.defineProperty;\n\n\t// `Object.defineProperty` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperty\n\tvar f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (ie8DomDefine) try {\n\t    return nativeDefineProperty(O, P, Attributes);\n\t  } catch (error) { /* empty */ }\n\t  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n\t  if ('value' in Attributes) O[P] = Attributes.value;\n\t  return O;\n\t};\n\n\tvar objectDefineProperty = {\n\t\tf: f$2\n\t};\n\n\tvar createNonEnumerableProperty = descriptors ? function (object, key, value) {\n\t  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar setGlobal = function (key, value) {\n\t  try {\n\t    createNonEnumerableProperty(global_1, key, value);\n\t  } catch (error) {\n\t    global_1[key] = value;\n\t  } return value;\n\t};\n\n\tvar SHARED = '__core-js_shared__';\n\tvar store$1 = global_1[SHARED] || setGlobal(SHARED, {});\n\n\tvar sharedStore = store$1;\n\n\tvar functionToString = Function.toString;\n\n\t// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\n\tif (typeof sharedStore.inspectSource != 'function') {\n\t  sharedStore.inspectSource = function (it) {\n\t    return functionToString.call(it);\n\t  };\n\t}\n\n\tvar inspectSource = sharedStore.inspectSource;\n\n\tvar WeakMap$2 = global_1.WeakMap;\n\n\tvar nativeWeakMap = typeof WeakMap$2 === 'function' && /native code/.test(inspectSource(WeakMap$2));\n\n\tvar isPure = false;\n\n\tvar shared = createCommonjsModule(function (module) {\n\t(module.exports = function (key, value) {\n\t  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: '3.8.3',\n\t  mode: isPure ? 'pure' : 'global',\n\t  copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'\n\t});\n\t});\n\n\tvar id = 0;\n\tvar postfix = Math.random();\n\n\tvar uid = function (key) {\n\t  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n\t};\n\n\tvar keys$1 = shared('keys');\n\n\tvar sharedKey = function (key) {\n\t  return keys$1[key] || (keys$1[key] = uid(key));\n\t};\n\n\tvar hiddenKeys$1 = {};\n\n\tvar WeakMap$1 = global_1.WeakMap;\n\tvar set$1, get$1, has$1;\n\n\tvar enforce = function (it) {\n\t  return has$1(it) ? get$1(it) : set$1(it, {});\n\t};\n\n\tvar getterFor = function (TYPE) {\n\t  return function (it) {\n\t    var state;\n\t    if (!isObject$1(it) || (state = get$1(it)).type !== TYPE) {\n\t      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n\t    } return state;\n\t  };\n\t};\n\n\tif (nativeWeakMap) {\n\t  var store = sharedStore.state || (sharedStore.state = new WeakMap$1());\n\t  var wmget = store.get;\n\t  var wmhas = store.has;\n\t  var wmset = store.set;\n\t  set$1 = function (it, metadata) {\n\t    metadata.facade = it;\n\t    wmset.call(store, it, metadata);\n\t    return metadata;\n\t  };\n\t  get$1 = function (it) {\n\t    return wmget.call(store, it) || {};\n\t  };\n\t  has$1 = function (it) {\n\t    return wmhas.call(store, it);\n\t  };\n\t} else {\n\t  var STATE = sharedKey('state');\n\t  hiddenKeys$1[STATE] = true;\n\t  set$1 = function (it, metadata) {\n\t    metadata.facade = it;\n\t    createNonEnumerableProperty(it, STATE, metadata);\n\t    return metadata;\n\t  };\n\t  get$1 = function (it) {\n\t    return has$2(it, STATE) ? it[STATE] : {};\n\t  };\n\t  has$1 = function (it) {\n\t    return has$2(it, STATE);\n\t  };\n\t}\n\n\tvar internalState = {\n\t  set: set$1,\n\t  get: get$1,\n\t  has: has$1,\n\t  enforce: enforce,\n\t  getterFor: getterFor\n\t};\n\tvar internalState_1 = internalState.set;\n\tvar internalState_2 = internalState.get;\n\tvar internalState_3 = internalState.has;\n\tvar internalState_4 = internalState.enforce;\n\tvar internalState_5 = internalState.getterFor;\n\n\tvar redefine = createCommonjsModule(function (module) {\n\tvar getInternalState = internalState.get;\n\tvar enforceInternalState = internalState.enforce;\n\tvar TEMPLATE = String(String).split('String');\n\n\t(module.exports = function (O, key, value, options) {\n\t  var unsafe = options ? !!options.unsafe : false;\n\t  var simple = options ? !!options.enumerable : false;\n\t  var noTargetGet = options ? !!options.noTargetGet : false;\n\t  var state;\n\t  if (typeof value == 'function') {\n\t    if (typeof key == 'string' && !has$2(value, 'name')) {\n\t      createNonEnumerableProperty(value, 'name', key);\n\t    }\n\t    state = enforceInternalState(value);\n\t    if (!state.source) {\n\t      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n\t    }\n\t  }\n\t  if (O === global_1) {\n\t    if (simple) O[key] = value;\n\t    else setGlobal(key, value);\n\t    return;\n\t  } else if (!unsafe) {\n\t    delete O[key];\n\t  } else if (!noTargetGet && O[key]) {\n\t    simple = true;\n\t  }\n\t  if (simple) O[key] = value;\n\t  else createNonEnumerableProperty(O, key, value);\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, 'toString', function toString() {\n\t  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n\t});\n\t});\n\n\tvar path = global_1;\n\n\tvar aFunction$1 = function (variable) {\n\t  return typeof variable == 'function' ? variable : undefined;\n\t};\n\n\tvar getBuiltIn = function (namespace, method) {\n\t  return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace])\n\t    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n\t};\n\n\tvar ceil = Math.ceil;\n\tvar floor$1 = Math.floor;\n\n\t// `ToInteger` abstract operation\n\t// https://tc39.es/ecma262/#sec-tointeger\n\tvar toInteger = function (argument) {\n\t  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$1 : ceil)(argument);\n\t};\n\n\tvar min$6 = Math.min;\n\n\t// `ToLength` abstract operation\n\t// https://tc39.es/ecma262/#sec-tolength\n\tvar toLength = function (argument) {\n\t  return argument > 0 ? min$6(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n\t};\n\n\tvar max$4 = Math.max;\n\tvar min$5 = Math.min;\n\n\t// Helper for a popular repeating case of the spec:\n\t// Let integer be ? ToInteger(index).\n\t// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n\tvar toAbsoluteIndex = function (index, length) {\n\t  var integer = toInteger(index);\n\t  return integer < 0 ? max$4(integer + length, 0) : min$5(integer, length);\n\t};\n\n\t// `Array.prototype.{ indexOf, includes }` methods implementation\n\tvar createMethod$2 = function (IS_INCLUDES) {\n\t  return function ($this, el, fromIndex) {\n\t    var O = toIndexedObject($this);\n\t    var length = toLength(O.length);\n\t    var index = toAbsoluteIndex(fromIndex, length);\n\t    var value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    // eslint-disable-next-line no-self-compare\n\t    if (IS_INCLUDES && el != el) while (length > index) {\n\t      value = O[index++];\n\t      // eslint-disable-next-line no-self-compare\n\t      if (value != value) return true;\n\t    // Array#indexOf ignores holes, Array#includes - not\n\t    } else for (;length > index; index++) {\n\t      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n\tvar arrayIncludes = {\n\t  // `Array.prototype.includes` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.includes\n\t  includes: createMethod$2(true),\n\t  // `Array.prototype.indexOf` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n\t  indexOf: createMethod$2(false)\n\t};\n\tvar arrayIncludes_1 = arrayIncludes.includes;\n\tvar arrayIncludes_2 = arrayIncludes.indexOf;\n\n\tvar indexOf = arrayIncludes.indexOf;\n\n\n\tvar objectKeysInternal = function (object, names) {\n\t  var O = toIndexedObject(object);\n\t  var i = 0;\n\t  var result = [];\n\t  var key;\n\t  for (key in O) !has$2(hiddenKeys$1, key) && has$2(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while (names.length > i) if (has$2(O, key = names[i++])) {\n\t    ~indexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n\t// IE8- don't enum bug keys\n\tvar enumBugKeys = [\n\t  'constructor',\n\t  'hasOwnProperty',\n\t  'isPrototypeOf',\n\t  'propertyIsEnumerable',\n\t  'toLocaleString',\n\t  'toString',\n\t  'valueOf'\n\t];\n\n\tvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n\t// `Object.getOwnPropertyNames` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertynames\n\tvar f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n\t  return objectKeysInternal(O, hiddenKeys);\n\t};\n\n\tvar objectGetOwnPropertyNames = {\n\t\tf: f$1\n\t};\n\n\tvar f = Object.getOwnPropertySymbols;\n\n\tvar objectGetOwnPropertySymbols = {\n\t\tf: f\n\t};\n\n\t// all object keys, includes non-enumerable and symbols\n\tvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n\t  var keys = objectGetOwnPropertyNames.f(anObject(it));\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n\t};\n\n\tvar copyConstructorProperties = function (target, source) {\n\t  var keys = ownKeys(source);\n\t  var defineProperty = objectDefineProperty.f;\n\t  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    if (!has$2(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n\t  }\n\t};\n\n\tvar replacement = /#|\\.prototype\\./;\n\n\tvar isForced = function (feature, detection) {\n\t  var value = data$1[normalize(feature)];\n\t  return value == POLYFILL ? true\n\t    : value == NATIVE ? false\n\t    : typeof detection == 'function' ? fails(detection)\n\t    : !!detection;\n\t};\n\n\tvar normalize = isForced.normalize = function (string) {\n\t  return String(string).replace(replacement, '.').toLowerCase();\n\t};\n\n\tvar data$1 = isForced.data = {};\n\tvar NATIVE = isForced.NATIVE = 'N';\n\tvar POLYFILL = isForced.POLYFILL = 'P';\n\n\tvar isForced_1 = isForced;\n\n\tvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\t/*\n\t  options.target      - name of the target object\n\t  options.global      - target is the global object\n\t  options.stat        - export as static methods of target\n\t  options.proto       - export as prototype methods of target\n\t  options.real        - real prototype method for the `pure` version\n\t  options.forced      - export even if the native feature is available\n\t  options.bind        - bind methods to the target, required for the `pure` version\n\t  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n\t  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n\t  options.sham        - add a flag to not completely full polyfills\n\t  options.enumerable  - export as enumerable property\n\t  options.noTargetGet - prevent calling a getter on target\n\t*/\n\tvar _export = function (options, source) {\n\t  var TARGET = options.target;\n\t  var GLOBAL = options.global;\n\t  var STATIC = options.stat;\n\t  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\t  if (GLOBAL) {\n\t    target = global_1;\n\t  } else if (STATIC) {\n\t    target = global_1[TARGET] || setGlobal(TARGET, {});\n\t  } else {\n\t    target = (global_1[TARGET] || {}).prototype;\n\t  }\n\t  if (target) for (key in source) {\n\t    sourceProperty = source[key];\n\t    if (options.noTargetGet) {\n\t      descriptor = getOwnPropertyDescriptor$1(target, key);\n\t      targetProperty = descriptor && descriptor.value;\n\t    } else targetProperty = target[key];\n\t    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n\t    // contained in target\n\t    if (!FORCED && targetProperty !== undefined) {\n\t      if (typeof sourceProperty === typeof targetProperty) continue;\n\t      copyConstructorProperties(sourceProperty, targetProperty);\n\t    }\n\t    // add a flag to not completely full polyfills\n\t    if (options.sham || (targetProperty && targetProperty.sham)) {\n\t      createNonEnumerableProperty(sourceProperty, 'sham', true);\n\t    }\n\t    // extend global\n\t    redefine(target, key, sourceProperty, options);\n\t  }\n\t};\n\n\tvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n\t  // Chrome 38 Symbol has incorrect toString conversion\n\t  // eslint-disable-next-line no-undef\n\t  return !String(Symbol());\n\t});\n\n\tvar useSymbolAsUid = nativeSymbol\n\t  // eslint-disable-next-line no-undef\n\t  && !Symbol.sham\n\t  // eslint-disable-next-line no-undef\n\t  && typeof Symbol.iterator == 'symbol';\n\n\tvar WellKnownSymbolsStore = shared('wks');\n\tvar Symbol$1 = global_1.Symbol;\n\tvar createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;\n\n\tvar wellKnownSymbol = function (name) {\n\t  if (!has$2(WellKnownSymbolsStore, name)) {\n\t    if (nativeSymbol && has$2(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];\n\t    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n\t  } return WellKnownSymbolsStore[name];\n\t};\n\n\t// `Object.keys` method\n\t// https://tc39.es/ecma262/#sec-object.keys\n\tvar objectKeys = Object.keys || function keys(O) {\n\t  return objectKeysInternal(O, enumBugKeys);\n\t};\n\n\t// `Object.defineProperties` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperties\n\tvar objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var keys = objectKeys(Properties);\n\t  var length = keys.length;\n\t  var index = 0;\n\t  var key;\n\t  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);\n\t  return O;\n\t};\n\n\tvar html$1 = getBuiltIn('document', 'documentElement');\n\n\tvar GT = '>';\n\tvar LT = '<';\n\tvar PROTOTYPE = 'prototype';\n\tvar SCRIPT = 'script';\n\tvar IE_PROTO$1 = sharedKey('IE_PROTO');\n\n\tvar EmptyConstructor = function () { /* empty */ };\n\n\tvar scriptTag = function (content) {\n\t  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n\t};\n\n\t// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n\tvar NullProtoObjectViaActiveX = function (activeXDocument) {\n\t  activeXDocument.write(scriptTag(''));\n\t  activeXDocument.close();\n\t  var temp = activeXDocument.parentWindow.Object;\n\t  activeXDocument = null; // avoid memory leak\n\t  return temp;\n\t};\n\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar NullProtoObjectViaIFrame = function () {\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = documentCreateElement('iframe');\n\t  var JS = 'java' + SCRIPT + ':';\n\t  var iframeDocument;\n\t  iframe.style.display = 'none';\n\t  html$1.appendChild(iframe);\n\t  // https://github.com/zloirock/core-js/issues/475\n\t  iframe.src = String(JS);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(scriptTag('document.F=Object'));\n\t  iframeDocument.close();\n\t  return iframeDocument.F;\n\t};\n\n\t// Check for document.domain and active x support\n\t// No need to use active x approach when document.domain is not set\n\t// see https://github.com/es-shims/es5-shim/issues/150\n\t// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n\t// avoid IE GC bug\n\tvar activeXDocument;\n\tvar NullProtoObject = function () {\n\t  try {\n\t    /* global ActiveXObject */\n\t    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n\t  } catch (error) { /* ignore */ }\n\t  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n\t  var length = enumBugKeys.length;\n\t  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n\t  return NullProtoObject();\n\t};\n\n\thiddenKeys$1[IE_PROTO$1] = true;\n\n\t// `Object.create` method\n\t// https://tc39.es/ecma262/#sec-object.create\n\tvar objectCreate = Object.create || function create(O, Properties) {\n\t  var result;\n\t  if (O !== null) {\n\t    EmptyConstructor[PROTOTYPE] = anObject(O);\n\t    result = new EmptyConstructor();\n\t    EmptyConstructor[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO$1] = O;\n\t  } else result = NullProtoObject();\n\t  return Properties === undefined ? result : objectDefineProperties(result, Properties);\n\t};\n\n\tvar UNSCOPABLES = wellKnownSymbol('unscopables');\n\tvar ArrayPrototype$1 = Array.prototype;\n\n\t// Array.prototype[@@unscopables]\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\tif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n\t  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {\n\t    configurable: true,\n\t    value: objectCreate(null)\n\t  });\n\t}\n\n\t// add a key to Array.prototype[@@unscopables]\n\tvar addToUnscopables = function (key) {\n\t  ArrayPrototype$1[UNSCOPABLES][key] = true;\n\t};\n\n\tvar defineProperty$1 = Object.defineProperty;\n\tvar cache = {};\n\n\tvar thrower = function (it) { throw it; };\n\n\tvar arrayMethodUsesToLength = function (METHOD_NAME, options) {\n\t  if (has$2(cache, METHOD_NAME)) return cache[METHOD_NAME];\n\t  if (!options) options = {};\n\t  var method = [][METHOD_NAME];\n\t  var ACCESSORS = has$2(options, 'ACCESSORS') ? options.ACCESSORS : false;\n\t  var argument0 = has$2(options, 0) ? options[0] : thrower;\n\t  var argument1 = has$2(options, 1) ? options[1] : undefined;\n\n\t  return cache[METHOD_NAME] = !!method && !fails(function () {\n\t    if (ACCESSORS && !descriptors) return true;\n\t    var O = { length: -1 };\n\n\t    if (ACCESSORS) defineProperty$1(O, 1, { enumerable: true, get: thrower });\n\t    else O[1] = 1;\n\n\t    method.call(O, argument0, argument1);\n\t  });\n\t};\n\n\t'use strict';\n\n\tvar $includes = arrayIncludes.includes;\n\n\n\n\tvar USES_TO_LENGTH$2 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });\n\n\t// `Array.prototype.includes` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.includes\n\t_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$2 }, {\n\t  includes: function includes(el /* , fromIndex = 0 */) {\n\t    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('includes');\n\n\tvar es_array_includes = {\n\n\t};\n\n\tvar aFunction = function (it) {\n\t  if (typeof it != 'function') {\n\t    throw TypeError(String(it) + ' is not a function');\n\t  } return it;\n\t};\n\n\t// optional / simple context binding\n\tvar functionBindContext = function (fn, that, length) {\n\t  aFunction(fn);\n\t  if (that === undefined) return fn;\n\t  switch (length) {\n\t    case 0: return function () {\n\t      return fn.call(that);\n\t    };\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar call = Function.call;\n\n\tvar entryUnbind = function (CONSTRUCTOR, METHOD, length) {\n\t  return functionBindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length);\n\t};\n\n\tvar includes$3 = entryUnbind('Array', 'includes');\n\n\tvar includes$2 = includes$3;\n\n\t// `ToObject` abstract operation\n\t// https://tc39.es/ecma262/#sec-toobject\n\tvar toObject = function (argument) {\n\t  return Object(requireObjectCoercible(argument));\n\t};\n\n\t// `IsArray` abstract operation\n\t// https://tc39.es/ecma262/#sec-isarray\n\tvar isArray = Array.isArray || function isArray(arg) {\n\t  return classofRaw(arg) == 'Array';\n\t};\n\n\tvar SPECIES = wellKnownSymbol('species');\n\n\t// `ArraySpeciesCreate` abstract operation\n\t// https://tc39.es/ecma262/#sec-arrayspeciescreate\n\tvar arraySpeciesCreate = function (originalArray, length) {\n\t  var C;\n\t  if (isArray(originalArray)) {\n\t    C = originalArray.constructor;\n\t    // cross-realm fallback\n\t    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n\t    else if (isObject$1(C)) {\n\t      C = C[SPECIES];\n\t      if (C === null) C = undefined;\n\t    }\n\t  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n\t};\n\n\tvar push = [].push;\n\n\t// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\n\tvar createMethod$1 = function (TYPE) {\n\t  var IS_MAP = TYPE == 1;\n\t  var IS_FILTER = TYPE == 2;\n\t  var IS_SOME = TYPE == 3;\n\t  var IS_EVERY = TYPE == 4;\n\t  var IS_FIND_INDEX = TYPE == 6;\n\t  var IS_FILTER_OUT = TYPE == 7;\n\t  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n\t  return function ($this, callbackfn, that, specificCreate) {\n\t    var O = toObject($this);\n\t    var self = indexedObject(O);\n\t    var boundFunction = functionBindContext(callbackfn, that, 3);\n\t    var length = toLength(self.length);\n\t    var index = 0;\n\t    var create = specificCreate || arraySpeciesCreate;\n\t    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\n\t    var value, result;\n\t    for (;length > index; index++) if (NO_HOLES || index in self) {\n\t      value = self[index];\n\t      result = boundFunction(value, index, O);\n\t      if (TYPE) {\n\t        if (IS_MAP) target[index] = result; // map\n\t        else if (result) switch (TYPE) {\n\t          case 3: return true;              // some\n\t          case 5: return value;             // find\n\t          case 6: return index;             // findIndex\n\t          case 2: push.call(target, value); // filter\n\t        } else switch (TYPE) {\n\t          case 4: return false;             // every\n\t          case 7: push.call(target, value); // filterOut\n\t        }\n\t      }\n\t    }\n\t    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n\t  };\n\t};\n\n\tvar arrayIteration = {\n\t  // `Array.prototype.forEach` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n\t  forEach: createMethod$1(0),\n\t  // `Array.prototype.map` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.map\n\t  map: createMethod$1(1),\n\t  // `Array.prototype.filter` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.filter\n\t  filter: createMethod$1(2),\n\t  // `Array.prototype.some` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.some\n\t  some: createMethod$1(3),\n\t  // `Array.prototype.every` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.every\n\t  every: createMethod$1(4),\n\t  // `Array.prototype.find` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.find\n\t  find: createMethod$1(5),\n\t  // `Array.prototype.findIndex` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n\t  findIndex: createMethod$1(6),\n\t  // `Array.prototype.filterOut` method\n\t  // https://github.com/tc39/proposal-array-filtering\n\t  filterOut: createMethod$1(7)\n\t};\n\tvar arrayIteration_1 = arrayIteration.forEach;\n\tvar arrayIteration_2 = arrayIteration.map;\n\tvar arrayIteration_3 = arrayIteration.filter;\n\tvar arrayIteration_4 = arrayIteration.some;\n\tvar arrayIteration_5 = arrayIteration.every;\n\tvar arrayIteration_6 = arrayIteration.find;\n\tvar arrayIteration_7 = arrayIteration.findIndex;\n\tvar arrayIteration_8 = arrayIteration.filterOut;\n\n\t'use strict';\n\n\tvar $find = arrayIteration.find;\n\n\n\n\tvar FIND = 'find';\n\tvar SKIPS_HOLES$1 = true;\n\n\tvar USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND);\n\n\t// Shouldn't skip holes\n\tif (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES$1 = false; });\n\n\t// `Array.prototype.find` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.find\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$1 }, {\n\t  find: function find(callbackfn /* , that = undefined */) {\n\t    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND);\n\n\tvar es_array_find = {\n\n\t};\n\n\tvar find$1 = entryUnbind('Array', 'find');\n\n\tvar find = find$1;\n\n\t// `String.prototype.{ codePointAt, at }` methods implementation\n\tvar createMethod = function (CONVERT_TO_STRING) {\n\t  return function ($this, pos) {\n\t    var S = String(requireObjectCoercible($this));\n\t    var position = toInteger(pos);\n\t    var size = S.length;\n\t    var first, second;\n\t    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n\t    first = S.charCodeAt(position);\n\t    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n\t      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n\t        ? CONVERT_TO_STRING ? S.charAt(position) : first\n\t        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n\t  };\n\t};\n\n\tvar stringMultibyte = {\n\t  // `String.prototype.codePointAt` method\n\t  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n\t  codeAt: createMethod(false),\n\t  // `String.prototype.at` method\n\t  // https://github.com/mathiasbynens/String.prototype.at\n\t  charAt: createMethod(true)\n\t};\n\tvar stringMultibyte_1 = stringMultibyte.codeAt;\n\tvar stringMultibyte_2 = stringMultibyte.charAt;\n\n\tvar correctPrototypeGetter = !fails(function () {\n\t  function F() { /* empty */ }\n\t  F.prototype.constructor = null;\n\t  return Object.getPrototypeOf(new F()) !== F.prototype;\n\t});\n\n\tvar IE_PROTO = sharedKey('IE_PROTO');\n\tvar ObjectPrototype = Object.prototype;\n\n\t// `Object.getPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.getprototypeof\n\tvar objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n\t  O = toObject(O);\n\t  if (has$2(O, IE_PROTO)) return O[IE_PROTO];\n\t  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectPrototype : null;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\n\tvar ITERATOR$4 = wellKnownSymbol('iterator');\n\tvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n\tvar returnThis$2 = function () { return this; };\n\n\t// `%IteratorPrototype%` object\n\t// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n\tvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n\tif ([].keys) {\n\t  arrayIterator = [].keys();\n\t  // Safari 8 has buggy iterators w/o `next`\n\t  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n\t  else {\n\t    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n\t    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n\t  }\n\t}\n\n\tvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails(function () {\n\t  var test = {};\n\t  // FF44- legacy iterators case\n\t  return IteratorPrototype$2[ITERATOR$4].call(test) !== test;\n\t});\n\n\tif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\tif ((!isPure || NEW_ITERATOR_PROTOTYPE) && !has$2(IteratorPrototype$2, ITERATOR$4)) {\n\t  createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$4, returnThis$2);\n\t}\n\n\tvar iteratorsCore = {\n\t  IteratorPrototype: IteratorPrototype$2,\n\t  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n\t};\n\tvar iteratorsCore_1 = iteratorsCore.IteratorPrototype;\n\tvar iteratorsCore_2 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\n\tvar defineProperty = objectDefineProperty.f;\n\n\n\n\tvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\n\tvar setToStringTag = function (it, TAG, STATIC) {\n\t  if (it && !has$2(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {\n\t    defineProperty(it, TO_STRING_TAG$2, { configurable: true, value: TAG });\n\t  }\n\t};\n\n\tvar iterators = {};\n\n\t'use strict';\n\tvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\n\n\n\n\n\tvar returnThis$1 = function () { return this; };\n\n\tvar createIteratorConstructor = function (IteratorConstructor, NAME, next) {\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });\n\t  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n\t  iterators[TO_STRING_TAG] = returnThis$1;\n\t  return IteratorConstructor;\n\t};\n\n\tvar aPossiblePrototype = function (it) {\n\t  if (!isObject$1(it) && it !== null) {\n\t    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n\t  } return it;\n\t};\n\n\t// `Object.setPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.setprototypeof\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n\t  var CORRECT_SETTER = false;\n\t  var test = {};\n\t  var setter;\n\t  try {\n\t    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n\t    setter.call(test, []);\n\t    CORRECT_SETTER = test instanceof Array;\n\t  } catch (error) { /* empty */ }\n\t  return function setPrototypeOf(O, proto) {\n\t    anObject(O);\n\t    aPossiblePrototype(proto);\n\t    if (CORRECT_SETTER) setter.call(O, proto);\n\t    else O.__proto__ = proto;\n\t    return O;\n\t  };\n\t}() : undefined);\n\n\t'use strict';\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar IteratorPrototype = iteratorsCore.IteratorPrototype;\n\tvar BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\tvar ITERATOR$3 = wellKnownSymbol('iterator');\n\tvar KEYS = 'keys';\n\tvar VALUES = 'values';\n\tvar ENTRIES = 'entries';\n\n\tvar returnThis = function () { return this; };\n\n\tvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n\t  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n\t  var getIterationMethod = function (KIND) {\n\t    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n\t    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n\t    switch (KIND) {\n\t      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n\t      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n\t      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n\t    } return function () { return new IteratorConstructor(this); };\n\t  };\n\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  var INCORRECT_VALUES_NAME = false;\n\t  var IterablePrototype = Iterable.prototype;\n\t  var nativeIterator = IterablePrototype[ITERATOR$3]\n\t    || IterablePrototype['@@iterator']\n\t    || DEFAULT && IterablePrototype[DEFAULT];\n\t  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n\t  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n\t  var CurrentIteratorPrototype, methods, KEY;\n\n\t  // fix native\n\t  if (anyNativeIterator) {\n\t    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\t    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n\t      if (!isPure && objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n\t        if (objectSetPrototypeOf) {\n\t          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n\t        } else if (typeof CurrentIteratorPrototype[ITERATOR$3] != 'function') {\n\t          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$3, returnThis);\n\t        }\n\t      }\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n\t      if (isPure) iterators[TO_STRING_TAG] = returnThis;\n\t    }\n\t  }\n\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n\t    INCORRECT_VALUES_NAME = true;\n\t    defaultIterator = function values() { return nativeIterator.call(this); };\n\t  }\n\n\t  // define iterator\n\t  if ((!isPure || FORCED) && IterablePrototype[ITERATOR$3] !== defaultIterator) {\n\t    createNonEnumerableProperty(IterablePrototype, ITERATOR$3, defaultIterator);\n\t  }\n\t  iterators[NAME] = defaultIterator;\n\n\t  // export additional methods\n\t  if (DEFAULT) {\n\t    methods = {\n\t      values: getIterationMethod(VALUES),\n\t      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n\t      entries: getIterationMethod(ENTRIES)\n\t    };\n\t    if (FORCED) for (KEY in methods) {\n\t      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n\t        redefine(IterablePrototype, KEY, methods[KEY]);\n\t      }\n\t    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n\t  }\n\n\t  return methods;\n\t};\n\n\t'use strict';\n\tvar charAt = stringMultibyte.charAt;\n\n\n\n\tvar STRING_ITERATOR = 'String Iterator';\n\tvar setInternalState = internalState.set;\n\tvar getInternalState = internalState.getterFor(STRING_ITERATOR);\n\n\t// `String.prototype[@@iterator]` method\n\t// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n\tdefineIterator(String, 'String', function (iterated) {\n\t  setInternalState(this, {\n\t    type: STRING_ITERATOR,\n\t    string: String(iterated),\n\t    index: 0\n\t  });\n\t// `%StringIteratorPrototype%.next` method\n\t// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n\t}, function next() {\n\t  var state = getInternalState(this);\n\t  var string = state.string;\n\t  var index = state.index;\n\t  var point;\n\t  if (index >= string.length) return { value: undefined, done: true };\n\t  point = charAt(string, index);\n\t  state.index += point.length;\n\t  return { value: point, done: false };\n\t});\n\n\tvar es_string_iterator = {\n\n\t};\n\n\tvar iteratorClose = function (iterator) {\n\t  var returnMethod = iterator['return'];\n\t  if (returnMethod !== undefined) {\n\t    return anObject(returnMethod.call(iterator)).value;\n\t  }\n\t};\n\n\t// call something on iterator step with safe closing on error\n\tvar callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {\n\t  try {\n\t    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch (error) {\n\t    iteratorClose(iterator);\n\t    throw error;\n\t  }\n\t};\n\n\tvar ITERATOR$2 = wellKnownSymbol('iterator');\n\tvar ArrayPrototype = Array.prototype;\n\n\t// check on default Array iterator\n\tvar isArrayIteratorMethod = function (it) {\n\t  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR$2] === it);\n\t};\n\n\t'use strict';\n\n\n\n\n\tvar createProperty = function (object, key, value) {\n\t  var propertyKey = toPrimitive(key);\n\t  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));\n\t  else object[propertyKey] = value;\n\t};\n\n\tvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');\n\tvar test = {};\n\n\ttest[TO_STRING_TAG$1] = 'z';\n\n\tvar toStringTagSupport = String(test) === '[object z]';\n\n\tvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\t// ES3 wrong here\n\tvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function (it, key) {\n\t  try {\n\t    return it[key];\n\t  } catch (error) { /* empty */ }\n\t};\n\n\t// getting tag from ES6+ `Object.prototype.toString`\n\tvar classof = toStringTagSupport ? classofRaw : function (it) {\n\t  var O, tag, result;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n\t    // builtinTag case\n\t    : CORRECT_ARGUMENTS ? classofRaw(O)\n\t    // ES3 arguments fallback\n\t    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n\t};\n\n\tvar ITERATOR$1 = wellKnownSymbol('iterator');\n\n\tvar getIteratorMethod = function (it) {\n\t  if (it != undefined) return it[ITERATOR$1]\n\t    || it['@@iterator']\n\t    || iterators[classof(it)];\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\n\n\t// `Array.from` method implementation\n\t// https://tc39.es/ecma262/#sec-array.from\n\tvar arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n\t  var O = toObject(arrayLike);\n\t  var C = typeof this == 'function' ? this : Array;\n\t  var argumentsLength = arguments.length;\n\t  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n\t  var mapping = mapfn !== undefined;\n\t  var iteratorMethod = getIteratorMethod(O);\n\t  var index = 0;\n\t  var length, result, step, iterator, next, value;\n\t  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n\t  // if the target is not iterable or it's an array with the default iterator - use a simple case\n\t  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n\t    iterator = iteratorMethod.call(O);\n\t    next = iterator.next;\n\t    result = new C();\n\t    for (;!(step = next.call(iterator)).done; index++) {\n\t      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n\t      createProperty(result, index, value);\n\t    }\n\t  } else {\n\t    length = toLength(O.length);\n\t    result = new C(length);\n\t    for (;length > index; index++) {\n\t      value = mapping ? mapfn(O[index], index) : O[index];\n\t      createProperty(result, index, value);\n\t    }\n\t  }\n\t  result.length = index;\n\t  return result;\n\t};\n\n\tvar ITERATOR = wellKnownSymbol('iterator');\n\tvar SAFE_CLOSING = false;\n\n\ttry {\n\t  var called = 0;\n\t  var iteratorWithReturn = {\n\t    next: function () {\n\t      return { done: !!called++ };\n\t    },\n\t    'return': function () {\n\t      SAFE_CLOSING = true;\n\t    }\n\t  };\n\t  iteratorWithReturn[ITERATOR] = function () {\n\t    return this;\n\t  };\n\t  // eslint-disable-next-line no-throw-literal\n\t  Array.from(iteratorWithReturn, function () { throw 2; });\n\t} catch (error) { /* empty */ }\n\n\tvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n\t  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n\t  var ITERATION_SUPPORT = false;\n\t  try {\n\t    var object = {};\n\t    object[ITERATOR] = function () {\n\t      return {\n\t        next: function () {\n\t          return { done: ITERATION_SUPPORT = true };\n\t        }\n\t      };\n\t    };\n\t    exec(object);\n\t  } catch (error) { /* empty */ }\n\t  return ITERATION_SUPPORT;\n\t};\n\n\tvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n\t  Array.from(iterable);\n\t});\n\n\t// `Array.from` method\n\t// https://tc39.es/ecma262/#sec-array.from\n\t_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n\t  from: arrayFrom\n\t});\n\n\tvar es_array_from = {\n\n\t};\n\n\tvar from_1$1 = path.Array.from;\n\n\tvar from_1 = from_1$1;\n\n\t'use strict';\n\n\tvar $findIndex = arrayIteration.findIndex;\n\n\n\n\tvar FIND_INDEX = 'findIndex';\n\tvar SKIPS_HOLES = true;\n\n\tvar USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);\n\n\t// Shouldn't skip holes\n\tif (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });\n\n\t// `Array.prototype.findIndex` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.findindex\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {\n\t  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n\t    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND_INDEX);\n\n\tvar es_array_findIndex = {\n\n\t};\n\n\tvar findIndex$1 = entryUnbind('Array', 'findIndex');\n\n\tvar findIndex = findIndex$1;\n\n\tvar base64 = createCommonjsModule(function (module, exports) {\n\t  (function () {\n\t    /**\n\t     * version: 0.3.0\n\t     * git://github.com/davidchambers/Base64.js.git\n\t     */\n\n\t    var object =  true ? exports : 0; // #8: web workers\n\t    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t    function InvalidCharacterError(message) {\n\t      this.message = message;\n\t    }\n\t    InvalidCharacterError.prototype = new Error();\n\t    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n\t    // encoder\n\t    // [https://gist.github.com/999166] by [https://github.com/nignag]\n\t    object.btoa || (object.btoa = function (input) {\n\t      var str = String(input);\n\t      for (\n\t      // initialize result and counter\n\t      var block, charCode, idx = 0, map = chars, output = '';\n\t      // if the next str index does not exist:\n\t      //   change the mapping table to \"=\"\n\t      //   check if d has no fractional digits\n\t      str.charAt(idx | 0) || (map = '=', idx % 1);\n\t      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n\t      output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {\n\t        charCode = str.charCodeAt(idx += 3 / 4);\n\t        if (charCode > 0xFF) {\n\t          throw new InvalidCharacterError('\\'btoa\\' failed: The string to be encoded contains characters outside of the Latin1 range.');\n\t        }\n\t        block = block << 8 | charCode;\n\t      }\n\t      return output;\n\t    });\n\n\t    // decoder\n\t    // [https://gist.github.com/1020396] by [https://github.com/atk]\n\t    object.atob || (object.atob = function (input) {\n\t      var str = String(input).replace(/=+$/, '');\n\t      if (str.length % 4 == 1) {\n\t        throw new InvalidCharacterError('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n\t      }\n\t      for (\n\t      // initialize result and counters\n\t      var bc = 0, bs, buffer, idx = 0, output = '';\n\t      // get next character\n\t      // eslint-disable-next-line no-cond-assign\n\t      buffer = str.charAt(idx++);\n\t      // character found in table? initialize bit storage and add its ascii value;\n\t      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n\t      // and if not first of each 4 characters,\n\t      // convert the first 8 bits to one ascii character\n\t      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n\t        // try to find character in table (0-63, not found => -1)\n\t        buffer = chars.indexOf(buffer);\n\t      }\n\t      return output;\n\t    });\n\t  })();\n\t});\n\n\t// `Number.isNaN` method\n\t// https://tc39.es/ecma262/#sec-number.isnan\n\t_export({ target: 'Number', stat: true }, {\n\t  isNaN: function isNaN(number) {\n\t    // eslint-disable-next-line no-self-compare\n\t    return number != number;\n\t  }\n\t});\n\n\tvar es_number_isNan = {\n\n\t};\n\n\tvar isNan$1 = path.Number.isNaN;\n\n\tvar isNan = isNan$1;\n\n\tvar globalIsFinite = global_1.isFinite;\n\n\t// `Number.isFinite` method\n\t// https://tc39.es/ecma262/#sec-number.isfinite\n\tvar numberIsFinite = Number.isFinite || function isFinite(it) {\n\t  return typeof it == 'number' && globalIsFinite(it);\n\t};\n\n\t// `Number.isFinite` method\n\t// https://tc39.es/ecma262/#sec-number.isfinite\n\t_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });\n\n\tvar es_number_isFinite = {\n\n\t};\n\n\tvar _isFinite$1 = path.Number.isFinite;\n\n\tvar _isFinite = _isFinite$1;\n\n\tvar MATCH$1 = wellKnownSymbol('match');\n\n\t// `IsRegExp` abstract operation\n\t// https://tc39.es/ecma262/#sec-isregexp\n\tvar isRegexp = function (it) {\n\t  var isRegExp;\n\t  return isObject$1(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');\n\t};\n\n\tvar notARegexp = function (it) {\n\t  if (isRegexp(it)) {\n\t    throw TypeError(\"The method doesn't accept regular expressions\");\n\t  } return it;\n\t};\n\n\tvar MATCH = wellKnownSymbol('match');\n\n\tvar correctIsRegexpLogic = function (METHOD_NAME) {\n\t  var regexp = /./;\n\t  try {\n\t    '/./'[METHOD_NAME](regexp);\n\t  } catch (error1) {\n\t    try {\n\t      regexp[MATCH] = false;\n\t      return '/./'[METHOD_NAME](regexp);\n\t    } catch (error2) { /* empty */ }\n\t  } return false;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\t// `String.prototype.includes` method\n\t// https://tc39.es/ecma262/#sec-string.prototype.includes\n\t_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {\n\t  includes: function includes(searchString /* , position = 0 */) {\n\t    return !!~String(requireObjectCoercible(this))\n\t      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar es_string_includes = {\n\n\t};\n\n\tvar includes$1 = entryUnbind('String', 'includes');\n\n\tvar includes = includes$1;\n\n\t'use strict';\n\n\tvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\tvar nativeStartsWith = ''.startsWith;\n\tvar min$4 = Math.min;\n\n\tvar CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith');\n\t// https://github.com/zloirock/core-js/pull/702\n\tvar MDN_POLYFILL_BUG = !isPure && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n\t  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');\n\t  return descriptor && !descriptor.writable;\n\t}();\n\n\t// `String.prototype.startsWith` method\n\t// https://tc39.es/ecma262/#sec-string.prototype.startswith\n\t_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {\n\t  startsWith: function startsWith(searchString /* , position = 0 */) {\n\t    var that = String(requireObjectCoercible(this));\n\t    notARegexp(searchString);\n\t    var index = toLength(min$4(arguments.length > 1 ? arguments[1] : undefined, that.length));\n\t    var search = String(searchString);\n\t    return nativeStartsWith\n\t      ? nativeStartsWith.call(that, search, index)\n\t      : that.slice(index, index + search.length) === search;\n\t  }\n\t});\n\n\tvar es_string_startsWith = {\n\n\t};\n\n\tvar startsWith$1 = entryUnbind('String', 'startsWith');\n\n\tvar startsWith = startsWith$1;\n\n\t(function () {\n\t  if (typeof Uint8Array !== 'undefined' || typeof window === 'undefined') {\n\t    return;\n\t  }\n\t  function subarray(start, end) {\n\t    return this.slice(start, end);\n\t  }\n\t  function set_(array, offset) {\n\t    if (arguments.length < 2) {\n\t      offset = 0;\n\t    }\n\t    for (var i = 0, n = array.length; i < n; ++i, ++offset) {\n\t      this[offset] = array[i] & 0xFF;\n\t    }\n\t  }\n\n\t  // we need typed arrays\n\t  function TypedArray(arg1) {\n\t    var result;\n\t    if (typeof arg1 === 'number') {\n\t      result = new Array(arg1);\n\t      for (var i = 0; i < arg1; ++i) {\n\t        result[i] = 0;\n\t      }\n\t    } else {\n\t      result = arg1.slice(0);\n\t    }\n\t    result.subarray = subarray;\n\t    result.buffer = result;\n\t    result.byteLength = result.length;\n\t    result.set = set_;\n\t    if (typeof arg1 === 'object' && arg1.buffer) {\n\t      result.buffer = arg1.buffer;\n\t    }\n\t    return result;\n\t  }\n\t  window.Uint8Array = TypedArray;\n\t  window.Uint32Array = TypedArray;\n\t  window.Int32Array = TypedArray;\n\t})();\n\n\t// Declare shorthands to the most used math functions.\n\tconst {\n\t  round: round$4,\n\t  floor,\n\t  PI: PI$1\n\t} = Math;\n\tconst scale = {\n\t  // Return the `value` from the `domain` interval scaled to the `range` interval.\n\t  linear: function (domain, range, value) {\n\t    var domainSpan = domain[1] - domain[0];\n\t    var rangeSpan = range[1] - range[0];\n\t    return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0;\n\t  }\n\t};\n\tconst normalizeAngle = function (angle) {\n\t  return angle % 360 + (angle < 0 ? 360 : 0);\n\t};\n\tconst snapToGrid$1 = function (value, gridSize) {\n\t  return gridSize * round$4(value / gridSize);\n\t};\n\tconst toDeg = function (rad) {\n\t  return 180 * rad / PI$1 % 360;\n\t};\n\tconst toRad = function (deg, over360) {\n\t  over360 = over360 || false;\n\t  deg = over360 ? deg : deg % 360;\n\t  return deg * PI$1 / 180;\n\t};\n\n\t// Return a random integer from the interval [min,max], inclusive.\n\tconst random = function (min, max) {\n\t  if (max === undefined) {\n\t    // use first argument as max, min is 0\n\t    max = min === undefined ? 1 : min;\n\t    min = 0;\n\t  } else if (max < min) {\n\t    // switch max and min\n\t    const temp = min;\n\t    min = max;\n\t    max = temp;\n\t  }\n\t  return floor(Math.random() * (max - min + 1) + min);\n\t};\n\n\t// @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n\t// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\tconst {\n\t  cos: cos$2,\n\t  sin: sin$2,\n\t  atan2: atan2$1\n\t} = Math;\n\tconst bearing = function (p, q) {\n\t  var lat1 = toRad(p.y);\n\t  var lat2 = toRad(q.y);\n\t  var lon1 = p.x;\n\t  var lon2 = q.x;\n\t  var dLon = toRad(lon2 - lon1);\n\t  var y = sin$2(dLon) * cos$2(lat2);\n\t  var x = cos$2(lat1) * sin$2(lat2) - sin$2(lat1) * cos$2(lat2) * cos$2(dLon);\n\t  var brng = toDeg(atan2$1(y, x));\n\t  var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\t  var index = brng - 22.5;\n\t  if (index < 0) index += 360;\n\t  index = parseInt(index / 45);\n\t  return bearings[index];\n\t};\n\n\t// @return {integer} length without sqrt\n\t// @note for applications where the exact length is not necessary (e.g. compare only)\n\tconst squaredLength = function (start, end) {\n\t  var x0 = start.x;\n\t  var y0 = start.y;\n\t  var x1 = end.x;\n\t  var y1 = end.y;\n\t  return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n\t};\n\n\tconst length = function (start, end) {\n\t  return Math.sqrt(squaredLength(start, end));\n\t};\n\n\tconst types = {\n\t  Point: 1,\n\t  Line: 2,\n\t  Ellipse: 3,\n\t  Rect: 4,\n\t  Polyline: 5,\n\t  Polygon: 6,\n\t  Curve: 7,\n\t  Path: 8\n\t};\n\n\t/*\n\t    Point is the most basic object consisting of x/y coordinate.\n\n\t    Possible instantiations are:\n\t    * `Point(10, 20)`\n\t    * `new Point(10, 20)`\n\t    * `Point('10 20')`\n\t    * `Point(Point(10, 20))`\n\t*/\n\tconst {\n\t  abs: abs$2,\n\t  cos: cos$1,\n\t  sin: sin$1,\n\t  sqrt: sqrt$2,\n\t  min: min$3,\n\t  max: max$3,\n\t  atan2,\n\t  round: round$3,\n\t  pow: pow$3,\n\t  PI\n\t} = Math;\n\tconst Point = function (x, y) {\n\t  if (!(this instanceof Point)) {\n\t    return new Point(x, y);\n\t  }\n\t  if (typeof x === 'string') {\n\t    var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n\t    x = parseFloat(xy[0]);\n\t    y = parseFloat(xy[1]);\n\t  } else if (Object(x) === x) {\n\t    y = x.y;\n\t    x = x.x;\n\t  }\n\t  this.x = x === undefined ? 0 : x;\n\t  this.y = y === undefined ? 0 : y;\n\t};\n\n\t// Alternative constructor, from polar coordinates.\n\t// @param {number} Distance.\n\t// @param {number} Angle in radians.\n\t// @param {point} [optional] Origin.\n\tPoint.fromPolar = function (distance, angle, origin) {\n\t  origin = new Point(origin);\n\t  var x = abs$2(distance * cos$1(angle));\n\t  var y = abs$2(distance * sin$1(angle));\n\t  var deg = normalizeAngle(toDeg(angle));\n\t  if (deg < 90) {\n\t    y = -y;\n\t  } else if (deg < 180) {\n\t    x = -x;\n\t    y = -y;\n\t  } else if (deg < 270) {\n\t    x = -x;\n\t  }\n\t  return new Point(origin.x + x, origin.y + y);\n\t};\n\n\t// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\n\tPoint.random = function (x1, x2, y1, y2) {\n\t  return new Point(random(x1, x2), random(y1, y2));\n\t};\n\tPoint.prototype = {\n\t  type: types.Point,\n\t  chooseClosest: function (points) {\n\t    var n = points.length;\n\t    if (n === 1) return new Point(points[0]);\n\t    var closest = null;\n\t    var minSqrDistance = Infinity;\n\t    for (var i = 0; i < n; i++) {\n\t      var p = new Point(points[i]);\n\t      var sqrDistance = this.squaredDistance(p);\n\t      if (sqrDistance < minSqrDistance) {\n\t        closest = p;\n\t        minSqrDistance = sqrDistance;\n\t      }\n\t    }\n\t    return closest;\n\t  },\n\t  // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n\t  // otherwise return point itself.\n\t  // (see Squeak Smalltalk, Point>>adhereTo:)\n\t  adhereToRect: function (r) {\n\t    if (r.containsPoint(this)) {\n\t      return this;\n\t    }\n\t    this.x = min$3(max$3(this.x, r.x), r.x + r.width);\n\t    this.y = min$3(max$3(this.y, r.y), r.y + r.height);\n\t    return this;\n\t  },\n\t  // Compute the angle between vector from me to p1 and the vector from me to p2.\n\t  // ordering of points p1 and p2 is important!\n\t  // theta function's angle convention:\n\t  // returns angles between 0 and 180 when the angle is counterclockwise\n\t  // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n\t  // returns NaN if any of the points p1, p2 is coincident with this point\n\t  angleBetween: function (p1, p2) {\n\t    var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);\n\t    if (angleBetween < 0) {\n\t      angleBetween += 360; // correction to keep angleBetween between 0 and 360\n\t    }\n\t    return angleBetween;\n\t  },\n\t  // Return the bearing between me and the given point.\n\t  bearing: function (point) {\n\t    return bearing(this, point);\n\t  },\n\t  // Returns change in angle from my previous position (-dx, -dy) to my new position\n\t  // relative to ref point.\n\t  changeInAngle: function (dx, dy, ref) {\n\t    // Revert the translation and measure the change in angle around x-axis.\n\t    return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n\t  },\n\t  clone: function () {\n\t    return new Point(this);\n\t  },\n\t  // Returns the cross product of this point relative to two other points\n\t  // this point is the common point\n\t  // point p1 lies on the first vector, point p2 lies on the second vector\n\t  // watch out for the ordering of points p1 and p2!\n\t  // positive result indicates a clockwise (\"right\") turn from first to second vector\n\t  // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n\t  // zero indicates that the first and second vector are collinear\n\t  // note that the above directions are reversed from the usual answer on the Internet\n\t  // that is because we are in a left-handed coord system (because the y-axis points downward)\n\t  cross: function (p1, p2) {\n\t    return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;\n\t  },\n\t  difference: function (dx, dy) {\n\t    if (Object(dx) === dx) {\n\t      dy = dx.y;\n\t      dx = dx.x;\n\t    }\n\t    return new Point(this.x - (dx || 0), this.y - (dy || 0));\n\t  },\n\t  // Returns distance between me and point `p`.\n\t  distance: function (p) {\n\t    return length(this, p);\n\t  },\n\t  // Returns the dot product of this point with given other point\n\t  dot: function (p) {\n\t    return p ? this.x * p.x + this.y * p.y : NaN;\n\t  },\n\t  equals: function (p) {\n\t    return !!p && this.x === p.x && this.y === p.y;\n\t  },\n\t  // Linear interpolation\n\t  lerp: function (p, t) {\n\t    var x = this.x;\n\t    var y = this.y;\n\t    return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n\t  },\n\t  magnitude: function () {\n\t    return sqrt$2(this.x * this.x + this.y * this.y) || 0.01;\n\t  },\n\t  // Returns a manhattan (taxi-cab) distance between me and point `p`.\n\t  manhattanDistance: function (p) {\n\t    return abs$2(p.x - this.x) + abs$2(p.y - this.y);\n\t  },\n\t  // Move point on line starting from ref ending at me by\n\t  // distance distance.\n\t  move: function (ref, distance) {\n\t    var theta = toRad(new Point(ref).theta(this));\n\t    var offset = this.offset(cos$1(theta) * distance, -sin$1(theta) * distance);\n\t    return offset;\n\t  },\n\t  // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n\t  normalize: function (length) {\n\t    var scale = (length || 1) / this.magnitude();\n\t    return this.scale(scale, scale);\n\t  },\n\t  // Offset me by the specified amount.\n\t  offset: function (dx, dy) {\n\t    if (Object(dx) === dx) {\n\t      dy = dx.y;\n\t      dx = dx.x;\n\t    }\n\t    this.x += dx || 0;\n\t    this.y += dy || 0;\n\t    return this;\n\t  },\n\t  // Returns a point that is the reflection of me with\n\t  // the center of inversion in ref point.\n\t  reflection: function (ref) {\n\t    return new Point(ref).move(this, this.distance(ref));\n\t  },\n\t  // Rotate point by angle around origin.\n\t  // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n\t  rotate: function (origin, angle) {\n\t    if (angle === 0) return this;\n\t    origin = origin || new Point(0, 0);\n\t    angle = toRad(normalizeAngle(-angle));\n\t    var cosAngle = cos$1(angle);\n\t    var sinAngle = sin$1(angle);\n\t    var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;\n\t    var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;\n\t    this.x = x;\n\t    this.y = y;\n\t    return this;\n\t  },\n\t  round: function (precision) {\n\t    let f = 1; // case 0\n\t    if (precision) {\n\t      switch (precision) {\n\t        case 1:\n\t          f = 10;\n\t          break;\n\t        case 2:\n\t          f = 100;\n\t          break;\n\t        case 3:\n\t          f = 1000;\n\t          break;\n\t        default:\n\t          f = pow$3(10, precision);\n\t          break;\n\t      }\n\t    }\n\t    this.x = round$3(this.x * f) / f;\n\t    this.y = round$3(this.y * f) / f;\n\t    return this;\n\t  },\n\t  // Scale point with origin.\n\t  scale: function (sx, sy, origin) {\n\t    origin = origin && new Point(origin) || new Point(0, 0);\n\t    this.x = origin.x + sx * (this.x - origin.x);\n\t    this.y = origin.y + sy * (this.y - origin.y);\n\t    return this;\n\t  },\n\t  snapToGrid: function (gx, gy) {\n\t    this.x = snapToGrid$1(this.x, gx);\n\t    this.y = snapToGrid$1(this.y, gy || gx);\n\t    return this;\n\t  },\n\t  squaredDistance: function (p) {\n\t    return squaredLength(this, p);\n\t  },\n\t  // Compute the angle between me and `p` and the x axis.\n\t  // (cartesian-to-polar coordinates conversion)\n\t  // Return theta angle in degrees.\n\t  theta: function (p) {\n\t    p = new Point(p);\n\n\t    // Invert the y-axis.\n\t    var y = -(p.y - this.y);\n\t    var x = p.x - this.x;\n\t    var rad = atan2(y, x); // defined for all 0 corner cases\n\n\t    // Correction for III. and IV. quadrant.\n\t    if (rad < 0) {\n\t      rad = 2 * PI + rad;\n\t    }\n\t    return 180 * rad / PI;\n\t  },\n\t  toJSON: function () {\n\t    return {\n\t      x: this.x,\n\t      y: this.y\n\t    };\n\t  },\n\t  // Converts rectangular to polar coordinates.\n\t  // An origin can be specified, otherwise it's 0@0.\n\t  toPolar: function (o) {\n\t    o = o && new Point(o) || new Point(0, 0);\n\t    var x = this.x;\n\t    var y = this.y;\n\t    this.x = sqrt$2((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n\t    this.y = toRad(o.theta(new Point(x, y)));\n\t    return this;\n\t  },\n\t  toString: function () {\n\t    return this.x + '@' + this.y;\n\t  },\n\t  serialize: function () {\n\t    return this.x + ',' + this.y;\n\t  },\n\t  update: function (x, y) {\n\t    if (Object(x) === x) {\n\t      y = x.y;\n\t      x = x.x;\n\t    }\n\t    this.x = x || 0;\n\t    this.y = y || 0;\n\t    return this;\n\t  },\n\t  // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n\t  // Returns NaN if p is at 0,0.\n\t  vectorAngle: function (p) {\n\t    var zero = new Point(0, 0);\n\t    return zero.angleBetween(this, p);\n\t  }\n\t};\n\tPoint.prototype.translate = Point.prototype.offset;\n\n\t// For backwards compatibility:\n\tconst point = Point;\n\n\tconst {\n\t  max: max$2,\n\t  min: min$2\n\t} = Math;\n\tconst Line = function (p1, p2) {\n\t  if (!(this instanceof Line)) {\n\t    return new Line(p1, p2);\n\t  }\n\t  if (p1 instanceof Line) {\n\t    return new Line(p1.start, p1.end);\n\t  }\n\t  this.start = new Point(p1);\n\t  this.end = new Point(p2);\n\t};\n\tLine.prototype = {\n\t  type: types.Line,\n\t  // @returns the angle of incline of the line.\n\t  angle: function () {\n\t    var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n\t    return this.start.angleBetween(this.end, horizontalPoint);\n\t  },\n\t  bbox: function () {\n\t    var left = min$2(this.start.x, this.end.x);\n\t    var top = min$2(this.start.y, this.end.y);\n\t    var right = max$2(this.start.x, this.end.x);\n\t    var bottom = max$2(this.start.y, this.end.y);\n\t    return new Rect(left, top, right - left, bottom - top);\n\t  },\n\t  // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n\t  // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\t  bearing: function () {\n\t    return bearing(this.start, this.end);\n\t  },\n\t  clone: function () {\n\t    return new Line(this.start, this.end);\n\t  },\n\t  // @return {point} the closest point on the line to point `p`\n\t  closestPoint: function (p) {\n\t    return this.pointAt(this.closestPointNormalizedLength(p));\n\t  },\n\t  closestPointLength: function (p) {\n\t    return this.closestPointNormalizedLength(p) * this.length();\n\t  },\n\t  // @return {number} the normalized length of the closest point on the line to point `p`\n\t  closestPointNormalizedLength: function (p) {\n\t    var product = this.vector().dot(new Line(this.start, p).vector());\n\t    var cpNormalizedLength = min$2(1, max$2(0, product / this.squaredLength()));\n\n\t    // cpNormalizedLength returns `NaN` if this line has zero length\n\t    // we can work with that - if `NaN`, return 0\n\t    if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n\t    // (`NaN` is the only value that is not equal to itself)\n\n\t    return cpNormalizedLength;\n\t  },\n\t  closestPointTangent: function (p) {\n\t    return this.tangentAt(this.closestPointNormalizedLength(p));\n\t  },\n\t  // Returns `true` if the point lies on the line.\n\t  containsPoint: function (p) {\n\t    var start = this.start;\n\t    var end = this.end;\n\t    if (start.cross(p, end) !== 0) return false;\n\t    // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n\t    var length = this.length();\n\t    if (new Line(start, p).length() > length) return false;\n\t    if (new Line(p, end).length() > length) return false;\n\t    // else: `p` lies between start and end of the line\n\n\t    return true;\n\t  },\n\t  // Divides the line into two at requested `ratio` between 0 and 1.\n\t  divideAt: function (ratio) {\n\t    var dividerPoint = this.pointAt(ratio);\n\n\t    // return array with two lines\n\t    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n\t  },\n\t  // Divides the line into two at requested `length`.\n\t  divideAtLength: function (length) {\n\t    var dividerPoint = this.pointAtLength(length);\n\n\t    // return array with two new lines\n\t    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n\t  },\n\t  equals: function (l) {\n\t    return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n\t  },\n\t  // @return {point} Point where I'm intersecting a line.\n\t  // @return [point] Points where I'm intersecting a rectangle.\n\t  // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n\t  intersect: function (shape, opt) {\n\t    if (shape && shape.intersectionWithLine) {\n\t      var intersection = shape.intersectionWithLine(this, opt);\n\n\t      // Backwards compatibility\n\t      if (intersection && shape instanceof Line) {\n\t        intersection = intersection[0];\n\t      }\n\t      return intersection;\n\t    }\n\t    return null;\n\t  },\n\t  intersectionWithLine: function (line) {\n\t    var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n\t    var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n\t    var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n\t    var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n\t    var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n\t    var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n\t    if (det === 0 || alpha * det < 0 || beta * det < 0) {\n\t      // No intersection found.\n\t      return null;\n\t    }\n\t    if (det > 0) {\n\t      if (alpha > det || beta > det) {\n\t        return null;\n\t      }\n\t    } else {\n\t      if (alpha < det || beta < det) {\n\t        return null;\n\t      }\n\t    }\n\t    return [new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)];\n\t  },\n\t  isDifferentiable: function () {\n\t    return !this.start.equals(this.end);\n\t  },\n\t  // @return {double} length of the line\n\t  length: function () {\n\t    return length(this.start, this.end);\n\t  },\n\t  // @return {point} my midpoint\n\t  midpoint: function () {\n\t    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n\t  },\n\t  parallel: function (distance) {\n\t    const l = this.clone();\n\t    if (!this.isDifferentiable()) return l;\n\t    const {\n\t      start,\n\t      end\n\t    } = l;\n\t    const eRef = start.clone().rotate(end, 270);\n\t    const sRef = end.clone().rotate(start, 90);\n\t    start.move(sRef, distance);\n\t    end.move(eRef, distance);\n\t    return l;\n\t  },\n\t  // @return {point} my point at 't' <0,1>\n\t  pointAt: function (t) {\n\t    var start = this.start;\n\t    var end = this.end;\n\t    if (t <= 0) return start.clone();\n\t    if (t >= 1) return end.clone();\n\t    return start.lerp(end, t);\n\t  },\n\t  pointAtLength: function (length) {\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    var lineLength = this.length();\n\t    if (length >= lineLength) return fromStart ? end.clone() : start.clone();\n\t    return this.pointAt((fromStart ? length : lineLength - length) / lineLength);\n\t  },\n\t  // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n\t  pointOffset: function (p) {\n\t    // Find the sign of the determinant of vectors (start,end), where p is the query point.\n\t    p = new Point(p);\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);\n\t    return determinant / this.length();\n\t  },\n\t  rotate: function (origin, angle) {\n\t    this.start.rotate(origin, angle);\n\t    this.end.rotate(origin, angle);\n\t    return this;\n\t  },\n\t  round: function (precision) {\n\t    this.start.round(precision);\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.start.scale(sx, sy, origin);\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  // @return {number} scale the line so that it has the requested length\n\t  setLength: function (length) {\n\t    var currentLength = this.length();\n\t    if (!currentLength) return this;\n\t    var scaleFactor = length / currentLength;\n\t    return this.scale(scaleFactor, scaleFactor, this.start);\n\t  },\n\t  // @return {integer} length without sqrt\n\t  // @note for applications where the exact length is not necessary (e.g. compare only)\n\t  squaredLength: function () {\n\t    return squaredLength(this.start, this.end);\n\t  },\n\t  tangentAt: function (t) {\n\t    if (!this.isDifferentiable()) return null;\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n\t    var tangentLine = new Line(start, end);\n\t    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n\t    return tangentLine;\n\t  },\n\t  tangentAtLength: function (length) {\n\t    if (!this.isDifferentiable()) return null;\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var tangentStart = this.pointAtLength(length);\n\t    var tangentLine = new Line(start, end);\n\t    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n\t    return tangentLine;\n\t  },\n\t  toString: function () {\n\t    return this.start.toString() + ' ' + this.end.toString();\n\t  },\n\t  serialize: function () {\n\t    return this.start.serialize() + ' ' + this.end.serialize();\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.start.translate(tx, ty);\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  },\n\t  // @return vector {point} of the line\n\t  vector: function () {\n\t    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n\t  }\n\t};\n\n\t// For backwards compatibility:\n\tLine.prototype.intersection = Line.prototype.intersect;\n\n\t// For backwards compatibility:\n\tconst line$1 = Line;\n\n\tconst {\n\t  sqrt: sqrt$1,\n\t  round: round$2,\n\t  pow: pow$2\n\t} = Math;\n\tconst Ellipse$1 = function (c, a, b) {\n\t  if (!(this instanceof Ellipse$1)) {\n\t    return new Ellipse$1(c, a, b);\n\t  }\n\t  if (c instanceof Ellipse$1) {\n\t    return new Ellipse$1(new Point(c.x, c.y), c.a, c.b);\n\t  }\n\t  c = new Point(c);\n\t  this.x = c.x;\n\t  this.y = c.y;\n\t  this.a = a;\n\t  this.b = b;\n\t};\n\tEllipse$1.fromRect = function (rect) {\n\t  rect = new Rect(rect);\n\t  return new Ellipse$1(rect.center(), rect.width / 2, rect.height / 2);\n\t};\n\tEllipse$1.prototype = {\n\t  type: types.Ellipse,\n\t  bbox: function () {\n\t    return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n\t  },\n\t  /**\n\t   * @returns {g.Point}\n\t   */\n\t  center: function () {\n\t    return new Point(this.x, this.y);\n\t  },\n\t  clone: function () {\n\t    return new Ellipse$1(this);\n\t  },\n\t  /**\n\t   * @param {g.Point} p\n\t   * @returns {boolean}\n\t   */\n\t  containsPoint: function (p) {\n\t    return this.normalizedDistance(p) <= 1;\n\t  },\n\t  equals: function (ellipse) {\n\t    return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n\t  },\n\t  // inflate by dx and dy\n\t  // @param dx {delta_x} representing additional size to x\n\t  // @param dy {delta_y} representing additional size to y -\n\t  // dy param is not required -> in that case y is sized by dx\n\t  inflate: function (dx, dy) {\n\t    if (dx === undefined) {\n\t      dx = 0;\n\t    }\n\t    if (dy === undefined) {\n\t      dy = dx;\n\t    }\n\t    this.a += 2 * dx;\n\t    this.b += 2 * dy;\n\t    return this;\n\t  },\n\t  intersectionWithLine: function (line) {\n\t    var intersections = [];\n\t    var a1 = line.start;\n\t    var a2 = line.end;\n\t    var rx = this.a;\n\t    var ry = this.b;\n\t    var dir = line.vector();\n\t    var diff = a1.difference(new Point(this));\n\t    var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n\t    var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\t    var a = dir.dot(mDir);\n\t    var b = dir.dot(mDiff);\n\t    var c = diff.dot(mDiff) - 1.0;\n\t    var d = b * b - a * c;\n\t    if (d < 0) {\n\t      return null;\n\t    } else if (d > 0) {\n\t      var root = sqrt$1(d);\n\t      var ta = (-b - root) / a;\n\t      var tb = (-b + root) / a;\n\t      if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n\t        // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n\t        return null;\n\t      } else {\n\t        if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n\t        if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n\t      }\n\t    } else {\n\t      var t = -b / a;\n\t      if (0 <= t && t <= 1) {\n\t        intersections.push(a1.lerp(a2, t));\n\t      } else {\n\t        // outside\n\t        return null;\n\t      }\n\t    }\n\t    return intersections;\n\t  },\n\t  // Find point on me where line from my center to\n\t  // point p intersects my boundary.\n\t  // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n\t  intersectionWithLineFromCenterToPoint: function (p, angle) {\n\t    p = new Point(p);\n\t    if (angle) p.rotate(new Point(this.x, this.y), angle);\n\t    var dx = p.x - this.x;\n\t    var dy = p.y - this.y;\n\t    var result;\n\t    if (dx === 0) {\n\t      result = this.bbox().pointNearestToPoint(p);\n\t      if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n\t      return result;\n\t    }\n\t    var m = dy / dx;\n\t    var mSquared = m * m;\n\t    var aSquared = this.a * this.a;\n\t    var bSquared = this.b * this.b;\n\t    var x = sqrt$1(1 / (1 / aSquared + mSquared / bSquared));\n\t    x = dx < 0 ? -x : x;\n\t    var y = m * x;\n\t    result = new Point(this.x + x, this.y + y);\n\t    if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n\t    return result;\n\t  },\n\t  /**\n\t   * @param {g.Point} point\n\t   * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n\t   */\n\t  normalizedDistance: function (point) {\n\t    var x0 = point.x;\n\t    var y0 = point.y;\n\t    var a = this.a;\n\t    var b = this.b;\n\t    var x = this.x;\n\t    var y = this.y;\n\t    return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);\n\t  },\n\t  round: function (precision) {\n\t    let f = 1; // case 0\n\t    if (precision) {\n\t      switch (precision) {\n\t        case 1:\n\t          f = 10;\n\t          break;\n\t        case 2:\n\t          f = 100;\n\t          break;\n\t        case 3:\n\t          f = 1000;\n\t          break;\n\t        default:\n\t          f = pow$2(10, precision);\n\t          break;\n\t      }\n\t    }\n\t    this.x = round$2(this.x * f) / f;\n\t    this.y = round$2(this.y * f) / f;\n\t    this.a = round$2(this.a * f) / f;\n\t    this.b = round$2(this.b * f) / f;\n\t    return this;\n\t  },\n\t  /** Compute angle between tangent and x axis\n\t   * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n\t   * @returns {number} angle between tangent and x axis\n\t   */\n\t  tangentTheta: function (p) {\n\t    var refPointDelta = 30;\n\t    var x0 = p.x;\n\t    var y0 = p.y;\n\t    var a = this.a;\n\t    var b = this.b;\n\t    var center = this.bbox().center();\n\t    var m = center.x;\n\t    var n = center.y;\n\t    var q1 = x0 > center.x + a / 2;\n\t    var q3 = x0 < center.x - a / 2;\n\t    var y, x;\n\t    if (q1 || q3) {\n\t      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n\t      x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;\n\t    } else {\n\t      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n\t      y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;\n\t    }\n\t    return new Point(x, y).theta(p);\n\t  },\n\t  toString: function () {\n\t    return new Point(this.x, this.y).toString() + ' ' + this.a + ' ' + this.b;\n\t  }\n\t};\n\n\t// For backwards compatibility:\n\tconst ellipse$1 = Ellipse$1;\n\n\tconst {\n\t  abs: abs$1,\n\t  cos,\n\t  sin,\n\t  min: min$1,\n\t  max: max$1,\n\t  round: round$1,\n\t  pow: pow$1\n\t} = Math;\n\tconst Rect = function (x, y, w, h) {\n\t  if (!(this instanceof Rect)) {\n\t    return new Rect(x, y, w, h);\n\t  }\n\t  if (Object(x) === x) {\n\t    y = x.y;\n\t    w = x.width;\n\t    h = x.height;\n\t    x = x.x;\n\t  }\n\t  this.x = x === undefined ? 0 : x;\n\t  this.y = y === undefined ? 0 : y;\n\t  this.width = w === undefined ? 0 : w;\n\t  this.height = h === undefined ? 0 : h;\n\t};\n\tRect.fromEllipse = function (e) {\n\t  e = new Ellipse$1(e);\n\t  return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n\t};\n\tRect.fromPointUnion = function (...points) {\n\t  if (points.length === 0) return null;\n\t  const p = new Point();\n\t  let minX, minY, maxX, maxY;\n\t  minX = minY = Infinity;\n\t  maxX = maxY = -Infinity;\n\t  for (let i = 0; i < points.length; i++) {\n\t    p.update(points[i]);\n\t    const x = p.x;\n\t    const y = p.y;\n\t    if (x < minX) minX = x;\n\t    if (x > maxX) maxX = x;\n\t    if (y < minY) minY = y;\n\t    if (y > maxY) maxY = y;\n\t  }\n\t  return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t};\n\tRect.fromRectUnion = function (...rects) {\n\t  if (rects.length === 0) return null;\n\t  const r = new Rect();\n\t  let minX, minY, maxX, maxY;\n\t  minX = minY = Infinity;\n\t  maxX = maxY = -Infinity;\n\t  for (let i = 0; i < rects.length; i++) {\n\t    r.update(rects[i]);\n\t    const x = r.x;\n\t    const y = r.y;\n\t    const mX = x + r.width;\n\t    const mY = y + r.height;\n\t    if (x < minX) minX = x;\n\t    if (mX > maxX) maxX = mX;\n\t    if (y < minY) minY = y;\n\t    if (mY > maxY) maxY = mY;\n\t  }\n\t  return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t};\n\tRect.prototype = {\n\t  type: types.Rect,\n\t  // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n\t  // @return r {rectangle} representing a bounding box\n\t  bbox: function (angle) {\n\t    return this.clone().rotateAroundCenter(angle);\n\t  },\n\t  rotateAroundCenter: function (angle) {\n\t    if (!angle) return this;\n\t    const {\n\t      width,\n\t      height\n\t    } = this;\n\t    const theta = toRad(angle);\n\t    const st = abs$1(sin(theta));\n\t    const ct = abs$1(cos(theta));\n\t    const w = width * ct + height * st;\n\t    const h = width * st + height * ct;\n\t    this.x += (width - w) / 2;\n\t    this.y += (height - h) / 2;\n\t    this.width = w;\n\t    this.height = h;\n\t    return this;\n\t  },\n\t  bottomLeft: function () {\n\t    return new Point(this.x, this.y + this.height);\n\t  },\n\t  bottomLine: function () {\n\t    return new Line(this.bottomLeft(), this.bottomRight());\n\t  },\n\t  bottomMiddle: function () {\n\t    return new Point(this.x + this.width / 2, this.y + this.height);\n\t  },\n\t  center: function () {\n\t    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t  },\n\t  clone: function () {\n\t    return new Rect(this);\n\t  },\n\t  // @return {bool} true if point p is inside me.\n\t  // @param {bool} strict If true, the point has to be strictly inside (not on the border).\n\t  containsPoint: function (p, opt) {\n\t    let x, y;\n\t    if (!p || typeof p === 'string') {\n\t      // Backwards compatibility: if the point is not provided,\n\t      // the point is considered to be the origin [0, 0].\n\t      ({\n\t        x,\n\t        y\n\t      } = new Point(p));\n\t    } else {\n\t      // Do not create a new Point object if the point is already a Point-like object.\n\t      ({\n\t        x = 0,\n\t        y = 0\n\t      } = p);\n\t    }\n\t    return opt && opt.strict ? x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height : x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n\t  },\n\t  // @return {bool} true if rectangle `r` is inside me.\n\t  containsRect: function (r) {\n\t    var r0 = new Rect(this).normalize();\n\t    var r1 = new Rect(r).normalize();\n\t    var w0 = r0.width;\n\t    var h0 = r0.height;\n\t    var w1 = r1.width;\n\t    var h1 = r1.height;\n\t    if (!w0 || !h0 || !w1 || !h1) {\n\t      // At least one of the dimensions is 0\n\t      return false;\n\t    }\n\t    var x0 = r0.x;\n\t    var y0 = r0.y;\n\t    var x1 = r1.x;\n\t    var y1 = r1.y;\n\t    w1 += x1;\n\t    w0 += x0;\n\t    h1 += y1;\n\t    h0 += y0;\n\t    return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n\t  },\n\t  corner: function () {\n\t    return new Point(this.x + this.width, this.y + this.height);\n\t  },\n\t  // @return {boolean} true if rectangles are equal.\n\t  equals: function (r) {\n\t    var mr = new Rect(this).normalize();\n\t    var nr = new Rect(r).normalize();\n\t    return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n\t  },\n\t  // inflate by dx and dy, recompute origin [x, y]\n\t  // @param dx {delta_x} representing additional size to x\n\t  // @param dy {delta_y} representing additional size to y -\n\t  // dy param is not required -> in that case y is sized by dx\n\t  inflate: function (dx, dy) {\n\t    if (dx === undefined) {\n\t      dx = 0;\n\t    }\n\t    if (dy === undefined) {\n\t      dy = dx;\n\t    }\n\t    this.x -= dx;\n\t    this.y -= dy;\n\t    this.width += 2 * dx;\n\t    this.height += 2 * dy;\n\t    return this;\n\t  },\n\t  // @return {rect} if rectangles intersect, {null} if not.\n\t  intersect: function (r) {\n\t    var myOrigin = this.origin();\n\t    var myCorner = this.corner();\n\t    var rOrigin = r.origin();\n\t    var rCorner = r.corner();\n\n\t    // No intersection found\n\t    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;\n\t    var x = max$1(myOrigin.x, rOrigin.x);\n\t    var y = max$1(myOrigin.y, rOrigin.y);\n\t    return new Rect(x, y, min$1(myCorner.x, rCorner.x) - x, min$1(myCorner.y, rCorner.y) - y);\n\t  },\n\t  intersectionWithLine: function (line) {\n\t    var r = this;\n\t    var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n\t    var points = [];\n\t    var dedupeArr = [];\n\t    var pt, i;\n\t    var n = rectLines.length;\n\t    for (i = 0; i < n; i++) {\n\t      pt = line.intersect(rectLines[i]);\n\t      if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n\t        points.push(pt);\n\t        dedupeArr.push(pt.toString());\n\t      }\n\t    }\n\t    return points.length > 0 ? points : null;\n\t  },\n\t  // Find point on my boundary where line starting\n\t  // from my center ending in point p intersects me.\n\t  // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n\t  intersectionWithLineFromCenterToPoint: function (p, angle) {\n\t    p = new Point(p);\n\t    var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t    var result;\n\t    if (angle) p.rotate(center, angle);\n\n\t    // (clockwise, starting from the top side)\n\t    var sides = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()];\n\t    var connector = new Line(center, p);\n\t    for (var i = sides.length - 1; i >= 0; --i) {\n\t      var intersection = sides[i].intersection(connector);\n\t      if (intersection !== null) {\n\t        result = intersection;\n\t        break;\n\t      }\n\t    }\n\t    if (result && angle) result.rotate(center, -angle);\n\t    return result;\n\t  },\n\t  leftLine: function () {\n\t    return new Line(this.topLeft(), this.bottomLeft());\n\t  },\n\t  leftMiddle: function () {\n\t    return new Point(this.x, this.y + this.height / 2);\n\t  },\n\t  maxRectScaleToFit: function (rect, origin) {\n\t    rect = new Rect(rect);\n\t    origin || (origin = rect.center());\n\t    var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n\t    var ox = origin.x;\n\t    var oy = origin.y;\n\n\t    // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n\t    // so when the scale is applied the point is still inside the rectangle.\n\n\t    sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n\t    // Top Left\n\t    var p1 = rect.topLeft();\n\t    if (p1.x < ox) {\n\t      sx1 = (this.x - ox) / (p1.x - ox);\n\t    }\n\t    if (p1.y < oy) {\n\t      sy1 = (this.y - oy) / (p1.y - oy);\n\t    }\n\t    // Bottom Right\n\t    var p2 = rect.bottomRight();\n\t    if (p2.x > ox) {\n\t      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n\t    }\n\t    if (p2.y > oy) {\n\t      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n\t    }\n\t    // Top Right\n\t    var p3 = rect.topRight();\n\t    if (p3.x > ox) {\n\t      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n\t    }\n\t    if (p3.y < oy) {\n\t      sy3 = (this.y - oy) / (p3.y - oy);\n\t    }\n\t    // Bottom Left\n\t    var p4 = rect.bottomLeft();\n\t    if (p4.x < ox) {\n\t      sx4 = (this.x - ox) / (p4.x - ox);\n\t    }\n\t    if (p4.y > oy) {\n\t      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n\t    }\n\t    return {\n\t      sx: min$1(sx1, sx2, sx3, sx4),\n\t      sy: min$1(sy1, sy2, sy3, sy4)\n\t    };\n\t  },\n\t  maxRectUniformScaleToFit: function (rect, origin) {\n\t    var scale = this.maxRectScaleToFit(rect, origin);\n\t    return min$1(scale.sx, scale.sy);\n\t  },\n\t  // Move and expand me.\n\t  // @param r {rectangle} representing deltas\n\t  moveAndExpand: function (r) {\n\t    this.x += r.x || 0;\n\t    this.y += r.y || 0;\n\t    this.width += r.width || 0;\n\t    this.height += r.height || 0;\n\t    return this;\n\t  },\n\t  moveAroundPoint: function (origin, angle) {\n\t    const newCenter = this.center().rotate(origin, angle);\n\t    this.x = newCenter.x - this.width / 2;\n\t    this.y = newCenter.y - this.height / 2;\n\t    return this;\n\t  },\n\t  // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n\t  // If width < 0 the function swaps the left and right corners,\n\t  // and it swaps the top and bottom corners if height < 0\n\t  // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n\t  normalize: function () {\n\t    var newx = this.x;\n\t    var newy = this.y;\n\t    var newwidth = this.width;\n\t    var newheight = this.height;\n\t    if (this.width < 0) {\n\t      newx = this.x + this.width;\n\t      newwidth = -this.width;\n\t    }\n\t    if (this.height < 0) {\n\t      newy = this.y + this.height;\n\t      newheight = -this.height;\n\t    }\n\t    this.x = newx;\n\t    this.y = newy;\n\t    this.width = newwidth;\n\t    this.height = newheight;\n\t    return this;\n\t  },\n\t  // Offset me by the specified amount.\n\t  offset: function (dx, dy) {\n\t    // pretend that this is a point and call offset()\n\t    // rewrites x and y according to dx and dy\n\t    return Point.prototype.offset.call(this, dx, dy);\n\t  },\n\t  origin: function () {\n\t    return new Point(this.x, this.y);\n\t  },\n\t  // @return {point} a point on my boundary nearest to the given point.\n\t  // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n\t  pointNearestToPoint: function (point) {\n\t    point = new Point(point);\n\t    if (this.containsPoint(point)) {\n\t      var side = this.sideNearestToPoint(point);\n\t      switch (side) {\n\t        case 'right':\n\t          return new Point(this.x + this.width, point.y);\n\t        case 'left':\n\t          return new Point(this.x, point.y);\n\t        case 'bottom':\n\t          return new Point(point.x, this.y + this.height);\n\t        case 'top':\n\t          return new Point(point.x, this.y);\n\t      }\n\t    }\n\t    return point.adhereToRect(this);\n\t  },\n\t  rightLine: function () {\n\t    return new Line(this.topRight(), this.bottomRight());\n\t  },\n\t  rightMiddle: function () {\n\t    return new Point(this.x + this.width, this.y + this.height / 2);\n\t  },\n\t  round: function (precision) {\n\t    let f = 1; // case 0\n\t    if (precision) {\n\t      switch (precision) {\n\t        case 1:\n\t          f = 10;\n\t          break;\n\t        case 2:\n\t          f = 100;\n\t          break;\n\t        case 3:\n\t          f = 1000;\n\t          break;\n\t        default:\n\t          f = pow$1(10, precision);\n\t          break;\n\t      }\n\t    }\n\t    this.x = round$1(this.x * f) / f;\n\t    this.y = round$1(this.y * f) / f;\n\t    this.width = round$1(this.width * f) / f;\n\t    this.height = round$1(this.height * f) / f;\n\t    return this;\n\t  },\n\t  // Scale rectangle with origin.\n\t  scale: function (sx, sy, origin) {\n\t    origin = this.origin().scale(sx, sy, origin);\n\t    this.x = origin.x;\n\t    this.y = origin.y;\n\t    this.width *= sx;\n\t    this.height *= sy;\n\t    return this;\n\t  },\n\t  // @return {string} (left|right|top|bottom) side which is nearest to point\n\t  // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n\t  sideNearestToPoint: function (point) {\n\t    point = new Point(point);\n\t    var distToLeft = point.x - this.x;\n\t    var distToRight = this.x + this.width - point.x;\n\t    var distToTop = point.y - this.y;\n\t    var distToBottom = this.y + this.height - point.y;\n\t    var closest = distToLeft;\n\t    var side = 'left';\n\t    if (distToRight < closest) {\n\t      closest = distToRight;\n\t      side = 'right';\n\t    }\n\t    if (distToTop < closest) {\n\t      closest = distToTop;\n\t      side = 'top';\n\t    }\n\t    if (distToBottom < closest) {\n\t      // closest = distToBottom;\n\t      side = 'bottom';\n\t    }\n\t    return side;\n\t  },\n\t  snapToGrid: function (gx, gy) {\n\t    var origin = this.origin().snapToGrid(gx, gy);\n\t    var corner = this.corner().snapToGrid(gx, gy);\n\t    this.x = origin.x;\n\t    this.y = origin.y;\n\t    this.width = corner.x - origin.x;\n\t    this.height = corner.y - origin.y;\n\t    return this;\n\t  },\n\t  toJSON: function () {\n\t    return {\n\t      x: this.x,\n\t      y: this.y,\n\t      width: this.width,\n\t      height: this.height\n\t    };\n\t  },\n\t  topLine: function () {\n\t    return new Line(this.topLeft(), this.topRight());\n\t  },\n\t  topMiddle: function () {\n\t    return new Point(this.x + this.width / 2, this.y);\n\t  },\n\t  topRight: function () {\n\t    return new Point(this.x + this.width, this.y);\n\t  },\n\t  toString: function () {\n\t    return this.origin().toString() + ' ' + this.corner().toString();\n\t  },\n\t  // @return {rect} representing the union of both rectangles.\n\t  union: function (rect) {\n\t    return Rect.fromRectUnion(this, rect);\n\t  },\n\t  update: function (x, y, w, h) {\n\t    if (Object(x) === x) {\n\t      y = x.y;\n\t      w = x.width;\n\t      h = x.height;\n\t      x = x.x;\n\t    }\n\t    this.x = x || 0;\n\t    this.y = y || 0;\n\t    this.width = w || 0;\n\t    this.height = h || 0;\n\t    return this;\n\t  }\n\t};\n\tRect.prototype.bottomRight = Rect.prototype.corner;\n\tRect.prototype.topLeft = Rect.prototype.origin;\n\tRect.prototype.translate = Rect.prototype.offset;\n\n\t// For backwards compatibility:\n\tconst rect = Rect;\n\n\tfunction parsePoints(svgString) {\n\t  // Step 1: Discard surrounding spaces\n\t  const trimmedString = svgString.trim();\n\t  if (trimmedString === '') return [];\n\t  const points = [];\n\n\t  // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n\t  // ReDoS mitigation: Have an anchor at the beginning of each alternation\n\t  // Note: This doesn't simplify double (or more) commas - causes empty coords\n\t  // This regex is used by `split()`, so it doesn't need to use /g\n\t  const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n\t  const numCoords = coords.length;\n\t  for (let i = 0; i < numCoords; i += 2) {\n\t    // Step 3: Convert each coord to number\n\t    // Note: If the coord cannot be converted to a number, it will be `NaN`\n\t    // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n\t    // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n\t    points.push({\n\t      x: +coords[i],\n\t      y: +coords[i + 1]\n\t    });\n\t  }\n\t  return points;\n\t}\n\tfunction clonePoints(points) {\n\t  const numPoints = points.length;\n\t  if (numPoints === 0) return [];\n\t  const newPoints = [];\n\t  for (let i = 0; i < numPoints; i++) {\n\t    const point = points[i].clone();\n\t    newPoints.push(point);\n\t  }\n\t  return newPoints;\n\t}\n\n\t// Returns a convex-hull polyline from this polyline.\n\t// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n\t// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n\t// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\n\tfunction convexHull(points) {\n\t  const {\n\t    abs\n\t  } = Math;\n\t  var i;\n\t  var n;\n\t  var numPoints = points.length;\n\t  if (numPoints === 0) return []; // if points array is empty\n\n\t  // step 1: find the starting point - point with the lowest y (if equality, highest x)\n\t  var startPoint;\n\t  for (i = 0; i < numPoints; i++) {\n\t    if (startPoint === undefined) {\n\t      // if this is the first point we see, set it as start point\n\t      startPoint = points[i];\n\t    } else if (points[i].y < startPoint.y) {\n\t      // start point should have lowest y from all points\n\t      startPoint = points[i];\n\t    } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n\t      // if two points have the lowest y, choose the one that has highest x\n\t      // there are no points to the right of startPoint - no ambiguity about theta 0\n\t      // if there are several coincident start point candidates, first one is reported\n\t      startPoint = points[i];\n\t    }\n\t  }\n\n\t  // step 2: sort the list of points\n\t  // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n\t  // step 2a: create the point records = [point, originalIndex, angle]\n\t  var sortedPointRecords = [];\n\t  for (i = 0; i < numPoints; i++) {\n\t    var angle = startPoint.theta(points[i]);\n\t    if (angle === 0) {\n\t      angle = 360; // give highest angle to start point\n\t      // the start point will end up at end of sorted list\n\t      // the start point will end up at beginning of hull points list\n\t    }\n\t    var entry = [points[i], i, angle];\n\t    sortedPointRecords.push(entry);\n\t  }\n\n\t  // step 2b: sort the list in place\n\t  sortedPointRecords.sort(function (record1, record2) {\n\t    // returning a negative number here sorts record1 before record2\n\t    // if first angle is smaller than second, first angle should come before second\n\n\t    var sortOutput = record1[2] - record2[2]; // negative if first angle smaller\n\t    if (sortOutput === 0) {\n\t      // if the two angles are equal, sort by originalIndex\n\t      sortOutput = record2[1] - record1[1]; // negative if first index larger\n\t      // coincident points will be sorted in reverse-numerical order\n\t      // so the coincident points with lower original index will be considered first\n\t    }\n\t    return sortOutput;\n\t  });\n\n\t  // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n\t  if (sortedPointRecords.length > 2) {\n\t    var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n\t    sortedPointRecords.unshift(startPointRecord);\n\t  }\n\n\t  // step 3a: go through sorted points in order and find those with right turns\n\t  // we want to get our results in clockwise order\n\t  var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n\t  var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n\t  var currentPointRecord;\n\t  var currentPoint;\n\t  var lastHullPointRecord;\n\t  var lastHullPoint;\n\t  var secondLastHullPointRecord;\n\t  var secondLastHullPoint;\n\t  while (sortedPointRecords.length !== 0) {\n\t    currentPointRecord = sortedPointRecords.pop();\n\t    currentPoint = currentPointRecord[0];\n\n\t    // check if point has already been discarded\n\t    // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n\t    if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n\t      // this point had an incorrect turn at some previous iteration of this loop\n\t      // this disqualifies it from possibly being on the hull\n\t      continue;\n\t    }\n\t    var correctTurnFound = false;\n\t    while (!correctTurnFound) {\n\t      if (hullPointRecords.length < 2) {\n\t        // not enough points for comparison, just add current point\n\t        hullPointRecords.push(currentPointRecord);\n\t        correctTurnFound = true;\n\t      } else {\n\t        lastHullPointRecord = hullPointRecords.pop();\n\t        lastHullPoint = lastHullPointRecord[0];\n\t        secondLastHullPointRecord = hullPointRecords.pop();\n\t        secondLastHullPoint = secondLastHullPointRecord[0];\n\t        var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\t        if (crossProduct < 0) {\n\t          // found a right turn\n\t          hullPointRecords.push(secondLastHullPointRecord);\n\t          hullPointRecords.push(lastHullPointRecord);\n\t          hullPointRecords.push(currentPointRecord);\n\t          correctTurnFound = true;\n\t        } else if (crossProduct === 0) {\n\t          // the three points are collinear\n\t          // three options:\n\t          // there may be a 180 or 0 degree angle at lastHullPoint\n\t          // or two of the three points are coincident\n\t          var THRESHOLD = 1e-10; // we have to take rounding errors into account\n\t          var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\t          if (abs(angleBetween - 180) < THRESHOLD) {\n\t            // rounding around 180 to 180\n\t            // if the cross product is 0 because the angle is 180 degrees\n\t            // discard last hull point (add to insidePoints)\n\t            //insidePoints.unshift(lastHullPoint);\n\t            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t            // reenter second-to-last hull point (will be last at next iter)\n\t            hullPointRecords.push(secondLastHullPointRecord);\n\t            // do not do anything with current point\n\t            // correct turn not found\n\t          } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n\t            // if the cross product is 0 because two points are the same\n\t            // discard last hull point (add to insidePoints)\n\t            //insidePoints.unshift(lastHullPoint);\n\t            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t            // reenter second-to-last hull point (will be last at next iter)\n\t            hullPointRecords.push(secondLastHullPointRecord);\n\t            // do not do anything with current point\n\t            // correct turn not found\n\t          } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n\t            // rounding around 0 and 360 to 0\n\t            // if the cross product is 0 because the angle is 0 degrees\n\t            // remove last hull point from hull BUT do not discard it\n\t            // reenter second-to-last hull point (will be last at next iter)\n\t            hullPointRecords.push(secondLastHullPointRecord);\n\t            // put last hull point back into the sorted point records list\n\t            sortedPointRecords.push(lastHullPointRecord);\n\t            // we are switching the order of the 0deg and 180deg points\n\t            // correct turn not found\n\t          }\n\t        } else {\n\t          // found a left turn\n\t          // discard last hull point (add to insidePoints)\n\t          //insidePoints.unshift(lastHullPoint);\n\t          insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t          // reenter second-to-last hull point (will be last at next iter of loop)\n\t          hullPointRecords.push(secondLastHullPointRecord);\n\t          // do not do anything with current point\n\t          // correct turn not found\n\t        }\n\t      }\n\t    }\n\t  }\n\t  // at this point, hullPointRecords contains the output points in clockwise order\n\t  // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n\t  // step 3b: remove duplicated startPointRecord from the end of the array\n\t  if (hullPointRecords.length > 2) {\n\t    hullPointRecords.pop();\n\t  }\n\n\t  // step 4: find the lowest originalIndex record and put it at the beginning of hull\n\t  var lowestHullIndex; // the lowest originalIndex on the hull\n\t  var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\t  n = hullPointRecords.length;\n\t  for (i = 0; i < n; i++) {\n\t    var currentHullIndex = hullPointRecords[i][1];\n\t    if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n\t      lowestHullIndex = currentHullIndex;\n\t      indexOfLowestHullIndexRecord = i;\n\t    }\n\t  }\n\t  var hullPointRecordsReordered = [];\n\t  if (indexOfLowestHullIndexRecord > 0) {\n\t    var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n\t    var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n\t    hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\t  } else {\n\t    hullPointRecordsReordered = hullPointRecords;\n\t  }\n\t  var hullPoints = [];\n\t  n = hullPointRecordsReordered.length;\n\t  for (i = 0; i < n; i++) {\n\t    hullPoints.push(hullPointRecordsReordered[i][0]);\n\t  }\n\t  return hullPoints;\n\t}\n\n\tconst Polyline$1 = function (points) {\n\t  if (!(this instanceof Polyline$1)) {\n\t    return new Polyline$1(points);\n\t  }\n\t  if (typeof points === 'string') {\n\t    return new Polyline$1.parse(points);\n\t  }\n\t  this.points = Array.isArray(points) ? points.map(Point) : [];\n\t};\n\tPolyline$1.parse = function (svgString) {\n\t  return new Polyline$1(parsePoints(svgString));\n\t};\n\tPolyline$1.fromRect = function (rect) {\n\t  return new Polyline$1([rect.topLeft(), rect.topRight(), rect.bottomRight(), rect.bottomLeft(), rect.topLeft()]);\n\t};\n\tPolyline$1.prototype = {\n\t  type: types.Polyline,\n\t  bbox: function () {\n\t    var x1 = Infinity;\n\t    var x2 = -Infinity;\n\t    var y1 = Infinity;\n\t    var y2 = -Infinity;\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\n\t    for (var i = 0; i < numPoints; i++) {\n\t      var point = points[i];\n\t      var x = point.x;\n\t      var y = point.y;\n\t      if (x < x1) x1 = x;\n\t      if (x > x2) x2 = x;\n\t      if (y < y1) y1 = y;\n\t      if (y > y2) y2 = y;\n\t    }\n\t    return new Rect(x1, y1, x2 - x1, y2 - y1);\n\t  },\n\t  clone: function () {\n\t    return new Polyline$1(clonePoints(this.points));\n\t  },\n\t  closestPoint: function (p) {\n\t    var cpLength = this.closestPointLength(p);\n\t    return this.pointAtLength(cpLength);\n\t  },\n\t  closestPointLength: function (p) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return 0; // if points array is empty\n\t    if (numPoints === 1) return 0; // if there is only one point\n\n\t    var cpLength;\n\t    var minSqrDistance = Infinity;\n\t    var length = 0;\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      var line = new Line(points[i], points[i + 1]);\n\t      var lineLength = line.length();\n\t      var cpNormalizedLength = line.closestPointNormalizedLength(p);\n\t      var cp = line.pointAt(cpNormalizedLength);\n\t      var sqrDistance = cp.squaredDistance(p);\n\t      if (sqrDistance < minSqrDistance) {\n\t        minSqrDistance = sqrDistance;\n\t        cpLength = length + cpNormalizedLength * lineLength;\n\t      }\n\t      length += lineLength;\n\t    }\n\t    return cpLength;\n\t  },\n\t  closestPointNormalizedLength: function (p) {\n\t    var cpLength = this.closestPointLength(p);\n\t    if (cpLength === 0) return 0; // shortcut\n\n\t    var length = this.length();\n\t    if (length === 0) return 0; // prevents division by zero\n\n\t    return cpLength / length;\n\t  },\n\t  closestPointTangent: function (p) {\n\t    var cpLength = this.closestPointLength(p);\n\t    return this.tangentAtLength(cpLength);\n\t  },\n\t  // Returns `true` if the area surrounded by the polyline contains the point `p`.\n\t  // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n\t  // (Uses horizontal rays to the right of `p` to look for intersections.)\n\t  // Closes open polylines (always imagines a final closing segment).\n\t  containsPoint: function (p) {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n\t    var x = p.x;\n\t    var y = p.y;\n\n\t    // initialize a final closing segment by creating one from last-first points on polyline\n\t    var startIndex = numPoints - 1; // start of current polyline segment\n\t    var endIndex = 0; // end of current polyline segment\n\t    var numIntersections = 0;\n\t    var segment = new Line();\n\t    var ray = new Line();\n\t    var rayEnd = new Point();\n\t    for (; endIndex < numPoints; endIndex++) {\n\t      var start = points[startIndex];\n\t      var end = points[endIndex];\n\t      if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n\t      // current polyline segment\n\t      segment.start = start;\n\t      segment.end = end;\n\t      if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n\t      // do we have an intersection?\n\t      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n\t        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n\t        // (when `y === start.y === end.y`)\n\t        // this conditional branch IS entered when `segment` touches `ray` at only one point\n\t        // (e.g. when `y === start.y !== end.y`)\n\t        // since this branch is entered again for the following segment, the two touches cancel out\n\n\t        var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\t        if (xDifference >= 0) {\n\t          // segment lies at least partially to the right of `p`\n\t          rayEnd.x = x + xDifference;\n\t          rayEnd.y = y; // right\n\t          ray.start = p;\n\t          ray.end = rayEnd;\n\t          if (segment.intersect(ray)) {\n\t            // an intersection was detected to the right of `p`\n\t            numIntersections++;\n\t          }\n\t        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\t      }\n\n\t      // move to check the next polyline segment\n\t      startIndex = endIndex;\n\t    }\n\n\t    // returns `true` for odd numbers of intersections (even-odd algorithm)\n\t    return numIntersections % 2 === 1;\n\t  },\n\t  close: function () {\n\t    const {\n\t      start,\n\t      end,\n\t      points\n\t    } = this;\n\t    if (start && end && !start.equals(end)) {\n\t      points.push(start.clone());\n\t    }\n\t    return this;\n\t  },\n\t  lengthPoints: function () {\n\t    return this.points;\n\t  },\n\t  convexHull: function () {\n\t    return new Polyline$1(convexHull(this.points));\n\t  },\n\t  // Checks whether two polylines are exactly the same.\n\t  // If `p` is undefined or null, returns false.\n\t  equals: function (p) {\n\t    if (!p) return false;\n\t    var points = this.points;\n\t    var otherPoints = p.points;\n\t    var numPoints = points.length;\n\t    if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n\t    for (var i = 0; i < numPoints; i++) {\n\t      var point = points[i];\n\t      var otherPoint = p.points[i];\n\n\t      // as soon as an inequality is found in points, return false\n\t      if (!point.equals(otherPoint)) return false;\n\t    }\n\n\t    // if no inequality found in points, return true\n\t    return true;\n\t  },\n\t  intersectionWithLine: function (l) {\n\t    var line = new Line(l);\n\t    var intersections = [];\n\t    var points = this.lengthPoints();\n\t    var l2 = new Line();\n\t    for (var i = 0, n = points.length - 1; i < n; i++) {\n\t      l2.start = points[i];\n\t      l2.end = points[i + 1];\n\t      var int = line.intersectionWithLine(l2);\n\t      if (int) intersections.push(int[0]);\n\t    }\n\t    return intersections.length > 0 ? intersections : null;\n\t  },\n\t  isDifferentiable: function () {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return false;\n\t    var line = new Line();\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      line.start = points[i];\n\t      line.end = points[i + 1];\n\t      // as soon as a differentiable line is found between two points, return true\n\t      if (line.isDifferentiable()) return true;\n\t    }\n\n\t    // if no differentiable line is found between pairs of points, return false\n\t    return false;\n\t  },\n\t  length: function () {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return 0; // if points array is empty\n\n\t    var length = 0;\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      length += points[i].distance(points[i + 1]);\n\t    }\n\t    return length;\n\t  },\n\t  pointAt: function (ratio) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\t    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n\t    if (ratio <= 0) return points[0].clone();\n\t    if (ratio >= 1) return points[numPoints - 1].clone();\n\t    var polylineLength = this.length();\n\t    var length = polylineLength * ratio;\n\t    return this.pointAtLength(length);\n\t  },\n\t  pointAtLength: function (length) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\t    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    var l = 0;\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      var index = fromStart ? i : n - 1 - i;\n\t      var a = points[index];\n\t      var b = points[index + 1];\n\t      var line = new Line(a, b);\n\t      var d = a.distance(b);\n\t      if (length <= l + d) {\n\t        return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the polyline, return last endpoint\n\t    var lastPoint = fromStart ? points[numPoints - 1] : points[0];\n\t    return lastPoint.clone();\n\t  },\n\t  round: function (precision) {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    for (var i = 0; i < numPoints; i++) {\n\t      points[i].round(precision);\n\t    }\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    for (var i = 0; i < numPoints; i++) {\n\t      points[i].scale(sx, sy, origin);\n\t    }\n\t    return this;\n\t  },\n\t  simplify: function (opt = {}) {\n\t    const points = this.points;\n\t    if (points.length < 3) return this; // we need at least 3 points\n\n\t    // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n\t    // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n\t    // because of the rounding errors that can occur when comparing distances.\n\t    const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n\n\t    // start at the beginning of the polyline and go forward\n\t    let currentIndex = 0;\n\t    // we need at least one intermediate point (3 points) in every iteration\n\t    // as soon as that stops being true, we know we reached the end of the polyline\n\t    while (points[currentIndex + 2]) {\n\t      const firstIndex = currentIndex;\n\t      const middleIndex = currentIndex + 1;\n\t      const lastIndex = currentIndex + 2;\n\t      const firstPoint = points[firstIndex];\n\t      const middlePoint = points[middleIndex];\n\t      const lastPoint = points[lastIndex];\n\t      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\t      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\t      const closestPointDistance = closestPoint.distance(middlePoint);\n\t      if (closestPointDistance <= threshold) {\n\t        // middle point is close enough to the chord = simplify\n\t        // 1) remove middle point:\n\t        points.splice(middleIndex, 1);\n\t        // 2) in next iteration, investigate the newly-created triplet of points\n\t        //    - do not change `currentIndex`\n\t        //    = (first point stays, point after removed point becomes middle point)\n\t      } else {\n\t        // middle point is far from the chord\n\t        // 1) preserve middle point\n\t        // 2) in next iteration, move `currentIndex` by one step:\n\t        currentIndex += 1;\n\t        //    = (point after first point becomes first point)\n\t      }\n\t    }\n\n\t    // `points` array was modified in-place\n\t    return this;\n\t  },\n\t  tangentAt: function (ratio) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\t    if (numPoints === 1) return null; // if there is only one point\n\n\t    if (ratio < 0) ratio = 0;\n\t    if (ratio > 1) ratio = 1;\n\t    var polylineLength = this.length();\n\t    var length = polylineLength * ratio;\n\t    return this.tangentAtLength(length);\n\t  },\n\t  tangentAtLength: function (length) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\t    if (numPoints === 1) return null; // if there is only one point\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    var lastValidLine; // differentiable (with a tangent)\n\t    var l = 0; // length so far\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      var index = fromStart ? i : n - 1 - i;\n\t      var a = points[index];\n\t      var b = points[index + 1];\n\t      var line = new Line(a, b);\n\t      var d = a.distance(b);\n\t      if (line.isDifferentiable()) {\n\t        // has a tangent line (line length is not 0)\n\t        if (length <= l + d) {\n\t          return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n\t        }\n\t        lastValidLine = line;\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the polyline, return last valid endpoint\n\t    if (lastValidLine) {\n\t      var ratio = fromStart ? 1 : 0;\n\t      return lastValidLine.tangentAt(ratio);\n\t    }\n\n\t    // if no valid line, return null\n\t    return null;\n\t  },\n\t  toString: function () {\n\t    return this.points + '';\n\t  },\n\t  translate: function (tx, ty) {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    for (var i = 0; i < numPoints; i++) {\n\t      points[i].translate(tx, ty);\n\t    }\n\t    return this;\n\t  },\n\t  // Return svgString that can be used to recreate this line.\n\t  serialize: function () {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return ''; // if points array is empty\n\n\t    var output = '';\n\t    for (var i = 0; i < numPoints; i++) {\n\t      var point = points[i];\n\t      output += point.x + ',' + point.y + ' ';\n\t    }\n\t    return output.trim();\n\t  }\n\t};\n\tObject.defineProperty(Polyline$1.prototype, 'start', {\n\t  // Getter for the first point of the polyline.\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\n\t    return this.points[0];\n\t  }\n\t});\n\tObject.defineProperty(Polyline$1.prototype, 'end', {\n\t  // Getter for the last point of the polyline.\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\n\t    return this.points[numPoints - 1];\n\t  }\n\t});\n\n\tconst {\n\t  abs,\n\t  sqrt,\n\t  min,\n\t  max,\n\t  pow\n\t} = Math;\n\tconst Curve = function (p1, p2, p3, p4) {\n\t  if (!(this instanceof Curve)) {\n\t    return new Curve(p1, p2, p3, p4);\n\t  }\n\t  if (p1 instanceof Curve) {\n\t    return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n\t  }\n\t  this.start = new Point(p1);\n\t  this.controlPoint1 = new Point(p2);\n\t  this.controlPoint2 = new Point(p3);\n\t  this.end = new Point(p4);\n\t};\n\n\t// Curve passing through points.\n\t// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n\t// @param {array} points Array of points through which the smooth line will go.\n\t// @return {array} curves.\n\tCurve.throughPoints = function () {\n\t  // Get open-ended Bezier Spline Control Points.\n\t  // @param knots Input Knot Bezier spline points (At least two points!).\n\t  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n\t  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n\t  function getCurveControlPoints(knots) {\n\t    var firstControlPoints = [];\n\t    var secondControlPoints = [];\n\t    var n = knots.length - 1;\n\t    var i;\n\n\t    // Special case: Bezier curve should be a straight line.\n\t    if (n == 1) {\n\t      // 3P1 = 2P0 + P3\n\t      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n\n\t      // P2 = 2P1 â P0\n\t      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n\t      return [firstControlPoints, secondControlPoints];\n\t    }\n\n\t    // Calculate first Bezier control points.\n\t    // Right hand side vector.\n\t    var rhs = [];\n\n\t    // Set right hand side X values.\n\t    for (i = 1; i < n - 1; i++) {\n\t      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n\t    }\n\t    rhs[0] = knots[0].x + 2 * knots[1].x;\n\t    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n\t    // Get first control points X-values.\n\t    var x = getFirstControlPoints(rhs);\n\n\t    // Set right hand side Y values.\n\t    for (i = 1; i < n - 1; ++i) {\n\t      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n\t    }\n\t    rhs[0] = knots[0].y + 2 * knots[1].y;\n\t    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n\t    // Get first control points Y-values.\n\t    var y = getFirstControlPoints(rhs);\n\n\t    // Fill output arrays.\n\t    for (i = 0; i < n; i++) {\n\t      // First control point.\n\t      firstControlPoints.push(new Point(x[i], y[i]));\n\n\t      // Second control point.\n\t      if (i < n - 1) {\n\t        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n\t      } else {\n\t        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n\t      }\n\t    }\n\t    return [firstControlPoints, secondControlPoints];\n\t  }\n\n\t  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n\t  // @param rhs Right hand side vector.\n\t  // @return Solution vector.\n\t  function getFirstControlPoints(rhs) {\n\t    var n = rhs.length;\n\t    // `x` is a solution vector.\n\t    var x = [];\n\t    var tmp = [];\n\t    var b = 2.0;\n\t    x[0] = rhs[0] / b;\n\n\t    // Decomposition and forward substitution.\n\t    for (var i = 1; i < n; i++) {\n\t      tmp[i] = 1 / b;\n\t      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n\t      x[i] = (rhs[i] - x[i - 1]) / b;\n\t    }\n\t    for (i = 1; i < n; i++) {\n\t      // Backsubstitution.\n\t      x[n - i - 1] -= tmp[n - i] * x[n - i];\n\t    }\n\t    return x;\n\t  }\n\t  return function (points) {\n\t    if (!points || Array.isArray(points) && points.length < 2) {\n\t      throw new Error('At least 2 points are required');\n\t    }\n\t    var controlPoints = getCurveControlPoints(points);\n\t    var curves = [];\n\t    var n = controlPoints[0].length;\n\t    for (var i = 0; i < n; i++) {\n\t      var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n\t      var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\t      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n\t    }\n\t    return curves;\n\t  };\n\t}();\n\tCurve.prototype = {\n\t  type: types.Curve,\n\t  // Returns a bbox that tightly envelops the curve.\n\t  bbox: function () {\n\t    var start = this.start;\n\t    var controlPoint1 = this.controlPoint1;\n\t    var controlPoint2 = this.controlPoint2;\n\t    var end = this.end;\n\t    var x0 = start.x;\n\t    var y0 = start.y;\n\t    var x1 = controlPoint1.x;\n\t    var y1 = controlPoint1.y;\n\t    var x2 = controlPoint2.x;\n\t    var y2 = controlPoint2.y;\n\t    var x3 = end.x;\n\t    var y3 = end.y;\n\t    var points = new Array(); // local extremes\n\t    var tvalues = new Array(); // t values of local extremes\n\t    var bounds = [new Array(), new Array()];\n\t    var a, b, c, t;\n\t    var t1, t2;\n\t    var b2ac, sqrtb2ac;\n\t    for (var i = 0; i < 2; ++i) {\n\t      if (i === 0) {\n\t        b = 6 * x0 - 12 * x1 + 6 * x2;\n\t        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n\t        c = 3 * x1 - 3 * x0;\n\t      } else {\n\t        b = 6 * y0 - 12 * y1 + 6 * y2;\n\t        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n\t        c = 3 * y1 - 3 * y0;\n\t      }\n\t      if (abs(a) < 1e-12) {\n\t        // Numerical robustness\n\t        if (abs(b) < 1e-12) {\n\t          // Numerical robustness\n\t          continue;\n\t        }\n\t        t = -c / b;\n\t        if (0 < t && t < 1) tvalues.push(t);\n\t        continue;\n\t      }\n\t      b2ac = b * b - 4 * c * a;\n\t      sqrtb2ac = sqrt(b2ac);\n\t      if (b2ac < 0) continue;\n\t      t1 = (-b + sqrtb2ac) / (2 * a);\n\t      if (0 < t1 && t1 < 1) tvalues.push(t1);\n\t      t2 = (-b - sqrtb2ac) / (2 * a);\n\t      if (0 < t2 && t2 < 1) tvalues.push(t2);\n\t    }\n\t    var j = tvalues.length;\n\t    var jlen = j;\n\t    var mt;\n\t    var x, y;\n\t    while (j--) {\n\t      t = tvalues[j];\n\t      mt = 1 - t;\n\t      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n\t      bounds[0][j] = x;\n\t      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n\t      bounds[1][j] = y;\n\t      points[j] = {\n\t        X: x,\n\t        Y: y\n\t      };\n\t    }\n\t    tvalues[jlen] = 0;\n\t    tvalues[jlen + 1] = 1;\n\t    points[jlen] = {\n\t      X: x0,\n\t      Y: y0\n\t    };\n\t    points[jlen + 1] = {\n\t      X: x3,\n\t      Y: y3\n\t    };\n\t    bounds[0][jlen] = x0;\n\t    bounds[1][jlen] = y0;\n\t    bounds[0][jlen + 1] = x3;\n\t    bounds[1][jlen + 1] = y3;\n\t    tvalues.length = jlen + 2;\n\t    bounds[0].length = jlen + 2;\n\t    bounds[1].length = jlen + 2;\n\t    points.length = jlen + 2;\n\t    var left = min.apply(null, bounds[0]);\n\t    var top = min.apply(null, bounds[1]);\n\t    var right = max.apply(null, bounds[0]);\n\t    var bottom = max.apply(null, bounds[1]);\n\t    return new Rect(left, top, right - left, bottom - top);\n\t  },\n\t  clone: function () {\n\t    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t  },\n\t  // Returns the point on the curve closest to point `p`\n\t  closestPoint: function (p, opt) {\n\t    return this.pointAtT(this.closestPointT(p, opt));\n\t  },\n\t  closestPointLength: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      subdivisions: subdivisions\n\t    };\n\t    return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n\t  },\n\t  closestPointNormalizedLength: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      subdivisions: subdivisions\n\t    };\n\t    var cpLength = this.closestPointLength(p, localOpt);\n\t    if (!cpLength) return 0;\n\t    var length = this.length(localOpt);\n\t    if (length === 0) return 0;\n\t    return cpLength / length;\n\t  },\n\t  // Returns `t` of the point on the curve closest to point `p`\n\t  closestPointT: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    // does not use localOpt\n\n\t    // identify the subdivision that contains the point:\n\t    var investigatedSubdivision;\n\t    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\t    var investigatedSubdivisionEndT;\n\t    var distFromStart; // distance of point from start of baseline\n\t    var distFromEnd; // distance of point from end of baseline\n\t    var chordLength; // distance between start and end of the subdivision\n\t    var minSumDist; // lowest observed sum of the two distances\n\t    var n = subdivisions.length;\n\t    var subdivisionSize = n ? 1 / n : 0;\n\t    for (var i = 0; i < n; i++) {\n\t      var currentSubdivision = subdivisions[i];\n\t      var startDist = currentSubdivision.start.distance(p);\n\t      var endDist = currentSubdivision.end.distance(p);\n\t      var sumDist = startDist + endDist;\n\n\t      // check that the point is closest to current subdivision and not any other\n\t      if (!minSumDist || sumDist < minSumDist) {\n\t        investigatedSubdivision = currentSubdivision;\n\t        investigatedSubdivisionStartT = i * subdivisionSize;\n\t        investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\t        distFromStart = startDist;\n\t        distFromEnd = endDist;\n\t        chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\t        minSumDist = sumDist;\n\t      }\n\t    }\n\t    var precisionRatio = pow(10, -precision);\n\n\t    // recursively divide investigated subdivision:\n\t    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n\t    // then return the closest endpoint of that final subdivision\n\t    while (true) {\n\t      // check if we have reached at least one required observed precision\n\t      // - calculated as: the difference in distances from point to start and end divided by the distance\n\t      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n\t      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n\t      // - this criterion works well for points lying far away from the curve\n\t      var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;\n\t      var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;\n\t      var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;\n\n\t      // check if we have reached at least one required minimal distance\n\t      // - calculated as: the subdivision chord length multiplied by precisionRatio\n\t      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n\t      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\t      var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n\t      var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n\t      var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance;\n\n\t      // do we stop now?\n\t      if (hasRequiredPrecision || hasMinimalDistance) {\n\t        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n\t      }\n\n\t      // otherwise, set up for next iteration\n\t      var divided = investigatedSubdivision.divide(0.5);\n\t      subdivisionSize /= 2;\n\t      var startDist1 = divided[0].start.distance(p);\n\t      var endDist1 = divided[0].end.distance(p);\n\t      var sumDist1 = startDist1 + endDist1;\n\t      var startDist2 = divided[1].start.distance(p);\n\t      var endDist2 = divided[1].end.distance(p);\n\t      var sumDist2 = startDist2 + endDist2;\n\t      if (sumDist1 <= sumDist2) {\n\t        investigatedSubdivision = divided[0];\n\t        investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n\t        distFromStart = startDist1;\n\t        distFromEnd = endDist1;\n\t      } else {\n\t        investigatedSubdivision = divided[1];\n\t        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n\t        distFromStart = startDist2;\n\t        distFromEnd = endDist2;\n\t      }\n\t    }\n\t  },\n\t  closestPointTangent: function (p, opt) {\n\t    return this.tangentAtT(this.closestPointT(p, opt));\n\t  },\n\t  // Returns `true` if the area surrounded by the curve contains the point `p`.\n\t  // Implements the even-odd algorithm (self-intersections are \"outside\").\n\t  // Closes open curves (always imagines a closing segment).\n\t  // Precision may be adjusted by passing an `opt` object.\n\t  containsPoint: function (p, opt) {\n\t    var polyline = this.toPolyline(opt);\n\t    return polyline.containsPoint(p);\n\t  },\n\t  // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  // For a function that uses `t`, use Curve.divideAtT().\n\t  divideAt: function (ratio, opt) {\n\t    if (ratio <= 0) return this.divideAtT(0);\n\t    if (ratio >= 1) return this.divideAtT(1);\n\t    var t = this.tAt(ratio, opt);\n\t    return this.divideAtT(t);\n\t  },\n\t  // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  divideAtLength: function (length, opt) {\n\t    var t = this.tAtLength(length, opt);\n\t    return this.divideAtT(t);\n\t  },\n\t  // Divides the curve into two at point defined by `t` between 0 and 1.\n\t  // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n\t  // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n\t  divideAtT: function (t) {\n\t    var start = this.start;\n\t    var controlPoint1 = this.controlPoint1;\n\t    var controlPoint2 = this.controlPoint2;\n\t    var end = this.end;\n\n\t    // shortcuts for `t` values that are out of range\n\t    if (t <= 0) {\n\t      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n\t    }\n\t    if (t >= 1) {\n\t      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n\t    }\n\t    var dividerPoints = this.getSkeletonPoints(t);\n\t    var startControl1 = dividerPoints.startControlPoint1;\n\t    var startControl2 = dividerPoints.startControlPoint2;\n\t    var divider = dividerPoints.divider;\n\t    var dividerControl1 = dividerPoints.dividerControlPoint1;\n\t    var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n\t    // return array with two new curves\n\t    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n\t  },\n\t  // Returns the distance between the curve's start and end points.\n\t  endpointDistance: function () {\n\t    return this.start.distance(this.end);\n\t  },\n\t  // Checks whether two curves are exactly the same.\n\t  equals: function (c) {\n\t    return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;\n\t  },\n\t  // Returns five helper points necessary for curve division.\n\t  getSkeletonPoints: function (t) {\n\t    var start = this.start;\n\t    var control1 = this.controlPoint1;\n\t    var control2 = this.controlPoint2;\n\t    var end = this.end;\n\n\t    // shortcuts for `t` values that are out of range\n\t    if (t <= 0) {\n\t      return {\n\t        startControlPoint1: start.clone(),\n\t        startControlPoint2: start.clone(),\n\t        divider: start.clone(),\n\t        dividerControlPoint1: control1.clone(),\n\t        dividerControlPoint2: control2.clone()\n\t      };\n\t    }\n\t    if (t >= 1) {\n\t      return {\n\t        startControlPoint1: control1.clone(),\n\t        startControlPoint2: control2.clone(),\n\t        divider: end.clone(),\n\t        dividerControlPoint1: end.clone(),\n\t        dividerControlPoint2: end.clone()\n\t      };\n\t    }\n\t    var midpoint1 = new Line(start, control1).pointAt(t);\n\t    var midpoint2 = new Line(control1, control2).pointAt(t);\n\t    var midpoint3 = new Line(control2, end).pointAt(t);\n\t    var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n\t    var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n\t    var divider = new Line(subControl1, subControl2).pointAt(t);\n\t    var output = {\n\t      startControlPoint1: midpoint1,\n\t      startControlPoint2: subControl1,\n\t      divider: divider,\n\t      dividerControlPoint1: subControl2,\n\t      dividerControlPoint2: midpoint3\n\t    };\n\t    return output;\n\t  },\n\t  // Returns a list of curves whose flattened length is better than `opt.precision`.\n\t  // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n\t  // (Observed difference is not real precision, but close enough as long as special cases are covered)\n\t  // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n\t  // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n\t  // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n\t  // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n\t  // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n\t  // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n\t  // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n\t  getSubdivisions: function (opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    // not using opt.subdivisions\n\t    // not using localOpt\n\n\t    var start = this.start;\n\t    var control1 = this.controlPoint1;\n\t    var control2 = this.controlPoint2;\n\t    var end = this.end;\n\t    var subdivisions = [new Curve(start, control1, control2, end)];\n\t    if (precision === 0) return subdivisions;\n\n\t    // special case #1: point-like curves\n\t    // - no need to calculate subdivisions, they would all be identical\n\t    var isPoint = !this.isDifferentiable();\n\t    if (isPoint) return subdivisions;\n\t    var previousLength = this.endpointDistance();\n\t    var precisionRatio = pow(10, -precision);\n\n\t    // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n\t    // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n\t    // - (i.e. cubic curves cannot intersect the baseline more than once)\n\t    // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n\t    // - (unless it's a straight-line curve, see below)\n\t    var minIterations = 2; // = 2*1\n\n\t    // special case #3: straight-line curves have the same observed length in all iterations\n\t    // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n\t    // - we enforce the expected number of iterations = 2 * precision\n\t    var isLine = control1.cross(start, end) === 0 && control2.cross(start, end) === 0;\n\t    if (isLine) {\n\t      minIterations = 2 * precision;\n\t    }\n\n\t    // recursively divide curve at `t = 0.5`\n\t    // until we reach `minIterations`\n\t    // and until the difference between observed length at subsequent iterations is lower than `precision`\n\t    var iteration = 0;\n\t    while (true) {\n\t      iteration += 1;\n\n\t      // divide all subdivisions\n\t      var newSubdivisions = [];\n\t      var numSubdivisions = subdivisions.length;\n\t      for (var i = 0; i < numSubdivisions; i++) {\n\t        var currentSubdivision = subdivisions[i];\n\t        var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n\t        newSubdivisions.push(divided[0], divided[1]);\n\t      }\n\n\t      // measure new length\n\t      var length = 0;\n\t      var numNewSubdivisions = newSubdivisions.length;\n\t      for (var j = 0; j < numNewSubdivisions; j++) {\n\t        var currentNewSubdivision = newSubdivisions[j];\n\t        length += currentNewSubdivision.endpointDistance();\n\t      }\n\n\t      // check if we have reached minimum number of iterations\n\t      if (iteration >= minIterations) {\n\t        // check if we have reached required observed precision\n\t        var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;\n\t        if (observedPrecisionRatio < precisionRatio) {\n\t          return newSubdivisions;\n\t        }\n\t      }\n\n\t      // otherwise, set up for next iteration\n\t      subdivisions = newSubdivisions;\n\t      previousLength = length;\n\t    }\n\t  },\n\t  isDifferentiable: function () {\n\t    var start = this.start;\n\t    var control1 = this.controlPoint1;\n\t    var control2 = this.controlPoint2;\n\t    var end = this.end;\n\t    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n\t  },\n\t  // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n\t  length: function (opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    // not using localOpt\n\n\t    var length = 0;\n\t    var n = subdivisions.length;\n\t    for (var i = 0; i < n; i++) {\n\t      var currentSubdivision = subdivisions[i];\n\t      length += currentSubdivision.endpointDistance();\n\t    }\n\t    return length;\n\t  },\n\t  // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n\t  lengthAtT: function (t, opt) {\n\t    if (t <= 0) return 0;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    // not using opt.subdivisions\n\t    // not using localOpt\n\n\t    var subCurve = this.divide(t)[0];\n\t    var subCurveLength = subCurve.length({\n\t      precision: precision\n\t    });\n\t    return subCurveLength;\n\t  },\n\t  // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  // Mirrors Line.pointAt() function.\n\t  // For a function that tracks `t`, use Curve.pointAtT().\n\t  pointAt: function (ratio, opt) {\n\t    if (ratio <= 0) return this.start.clone();\n\t    if (ratio >= 1) return this.end.clone();\n\t    var t = this.tAt(ratio, opt);\n\t    return this.pointAtT(t);\n\t  },\n\t  // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  pointAtLength: function (length, opt) {\n\t    var t = this.tAtLength(length, opt);\n\t    return this.pointAtT(t);\n\t  },\n\t  // Returns the point at provided `t` between 0 and 1.\n\t  // `t` does not track distance along curve as it does in Line objects.\n\t  // Non-linear relationship, speeds up and slows down as curve warps!\n\t  // For linear length-based solution, use Curve.pointAt().\n\t  pointAtT: function (t) {\n\t    if (t <= 0) return this.start.clone();\n\t    if (t >= 1) return this.end.clone();\n\t    return this.getSkeletonPoints(t).divider;\n\t  },\n\t  // Default precision\n\t  PRECISION: 3,\n\t  round: function (precision) {\n\t    this.start.round(precision);\n\t    this.controlPoint1.round(precision);\n\t    this.controlPoint2.round(precision);\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.start.scale(sx, sy, origin);\n\t    this.controlPoint1.scale(sx, sy, origin);\n\t    this.controlPoint2.scale(sx, sy, origin);\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n\t  tangentAt: function (ratio, opt) {\n\t    if (!this.isDifferentiable()) return null;\n\t    if (ratio < 0) ratio = 0;else if (ratio > 1) ratio = 1;\n\t    var t = this.tAt(ratio, opt);\n\t    return this.tangentAtT(t);\n\t  },\n\t  // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n\t  tangentAtLength: function (length, opt) {\n\t    if (!this.isDifferentiable()) return null;\n\t    var t = this.tAtLength(length, opt);\n\t    return this.tangentAtT(t);\n\t  },\n\t  // Returns a tangent line at requested `t`.\n\t  tangentAtT: function (t) {\n\t    if (!this.isDifferentiable()) return null;\n\t    if (t < 0) t = 0;else if (t > 1) t = 1;\n\t    var skeletonPoints = this.getSkeletonPoints(t);\n\t    var p1 = skeletonPoints.startControlPoint2;\n\t    var p2 = skeletonPoints.dividerControlPoint1;\n\t    var tangentStart = skeletonPoints.divider;\n\t    var tangentLine = new Line(p1, p2);\n\t    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n\t    return tangentLine;\n\t  },\n\t  // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  tAt: function (ratio, opt) {\n\t    if (ratio <= 0) return 0;\n\t    if (ratio >= 1) return 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      subdivisions: subdivisions\n\t    };\n\t    var curveLength = this.length(localOpt);\n\t    var length = curveLength * ratio;\n\t    return this.tAtLength(length, localOpt);\n\t  },\n\t  // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  // Uses `precision` to approximate length within `precision` (always underestimates)\n\t  // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n\t  // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n\t  // - Precision 0 (chooses one of the two endpoints) - 0 levels\n\t  // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n\t  // - Precision 2 (<1% error) - 3 levels\n\t  // - Precision 3 (<0.1% error) - 7 levels\n\t  // - Precision 4 (<0.01% error) - 15 levels\n\t  tAtLength: function (length, opt) {\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      subdivisions: subdivisions\n\t    };\n\n\t    // identify the subdivision that contains the point at requested `length`:\n\t    var investigatedSubdivision;\n\t    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\t    var investigatedSubdivisionEndT;\n\t    //var baseline; // straightened version of subdivision to investigate\n\t    //var baselinePoint; // point on the baseline that is the requested distance away from start\n\t    var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n\t    var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n\t    var l = 0; // length so far\n\t    var n = subdivisions.length;\n\t    var subdivisionSize = 1 / n;\n\t    for (var i = 0; i < n; i++) {\n\t      var index = fromStart ? i : n - 1 - i;\n\t      var currentSubdivision = subdivisions[i];\n\t      var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n\t      if (length <= l + d) {\n\t        investigatedSubdivision = currentSubdivision;\n\t        investigatedSubdivisionStartT = index * subdivisionSize;\n\t        investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\t        baselinePointDistFromStart = fromStart ? length - l : d + l - length;\n\t        baselinePointDistFromEnd = fromStart ? d + l - length : length - l;\n\t        break;\n\t      }\n\t      l += d;\n\t    }\n\t    if (!investigatedSubdivision) return fromStart ? 1 : 0; // length requested is out of range - return maximum t\n\t    // note that precision affects what length is recorded\n\t    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n\t    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n\t    var curveLength = this.length(localOpt);\n\t    var precisionRatio = pow(10, -precision);\n\n\t    // recursively divide investigated subdivision:\n\t    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n\t    // then return the closest endpoint of that final subdivision\n\t    while (true) {\n\t      // check if we have reached required observed precision\n\t      var observedPrecisionRatio;\n\t      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;\n\t      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n\t      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;\n\t      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n\t      // otherwise, set up for next iteration\n\t      var newBaselinePointDistFromStart;\n\t      var newBaselinePointDistFromEnd;\n\t      var divided = investigatedSubdivision.divide(0.5);\n\t      subdivisionSize /= 2;\n\t      var baseline1Length = divided[0].endpointDistance();\n\t      var baseline2Length = divided[1].endpointDistance();\n\t      if (baselinePointDistFromStart <= baseline1Length) {\n\t        // point at requested length is inside divided[0]\n\t        investigatedSubdivision = divided[0];\n\t        investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n\t        newBaselinePointDistFromStart = baselinePointDistFromStart;\n\t        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\t      } else {\n\t        // point at requested length is inside divided[1]\n\t        investigatedSubdivision = divided[1];\n\t        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n\t        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n\t        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n\t      }\n\t      baselinePointDistFromStart = newBaselinePointDistFromStart;\n\t      baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n\t    }\n\t  },\n\t  // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n\t  // Flattened length is no more than 10^(-precision) away from real curve length.\n\t  toPoints: function (opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    // not using localOpt\n\n\t    var points = [subdivisions[0].start.clone()];\n\t    var n = subdivisions.length;\n\t    for (var i = 0; i < n; i++) {\n\t      var currentSubdivision = subdivisions[i];\n\t      points.push(currentSubdivision.end.clone());\n\t    }\n\t    return points;\n\t  },\n\t  // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n\t  // Flattened length is no more than 10^(-precision) away from real curve length.\n\t  toPolyline: function (opt) {\n\t    return new Polyline$1(this.toPoints(opt));\n\t  },\n\t  toString: function () {\n\t    return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.start.translate(tx, ty);\n\t    this.controlPoint1.translate(tx, ty);\n\t    this.controlPoint2.translate(tx, ty);\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  }\n\t};\n\tCurve.prototype.divide = Curve.prototype.divideAtT;\n\n\t// Local helper function.\n\t// Add properties from arguments on top of properties from `obj`.\n\t// This allows for rudimentary inheritance.\n\t// - The `obj` argument acts as parent.\n\t// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n\t// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\n\tfunction extend$1(obj) {\n\t  // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n\t  // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n\t  // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n\t  // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n\t  // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n\t  // - This method provides a way to do exactly that.\n\t  // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n\t  // - Therefore, to continue with the example above:\n\t  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n\t  //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n\t  //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n\t  //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n\t  // - Multiple inheritance is also possible, if multiple arguments are provided.\n\t  // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n\t  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n\t  //   - The ancestors are applied in order of appearance.\n\t  //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n\t  //   - Any number of ancestors may be provided.\n\t  // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n\t  // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n\t  //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n\t  //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n\t  // - Therefore, both of the following are valid:\n\t  //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n\t  //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n\t  var i;\n\t  var n;\n\t  var args = [];\n\t  n = arguments.length;\n\t  for (i = 1; i < n; i++) {\n\t    // skip over obj\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!obj) throw new Error('Missing a parent object.');\n\t  var child = Object.create(obj);\n\t  n = args.length;\n\t  for (i = 0; i < n; i++) {\n\t    var src = args[i];\n\t    var inheritedProperty;\n\t    var key;\n\t    for (key in src) {\n\t      if (src.hasOwnProperty(key)) {\n\t        delete child[key]; // delete property inherited from parent\n\t        inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n\t        Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n\t      }\n\t    }\n\t  }\n\t  return child;\n\t}\n\n\t// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n\t// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\n\tconst Path$1 = function (arg) {\n\t  if (!(this instanceof Path$1)) {\n\t    return new Path$1(arg);\n\t  }\n\t  if (typeof arg === 'string') {\n\t    // create from a path data string\n\t    return new Path$1.parse(arg);\n\t  }\n\t  this.segments = [];\n\t  var i;\n\t  var n;\n\t  if (!arg) {\n\t    // don't do anything\n\t  } else if (Array.isArray(arg) && arg.length !== 0) {\n\t    // if arg is a non-empty array\n\t    // flatten one level deep\n\t    // so we can chain arbitrary Path.createSegment results\n\t    arg = arg.reduce(function (acc, val) {\n\t      return acc.concat(val);\n\t    }, []);\n\t    n = arg.length;\n\t    if (arg[0].isSegment) {\n\t      // create from an array of segments\n\t      for (i = 0; i < n; i++) {\n\t        var segment = arg[i];\n\t        this.appendSegment(segment);\n\t      }\n\t    } else {\n\t      // create from an array of Curves and/or Lines\n\t      var previousObj = null;\n\t      for (i = 0; i < n; i++) {\n\t        var obj = arg[i];\n\t        if (!(obj instanceof Line || obj instanceof Curve)) {\n\t          throw new Error('Cannot construct a path segment from the provided object.');\n\t        }\n\t        if (i === 0) this.appendSegment(Path$1.createSegment('M', obj.start));\n\n\t        // if objects do not link up, moveto segments are inserted to cover the gaps\n\t        if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path$1.createSegment('M', obj.start));\n\t        if (obj instanceof Line) {\n\t          this.appendSegment(Path$1.createSegment('L', obj.end));\n\t        } else if (obj instanceof Curve) {\n\t          this.appendSegment(Path$1.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n\t        }\n\t        previousObj = obj;\n\t      }\n\t    }\n\t  } else if (arg.isSegment) {\n\t    // create from a single segment\n\t    this.appendSegment(arg);\n\t  } else if (arg instanceof Line) {\n\t    // create from a single Line\n\t    this.appendSegment(Path$1.createSegment('M', arg.start));\n\t    this.appendSegment(Path$1.createSegment('L', arg.end));\n\t  } else if (arg instanceof Curve) {\n\t    // create from a single Curve\n\t    this.appendSegment(Path$1.createSegment('M', arg.start));\n\t    this.appendSegment(Path$1.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\t  } else if (arg instanceof Polyline$1) {\n\t    // create from a Polyline\n\t    if (!(arg.points && arg.points.length !== 0)) return; // if Polyline has no points, leave Path empty\n\n\t    n = arg.points.length;\n\t    for (i = 0; i < n; i++) {\n\t      var point = arg.points[i];\n\t      if (i === 0) this.appendSegment(Path$1.createSegment('M', point));else this.appendSegment(Path$1.createSegment('L', point));\n\t    }\n\t  } else {\n\t    // unknown object\n\t    throw new Error('Cannot construct a path from the provided object.');\n\t  }\n\t};\n\n\t// More permissive than V.normalizePathData and Path.prototype.serialize.\n\t// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n\t// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n\t// Allows for command argument chaining.\n\t// Throws an error if wrong number of arguments is provided with a command.\n\t// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\n\tPath$1.parse = function (pathData) {\n\t  if (!pathData) return new Path$1();\n\t  var path = new Path$1();\n\t  var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n\t  var commands = pathData.match(commandRe);\n\t  var numCommands = commands.length;\n\t  for (var i = 0; i < numCommands; i++) {\n\t    var command = commands[i];\n\t    var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n\t    var args = command.match(argRe);\n\t    var segment = Path$1.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n\t    path.appendSegment(segment);\n\t  }\n\t  return path;\n\t};\n\n\t// Create a segment or an array of segments.\n\t// Accepts unlimited points/coords arguments after `type`.\n\tPath$1.createSegment = function (type) {\n\t  if (!type) throw new Error('Type must be provided.');\n\t  var segmentConstructor = Path$1.segmentTypes[type];\n\t  if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 1; i < n; i++) {\n\t    // do not add first element (`type`) to args array\n\t    args.push(arguments[i]);\n\t  }\n\t  return applyToNew(segmentConstructor, args);\n\t};\n\tPath$1.prototype = {\n\t  type: types.Path,\n\t  // Accepts one segment or an array of segments as argument.\n\t  // Throws an error if argument is not a segment or an array of segments.\n\t  appendSegment: function (arg) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    // works even if path has no segments\n\n\t    var currentSegment;\n\t    var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null\n\t    var nextSegment = null;\n\t    if (!Array.isArray(arg)) {\n\t      // arg is a segment\n\t      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\t      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t      segments.push(currentSegment);\n\t    } else {\n\t      // arg is an array of segments\n\t      // flatten one level deep\n\t      // so we can chain arbitrary Path.createSegment results\n\t      arg = arg.reduce(function (acc, val) {\n\t        return acc.concat(val);\n\t      }, []);\n\t      if (!arg[0].isSegment) throw new Error('Segments required.');\n\t      var n = arg.length;\n\t      for (var i = 0; i < n; i++) {\n\t        var currentArg = arg[i];\n\t        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t        segments.push(currentSegment);\n\t        previousSegment = currentSegment;\n\t      }\n\t    }\n\t  },\n\t  // Returns the bbox of the path.\n\t  // If path has no segments, returns null.\n\t  // If path has only invisible segments, returns bbox of the end point of last segment.\n\t  bbox: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var bbox;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      if (segment.isVisible) {\n\t        var segmentBBox = segment.bbox();\n\t        bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n\t      }\n\t    }\n\t    if (bbox) return bbox;\n\n\t    // if the path has only invisible elements, return end point of last segment\n\t    var lastSegment = segments[numSegments - 1];\n\t    return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n\t  },\n\t  // Returns a new path that is a clone of this path.\n\t  clone: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    // works even if path has no segments\n\n\t    var path = new Path$1();\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i].clone();\n\t      path.appendSegment(segment);\n\t    }\n\t    return path;\n\t  },\n\t  closestPoint: function (p, opt) {\n\t    var t = this.closestPointT(p, opt);\n\t    if (!t) return null;\n\t    return this.pointAtT(t);\n\t  },\n\t  closestPointLength: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var t = this.closestPointT(p, localOpt);\n\t    if (!t) return 0;\n\t    return this.lengthAtT(t, localOpt);\n\t  },\n\t  closestPointNormalizedLength: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var cpLength = this.closestPointLength(p, localOpt);\n\t    if (cpLength === 0) return 0; // shortcut\n\n\t    var length = this.length(localOpt);\n\t    if (length === 0) return 0; // prevents division by zero\n\n\t    return cpLength / length;\n\t  },\n\t  // Private function.\n\t  closestPointT: function (p, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var closestPointT;\n\t    var minSquaredDistance = Infinity;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var subdivisions = segmentSubdivisions[i];\n\t      if (segment.isVisible) {\n\t        var segmentClosestPointT = segment.closestPointT(p, {\n\t          precision: precision,\n\t          subdivisions: subdivisions\n\t        });\n\t        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n\t        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n\t        if (squaredDistance < minSquaredDistance) {\n\t          closestPointT = {\n\t            segmentIndex: i,\n\t            value: segmentClosestPointT\n\t          };\n\t          minSquaredDistance = squaredDistance;\n\t        }\n\t      }\n\t    }\n\t    if (closestPointT) return closestPointT;\n\n\t    // if no visible segment, return end of last segment\n\t    return {\n\t      segmentIndex: numSegments - 1,\n\t      value: 1\n\t    };\n\t  },\n\t  closestPointTangent: function (p, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var closestPointTangent;\n\t    var minSquaredDistance = Infinity;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var subdivisions = segmentSubdivisions[i];\n\t      if (segment.isDifferentiable()) {\n\t        var segmentClosestPointT = segment.closestPointT(p, {\n\t          precision: precision,\n\t          subdivisions: subdivisions\n\t        });\n\t        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n\t        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n\t        if (squaredDistance < minSquaredDistance) {\n\t          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n\t          minSquaredDistance = squaredDistance;\n\t        }\n\t      }\n\t    }\n\t    if (closestPointTangent) return closestPointTangent;\n\n\t    // if no valid segment, return null\n\t    return null;\n\t  },\n\t  // Returns `true` if the area surrounded by the path contains the point `p`.\n\t  // Implements the even-odd algorithm (self-intersections are \"outside\").\n\t  // Closes open paths (always imagines a final closing segment).\n\t  // Precision may be adjusted by passing an `opt` object.\n\t  containsPoint: function (p, opt) {\n\t    var polylines = this.toPolylines(opt);\n\t    if (!polylines) return false; // shortcut (this path has no polylines)\n\n\t    var numPolylines = polylines.length;\n\n\t    // how many component polylines does `p` lie within?\n\t    var numIntersections = 0;\n\t    for (var i = 0; i < numPolylines; i++) {\n\t      var polyline = polylines[i];\n\t      if (polyline.containsPoint(p)) {\n\t        // `p` lies within this polyline\n\t        numIntersections++;\n\t      }\n\t    }\n\n\t    // returns `true` for odd numbers of intersections (even-odd algorithm)\n\t    return numIntersections % 2 === 1;\n\t  },\n\t  // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  divideAt: function (ratio, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (ratio < 0) ratio = 0;\n\t    if (ratio > 1) ratio = 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var pathLength = this.length(localOpt);\n\t    var length = pathLength * ratio;\n\t    return this.divideAtLength(length, localOpt);\n\t  },\n\t  // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  divideAtLength: function (length, opt) {\n\t    var numSegments = this.segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var i;\n\t    var segment;\n\n\t    // identify the segment to divide:\n\n\t    var l = 0; // length so far\n\t    var divided;\n\t    var dividedSegmentIndex;\n\t    var lastValidSegment; // visible AND differentiable\n\t    var lastValidSegmentIndex;\n\t    var t;\n\t    for (i = 0; i < numSegments; i++) {\n\t      var index = fromStart ? i : numSegments - 1 - i;\n\t      segment = this.getSegment(index);\n\t      var subdivisions = segmentSubdivisions[index];\n\t      var d = segment.length({\n\t        precision: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t      if (segment.isDifferentiable()) {\n\t        // segment is not just a point\n\t        lastValidSegment = segment;\n\t        lastValidSegmentIndex = index;\n\t        if (length <= l + d) {\n\t          dividedSegmentIndex = index;\n\t          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {\n\t            precision: precision,\n\t            subdivisions: subdivisions\n\t          });\n\t          break;\n\t        }\n\t      }\n\t      l += d;\n\t    }\n\t    if (!lastValidSegment) {\n\t      // no valid segment found\n\t      return null;\n\t    }\n\n\t    // else: the path contains at least one valid segment\n\n\t    if (!divided) {\n\t      // the desired length is greater than the length of the path\n\t      dividedSegmentIndex = lastValidSegmentIndex;\n\t      t = fromStart ? 1 : 0;\n\t      divided = lastValidSegment.divideAtT(t);\n\t    }\n\n\t    // create a copy of this path and replace the identified segment with its two divided parts:\n\n\t    var pathCopy = this.clone();\n\t    pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\t    var divisionStartIndex = dividedSegmentIndex;\n\t    var divisionMidIndex = dividedSegmentIndex + 1;\n\t    var divisionEndIndex = dividedSegmentIndex + 2;\n\n\t    // do not insert the part if it looks like a point\n\t    if (!divided[0].isDifferentiable()) {\n\t      pathCopy.removeSegment(divisionStartIndex);\n\t      divisionMidIndex -= 1;\n\t      divisionEndIndex -= 1;\n\t    }\n\n\t    // insert a Moveto segment to ensure secondPath will be valid:\n\t    var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n\t    pathCopy.insertSegment(divisionMidIndex, Path$1.createSegment('M', movetoEnd));\n\t    divisionEndIndex += 1;\n\n\t    // do not insert the part if it looks like a point\n\t    if (!divided[1].isDifferentiable()) {\n\t      pathCopy.removeSegment(divisionEndIndex - 1);\n\t      divisionEndIndex -= 1;\n\t    }\n\n\t    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\t    var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\t    for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\t      var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n\t      segment = pathCopy.getSegment(i);\n\t      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n\t        // pathCopy segment's subpathStartSegment is different from original segment's one\n\t        // convert this Closepath segment to a Lineto and replace it in pathCopy\n\t        var convertedSegment = Path$1.createSegment('L', originalSegment.end);\n\t        pathCopy.replaceSegment(i, convertedSegment);\n\t      }\n\t    }\n\n\t    // distribute pathCopy segments into two paths and return those:\n\n\t    var firstPath = new Path$1(pathCopy.segments.slice(0, divisionMidIndex));\n\t    var secondPath = new Path$1(pathCopy.segments.slice(divisionMidIndex));\n\t    return [firstPath, secondPath];\n\t  },\n\t  // Checks whether two paths are exactly the same.\n\t  // If `p` is undefined or null, returns false.\n\t  equals: function (p) {\n\t    if (!p) return false;\n\t    var segments = this.segments;\n\t    var otherSegments = p.segments;\n\t    var numSegments = segments.length;\n\t    if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var otherSegment = otherSegments[i];\n\n\t      // as soon as an inequality is found in segments, return false\n\t      if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;\n\t    }\n\n\t    // if no inequality found in segments, return true\n\t    return true;\n\t  },\n\t  // Accepts negative indices.\n\t  // Throws an error if path has no segments.\n\t  // Throws an error if index is out of range.\n\t  getSegment: function (index) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) throw new Error('Path has no segments.');\n\t    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\t    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\t    return segments[index];\n\t  },\n\t  // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n\t  getSegmentSubdivisions: function (opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    // works even if path has no segments\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    // not using opt.segmentSubdivisions\n\t    // not using localOpt\n\n\t    var segmentSubdivisions = [];\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var subdivisions = segment.getSubdivisions({\n\t        precision: precision\n\t      });\n\t      segmentSubdivisions.push(subdivisions);\n\t    }\n\t    return segmentSubdivisions;\n\t  },\n\t  // Returns an array of subpaths of this path.\n\t  // Invalid paths are validated first.\n\t  // Returns `[]` if path has no segments.\n\t  getSubpaths: function () {\n\t    const validatedPath = this.clone().validate();\n\t    const segments = validatedPath.segments;\n\t    const numSegments = segments.length;\n\t    const subpaths = [];\n\t    for (let i = 0; i < numSegments; i++) {\n\t      const segment = segments[i];\n\t      if (segment.isSubpathStart) {\n\t        // we encountered a subpath start segment\n\t        // create a new path for segment, and push it to list of subpaths\n\t        subpaths.push(new Path$1(segment));\n\t      } else {\n\t        // append current segment to the last subpath\n\t        subpaths[subpaths.length - 1].appendSegment(segment);\n\t      }\n\t    }\n\t    return subpaths;\n\t  },\n\t  // Insert `arg` at given `index`.\n\t  // `index = 0` means insert at the beginning.\n\t  // `index = segments.length` means insert at the end.\n\t  // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n\t  // Accepts one segment or an array of segments as argument.\n\t  // Throws an error if index is out of range.\n\t  // Throws an error if argument is not a segment or an array of segments.\n\t  insertSegment: function (index, arg) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    // works even if path has no segments\n\n\t    // note that these are incremented compared to getSegments()\n\t    // we can insert after last element (note that this changes the meaning of index -1)\n\t    if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n\t    if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\t    var currentSegment;\n\t    var previousSegment = null;\n\t    var nextSegment = null;\n\t    if (numSegments !== 0) {\n\t      if (index >= 1) {\n\t        previousSegment = segments[index - 1];\n\t        nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\t      } else {\n\t        // if index === 0\n\t        // previousSegment is null\n\t        nextSegment = segments[0];\n\t      }\n\t    }\n\t    if (!Array.isArray(arg)) {\n\t      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\t      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t      segments.splice(index, 0, currentSegment);\n\t    } else {\n\t      // flatten one level deep\n\t      // so we can chain arbitrary Path.createSegment results\n\t      arg = arg.reduce(function (acc, val) {\n\t        return acc.concat(val);\n\t      }, []);\n\t      if (!arg[0].isSegment) throw new Error('Segments required.');\n\t      var n = arg.length;\n\t      for (var i = 0; i < n; i++) {\n\t        var currentArg = arg[i];\n\t        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\t        previousSegment = currentSegment;\n\t      }\n\t    }\n\t  },\n\t  intersectionWithLine: function (line, opt) {\n\t    var intersection = null;\n\t    var polylines = this.toPolylines(opt);\n\t    if (!polylines) return null;\n\t    for (var i = 0, n = polylines.length; i < n; i++) {\n\t      var polyline = polylines[i];\n\t      var polylineIntersection = line.intersect(polyline);\n\t      if (polylineIntersection) {\n\t        intersection || (intersection = []);\n\t        if (Array.isArray(polylineIntersection)) {\n\t          Array.prototype.push.apply(intersection, polylineIntersection);\n\t        } else {\n\t          intersection.push(polylineIntersection);\n\t        }\n\t      }\n\t    }\n\t    return intersection;\n\t  },\n\t  isDifferentiable: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      // as soon as a differentiable segment is found in segments, return true\n\t      if (segment.isDifferentiable()) return true;\n\t    }\n\n\t    // if no differentiable segment is found in segments, return false\n\t    return false;\n\t  },\n\t  // Checks whether current path segments are valid.\n\t  // Note that d is allowed to be empty - should disable rendering of the path.\n\t  isValid: function () {\n\t    var segments = this.segments;\n\t    var isValid = segments.length === 0 || segments[0].type === 'M'; // either empty or first segment is a Moveto\n\t    return isValid;\n\t  },\n\t  // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n\t  // If path has no segments, returns 0.\n\t  length: function (opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return 0; // if segments is an empty array\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var length = 0;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var subdivisions = segmentSubdivisions[i];\n\t      length += segment.length({\n\t        subdivisions: subdivisions\n\t      });\n\t    }\n\t    return length;\n\t  },\n\t  // Private function.\n\t  lengthAtT: function (t, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return 0; // if segments is an empty array\n\n\t    var segmentIndex = t.segmentIndex;\n\t    if (segmentIndex < 0) return 0; // regardless of t.value\n\n\t    var tValue = t.value;\n\t    if (segmentIndex >= numSegments) {\n\t      segmentIndex = numSegments - 1;\n\t      tValue = 1;\n\t    } else if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var subdivisions;\n\t    var length = 0;\n\t    for (var i = 0; i < segmentIndex; i++) {\n\t      var segment = segments[i];\n\t      subdivisions = segmentSubdivisions[i];\n\t      length += segment.length({\n\t        precisison: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t    }\n\t    segment = segments[segmentIndex];\n\t    subdivisions = segmentSubdivisions[segmentIndex];\n\t    length += segment.lengthAtT(tValue, {\n\t      precisison: precision,\n\t      subdivisions: subdivisions\n\t    });\n\t    return length;\n\t  },\n\t  // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t  pointAt: function (ratio, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (ratio <= 0) return this.start.clone();\n\t    if (ratio >= 1) return this.end.clone();\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var pathLength = this.length(localOpt);\n\t    var length = pathLength * ratio;\n\t    return this.pointAtLength(length, localOpt);\n\t  },\n\t  // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t  // Accepts negative length.\n\t  pointAtLength: function (length, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (length === 0) return this.start.clone();\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var lastVisibleSegment;\n\t    var l = 0; // length so far\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var index = fromStart ? i : numSegments - 1 - i;\n\t      var segment = segments[index];\n\t      var subdivisions = segmentSubdivisions[index];\n\t      var d = segment.length({\n\t        precision: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t      if (segment.isVisible) {\n\t        if (length <= l + d) {\n\t          return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {\n\t            precision: precision,\n\t            subdivisions: subdivisions\n\t          });\n\t        }\n\t        lastVisibleSegment = segment;\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the path, return last visible segment endpoint\n\t    if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n\n\t    // if no visible segment, return last segment end point (no matter if fromStart or no)\n\t    var lastSegment = segments[numSegments - 1];\n\t    return lastSegment.end.clone();\n\t  },\n\t  // Private function.\n\t  pointAtT: function (t) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var segmentIndex = t.segmentIndex;\n\t    if (segmentIndex < 0) return segments[0].pointAtT(0);\n\t    if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\t    var tValue = t.value;\n\t    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n\t    return segments[segmentIndex].pointAtT(tValue);\n\t  },\n\t  // Default precision\n\t  PRECISION: 3,\n\t  // Helper method for adding segments.\n\t  prepareSegment: function (segment, previousSegment, nextSegment) {\n\t    // insert after previous segment and before previous segment's next segment\n\t    segment.previousSegment = previousSegment;\n\t    segment.nextSegment = nextSegment;\n\t    if (previousSegment) previousSegment.nextSegment = segment;\n\t    if (nextSegment) nextSegment.previousSegment = segment;\n\t    var updateSubpathStart = segment;\n\t    if (segment.isSubpathStart) {\n\t      segment.subpathStartSegment = segment; // assign self as subpath start segment\n\t      updateSubpathStart = nextSegment; // start updating from next segment\n\t    }\n\n\t    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\t    if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\t    return segment;\n\t  },\n\t  // Remove the segment at `index`.\n\t  // Accepts negative indices, from `-1` to `-segments.length`.\n\t  // Throws an error if path has no segments.\n\t  // Throws an error if index is out of range.\n\t  removeSegment: function (index) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) throw new Error('Path has no segments.');\n\t    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\t    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\t    var removedSegment = segments.splice(index, 1)[0];\n\t    var previousSegment = removedSegment.previousSegment;\n\t    var nextSegment = removedSegment.nextSegment;\n\n\t    // link the previous and next segments together (if present)\n\t    if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n\t    if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n\t    // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n\t    if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n\t  },\n\t  // Replace the segment at `index` with `arg`.\n\t  // Accepts negative indices, from `-1` to `-segments.length`.\n\t  // Accepts one segment or an array of segments as argument.\n\t  // Throws an error if path has no segments.\n\t  // Throws an error if index is out of range.\n\t  // Throws an error if argument is not a segment or an array of segments.\n\t  replaceSegment: function (index, arg) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) throw new Error('Path has no segments.');\n\t    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\t    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\t    var currentSegment;\n\t    var replacedSegment = segments[index];\n\t    var previousSegment = replacedSegment.previousSegment;\n\t    var nextSegment = replacedSegment.nextSegment;\n\t    var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n\t    if (!Array.isArray(arg)) {\n\t      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\t      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t      segments.splice(index, 1, currentSegment); // directly replace\n\n\t      if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\t    } else {\n\t      // flatten one level deep\n\t      // so we can chain arbitrary Path.createSegment results\n\t      arg = arg.reduce(function (acc, val) {\n\t        return acc.concat(val);\n\t      }, []);\n\t      if (!arg[0].isSegment) throw new Error('Segments required.');\n\t      segments.splice(index, 1);\n\t      var n = arg.length;\n\t      for (var i = 0; i < n; i++) {\n\t        var currentArg = arg[i];\n\t        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\t        previousSegment = currentSegment;\n\t        if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\t      }\n\t    }\n\n\t    // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n\t    if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n\t  },\n\t  round: function (precision) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      segment.round(precision);\n\t    }\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      segment.scale(sx, sy, origin);\n\t    }\n\t    return this;\n\t  },\n\t  segmentAt: function (ratio, opt) {\n\t    var index = this.segmentIndexAt(ratio, opt);\n\t    if (!index) return null;\n\t    return this.getSegment(index);\n\t  },\n\t  // Accepts negative length.\n\t  segmentAtLength: function (length, opt) {\n\t    var index = this.segmentIndexAtLength(length, opt);\n\t    if (!index) return null;\n\t    return this.getSegment(index);\n\t  },\n\t  segmentIndexAt: function (ratio, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (ratio < 0) ratio = 0;\n\t    if (ratio > 1) ratio = 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var pathLength = this.length(localOpt);\n\t    var length = pathLength * ratio;\n\t    return this.segmentIndexAtLength(length, localOpt);\n\t  },\n\t  // Accepts negative length.\n\t  segmentIndexAtLength: function (length, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var lastVisibleSegmentIndex = null;\n\t    var l = 0; // length so far\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var index = fromStart ? i : numSegments - 1 - i;\n\t      var segment = segments[index];\n\t      var subdivisions = segmentSubdivisions[index];\n\t      var d = segment.length({\n\t        precision: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t      if (segment.isVisible) {\n\t        if (length <= l + d) return index;\n\t        lastVisibleSegmentIndex = index;\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the path, return last visible segment index\n\t    // if no visible segment, return null\n\t    return lastVisibleSegmentIndex;\n\t  },\n\t  // Returns a string that can be used to reconstruct the path.\n\t  // Additional error checking compared to toString (must start with M segment).\n\t  serialize: function () {\n\t    if (!this.isValid()) throw new Error('Invalid path segments.');\n\t    return this.toString();\n\t  },\n\t  // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t  tangentAt: function (ratio, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (ratio < 0) ratio = 0;\n\t    if (ratio > 1) ratio = 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var pathLength = this.length(localOpt);\n\t    var length = pathLength * ratio;\n\t    return this.tangentAtLength(length, localOpt);\n\t  },\n\t  // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t  // Accepts negative length.\n\t  tangentAtLength: function (length, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var lastValidSegment; // visible AND differentiable (with a tangent)\n\t    var l = 0; // length so far\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var index = fromStart ? i : numSegments - 1 - i;\n\t      var segment = segments[index];\n\t      var subdivisions = segmentSubdivisions[index];\n\t      var d = segment.length({\n\t        precision: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t      if (segment.isDifferentiable()) {\n\t        if (length <= l + d) {\n\t          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {\n\t            precision: precision,\n\t            subdivisions: subdivisions\n\t          });\n\t        }\n\t        lastValidSegment = segment;\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\t    if (lastValidSegment) {\n\t      var t = fromStart ? 1 : 0;\n\t      return lastValidSegment.tangentAtT(t);\n\t    }\n\n\t    // if no valid segment, return null\n\t    return null;\n\t  },\n\t  // Private function.\n\t  tangentAtT: function (t) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var segmentIndex = t.segmentIndex;\n\t    if (segmentIndex < 0) return segments[0].tangentAtT(0);\n\t    if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\t    var tValue = t.value;\n\t    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n\t    return segments[segmentIndex].tangentAtT(tValue);\n\t  },\n\t  toPoints: function (opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var points = [];\n\t    var partialPoints = [];\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      if (segment.isVisible) {\n\t        var currentSegmentSubdivisions = segmentSubdivisions[i];\n\t        if (currentSegmentSubdivisions.length > 0) {\n\t          var subdivisionPoints = currentSegmentSubdivisions.map(function (curve) {\n\t            return curve.start;\n\t          });\n\t          Array.prototype.push.apply(partialPoints, subdivisionPoints);\n\t        } else {\n\t          partialPoints.push(segment.start);\n\t        }\n\t      } else if (partialPoints.length > 0) {\n\t        partialPoints.push(segments[i - 1].end);\n\t        points.push(partialPoints);\n\t        partialPoints = [];\n\t      }\n\t    }\n\t    if (partialPoints.length > 0) {\n\t      partialPoints.push(this.end);\n\t      points.push(partialPoints);\n\t    }\n\t    return points;\n\t  },\n\t  toPolylines: function (opt) {\n\t    var polylines = [];\n\t    var points = this.toPoints(opt);\n\t    if (!points) return null;\n\t    for (var i = 0, n = points.length; i < n; i++) {\n\t      polylines.push(new Polyline$1(points[i]));\n\t    }\n\t    return polylines;\n\t  },\n\t  toString: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    var pathData = '';\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      pathData += segment.serialize() + ' ';\n\t    }\n\t    return pathData.trim();\n\t  },\n\t  translate: function (tx, ty) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      segment.translate(tx, ty);\n\t    }\n\t    return this;\n\t  },\n\t  // Helper method for updating subpath start of segments, starting with the one provided.\n\t  updateSubpathStartSegment: function (segment) {\n\t    var previousSegment = segment.previousSegment; // may be null\n\t    while (segment && !segment.isSubpathStart) {\n\t      // assign previous segment's subpath start segment to this segment\n\t      if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n\t      else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n\t      previousSegment = segment;\n\t      segment = segment.nextSegment; // move on to the segment after etc.\n\t    }\n\t  },\n\t  // If the path is not valid, insert M 0 0 at the beginning.\n\t  // Path with no segments is considered valid, so nothing is inserted.\n\t  validate: function () {\n\t    if (!this.isValid()) this.insertSegment(0, Path$1.createSegment('M', 0, 0));\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(Path$1.prototype, 'start', {\n\t  // Getter for the first visible endpoint of the path.\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      if (segment.isVisible) return segment.start;\n\t    }\n\n\t    // if no visible segment, return last segment end point\n\t    return segments[numSegments - 1].end;\n\t  }\n\t});\n\tObject.defineProperty(Path$1.prototype, 'end', {\n\t  // Getter for the last visible endpoint of the path.\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null;\n\t    for (var i = numSegments - 1; i >= 0; i--) {\n\t      var segment = segments[i];\n\t      if (segment.isVisible) return segment.end;\n\t    }\n\n\t    // if no visible segment, return last segment end point\n\t    return segments[numSegments - 1].end;\n\t  }\n\t});\n\n\t// Local helper function.\n\t// Use an array of arguments to call a constructor (function called with `new`).\n\t// Adapted from https://stackoverflow.com/a/8843181/2263595\n\t// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n\t// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n\t// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n\t// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\n\tfunction applyToNew(constructor, argsArray) {\n\t  // The `new` keyword can only be applied to functions that take a limited number of arguments.\n\t  // - We can fake that with .bind().\n\t  // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n\t  // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n\t  // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n\t  // We need to pass in a variable number of arguments to the bind() call.\n\t  // - We can use .apply().\n\t  // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\t  // - `thisArg` can still be anything because `new` overwrites it.\n\t  // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n\t  // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n\t  // The function expects `argsArray[0]` to be `thisArg`.\n\t  // - This means that whatever is sent as the first element will be ignored.\n\t  // - The constructor will only see arguments starting from argsArray[1].\n\t  // - So, a new dummy element is inserted at the start of the array.\n\t  argsArray.unshift(null);\n\t  return new (Function.prototype.bind.apply(constructor, argsArray))();\n\t}\n\n\t// Path segment interface:\n\tvar segmentPrototype = {\n\t  // virtual\n\t  bbox: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  clone: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  closestPoint: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  closestPointLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  closestPointNormalizedLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n\t  closestPointT: function (p) {\n\t    if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\t    throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n\t  },\n\t  // virtual\n\t  closestPointTangent: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  divideAt: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  divideAtLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n\t  divideAtT: function (t) {\n\t    if (this.divideAt) return this.divideAt(t);\n\t    throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n\t  },\n\t  // virtual\n\t  equals: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  getSubdivisions: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  isDifferentiable: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  isSegment: true,\n\t  isSubpathStart: false,\n\t  // true for Moveto segments\n\n\t  isVisible: true,\n\t  // false for Moveto segments\n\n\t  // virtual\n\t  length: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n\t  lengthAtT: function (t) {\n\t    if (t <= 0) return 0;\n\t    var length = this.length();\n\t    if (t >= 1) return length;\n\t    return length * t;\n\t  },\n\t  nextSegment: null,\n\t  // needed for subpath start segment updating\n\n\t  // virtual\n\t  pointAt: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  pointAtLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n\t  pointAtT: function (t) {\n\t    if (this.pointAt) return this.pointAt(t);\n\t    throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n\t  },\n\t  previousSegment: null,\n\t  // needed to get segment start property\n\n\t  // virtual\n\t  round: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  subpathStartSegment: null,\n\t  // needed to get Closepath segment end property\n\n\t  // virtual\n\t  scale: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  serialize: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  tangentAt: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  tangentAtLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n\t  tangentAtT: function (t) {\n\t    if (this.tangentAt) return this.tangentAt(t);\n\t    throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n\t  },\n\t  // virtual\n\t  toString: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  translate: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  }\n\t};\n\n\t// usually directly assigned\n\t// getter for Closepath\n\tObject.defineProperty(segmentPrototype, 'end', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  writable: true\n\t});\n\n\t// always a getter\n\t// always throws error for Moveto\n\tObject.defineProperty(segmentPrototype, 'start', {\n\t  // get a reference to the end point of previous segment\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\t    return this.previousSegment.end;\n\t  }\n\t});\n\n\t// virtual\n\tObject.defineProperty(segmentPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    throw new Error('Bad segment declaration. No type specified.');\n\t  }\n\t});\n\n\t// Path segment implementations:\n\tvar Lineto = function () {\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 0; i < n; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!(this instanceof Lineto)) {\n\t    // switching context of `this` to Lineto when called without `new`\n\t    return applyToNew(Lineto, args);\n\t  }\n\t  if (n === 0) {\n\t    throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n\t  }\n\t  var outputArray;\n\t  if (args[0] instanceof Line) {\n\t    // lines provided\n\t    if (n === 1) {\n\t      this.end = args[0].end.clone();\n\t      return this;\n\t    } else {\n\t      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n\t    }\n\t  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n\t    // coordinates provided\n\t    if (n === 2) {\n\t      this.end = new Point(+args[0], +args[1]);\n\t      return this;\n\t    } else if (n < 2) {\n\t      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\t    } else {\n\t      // this is a poly-line segment\n\t      var segmentCoords;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 2) {\n\t        // coords come in groups of two\n\n\t        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\t        outputArray.push(applyToNew(Lineto, segmentCoords));\n\t      }\n\t      return outputArray;\n\t    }\n\t  } else {\n\t    // points provided (needs to be last to also cover plain objects with x and y)\n\t    if (n === 1) {\n\t      this.end = new Point(args[0]);\n\t      return this;\n\t    } else {\n\t      // this is a poly-line segment\n\t      var segmentPoint;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 1) {\n\t        segmentPoint = args[i];\n\t        outputArray.push(new Lineto(segmentPoint));\n\t      }\n\t      return outputArray;\n\t    }\n\t  }\n\t};\n\tvar linetoPrototype = {\n\t  clone: function () {\n\t    return new Lineto(this.end);\n\t  },\n\t  divideAt: function (ratio) {\n\t    var line = new Line(this.start, this.end);\n\t    var divided = line.divideAt(ratio);\n\t    return [new Lineto(divided[0]), new Lineto(divided[1])];\n\t  },\n\t  divideAtLength: function (length) {\n\t    var line = new Line(this.start, this.end);\n\t    var divided = line.divideAtLength(length);\n\t    return [new Lineto(divided[0]), new Lineto(divided[1])];\n\t  },\n\t  getSubdivisions: function () {\n\t    return [];\n\t  },\n\t  isDifferentiable: function () {\n\t    if (!this.previousSegment) return false;\n\t    return !this.start.equals(this.end);\n\t  },\n\t  round: function (precision) {\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  serialize: function () {\n\t    var end = this.end;\n\t    return this.type + ' ' + end.x + ' ' + end.y;\n\t  },\n\t  toString: function () {\n\t    return this.type + ' ' + this.start + ' ' + this.end;\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(linetoPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  value: 'L'\n\t});\n\tLineto.prototype = extend$1(segmentPrototype, Line.prototype, linetoPrototype);\n\tvar Curveto = function () {\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 0; i < n; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!(this instanceof Curveto)) {\n\t    // switching context of `this` to Curveto when called without `new`\n\t    return applyToNew(Curveto, args);\n\t  }\n\t  if (n === 0) {\n\t    throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n\t  }\n\t  var outputArray;\n\t  if (args[0] instanceof Curve) {\n\t    // curves provided\n\t    if (n === 1) {\n\t      this.controlPoint1 = args[0].controlPoint1.clone();\n\t      this.controlPoint2 = args[0].controlPoint2.clone();\n\t      this.end = args[0].end.clone();\n\t      return this;\n\t    } else {\n\t      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n\t    }\n\t  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n\t    // coordinates provided\n\t    if (n === 6) {\n\t      this.controlPoint1 = new Point(+args[0], +args[1]);\n\t      this.controlPoint2 = new Point(+args[2], +args[3]);\n\t      this.end = new Point(+args[4], +args[5]);\n\t      return this;\n\t    } else if (n < 6) {\n\t      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\t    } else {\n\t      // this is a poly-bezier segment\n\t      var segmentCoords;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 6) {\n\t        // coords come in groups of six\n\n\t        segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n\t        outputArray.push(applyToNew(Curveto, segmentCoords));\n\t      }\n\t      return outputArray;\n\t    }\n\t  } else {\n\t    // points provided (needs to be last to also cover plain objects with x and y)\n\t    if (n === 3) {\n\t      this.controlPoint1 = new Point(args[0]);\n\t      this.controlPoint2 = new Point(args[1]);\n\t      this.end = new Point(args[2]);\n\t      return this;\n\t    } else if (n < 3) {\n\t      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\t    } else {\n\t      // this is a poly-bezier segment\n\t      var segmentPoints;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 3) {\n\t        // points come in groups of three\n\n\t        segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n\t        outputArray.push(applyToNew(Curveto, segmentPoints));\n\t      }\n\t      return outputArray;\n\t    }\n\t  }\n\t};\n\tvar curvetoPrototype = {\n\t  clone: function () {\n\t    return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n\t  },\n\t  divideAt: function (ratio, opt) {\n\t    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t    var divided = curve.divideAt(ratio, opt);\n\t    return [new Curveto(divided[0]), new Curveto(divided[1])];\n\t  },\n\t  divideAtLength: function (length, opt) {\n\t    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t    var divided = curve.divideAtLength(length, opt);\n\t    return [new Curveto(divided[0]), new Curveto(divided[1])];\n\t  },\n\t  divideAtT: function (t) {\n\t    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t    var divided = curve.divideAtT(t);\n\t    return [new Curveto(divided[0]), new Curveto(divided[1])];\n\t  },\n\t  isDifferentiable: function () {\n\t    if (!this.previousSegment) return false;\n\t    var start = this.start;\n\t    var control1 = this.controlPoint1;\n\t    var control2 = this.controlPoint2;\n\t    var end = this.end;\n\t    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n\t  },\n\t  round: function (precision) {\n\t    this.controlPoint1.round(precision);\n\t    this.controlPoint2.round(precision);\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.controlPoint1.scale(sx, sy, origin);\n\t    this.controlPoint2.scale(sx, sy, origin);\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  serialize: function () {\n\t    var c1 = this.controlPoint1;\n\t    var c2 = this.controlPoint2;\n\t    var end = this.end;\n\t    return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n\t  },\n\t  toString: function () {\n\t    return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.controlPoint1.translate(tx, ty);\n\t    this.controlPoint2.translate(tx, ty);\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(curvetoPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  value: 'C'\n\t});\n\tCurveto.prototype = extend$1(segmentPrototype, Curve.prototype, curvetoPrototype);\n\tvar Moveto = function () {\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 0; i < n; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!(this instanceof Moveto)) {\n\t    // switching context of `this` to Moveto when called without `new`\n\t    return applyToNew(Moveto, args);\n\t  }\n\t  if (n === 0) {\n\t    throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n\t  }\n\t  var outputArray;\n\t  if (args[0] instanceof Line) {\n\t    // lines provided\n\t    if (n === 1) {\n\t      this.end = args[0].end.clone();\n\t      return this;\n\t    } else {\n\t      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n\t    }\n\t  } else if (args[0] instanceof Curve) {\n\t    // curves provided\n\t    if (n === 1) {\n\t      this.end = args[0].end.clone();\n\t      return this;\n\t    } else {\n\t      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n\t    }\n\t  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n\t    // coordinates provided\n\t    if (n === 2) {\n\t      this.end = new Point(+args[0], +args[1]);\n\t      return this;\n\t    } else if (n < 2) {\n\t      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\t    } else {\n\t      // this is a moveto-with-subsequent-poly-line segment\n\t      var segmentCoords;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 2) {\n\t        // coords come in groups of two\n\n\t        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\t        if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));else outputArray.push(applyToNew(Lineto, segmentCoords));\n\t      }\n\t      return outputArray;\n\t    }\n\t  } else {\n\t    // points provided (needs to be last to also cover plain objects with x and y)\n\t    if (n === 1) {\n\t      this.end = new Point(args[0]);\n\t      return this;\n\t    } else {\n\t      // this is a moveto-with-subsequent-poly-line segment\n\t      var segmentPoint;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 1) {\n\t        // points come one by one\n\n\t        segmentPoint = args[i];\n\t        if (i === 0) outputArray.push(new Moveto(segmentPoint));else outputArray.push(new Lineto(segmentPoint));\n\t      }\n\t      return outputArray;\n\t    }\n\t  }\n\t};\n\tvar movetoPrototype = {\n\t  bbox: function () {\n\t    return null;\n\t  },\n\t  clone: function () {\n\t    return new Moveto(this.end);\n\t  },\n\t  closestPoint: function () {\n\t    return this.end.clone();\n\t  },\n\t  closestPointNormalizedLength: function () {\n\t    return 0;\n\t  },\n\t  closestPointLength: function () {\n\t    return 0;\n\t  },\n\t  closestPointT: function () {\n\t    return 1;\n\t  },\n\t  closestPointTangent: function () {\n\t    return null;\n\t  },\n\t  divideAt: function () {\n\t    return [this.clone(), this.clone()];\n\t  },\n\t  divideAtLength: function () {\n\t    return [this.clone(), this.clone()];\n\t  },\n\t  equals: function (m) {\n\t    return this.end.equals(m.end);\n\t  },\n\t  getSubdivisions: function () {\n\t    return [];\n\t  },\n\t  isDifferentiable: function () {\n\t    return false;\n\t  },\n\t  isSubpathStart: true,\n\t  isVisible: false,\n\t  length: function () {\n\t    return 0;\n\t  },\n\t  lengthAtT: function () {\n\t    return 0;\n\t  },\n\t  pointAt: function () {\n\t    return this.end.clone();\n\t  },\n\t  pointAtLength: function () {\n\t    return this.end.clone();\n\t  },\n\t  pointAtT: function () {\n\t    return this.end.clone();\n\t  },\n\t  round: function (precision) {\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  serialize: function () {\n\t    var end = this.end;\n\t    return this.type + ' ' + end.x + ' ' + end.y;\n\t  },\n\t  tangentAt: function () {\n\t    return null;\n\t  },\n\t  tangentAtLength: function () {\n\t    return null;\n\t  },\n\t  tangentAtT: function () {\n\t    return null;\n\t  },\n\t  toString: function () {\n\t    return this.type + ' ' + this.end;\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(movetoPrototype, 'start', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    throw new Error('Illegal access. Moveto segments should not need a start property.');\n\t  }\n\t});\n\tObject.defineProperty(movetoPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  value: 'M'\n\t});\n\tMoveto.prototype = extend$1(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\n\tvar Closepath = function () {\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 0; i < n; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!(this instanceof Closepath)) {\n\t    // switching context of `this` to Closepath when called without `new`\n\t    return applyToNew(Closepath, args);\n\t  }\n\t  if (n > 0) {\n\t    throw new Error('Closepath constructor expects no arguments.');\n\t  }\n\t  return this;\n\t};\n\tvar closepathPrototype = {\n\t  clone: function () {\n\t    return new Closepath();\n\t  },\n\t  divideAt: function (ratio) {\n\t    var line = new Line(this.start, this.end);\n\t    var divided = line.divideAt(ratio);\n\t    return [\n\t    // if we didn't actually cut into the segment, first divided part can stay as Z\n\t    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n\t  },\n\t  divideAtLength: function (length) {\n\t    var line = new Line(this.start, this.end);\n\t    var divided = line.divideAtLength(length);\n\t    return [\n\t    // if we didn't actually cut into the segment, first divided part can stay as Z\n\t    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n\t  },\n\t  getSubdivisions: function () {\n\t    return [];\n\t  },\n\t  isDifferentiable: function () {\n\t    if (!this.previousSegment || !this.subpathStartSegment) return false;\n\t    return !this.start.equals(this.end);\n\t  },\n\t  round: function () {\n\t    return this;\n\t  },\n\t  scale: function () {\n\t    return this;\n\t  },\n\t  serialize: function () {\n\t    return this.type;\n\t  },\n\t  toString: function () {\n\t    return this.type + ' ' + this.start + ' ' + this.end;\n\t  },\n\t  translate: function () {\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(closepathPrototype, 'end', {\n\t  // get a reference to the end point of subpath start segment\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\t    return this.subpathStartSegment.end;\n\t  }\n\t});\n\tObject.defineProperty(closepathPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  value: 'Z'\n\t});\n\tClosepath.prototype = extend$1(segmentPrototype, Line.prototype, closepathPrototype);\n\tvar segmentTypes = Path$1.segmentTypes = {\n\t  L: Lineto,\n\t  C: Curveto,\n\t  M: Moveto,\n\t  Z: Closepath,\n\t  z: Closepath\n\t};\n\tPath$1.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\tPath$1.isDataSupported = function (data) {\n\t  if (typeof data !== 'string') return false;\n\t  return this.regexSupportedData.test(data);\n\t};\n\n\tconst bezier = {\n\t  // Cubic Bezier curve path through points.\n\t  // @deprecated\n\t  // @param {array} points Array of points through which the smooth line will go.\n\t  // @return {array} SVG Path commands as an array\n\t  curveThroughPoints: function (points) {\n\t    console.warn('deprecated');\n\t    return new Path$1(Curve.throughPoints(points)).serialize();\n\t  },\n\t  // Get open-ended Bezier Spline Control Points.\n\t  // @deprecated\n\t  // @param knots Input Knot Bezier spline points (At least two points!).\n\t  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n\t  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n\t  getCurveControlPoints: function (knots) {\n\t    console.warn('deprecated');\n\t    var firstControlPoints = [];\n\t    var secondControlPoints = [];\n\t    var n = knots.length - 1;\n\t    var i;\n\n\t    // Special case: Bezier curve should be a straight line.\n\t    if (n == 1) {\n\t      // 3P1 = 2P0 + P3\n\t      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n\n\t      // P2 = 2P1 â P0\n\t      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n\t      return [firstControlPoints, secondControlPoints];\n\t    }\n\n\t    // Calculate first Bezier control points.\n\t    // Right hand side vector.\n\t    var rhs = [];\n\n\t    // Set right hand side X values.\n\t    for (i = 1; i < n - 1; i++) {\n\t      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n\t    }\n\t    rhs[0] = knots[0].x + 2 * knots[1].x;\n\t    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n\t    // Get first control points X-values.\n\t    var x = this.getFirstControlPoints(rhs);\n\n\t    // Set right hand side Y values.\n\t    for (i = 1; i < n - 1; ++i) {\n\t      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n\t    }\n\t    rhs[0] = knots[0].y + 2 * knots[1].y;\n\t    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n\t    // Get first control points Y-values.\n\t    var y = this.getFirstControlPoints(rhs);\n\n\t    // Fill output arrays.\n\t    for (i = 0; i < n; i++) {\n\t      // First control point.\n\t      firstControlPoints.push(new Point(x[i], y[i]));\n\n\t      // Second control point.\n\t      if (i < n - 1) {\n\t        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n\t      } else {\n\t        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n\t      }\n\t    }\n\t    return [firstControlPoints, secondControlPoints];\n\t  },\n\t  // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n\t  // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n\t  // @deprecated\n\t  // @param control points (start, control start, control end, end)\n\t  // @return a function that accepts t and returns 2 curves.\n\t  getCurveDivider: function (p0, p1, p2, p3) {\n\t    console.warn('deprecated');\n\t    var curve = new Curve(p0, p1, p2, p3);\n\t    return function divideCurve(t) {\n\t      var divided = curve.divide(t);\n\t      return [{\n\t        p0: divided[0].start,\n\t        p1: divided[0].controlPoint1,\n\t        p2: divided[0].controlPoint2,\n\t        p3: divided[0].end\n\t      }, {\n\t        p0: divided[1].start,\n\t        p1: divided[1].controlPoint1,\n\t        p2: divided[1].controlPoint2,\n\t        p3: divided[1].end\n\t      }];\n\t    };\n\t  },\n\t  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n\t  // @deprecated\n\t  // @param rhs Right hand side vector.\n\t  // @return Solution vector.\n\t  getFirstControlPoints: function (rhs) {\n\t    console.warn('deprecated');\n\t    var n = rhs.length;\n\t    // `x` is a solution vector.\n\t    var x = [];\n\t    var tmp = [];\n\t    var b = 2.0;\n\t    x[0] = rhs[0] / b;\n\n\t    // Decomposition and forward substitution.\n\t    for (var i = 1; i < n; i++) {\n\t      tmp[i] = 1 / b;\n\t      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n\t      x[i] = (rhs[i] - x[i - 1]) / b;\n\t    }\n\t    for (i = 1; i < n; i++) {\n\t      // Backsubstitution.\n\t      x[n - i - 1] -= tmp[n - i] * x[n - i];\n\t    }\n\t    return x;\n\t  },\n\t  // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n\t  // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ï¬nd the parameter value t\n\t  // which corresponds to that point.\n\t  // @deprecated\n\t  // @param control points (start, control start, control end, end)\n\t  // @return a function that accepts a point and returns t.\n\t  getInversionSolver: function (p0, p1, p2, p3) {\n\t    console.warn('deprecated');\n\t    var curve = new Curve(p0, p1, p2, p3);\n\t    return function solveInversion(p) {\n\t      return curve.closestPointT(p);\n\t    };\n\t  }\n\t};\n\n\tconst Polygon$1 = function (points) {\n\t  if (!(this instanceof Polygon$1)) {\n\t    return new Polygon$1(points);\n\t  }\n\t  if (typeof points === 'string') {\n\t    return new Polygon$1.parse(points);\n\t  }\n\t  this.points = Array.isArray(points) ? points.map(Point) : [];\n\t};\n\tPolygon$1.parse = function (svgString) {\n\t  return new Polygon$1(parsePoints(svgString));\n\t};\n\tPolygon$1.fromRect = function (rect) {\n\t  return new Polygon$1([rect.topLeft(), rect.topRight(), rect.bottomRight(), rect.bottomLeft()]);\n\t};\n\tPolygon$1.prototype = extend$1(Polyline$1.prototype, {\n\t  type: types.Polygon,\n\t  clone: function () {\n\t    return new Polygon$1(clonePoints(this.points));\n\t  },\n\t  convexHull: function () {\n\t    return new Polygon$1(convexHull(this.points));\n\t  },\n\t  lengthPoints: function () {\n\t    const {\n\t      start,\n\t      end,\n\t      points\n\t    } = this;\n\t    if (points.length <= 1 || start.equals(end)) return points;\n\t    return [...points, start.clone()];\n\t  }\n\t});\n\n\tfunction exists(shape1, shape2, shape1opt, shape2opt) {\n\t  switch (shape1.type) {\n\t    case types.Line:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return lineWithLine(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Ellipse:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return ellipseWithLine(shape1, shape2);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return ellipseWithEllipse(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Rect:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return rectWithLine(shape1, shape2);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return rectWithEllipse(shape1, shape2);\n\t            }\n\t          case types.Rect:\n\t            {\n\t              return rectWithRect(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Polyline:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return polylineWithLine(shape1, shape2);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return polylineWithEllipse(shape1, shape2);\n\t            }\n\t          case types.Rect:\n\t            {\n\t              return polylineWithRect(shape1, shape2);\n\t            }\n\t          case types.Polyline:\n\t            {\n\t              return polylineWithPolyline(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Polygon:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return polygonWithLine(shape1, shape2);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return polygonWithEllipse(shape1, shape2);\n\t            }\n\t          case types.Rect:\n\t            {\n\t              return polygonWithRect(shape1, shape2);\n\t            }\n\t          case types.Polyline:\n\t            {\n\t              return polygonWithPolyline(shape1, shape2);\n\t            }\n\t          case types.Polygon:\n\t            {\n\t              return polygonWithPolygon(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Path:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return pathWithLine(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return pathWithEllipse(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Rect:\n\t            {\n\t              return pathWithRect(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Polyline:\n\t            {\n\t              return pathWithPolyline(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Polygon:\n\t            {\n\t              return pathWithPolygon(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Path:\n\t            {\n\t              return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t  }\n\t  // None of the cases above\n\t  switch (shape2.type) {\n\t    case types.Ellipse:\n\t    case types.Rect:\n\t    case types.Polyline:\n\t    case types.Polygon:\n\t    case types.Path:\n\t      {\n\t        return exists(shape2, shape1, shape2opt, shape1opt);\n\t      }\n\t    default:\n\t      {\n\t        throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n\t      }\n\t  }\n\t}\n\n\t/* Line */\n\n\tfunction lineWithLine(line1, line2) {\n\t  const x1 = line1.start.x;\n\t  const y1 = line1.start.y;\n\t  const x2 = line1.end.x;\n\t  const y2 = line1.end.y;\n\t  const x3 = line2.start.x;\n\t  const y3 = line2.start.y;\n\t  const x4 = line2.end.x;\n\t  const y4 = line2.end.y;\n\t  const s1x = x2 - x1;\n\t  const s1y = y2 - y1;\n\t  const s2x = x4 - x3;\n\t  const s2y = y4 - y3;\n\t  const s3x = x1 - x3;\n\t  const s3y = y1 - y3;\n\t  const p = s1x * s2y - s2x * s1y;\n\t  const s = (s1x * s3y - s1y * s3x) / p;\n\t  const t = (s2x * s3y - s2y * s3x) / p;\n\t  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n\t}\n\n\t/* Ellipse */\n\n\tfunction ellipseWithLine(ellipse, line) {\n\t  const rex = ellipse.a;\n\t  const rey = ellipse.b;\n\t  const xe = ellipse.x;\n\t  const ye = ellipse.y;\n\t  const x1 = line.start.x - xe;\n\t  const x2 = line.end.x - xe;\n\t  const y1 = line.start.y - ye;\n\t  const y2 = line.end.y - ye;\n\t  const rex_2 = rex * rex;\n\t  const rey_2 = rey * rey;\n\t  const dx = x2 - x1;\n\t  const dy = y2 - y1;\n\t  const A = dx * dx / rex_2 + dy * dy / rey_2;\n\t  const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n\t  const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n\t  const D = B * B - 4 * A * C;\n\t  if (D === 0) {\n\t    const t = -B / 2 / A;\n\t    return t >= 0 && t <= 1;\n\t  } else if (D > 0) {\n\t    const sqrt = Math.sqrt(D);\n\t    const t1 = (-B + sqrt) / 2 / A;\n\t    const t2 = (-B - sqrt) / 2 / A;\n\t    return t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1;\n\t  }\n\t  return false;\n\t}\n\tfunction ellipseWithEllipse(ellipse1, ellipse2) {\n\t  return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n\t}\n\n\t/* Rect */\n\n\tfunction rectWithLine(rect, line) {\n\t  const {\n\t    start,\n\t    end\n\t  } = line;\n\t  const {\n\t    x,\n\t    y,\n\t    width,\n\t    height\n\t  } = rect;\n\t  if (start.x > x + width && end.x > x + width || start.x < x && end.x < x || start.y > y + height && end.y > y + height || start.y < y && end.y < y) {\n\t    return false;\n\t  }\n\t  if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n\t    return true;\n\t  }\n\t  return lineWithLine(rect.topLine(), line) || lineWithLine(rect.rightLine(), line) || lineWithLine(rect.bottomLine(), line) || lineWithLine(rect.leftLine(), line);\n\t}\n\tfunction rectWithEllipse(rect, ellipse) {\n\t  if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) return false;\n\t  return polygonWithEllipse(Polygon$1.fromRect(rect), ellipse);\n\t}\n\tfunction rectWithRect(rect1, rect2) {\n\t  return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;\n\t}\n\n\t/* Polyline */\n\n\tfunction polylineWithLine(polyline, line) {\n\t  return _polylineWithLine(polyline, line, {\n\t    interior: false\n\t  });\n\t}\n\tfunction polylineWithEllipse(polyline, ellipse) {\n\t  return _polylineWithEllipse(polyline, ellipse, {\n\t    interior: false\n\t  });\n\t}\n\tfunction polylineWithRect(polyline, rect) {\n\t  return _polylineWithRect(polyline, rect, {\n\t    interior: false\n\t  });\n\t}\n\tfunction polylineWithPolyline(polyline1, polyline2) {\n\t  return _polylineWithPolyline(polyline1, polyline2, {\n\t    interior: false\n\t  });\n\t}\n\n\t/* Polygon */\n\n\tfunction polygonWithLine(polygon, line) {\n\t  return _polylineWithLine(polygon, line, {\n\t    interior: true\n\t  });\n\t}\n\tfunction polygonWithEllipse(polygon, ellipse) {\n\t  return _polylineWithEllipse(polygon, ellipse, {\n\t    interior: true\n\t  });\n\t}\n\tfunction polygonWithRect(polygon, rect) {\n\t  return _polylineWithRect(polygon, rect, {\n\t    interior: true\n\t  });\n\t}\n\tfunction polygonWithPolyline(polygon, polyline) {\n\t  return _polylineWithPolyline(polygon, polyline, {\n\t    interior: true\n\t  });\n\t}\n\tfunction polygonWithPolygon(polygon1, polygon2) {\n\t  return _polylineWithPolygon(polygon1, polygon2, {\n\t    interior: true\n\t  });\n\t}\n\n\t/* Path */\n\n\tfunction pathWithLine(path, line, pathOpt) {\n\t  return path.getSubpaths().some(subpath => {\n\t    const [polyline] = subpath.toPolylines(pathOpt);\n\t    const {\n\t      type\n\t    } = subpath.getSegment(-1);\n\t    if (type === 'Z') {\n\t      return polygonWithLine(polyline, line);\n\t    } else {\n\t      return polylineWithLine(polyline, line);\n\t    }\n\t  });\n\t}\n\tfunction pathWithEllipse(path, ellipse, pathOpt) {\n\t  return path.getSubpaths().some(subpath => {\n\t    const [polyline] = subpath.toPolylines(pathOpt);\n\t    const {\n\t      type\n\t    } = subpath.getSegment(-1);\n\t    if (type === 'Z') {\n\t      return polygonWithEllipse(polyline, ellipse);\n\t    } else {\n\t      return polylineWithEllipse(polyline, ellipse);\n\t    }\n\t  });\n\t}\n\tfunction pathWithRect(path, rect, pathOpt) {\n\t  return pathWithPolygon(path, Polygon$1.fromRect(rect), pathOpt);\n\t}\n\tfunction pathWithPolyline(path, polyline, pathOpt) {\n\t  return _pathWithPolyline(path, polyline, pathOpt, {\n\t    interior: false\n\t  });\n\t}\n\tfunction pathWithPolygon(path, polygon, pathOpt) {\n\t  return _pathWithPolyline(path, polygon, pathOpt, {\n\t    interior: true\n\t  });\n\t}\n\tfunction pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n\t  return path1.getSubpaths().some(subpath => {\n\t    const [polyline1] = subpath.toPolylines(pathOpt1);\n\t    const {\n\t      type\n\t    } = subpath.getSegment(-1);\n\t    if (type === 'Z') {\n\t      return pathWithPolygon(path2, polyline1, pathOpt2);\n\t    } else {\n\t      return pathWithPolyline(path2, polyline1, pathOpt2);\n\t    }\n\t  });\n\t}\n\tfunction _polylineWithLine(polyline, line, opt = {}) {\n\t  const {\n\t    interior = false\n\t  } = opt;\n\t  let thisPoints;\n\t  if (interior) {\n\t    if (polyline.containsPoint(line.start)) {\n\t      // If any point of the polyline lies inside this polygon (interior = true)\n\t      // there is an intersection (we've chosen the start point)\n\t      return true;\n\t    }\n\t    const {\n\t      start,\n\t      end,\n\t      points\n\t    } = polyline;\n\t    thisPoints = end.equals(start) ? points : [...points, start];\n\t  } else {\n\t    thisPoints = polyline.points;\n\t  }\n\t  const {\n\t    length\n\t  } = thisPoints;\n\t  const segment = new Line();\n\t  for (let i = 0; i < length - 1; i++) {\n\t    segment.start = thisPoints[i];\n\t    segment.end = thisPoints[i + 1];\n\t    if (lineWithLine(line, segment)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\tfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n\t  const {\n\t    start,\n\t    end,\n\t    points\n\t  } = polyline;\n\t  if (ellipse.containsPoint(start)) {\n\t    return true;\n\t  }\n\t  let thisPoints;\n\t  const {\n\t    interior = false\n\t  } = opt;\n\t  if (interior) {\n\t    if (polyline.containsPoint(ellipse.center())) {\n\t      // If any point of the ellipse lies inside this polygon (interior = true)\n\t      // there is an intersection (we've chosen the center point)\n\t      return true;\n\t    }\n\t    thisPoints = end.equals(start) ? points : [...points, start];\n\t  } else {\n\t    thisPoints = points;\n\t  }\n\t  const {\n\t    length\n\t  } = thisPoints;\n\t  const segment = new Line();\n\t  for (let i = 0; i < length - 1; i++) {\n\t    segment.start = thisPoints[i];\n\t    segment.end = thisPoints[i + 1];\n\t    if (ellipseWithLine(ellipse, segment)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\tfunction _polylineWithRect(polyline, rect, opt) {\n\t  const polygon = Polygon$1.fromRect(rect);\n\t  return _polylineWithPolygon(polyline, polygon, opt);\n\t}\n\tfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n\t  return path.getSubpaths().some(subpath => {\n\t    const [polyline2] = subpath.toPolylines(pathOpt);\n\t    const {\n\t      type\n\t    } = subpath.getSegment(-1);\n\t    if (type === 'Z') {\n\t      return _polylineWithPolygon(polyline1, polyline2, opt);\n\t    } else {\n\t      return _polylineWithPolyline(polyline1, polyline2, opt);\n\t    }\n\t  });\n\t}\n\tfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n\t  const {\n\t    interior = false\n\t  } = opt;\n\t  let thisPolyline;\n\t  if (interior) {\n\t    const {\n\t      start\n\t    } = polyline2;\n\t    if (polyline1.containsPoint(start)) {\n\t      // If any point of the polyline lies inside this polygon (interior = true)\n\t      // there is an intersection (we've chosen the start point)\n\t      return true;\n\t    }\n\t    thisPolyline = polyline1.clone().close();\n\t  } else {\n\t    thisPolyline = polyline1;\n\t  }\n\t  const otherPoints = polyline2.points;\n\t  const {\n\t    length\n\t  } = otherPoints;\n\t  const segment = new Line();\n\t  for (let i = 0; i < length - 1; i++) {\n\t    segment.start = otherPoints[i];\n\t    segment.end = otherPoints[i + 1];\n\t    if (polylineWithLine(thisPolyline, segment)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\tfunction _polylineWithPolygon(polyline, polygon, opt) {\n\t  return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n\t}\n\tfunction _ellipsesIntersection(e1, w1, e2, w2) {\n\t  const {\n\t    cos,\n\t    sin\n\t  } = Math;\n\t  const sinW1 = sin(w1);\n\t  const cosW1 = cos(w1);\n\t  const sinW2 = sin(w2);\n\t  const cosW2 = cos(w2);\n\t  const sinW1s = sinW1 * sinW1;\n\t  const cosW1s = cosW1 * cosW1;\n\t  const sinCos1 = sinW1 * cosW1;\n\t  const sinW2s = sinW2 * sinW2;\n\t  const cosW2s = cosW2 * cosW2;\n\t  const sinCos2 = sinW2 * cosW2;\n\t  const a1s = e1.a * e1.a;\n\t  const b1s = e1.b * e1.b;\n\t  const a2s = e2.a * e2.a;\n\t  const b2s = e2.b * e2.b;\n\t  const A1 = a1s * sinW1s + b1s * cosW1s;\n\t  const A2 = a2s * sinW2s + b2s * cosW2s;\n\t  const B1 = a1s * cosW1s + b1s * sinW1s;\n\t  const B2 = a2s * cosW2s + b2s * sinW2s;\n\t  let C1 = 2 * (b1s - a1s) * sinCos1;\n\t  let C2 = 2 * (b2s - a2s) * sinCos2;\n\t  let D1 = -2 * A1 * e1.x - C1 * e1.y;\n\t  let D2 = -2 * A2 * e2.x - C2 * e2.y;\n\t  let E1 = -C1 * e1.x - 2 * B1 * e1.y;\n\t  let E2 = -C2 * e2.x - 2 * B2 * e2.y;\n\t  const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n\t  const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n\t  C1 = C1 / 2;\n\t  C2 = C2 / 2;\n\t  D1 = D1 / 2;\n\t  D2 = D2 / 2;\n\t  E1 = E1 / 2;\n\t  E2 = E2 / 2;\n\t  const l3 = det3([[A1, C1, D1], [C1, B1, E1], [D1, E1, F1]]);\n\t  const l0 = det3([[A2, C2, D2], [C2, B2, E2], [D2, E2, F2]]);\n\t  const l2 = 0.33333333 * (det3([[A2, C1, D1], [C2, B1, E1], [D2, E1, F1]]) + det3([[A1, C2, D1], [C1, B2, E1], [D1, E2, F1]]) + det3([[A1, C1, D2], [C1, B1, E2], [D1, E1, F2]]));\n\t  const l1 = 0.33333333 * (det3([[A1, C2, D2], [C1, B2, E2], [D1, E2, F2]]) + det3([[A2, C1, D2], [C2, B1, E2], [D2, E1, F2]]) + det3([[A2, C2, D1], [C2, B2, E1], [D2, E2, F1]]));\n\t  const delta1 = det2([[l3, l2], [l2, l1]]);\n\t  const delta2 = det2([[l3, l1], [l2, l0]]);\n\t  const delta3 = det2([[l2, l1], [l1, l0]]);\n\t  const dP = det2([[2 * delta1, delta2], [delta2, 2 * delta3]]);\n\t  if (dP > 0 && (l1 > 0 || l2 > 0)) {\n\t    return false;\n\t  }\n\t  return true;\n\t}\n\tfunction det2(m) {\n\t  return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n\t}\n\tfunction det3(m) {\n\t  return m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[1][2] * m[2][1] - m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[1][1] * m[2][0];\n\t}\n\n\tvar _intersection = {\n\t\t__proto__: null,\n\t\tellipseWithEllipse: ellipseWithEllipse,\n\t\tellipseWithLine: ellipseWithLine,\n\t\texists: exists,\n\t\tlineWithLine: lineWithLine,\n\t\tpathWithEllipse: pathWithEllipse,\n\t\tpathWithLine: pathWithLine,\n\t\tpathWithPath: pathWithPath,\n\t\tpathWithPolygon: pathWithPolygon,\n\t\tpathWithPolyline: pathWithPolyline,\n\t\tpathWithRect: pathWithRect,\n\t\tpolygonWithEllipse: polygonWithEllipse,\n\t\tpolygonWithLine: polygonWithLine,\n\t\tpolygonWithPolygon: polygonWithPolygon,\n\t\tpolygonWithPolyline: polygonWithPolyline,\n\t\tpolygonWithRect: polygonWithRect,\n\t\tpolylineWithEllipse: polylineWithEllipse,\n\t\tpolylineWithLine: polylineWithLine,\n\t\tpolylineWithPolyline: polylineWithPolyline,\n\t\tpolylineWithRect: polylineWithRect,\n\t\trectWithEllipse: rectWithEllipse,\n\t\trectWithLine: rectWithLine,\n\t\trectWithRect: rectWithRect\n\t};\n\n\t// Geometry library.\n\t// -----------------\n\n\tconst intersection$1 = _intersection;\n\n\tvar g = {\n\t\t__proto__: null,\n\t\tCurve: Curve,\n\t\tEllipse: Ellipse$1,\n\t\tLine: Line,\n\t\tPath: Path$1,\n\t\tPoint: Point,\n\t\tPolygon: Polygon$1,\n\t\tPolyline: Polyline$1,\n\t\tRect: Rect,\n\t\tbezier: bezier,\n\t\tellipse: ellipse$1,\n\t\tintersection: intersection$1,\n\t\tline: line$1,\n\t\tnormalizeAngle: normalizeAngle,\n\t\tpoint: point,\n\t\trandom: random,\n\t\trect: rect,\n\t\tscale: scale,\n\t\tsnapToGrid: snapToGrid$1,\n\t\ttoDeg: toDeg,\n\t\ttoRad: toRad,\n\t\ttypes: types\n\t};\n\n\t// code is inspired by https://github.com/lodash/lodash\n\n\t/* eslint-disable no-case-declarations */\n\t// -- helper constants\n\tconst argsTag = '[object Arguments]';\n\tconst arrayTag = '[object Array]';\n\tconst boolTag = '[object Boolean]';\n\tconst dateTag = '[object Date]';\n\tconst errorTag = '[object Error]';\n\tconst funcTag = '[object Function]';\n\tconst mapTag = '[object Map]';\n\tconst numberTag = '[object Number]';\n\tconst nullTag = '[object Null]';\n\tconst objectTag = '[object Object]';\n\tconst regexpTag = '[object RegExp]';\n\tconst setTag = '[object Set]';\n\tconst stringTag = '[object String]';\n\tconst symbolTag = '[object Symbol]';\n\tconst undefinedTag = '[object Undefined]';\n\tconst weakMapTag = '[object WeakMap]';\n\tconst arrayBufferTag = '[object ArrayBuffer]';\n\tconst dataViewTag = '[object DataView]';\n\tconst float32Tag = '[object Float32Array]';\n\tconst float64Tag = '[object Float64Array]';\n\tconst int8Tag = '[object Int8Array]';\n\tconst int16Tag = '[object Int16Array]';\n\tconst int32Tag = '[object Int32Array]';\n\tconst uint8Tag = '[object Uint8Array]';\n\tconst uint8ClampedTag = '[object Uint8ClampedArray]';\n\tconst uint16Tag = '[object Uint16Array]';\n\tconst uint32Tag = '[object Uint32Array]';\n\tconst CLONEABLE_TAGS = {\n\t  [argsTag]: true,\n\t  [arrayTag]: true,\n\t  [arrayBufferTag]: true,\n\t  [dataViewTag]: true,\n\t  [boolTag]: true,\n\t  [dateTag]: true,\n\t  [float32Tag]: true,\n\t  [float64Tag]: true,\n\t  [int8Tag]: true,\n\t  [int16Tag]: true,\n\t  [int32Tag]: true,\n\t  [mapTag]: true,\n\t  [numberTag]: true,\n\t  [objectTag]: true,\n\t  [regexpTag]: true,\n\t  [setTag]: true,\n\t  [stringTag]: true,\n\t  [symbolTag]: true,\n\t  [uint8Tag]: true,\n\t  [uint8ClampedTag]: true,\n\t  [uint16Tag]: true,\n\t  [uint32Tag]: true,\n\t  [errorTag]: false,\n\t  [funcTag]: false,\n\t  [weakMapTag]: false\n\t};\n\n\t/** Used to compose unicode character classes. */\n\tconst rsAstralRange = '\\\\ud800-\\\\udfff';\n\tconst rsComboMarksRange = '\\\\u0300-\\\\u036f';\n\tconst reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\n\tconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\n\tconst rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff';\n\tconst rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff';\n\tconst rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\n\tconst rsDingbatRange = '\\\\u2700-\\\\u27bf';\n\tconst rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff';\n\tconst rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7';\n\tconst rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf';\n\tconst rsPunctuationRange = '\\\\u2000-\\\\u206f';\n\tconst rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000';\n\tconst rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde';\n\tconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\tconst rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n\t/** Used to compose unicode capture groups. */\n\tconst rsApos = '[\\'\\u2019]';\n\tconst rsBreak = `[${rsBreakRange}]`;\n\tconst rsCombo = `[${rsComboRange}]`;\n\tconst rsDigit = '\\\\d';\n\tconst rsDingbat = `[${rsDingbatRange}]`;\n\tconst rsLower = `[${rsLowerRange}]`;\n\tconst rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;\n\tconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\n\tconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\n\tconst rsNonAstral = `[^${rsAstralRange}]`;\n\tconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\n\tconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\n\tconst rsUpper = `[${rsUpperRange}]`;\n\tconst rsZWJ = '\\\\u200d';\n\n\t/** Used to compose unicode regexes. */\n\tconst rsMiscLower = `(?:${rsLower}|${rsMisc})`;\n\tconst rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;\n\tconst rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;\n\tconst rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;\n\tconst reOptMod = `${rsModifier}?`;\n\tconst rsOptVar = `[${rsVarRange}]?`;\n\tconst rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${rsOptVar + reOptMod})*`;\n\tconst rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])';\n\tconst rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])';\n\tconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\n\tconst rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`;\n\n\t// eslint-disable-next-line no-misleading-character-class\n\tconst reUnicodeWords = RegExp([`${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`, `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`, `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`, `${rsUpper}+${rsOptContrUpper}`, rsOrdUpper, rsOrdLower, `${rsDigit}+`, rsEmoji].join('|'), 'g');\n\tconst LARGE_ARRAY_SIZE = 200;\n\tconst HASH_UNDEFINED = '__hash_undefined__';\n\n\t// Used to match `toStringTag` values of typed arrays\n\tconst reTypedTag = /^\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\\]$/;\n\n\t// Used to compose unicode capture groups\n\tconst rsAstral = `[${rsAstralRange}]`;\n\n\t// Used to compose unicode regexes\n\tconst rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;\n\tconst rsSymbol = `(?:${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')})`;\n\n\t// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)\n\t// eslint-disable-next-line no-misleading-character-class\n\tconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, 'g');\n\tconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n\tconst reIsPlainProp = /^\\w*$/;\n\tconst charCodeOfDot = '.'.charCodeAt(0);\n\tconst reEscapeChar = /\\\\(\\\\)?/g;\n\tconst rePropName = RegExp(\n\t// Match anything that isn't a dot or bracket.\n\t'[^.[\\\\]]+' + '|' +\n\t// Or match property names within brackets.\n\t'\\\\[(?:' +\n\t// Match a non-string expression.\n\t'([^\"\\'][^[]*)' + '|' +\n\t// Or match strings (supports escaping characters).\n\t'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' + ')\\\\]' + '|' +\n\t// Or match \"\" as the space between consecutive dots or empty brackets.\n\t'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))', 'g');\n\tconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n\tconst hasUnicodeWord = RegExp.prototype.test.bind(/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/);\n\tconst MAX_ARRAY_INDEX = 4294967295 - 1;\n\n\t/** Used to match words composed of alphanumeric characters. */\n\t// eslint-disable-next-line no-control-regex\n\tconst reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n\t// -- helper functions\n\tconst hasUnicode = string => {\n\t  return reUnicode.test(string);\n\t};\n\tconst unicodeToArray = string => {\n\t  return string.match(reUnicode) || [];\n\t};\n\tconst asciiToArray = string => {\n\t  return string.split('');\n\t};\n\tconst stringToArray = string => {\n\t  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n\t};\n\tconst values = object => {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  return keys(object).map(key => object[key]);\n\t};\n\tconst keys = object => {\n\t  return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));\n\t};\n\tconst baseKeys = object => {\n\t  if (!isPrototype(object)) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t  for (var key in Object(object)) {\n\t    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst arrayLikeKeys = (value, inherited) => {\n\t  const isArr = Array.isArray(value);\n\t  const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;\n\t  const isType = !isArr && !isArg && isTypedArray(value);\n\t  const skipIndexes = isArr || isArg || isType;\n\t  const length = value.length;\n\t  const result = new Array(skipIndexes ? length : 0);\n\t  let index = skipIndexes ? -1 : length;\n\t  while (++index < length) {\n\t    result[index] = `${index}`;\n\t  }\n\t  for (const key in value) {\n\t    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (\n\t    // Safari 9 has enumerable `arguments.length` in strict mode.\n\t    key === 'length' ||\n\t    // Skip index properties.\n\t    isIndex(key, length)))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst assocIndexOf = (array, key) => {\n\t  let {\n\t    length\n\t  } = array;\n\t  while (length--) {\n\t    if (eq(array[length][0], key)) {\n\t      return length;\n\t    }\n\t  }\n\t  return -1;\n\t};\n\tconst eq = (value, other) => {\n\t  return value === other || value !== value && other !== other;\n\t};\n\tconst isObjectLike = value => {\n\t  return value != null && typeof value == 'object';\n\t};\n\tconst isIterateeCall = (value, index, object) => {\n\t  if (!isObject(object)) {\n\t    return false;\n\t  }\n\t  const type = typeof index;\n\t  const isPossibleIteratee = type == 'number' ? isArrayLike(object) && index > -1 && index < object.length : type == 'string' && index in object;\n\t  if (isPossibleIteratee) {\n\t    return eq(object[index], value);\n\t  }\n\t  return false;\n\t};\n\tconst isSet = value => {\n\t  return isObjectLike(value) && getTag(value) == setTag;\n\t};\n\tconst isMap = value => {\n\t  return isObjectLike(value) && getTag(value) == mapTag;\n\t};\n\tconst isPrototype = value => {\n\t  const Ctor = value && value.constructor;\n\t  const proto = typeof Ctor === 'function' && Ctor.prototype || Object.prototype;\n\t  return value === proto;\n\t};\n\tconst assignValue = (object, key, value) => {\n\t  const objValue = object[key];\n\t  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n\t    object[key] = value;\n\t  }\n\t};\n\tconst copyObject = (source, props, object) => {\n\t  let index = -1;\n\t  const length = props.length;\n\t  while (++index < length) {\n\t    const key = props[index];\n\t    assignValue(object, key, source[key]);\n\t  }\n\t  return object;\n\t};\n\tconst isArrayLike = value => {\n\t  return value != null && typeof value !== 'function' && typeof value.length === 'number' && value.length > -1 && value.length % 1 === 0;\n\t};\n\tconst isSymbol = value => {\n\t  return typeof value == 'symbol' || isObjectLike(value) && getTag(value) === symbolTag;\n\t};\n\tconst initCloneArray = array => {\n\t  const length = array.length;\n\t  const result = new array.constructor(length);\n\t  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n\t    result.index = array.index;\n\t    result.input = array.input;\n\t  }\n\t  return result;\n\t};\n\tconst copyArray = (source, array) => {\n\t  let index = -1;\n\t  const length = source.length;\n\t  array || (array = new Array(length));\n\t  while (++index < length) {\n\t    array[index] = source[index];\n\t  }\n\t  return array;\n\t};\n\tconst getTag = value => {\n\t  if (value == null) {\n\t    return value === undefined ? undefinedTag : nullTag;\n\t  }\n\t  return Object.prototype.toString.call(value);\n\t};\n\tconst cloneArrayBuffer = arrayBuffer => {\n\t  const result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n\t  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n\t  return result;\n\t};\n\tconst cloneTypedArray = (typedArray, isDeep) => {\n\t  const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n\t  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n\t};\n\tconst cloneRegExp = regexp => {\n\t  const result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp));\n\t  result.lastIndex = regexp.lastIndex;\n\t  return result;\n\t};\n\tconst initCloneObject = object => {\n\t  return typeof object.constructor == 'function' && !isPrototype(object) ? Object.create(Object.getPrototypeOf(object)) : {};\n\t};\n\tconst getSymbols = object => {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  object = Object(object);\n\t  const symbols = Object.getOwnPropertySymbols(object);\n\t  return symbols.filter(symbol => propertyIsEnumerable.call(object, symbol));\n\t};\n\tconst copySymbols = (source, object) => {\n\t  return copyObject(source, getSymbols(source), object);\n\t};\n\tfunction cloneDataView(dataView, isDeep) {\n\t  const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n\t  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n\t}\n\tconst initCloneByTag = (object, tag, isDeep) => {\n\t  const Constructor = object.constructor;\n\t  switch (tag) {\n\t    case arrayBufferTag:\n\t      return cloneArrayBuffer(object);\n\t    case boolTag:\n\t    case dateTag:\n\t      return new Constructor(+object);\n\t    case dataViewTag:\n\t      return cloneDataView(object, isDeep);\n\t    case float32Tag:\n\t    case float64Tag:\n\t    case int8Tag:\n\t    case int16Tag:\n\t    case int32Tag:\n\t    case uint8Tag:\n\t    case uint8ClampedTag:\n\t    case uint16Tag:\n\t    case uint32Tag:\n\t      return cloneTypedArray(object, isDeep);\n\t    case mapTag:\n\t      return new Constructor(object);\n\t    case numberTag:\n\t    case stringTag:\n\t      return new Constructor(object);\n\t    case regexpTag:\n\t      return cloneRegExp(object);\n\t    case setTag:\n\t      return new Constructor();\n\t    case symbolTag:\n\t      return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};\n\t  }\n\t};\n\tconst isTypedArray = value => {\n\t  return isObjectLike(value) && reTypedTag.test(getTag(value));\n\t};\n\tconst getAllKeys = object => {\n\t  const result = Object.keys(object);\n\t  if (!Array.isArray(object) && object != null) {\n\t    result.push(...getSymbols(Object(object)));\n\t  }\n\t  return result;\n\t};\n\tconst getSymbolsIn = object => {\n\t  const result = [];\n\t  while (object) {\n\t    result.push(...getSymbols(object));\n\t    object = Object.getPrototypeOf(Object(object));\n\t  }\n\t  return result;\n\t};\n\tconst getAllKeysIn = object => {\n\t  const result = [];\n\t  for (const key in object) {\n\t    result.push(key);\n\t  }\n\t  if (!Array.isArray(object)) {\n\t    result.push(...getSymbolsIn(object));\n\t  }\n\t  return result;\n\t};\n\tconst getMapData = ({\n\t  __data__\n\t}, key) => {\n\t  const data = __data__;\n\t  return isKeyable(key) ? data[typeof key === 'string' ? 'string' : 'hash'] : data.map;\n\t};\n\tconst equalObjects = (object, other, equalFunc, stack) => {\n\t  const objProps = getAllKeys(object);\n\t  const objLength = objProps.length;\n\t  const othProps = getAllKeys(other);\n\t  const othLength = othProps.length;\n\t  if (objLength != othLength) {\n\t    return false;\n\t  }\n\t  let key;\n\t  let index = objLength;\n\t  while (index--) {\n\t    key = objProps[index];\n\t    if (!hasOwnProperty.call(other, key)) {\n\t      return false;\n\t    }\n\t  }\n\t  const objStacked = stack.get(object);\n\t  const othStacked = stack.get(other);\n\t  if (objStacked && othStacked) {\n\t    return objStacked == other && othStacked == object;\n\t  }\n\t  let result = true;\n\t  stack.set(object, other);\n\t  stack.set(other, object);\n\t  let compared;\n\t  let skipCtor;\n\t  while (++index < objLength) {\n\t    key = objProps[index];\n\t    const objValue = object[key];\n\t    const othValue = other[key];\n\t    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, stack) : compared)) {\n\t      result = false;\n\t      break;\n\t    }\n\t    skipCtor || (skipCtor = key == 'constructor');\n\t  }\n\t  if (result && !skipCtor) {\n\t    const objCtor = object.constructor;\n\t    const othCtor = other.constructor;\n\t    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor === 'function' && objCtor instanceof objCtor && typeof othCtor === 'function' && othCtor instanceof othCtor)) {\n\t      result = false;\n\t    }\n\t  }\n\t  stack['delete'](object);\n\t  stack['delete'](other);\n\t  return result;\n\t};\n\tconst baseIsEqual = (value, other, stack) => {\n\t  if (value === other) {\n\t    return true;\n\t  }\n\t  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n\t    return value !== value && other !== other;\n\t  }\n\t  return baseIsEqualDeep(value, other, baseIsEqual, stack);\n\t};\n\tconst baseIsEqualDeep = (object, other, equalFunc, stack) => {\n\t  const objIsArr = Array.isArray(object);\n\t  const othIsArr = Array.isArray(other);\n\t  let objTag = objIsArr ? arrayTag : getTag(object);\n\t  let othTag = othIsArr ? arrayTag : getTag(other);\n\t  objTag = objTag == argsTag ? objectTag : objTag;\n\t  othTag = othTag == argsTag ? objectTag : othTag;\n\t  const objIsObj = objTag == objectTag;\n\t  const othIsObj = othTag == objectTag;\n\t  const isSameTag = objTag == othTag;\n\t  if (isSameTag && !objIsObj) {\n\t    stack || (stack = new Stack());\n\t    return objIsArr || isTypedArray(object) ? equalArrays(object, other, false, equalFunc, stack) : equalByTag(object, other, objTag, equalFunc, stack);\n\t  }\n\t  const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__');\n\t  const othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\t  if (objIsWrapped || othIsWrapped) {\n\t    const objUnwrapped = objIsWrapped ? object.value() : object;\n\t    const othUnwrapped = othIsWrapped ? other.value() : other;\n\t    stack || (stack = new Stack());\n\t    return equalFunc(objUnwrapped, othUnwrapped, stack);\n\t  }\n\t  if (!isSameTag) {\n\t    return false;\n\t  }\n\t  stack || (stack = new Stack());\n\t  return equalObjects(object, other, equalFunc, stack);\n\t};\n\tconst equalArrays = (array, other, compareUnordered, equalFunc, stack) => {\n\t  const isPartial = false;\n\t  const arrLength = array.length;\n\t  const othLength = other.length;\n\t  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n\t    return false;\n\t  }\n\t  // Assume cyclic values are equal.\n\t  const arrStacked = stack.get(array);\n\t  const othStacked = stack.get(other);\n\t  if (arrStacked && othStacked) {\n\t    return arrStacked == other && othStacked == array;\n\t  }\n\t  let index = -1;\n\t  let result = true;\n\t  const seen = compareUnordered ? new SetCache() : undefined;\n\t  stack.set(array, other);\n\t  stack.set(other, array);\n\t  while (++index < arrLength) {\n\t    let compared;\n\t    const arrValue = array[index];\n\t    const othValue = other[index];\n\t    if (compared !== undefined) {\n\t      if (compared) {\n\t        continue;\n\t      }\n\t      result = false;\n\t      break;\n\t    }\n\t    if (seen) {\n\t      if (!some(other, (othValue, othIndex) => {\n\t        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n\t          return seen.push(othIndex);\n\t        }\n\t      })) {\n\t        result = false;\n\t        break;\n\t      }\n\t    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n\t      result = false;\n\t      break;\n\t    }\n\t  }\n\t  stack['delete'](array);\n\t  stack['delete'](other);\n\t  return result;\n\t};\n\tconst some = (array, predicate) => {\n\t  let index = -1;\n\t  const length = array == null ? 0 : array.length;\n\t  while (++index < length) {\n\t    if (predicate(array[index], index, array)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t};\n\tconst cacheHas = (cache, key) => {\n\t  return cache.has(key);\n\t};\n\tconst compareArrayBufferTag = (object, other, equalFunc, stack) => {\n\t  if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {\n\t    return false;\n\t  }\n\t  return true;\n\t};\n\tconst equalByTag = (object, other, tag, equalFunc, stack) => {\n\t  switch (tag) {\n\t    case dataViewTag:\n\t      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n\t        return false;\n\t      }\n\t      object = object.buffer;\n\t      other = other.buffer;\n\t      return compareArrayBufferTag(object, other, equalFunc, stack);\n\t    case arrayBufferTag:\n\t      return compareArrayBufferTag(object, other, equalFunc, stack);\n\t    case boolTag:\n\t    case dateTag:\n\t    case numberTag:\n\t      return eq(+object, +other);\n\t    case errorTag:\n\t      return object.name == other.name && object.message == other.message;\n\t    case regexpTag:\n\t    case stringTag:\n\t      return object == `${other}`;\n\t    case mapTag:\n\t      // This use of 'var' is intentional. Don't remove if replacing all instances.\n\t      var convert = mapToArray;\n\t    // Intentional fallthrough\n\t    // eslint-disable-next-line no-fallthrough\n\t    case setTag:\n\t      convert || (convert = setToArray);\n\t      if (object.size != other.size) {\n\t        return false;\n\t      }\n\t      // Assume cyclic values are equal.\n\t      const stacked = stack.get(object);\n\t      if (stacked) {\n\t        return stacked == other;\n\t      }\n\n\t      // Recursively compare objects (susceptible to call stack limits).\n\t      stack.set(object, other);\n\t      const result = equalArrays(convert(object), convert(other), true, equalFunc, stack);\n\t      stack['delete'](object);\n\t      return result;\n\t    case symbolTag:\n\t      return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);\n\t  }\n\t  return false;\n\t};\n\tconst mapToArray = map => {\n\t  let index = -1;\n\t  const result = Array(map.size);\n\t  map.forEach((value, key) => {\n\t    result[++index] = [key, value];\n\t  });\n\t  return result;\n\t};\n\tconst setToArray = set => {\n\t  let index = -1;\n\t  const result = new Array(set.size);\n\t  set.forEach(value => {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t};\n\tconst isKey = (value, object) => {\n\t  if (Array.isArray(value)) {\n\t    return false;\n\t  }\n\t  const type = typeof value;\n\t  if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\n\t    return true;\n\t  }\n\t  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n\t};\n\tconst stringToPath = string => {\n\t  const result = [];\n\t  if (string.charCodeAt(0) === charCodeOfDot) {\n\t    result.push('');\n\t  }\n\t  string.replace(rePropName, (match, expression, quote, subString) => {\n\t    let key = match;\n\t    if (quote) {\n\t      key = subString.replace(reEscapeChar, '$1');\n\t    } else if (expression) {\n\t      key = expression.trim();\n\t    }\n\t    result.push(key);\n\t  });\n\t  return result;\n\t};\n\tconst castPath = (path, object) => {\n\t  if (Array.isArray(path)) {\n\t    return path;\n\t  }\n\t  return isKey(path, object) ? [path] : stringToPath(`${path}`);\n\t};\n\tconst get = (object, path) => {\n\t  path = castPath(path, object);\n\t  let index = 0;\n\t  const length = path.length;\n\t  while (object != null && index < length) {\n\t    object = object[toKey(path[index])];\n\t    index++;\n\t  }\n\t  return index && index == length ? object : undefined;\n\t};\n\tfunction compareAscending(value, other) {\n\t  if (value !== other) {\n\t    const valIsDefined = value !== undefined;\n\t    const valIsNull = value === null;\n\t    const valIsReflexive = value === value;\n\t    const valIsSymbol = isSymbol(value);\n\t    const othIsDefined = other !== undefined;\n\t    const othIsNull = other === null;\n\t    const othIsReflexive = other === other;\n\t    const othIsSymbol = isSymbol(other);\n\t    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n\t      return 1;\n\t    }\n\t    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n\t      return -1;\n\t    }\n\t  }\n\t  return 0;\n\t}\n\tfunction compareMultiple(object, other, orders) {\n\t  let index = -1;\n\t  const objCriteria = object.criteria;\n\t  const othCriteria = other.criteria;\n\t  const length = objCriteria.length;\n\t  const ordersLength = orders.length;\n\t  while (++index < length) {\n\t    const order = index < ordersLength ? orders[index] : null;\n\t    const cmpFn = order && typeof order === 'function' ? order : compareAscending;\n\t    const result = cmpFn(objCriteria[index], othCriteria[index]);\n\t    if (result) {\n\t      if (order && typeof order !== 'function') {\n\t        return result * (order == 'desc' ? -1 : 1);\n\t      }\n\t      return result;\n\t    }\n\t  }\n\t  return object.index - other.index;\n\t}\n\tconst diff = (array, values) => {\n\t  let includes = (array, value) => {\n\t    const length = array == null ? 0 : array.length;\n\t    return !!length && array.indexOf(value) > -1;\n\t  };\n\t  let isCommon = true;\n\t  const result = [];\n\t  const valuesLength = values.length;\n\t  if (!array.length) {\n\t    return result;\n\t  }\n\t  if (values.length >= LARGE_ARRAY_SIZE) {\n\t    includes = (cache, key) => cache.has(key);\n\t    isCommon = false;\n\t    values = new SetCache(values);\n\t  }\n\t  outer: for (const key in array) {\n\t    let value = array[key];\n\t    const computed = value;\n\t    value = value !== 0 ? value : 0;\n\t    if (isCommon && computed === computed) {\n\t      let valuesIndex = valuesLength;\n\t      while (valuesIndex--) {\n\t        if (values[valuesIndex] === computed) {\n\t          continue outer;\n\t        }\n\t      }\n\t      result.push(value);\n\t    } else if (!includes(values, computed)) {\n\t      result.push(value);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst intersect = arrays => {\n\t  const includes = (array, value) => {\n\t    const length = array == null ? 0 : array.length;\n\t    return !!length && array.indexOf(value) > -1;\n\t  };\n\t  const cacheHas = (cache, key) => cache.has(key);\n\t  const length = arrays[0].length;\n\t  const othLength = arrays.length;\n\t  const caches = new Array(othLength);\n\t  const result = [];\n\t  let array;\n\t  let maxLength = Infinity;\n\t  let othIndex = othLength;\n\t  while (othIndex--) {\n\t    array = arrays[othIndex];\n\t    maxLength = Math.min(array.length, maxLength);\n\t    caches[othIndex] = length >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : undefined;\n\t  }\n\t  array = arrays[0];\n\t  let index = -1;\n\t  const seen = caches[0];\n\t  outer: while (++index < length && result.length < maxLength) {\n\t    let value = array[index];\n\t    const computed = value;\n\t    value = value !== 0 ? value : 0;\n\t    if (!(seen ? cacheHas(seen, computed) : includes(result, computed))) {\n\t      othIndex = othLength;\n\t      while (--othIndex) {\n\t        const cache = caches[othIndex];\n\t        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed))) {\n\t          continue outer;\n\t        }\n\t      }\n\t      if (seen) {\n\t        seen.push(computed);\n\t      }\n\t      result.push(value);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst toKey = value => {\n\t  if (typeof value === 'string' || isSymbol(value)) {\n\t    return value;\n\t  }\n\t  const result = `${value}`;\n\t  return result == '0' && 1 / value == -Infinity ? '-0' : result;\n\t};\n\tconst baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack) => {\n\t  let result;\n\t  if (customizer) {\n\t    result = object ? customizer(value, key, object, stack) : customizer(value);\n\t  }\n\t  if (result !== undefined) {\n\t    return result;\n\t  }\n\t  if (!isObject(value)) {\n\t    return value;\n\t  }\n\t  const isArr = Array.isArray(value);\n\t  const tag = getTag(value);\n\t  if (isArr) {\n\t    result = initCloneArray(value);\n\t    if (!isDeep) {\n\t      return copyArray(value, result);\n\t    }\n\t  } else {\n\t    const isFunc = typeof value === 'function';\n\t    if (tag === objectTag || tag === argsTag || isFunc && !object) {\n\t      result = isFlat || isFunc ? {} : initCloneObject(value);\n\t      if (!isDeep) {\n\t        return isFlat ? copySymbolsIn(value, copyObject(value, Object.keys(value), result)) : copySymbols(value, Object.assign(result, value));\n\t      }\n\t    } else {\n\t      if (isFunc || !CLONEABLE_TAGS[tag]) {\n\t        return object ? value : {};\n\t      }\n\t      result = initCloneByTag(value, tag, isDeep);\n\t    }\n\t  }\n\t  stack || (stack = new Stack());\n\t  const stacked = stack.get(value);\n\t  if (stacked) {\n\t    return stacked;\n\t  }\n\t  stack.set(value, result);\n\t  if (isMap(value)) {\n\t    value.forEach((subValue, key) => {\n\t      result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n\t    });\n\t    return result;\n\t  }\n\t  if (isSet(value)) {\n\t    value.forEach(subValue => {\n\t      result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));\n\t    });\n\t    return result;\n\t  }\n\t  if (isTypedArray(value)) {\n\t    return result;\n\t  }\n\t  const keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;\n\t  const props = isArr ? undefined : keysFunc(value);\n\t  (props || value).forEach((subValue, key) => {\n\t    if (props) {\n\t      key = subValue;\n\t      subValue = value[key];\n\t    }\n\t    assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n\t  });\n\t  return result;\n\t};\n\tconst copySymbolsIn = (source, object) => {\n\t  return copyObject(source, getSymbolsIn(source), object);\n\t};\n\tconst parent = (object, path) => {\n\t  return path.length < 2 ? object : get(object, path.slice(0, -1));\n\t};\n\tconst set = (object, path, value) => {\n\t  if (!isObject(object)) {\n\t    return object;\n\t  }\n\t  path = castPath(path, object);\n\t  const length = path.length;\n\t  const lastIndex = length - 1;\n\t  let index = -1;\n\t  let nested = object;\n\t  while (nested != null && ++index < length) {\n\t    const key = toKey(path[index]);\n\t    let newValue = value;\n\t    if (index != lastIndex) {\n\t      const objValue = nested[key];\n\t      newValue = undefined;\n\t      if (newValue === undefined) {\n\t        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n\t      }\n\t    }\n\t    assignValue(nested, key, newValue);\n\t    nested = nested[key];\n\t  }\n\t  return object;\n\t};\n\tconst isIndex = (value, length) => {\n\t  const type = typeof value;\n\t  length = length == null ? Number.MAX_SAFE_INTEGER : length;\n\t  return !!length && (type === 'number' || type !== 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n\t};\n\tconst unset = (object, path) => {\n\t  path = castPath(path, object);\n\t  object = parent(object, path);\n\t  const lastSegment = path[path.length - 1];\n\t  return object == null || delete object[toKey(lastSegment)];\n\t};\n\tconst isKeyable = value => {\n\t  const type = typeof value;\n\t  return type === 'string' || type === 'number' || type === 'symbol' || type === 'boolean' ? value !== '__proto__' : value === null;\n\t};\n\tconst keysIn = object => {\n\t  const result = [];\n\t  for (const key in object) {\n\t    result.push(key);\n\t  }\n\t  return result;\n\t};\n\tconst toPlainObject = value => {\n\t  value = Object(value);\n\t  const result = {};\n\t  for (const key in value) {\n\t    result[key] = value[key];\n\t  }\n\t  return result;\n\t};\n\tconst safeGet = (object, key) => {\n\t  if (key === 'constructor' && typeof object[key] === 'function') {\n\t    return;\n\t  }\n\t  if (key == '__proto__') {\n\t    return;\n\t  }\n\t  return object[key];\n\t};\n\tfunction createAssigner(assigner, isMerge = false) {\n\t  return (object, ...sources) => {\n\t    let index = -1;\n\t    let length = sources.length;\n\t    let customizer = length > 1 ? sources[length - 1] : undefined;\n\t    const guard = length > 2 ? sources[2] : undefined;\n\t    customizer = assigner.length > 3 && typeof customizer === 'function' ? (length--, customizer) : isMerge ? (a, b) => {\n\t      if (Array.isArray(a) && !Array.isArray(b)) {\n\t        return b;\n\t      }\n\t    } : undefined;\n\t    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t      customizer = length < 3 ? undefined : customizer;\n\t      length = 1;\n\t    }\n\t    object = Object(object);\n\t    while (++index < length) {\n\t      const source = sources[index];\n\t      if (source) {\n\t        assigner(object, source, index, customizer);\n\t      }\n\t    }\n\t    return object;\n\t  };\n\t}\n\tconst baseMerge = (object, source, srcIndex, customizer, stack) => {\n\t  if (object === source) {\n\t    return;\n\t  }\n\t  forIn(source, (srcValue, key) => {\n\t    if (isObject(srcValue)) {\n\t      stack || (stack = new Stack());\n\t      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n\t    } else {\n\t      let newValue = customizer ? customizer(object[key], srcValue, `${key}`, object, source, stack) : undefined;\n\t      if (newValue === undefined) {\n\t        newValue = srcValue;\n\t      }\n\t      assignMergeValue(object, key, newValue);\n\t    }\n\t  });\n\t};\n\tconst baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack) => {\n\t  const objValue = safeGet(object, key);\n\t  const srcValue = safeGet(source, key);\n\t  const stacked = stack.get(srcValue);\n\t  if (stacked) {\n\t    assignMergeValue(object, key, stacked);\n\t    return;\n\t  }\n\t  let newValue = customizer ? customizer(objValue, srcValue, `${key}`, object, source, stack) : undefined;\n\t  let isCommon = newValue === undefined;\n\t  if (isCommon) {\n\t    const isArr = Array.isArray(srcValue);\n\t    const isTyped = !isArr && isTypedArray(srcValue);\n\t    newValue = srcValue;\n\t    if (isArr || isTyped) {\n\t      if (Array.isArray(objValue)) {\n\t        newValue = objValue;\n\t      } else if (isObjectLike(objValue) && isArrayLike(objValue)) {\n\t        newValue = copyArray(objValue);\n\t      } else if (isTyped) {\n\t        isCommon = false;\n\t        newValue = cloneTypedArray(srcValue, true);\n\t      } else {\n\t        newValue = [];\n\t      }\n\t    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n\t      newValue = objValue;\n\t      if (isArguments(objValue)) {\n\t        newValue = toPlainObject(objValue);\n\t      } else if (typeof objValue === 'function' || !isObject(objValue)) {\n\t        newValue = initCloneObject(srcValue);\n\t      }\n\t    } else {\n\t      isCommon = false;\n\t    }\n\t  }\n\t  if (isCommon) {\n\t    // Recursively merge objects and arrays (susceptible to call stack limits).\n\t    stack.set(srcValue, newValue);\n\t    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n\t    stack['delete'](srcValue);\n\t  }\n\t  assignMergeValue(object, key, newValue);\n\t};\n\tconst assignMergeValue = (object, key, value) => {\n\t  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {\n\t    assignValue(object, key, value);\n\t  }\n\t};\n\tfunction baseFor(object, iteratee, keysFunc) {\n\t  const iterable = Object(object);\n\t  const props = keysFunc(object);\n\t  let {\n\t    length\n\t  } = props;\n\t  let index = -1;\n\t  while (length--) {\n\t    const key = props[++index];\n\t    if (iteratee(iterable[key], key, iterable) === false) {\n\t      break;\n\t    }\n\t  }\n\t  return object;\n\t}\n\tconst baseForOwn = (object, iteratee) => {\n\t  return object && baseFor(object, iteratee, keys);\n\t};\n\tconst baseEach = (collection, iteratee) => {\n\t  if (collection == null) {\n\t    return collection;\n\t  }\n\t  if (!isArrayLike(collection)) {\n\t    return baseForOwn(collection, iteratee);\n\t  }\n\t  const length = collection.length;\n\t  const iterable = Object(collection);\n\t  let index = -1;\n\t  while (++index < length) {\n\t    if (iteratee(iterable[index], index, iterable) === false) {\n\t      break;\n\t    }\n\t  }\n\t  return collection;\n\t};\n\tfunction last(array) {\n\t  const length = array == null ? 0 : array.length;\n\t  return length ? array[length - 1] : undefined;\n\t}\n\tconst createSet = Set && 1 / setToArray(new Set([undefined, -0]))[1] == 1 / 0 ? values => new Set(values) : () => {/* no-op */};\n\tfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n\t  if (isObject(objValue) && isObject(srcValue)) {\n\t    // Recursively merge objects and arrays (susceptible to call stack limits).\n\t    stack.set(srcValue, objValue);\n\t    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n\t    stack['delete'](srcValue);\n\t  }\n\t  return objValue;\n\t}\n\tfunction baseOrderBy(collection, iteratees, orders) {\n\t  if (iteratees.length) {\n\t    iteratees = iteratees.map(iteratee => {\n\t      if (Array.isArray(iteratee)) {\n\t        return value => get(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n\t      }\n\t      return iteratee;\n\t    });\n\t  } else {\n\t    iteratees = [value => value];\n\t  }\n\t  let criteriaIndex = -1;\n\t  let eachIndex = -1;\n\t  const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\t  baseEach(collection, value => {\n\t    const criteria = iteratees.map(iteratee => iteratee(value));\n\t    result[++eachIndex] = {\n\t      criteria,\n\t      index: ++criteriaIndex,\n\t      value\n\t    };\n\t  });\n\t  return baseSortBy(result, (object, other) => compareMultiple(object, other, orders));\n\t}\n\tfunction baseSortBy(array, comparer) {\n\t  let {\n\t    length\n\t  } = array;\n\t  array.sort(comparer);\n\t  while (length--) {\n\t    array[length] = array[length].value;\n\t  }\n\t  return array;\n\t}\n\tfunction isStrictComparable(value) {\n\t  return value === value && !isObject(value);\n\t}\n\tfunction matchesStrictComparable(key, srcValue) {\n\t  return object => {\n\t    if (object == null) {\n\t      return false;\n\t    }\n\t    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n\t  };\n\t}\n\tfunction hasIn(object, path) {\n\t  return object != null && hasPath(object, path, baseHasIn);\n\t}\n\tfunction baseMatchesProperty(path, srcValue) {\n\t  if (isKey(path) && isStrictComparable(srcValue)) {\n\t    return matchesStrictComparable(toKey(path), srcValue);\n\t  }\n\t  return object => {\n\t    const objValue = get(object, path);\n\t    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue);\n\t  };\n\t}\n\tfunction baseMatches(source) {\n\t  const matchData = getMatchData(source);\n\t  if (matchData.length === 1 && matchData[0][2]) {\n\t    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n\t  }\n\t  return object => object === source || baseIsMatch(object, source, matchData);\n\t}\n\tfunction getMatchData(object) {\n\t  const result = keys(object);\n\t  let length = result.length;\n\t  while (length--) {\n\t    const key = result[length];\n\t    const value = object[key];\n\t    result[length] = [key, value, isStrictComparable(value)];\n\t  }\n\t  return result;\n\t}\n\tfunction baseIsMatch(object, source, matchData, customizer) {\n\t  let index = matchData.length;\n\t  const length = index;\n\t  const noCustomizer = !customizer;\n\t  if (object == null) {\n\t    return !length;\n\t  }\n\t  let data;\n\t  let result;\n\t  object = Object(object);\n\t  while (index--) {\n\t    data = matchData[index];\n\t    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n\t      return false;\n\t    }\n\t  }\n\t  while (++index < length) {\n\t    data = matchData[index];\n\t    const key = data[0];\n\t    const objValue = object[key];\n\t    const srcValue = data[1];\n\t    if (noCustomizer && data[2]) {\n\t      if (objValue === undefined && !(key in object)) {\n\t        return false;\n\t      }\n\t    } else {\n\t      const stack = new Stack();\n\t      if (customizer) {\n\t        result = customizer(objValue, srcValue, key, object, source, stack);\n\t      }\n\t      if (!(result === undefined ? baseIsEqual(srcValue, objValue, stack) : result)) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\tfunction property(path) {\n\t  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n\t}\n\tfunction baseProperty(key) {\n\t  return object => object == null ? undefined : object[key];\n\t}\n\tfunction basePropertyDeep(path) {\n\t  return object => get(object, path);\n\t}\n\tfunction baseIteratee(value) {\n\t  if (typeof value == 'function') {\n\t    return value;\n\t  }\n\t  if (value == null) {\n\t    return val => val;\n\t  }\n\t  if (typeof value == 'object') {\n\t    return Array.isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n\t  }\n\t  return property(value);\n\t}\n\tfunction getIteratee() {\n\t  const result = baseIteratee;\n\t  return arguments.length ? result(arguments[0], arguments[1]) : result;\n\t}\n\tconst arrayReduce = (array, iteratee, accumulator, initAccum) => {\n\t  let index = -1;\n\t  const length = array == null ? 0 : array.length;\n\t  if (initAccum && length) {\n\t    accumulator = array[++index];\n\t  }\n\t  while (++index < length) {\n\t    accumulator = iteratee(accumulator, array[index], index, array);\n\t  }\n\t  return accumulator;\n\t};\n\tconst baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc) => {\n\t  eachFunc(collection, (value, index, collection) => {\n\t    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);\n\t  });\n\t  return accumulator;\n\t};\n\tfunction reduce(collection, iteratee, accumulator) {\n\t  const func = Array.isArray(collection) ? arrayReduce : baseReduce;\n\t  const initAccum = arguments.length < 3;\n\t  return func(collection, iteratee, accumulator, initAccum, baseEach);\n\t}\n\tconst isFlattenable = value => {\n\t  return Array.isArray(value) || isArguments(value) || !!(value && value[Symbol.isConcatSpreadable]);\n\t};\n\tfunction baseFlatten(array, depth, predicate, isStrict, result) {\n\t  let index = -1;\n\t  const length = array.length;\n\t  predicate || (predicate = isFlattenable);\n\t  result || (result = []);\n\t  while (++index < length) {\n\t    var value = array[index];\n\t    if (depth > 0 && predicate(value)) {\n\t      if (depth > 1) {\n\t        // Recursively flatten arrays (susceptible to call stack limits).\n\t        baseFlatten(value, depth - 1, predicate, isStrict, result);\n\t      } else {\n\t        result.push(...value);\n\t      }\n\t    } else if (!isStrict) {\n\t      result[result.length] = value;\n\t    }\n\t  }\n\t  return result;\n\t}\n\tconst isArguments = value => {\n\t  return isObjectLike(value) && getTag(value) == '[object Arguments]';\n\t};\n\tconst basePick = (object, paths) => {\n\t  return basePickBy(object, paths, (value, path) => hasIn(object, path));\n\t};\n\tconst basePickBy = (object, paths, predicate) => {\n\t  let index = -1;\n\t  const length = paths.length;\n\t  const result = {};\n\t  while (++index < length) {\n\t    const path = paths[index];\n\t    const value = get(object, path);\n\t    if (predicate(value, path)) {\n\t      set(result, castPath(path, object), value);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst isLength = value => {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n\t};\n\tconst baseHasIn = (object, key) => {\n\t  return object != null && key in Object(object);\n\t};\n\tconst hasPath = (object, path, hasFunc) => {\n\t  path = castPath(path, object);\n\t  var index = -1,\n\t    length = path.length,\n\t    result = false;\n\t  while (++index < length) {\n\t    var key = toKey(path[index]);\n\t    if (!(result = object != null && hasFunc(object, key))) {\n\t      break;\n\t    }\n\t    object = object[key];\n\t  }\n\t  if (result || ++index != length) {\n\t    return result;\n\t  }\n\t  length = object == null ? 0 : object.length;\n\t  return !!length && isLength(length) && isIndex(key, length) && (Array.isArray(object) || isArguments(object));\n\t};\n\tconst asciiWords = string => {\n\t  return string.match(reAsciiWord);\n\t};\n\tconst unicodeWords = string => {\n\t  return string.match(reUnicodeWords);\n\t};\n\tconst words = (string, pattern) => {\n\t  if (pattern === undefined) {\n\t    const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n\t    return result || [];\n\t  }\n\t  return string.match(pattern) || [];\n\t};\n\tconst castSlice = (array, start, end) => {\n\t  const {\n\t    length\n\t  } = array;\n\t  end = end === undefined ? length : end;\n\t  return !start && end >= length ? array : array.slice(start, end);\n\t};\n\tconst upperFirst = createCaseFirst('toUpperCase');\n\tfunction createCaseFirst(methodName) {\n\t  return string => {\n\t    if (!string) {\n\t      return '';\n\t    }\n\t    const strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;\n\t    const chr = strSymbols ? strSymbols[0] : string[0];\n\t    const trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);\n\t    return chr[methodName]() + trailing;\n\t  };\n\t}\n\tfunction matches(source) {\n\t  return baseMatches(baseClone(source, true));\n\t}\n\n\t// -- helper classes\n\tclass Stack {\n\t  constructor(entries) {\n\t    const data = this.__data__ = new ListCache(entries);\n\t    this.size = data.size;\n\t  }\n\t  clear() {\n\t    this.__data__ = new ListCache();\n\t    this.size = 0;\n\t  }\n\t  delete(key) {\n\t    const data = this.__data__;\n\t    const result = data['delete'](key);\n\t    this.size = data.size;\n\t    return result;\n\t  }\n\t  get(key) {\n\t    return this.__data__.get(key);\n\t  }\n\t  has(key) {\n\t    return this.__data__.has(key);\n\t  }\n\t  set(key, value) {\n\t    let data = this.__data__;\n\t    if (data instanceof ListCache) {\n\t      const pairs = data.__data__;\n\t      if (pairs.length < LARGE_ARRAY_SIZE - 1) {\n\t        pairs.push([key, value]);\n\t        this.size = ++data.size;\n\t        return this;\n\t      }\n\t      data = this.__data__ = new MapCache(pairs);\n\t    }\n\t    data.set(key, value);\n\t    this.size = data.size;\n\t    return this;\n\t  }\n\t}\n\tclass ListCache {\n\t  constructor(entries) {\n\t    let index = -1;\n\t    const length = entries == null ? 0 : entries.length;\n\t    this.clear();\n\t    while (++index < length) {\n\t      const entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\t  clear() {\n\t    this.__data__ = [];\n\t    this.size = 0;\n\t  }\n\t  delete(key) {\n\t    const data = this.__data__;\n\t    const index = assocIndexOf(data, key);\n\t    if (index < 0) {\n\t      return false;\n\t    }\n\t    const lastIndex = data.length - 1;\n\t    if (index == lastIndex) {\n\t      data.pop();\n\t    } else {\n\t      data.splice(index, 1);\n\t    }\n\t    --this.size;\n\t    return true;\n\t  }\n\t  get(key) {\n\t    const data = this.__data__;\n\t    const index = assocIndexOf(data, key);\n\t    return index < 0 ? undefined : data[index][1];\n\t  }\n\t  has(key) {\n\t    return assocIndexOf(this.__data__, key) > -1;\n\t  }\n\t  set(key, value) {\n\t    const data = this.__data__;\n\t    const index = assocIndexOf(data, key);\n\t    if (index < 0) {\n\t      ++this.size;\n\t      data.push([key, value]);\n\t    } else {\n\t      data[index][1] = value;\n\t    }\n\t    return this;\n\t  }\n\t}\n\tclass MapCache {\n\t  constructor(entries) {\n\t    let index = -1;\n\t    const length = entries == null ? 0 : entries.length;\n\t    this.clear();\n\t    while (++index < length) {\n\t      const entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\t  clear() {\n\t    this.size = 0;\n\t    this.__data__ = {\n\t      'hash': new Hash(),\n\t      'map': new Map(),\n\t      'string': new Hash()\n\t    };\n\t  }\n\t  delete(key) {\n\t    const result = getMapData(this, key)['delete'](key);\n\t    this.size -= result ? 1 : 0;\n\t    return result;\n\t  }\n\t  get(key) {\n\t    return getMapData(this, key).get(key);\n\t  }\n\t  has(key) {\n\t    return getMapData(this, key).has(key);\n\t  }\n\t  set(key, value) {\n\t    const data = getMapData(this, key);\n\t    const size = data.size;\n\t    data.set(key, value);\n\t    this.size += data.size == size ? 0 : 1;\n\t    return this;\n\t  }\n\t}\n\tclass Hash {\n\t  constructor(entries) {\n\t    let index = -1;\n\t    const length = entries == null ? 0 : entries.length;\n\t    this.clear();\n\t    while (++index < length) {\n\t      const entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\t  clear() {\n\t    this.__data__ = Object.create(null);\n\t    this.size = 0;\n\t  }\n\t  delete(key) {\n\t    const result = this.has(key) && delete this.__data__[key];\n\t    this.size -= result ? 1 : 0;\n\t    return result;\n\t  }\n\t  get(key) {\n\t    const data = this.__data__;\n\t    const result = data[key];\n\t    return result === HASH_UNDEFINED ? undefined : result;\n\t  }\n\t  has(key) {\n\t    const data = this.__data__;\n\t    return data[key] !== undefined;\n\t  }\n\t  set(key, value) {\n\t    const data = this.__data__;\n\t    this.size += this.has(key) ? 0 : 1;\n\t    data[key] = value === undefined ? HASH_UNDEFINED : value;\n\t    return this;\n\t  }\n\t}\n\tclass SetCache {\n\t  constructor(values) {\n\t    let index = -1;\n\t    const length = values == null ? 0 : values.length;\n\t    this.__data__ = new MapCache();\n\t    while (++index < length) {\n\t      this.add(values[index]);\n\t    }\n\t  }\n\t  add(value) {\n\t    this.__data__.set(value, HASH_UNDEFINED);\n\t    return this;\n\t  }\n\t  has(value) {\n\t    return this.__data__.has(value);\n\t  }\n\t}\n\tSetCache.prototype.push = SetCache.prototype.add;\n\n\t// -- top level functions\n\n\tconst isBoolean = function (value) {\n\t  var toString = Object.prototype.toString;\n\t  return value === true || value === false || !!value && typeof value === 'object' && toString.call(value) === boolTag;\n\t};\n\tconst isObject = function (value) {\n\t  return !!value && (typeof value === 'object' || typeof value === 'function');\n\t};\n\tconst isNumber = function (value) {\n\t  var toString = Object.prototype.toString;\n\t  return typeof value === 'number' || !!value && typeof value === 'object' && toString.call(value) === numberTag;\n\t};\n\tconst isString = function (value) {\n\t  var toString = Object.prototype.toString;\n\t  return typeof value === 'string' || !!value && typeof value === 'object' && toString.call(value) === stringTag;\n\t};\n\tconst assign = createAssigner((object, source) => {\n\t  if (isPrototype(source) || isArrayLike(source)) {\n\t    copyObject(source, keys(source), object);\n\t    return;\n\t  }\n\t  for (var key in source) {\n\t    if (hasOwnProperty.call(source, key)) {\n\t      assignValue(object, key, source[key]);\n\t    }\n\t  }\n\t});\n\tconst mixin = assign;\n\tconst deepMixin = mixin;\n\tconst supplement = (object, ...sources) => {\n\t  let index = -1;\n\t  let length = sources.length;\n\t  const guard = length > 2 ? sources[2] : undefined;\n\t  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t    length = 1;\n\t  }\n\t  while (++index < length) {\n\t    const source = sources[index];\n\t    if (source == null) {\n\t      continue;\n\t    }\n\t    const props = Object.keys(source);\n\t    const propsLength = props.length;\n\t    let propsIndex = -1;\n\t    while (++propsIndex < propsLength) {\n\t      const key = props[propsIndex];\n\t      const value = object[key];\n\t      if (value === undefined || eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key)) {\n\t        object[key] = source[key];\n\t      }\n\t    }\n\t  }\n\t  return object;\n\t};\n\tconst defaults = supplement;\n\tconst deepSupplement = function defaultsDeep(...args) {\n\t  args.push(undefined, customDefaultsMerge);\n\t  return merge.apply(undefined, args);\n\t};\n\tconst defaultsDeep = deepSupplement;\n\n\t// _.invokeMap\n\tconst invoke = (collection, path, ...args) => {\n\t  let index = -1;\n\t  const isFunc = typeof path === 'function';\n\t  const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\t  baseEach(collection, value => {\n\t    result[++index] = isFunc ? path.apply(value, args) : invokeProperty(value, path, ...args);\n\t  });\n\t  return result;\n\t};\n\n\t// _.invoke\n\tconst invokeProperty = (object, path, ...args) => {\n\t  path = castPath(path, object);\n\t  object = parent(object, path);\n\t  const func = object == null ? object : object[toKey(last(path))];\n\t  return func == null ? undefined : func.apply(object, args);\n\t};\n\tconst sortedIndex = (array, value, iteratee) => {\n\t  let low = 0;\n\t  let high = array == null ? 0 : array.length;\n\t  if (high == 0) {\n\t    return 0;\n\t  }\n\t  iteratee = getIteratee(iteratee, 2);\n\t  value = iteratee(value);\n\t  const valIsNaN = value !== value;\n\t  const valIsNull = value === null;\n\t  const valIsSymbol = isSymbol(value);\n\t  const valIsUndefined = value === undefined;\n\t  while (low < high) {\n\t    let setLow;\n\t    const mid = Math.floor((low + high) / 2);\n\t    const computed = iteratee(array[mid]);\n\t    const othIsDefined = computed !== undefined;\n\t    const othIsNull = computed === null;\n\t    const othIsReflexive = computed === computed;\n\t    const othIsSymbol = isSymbol(computed);\n\t    if (valIsNaN) {\n\t      setLow = othIsReflexive;\n\t    } else if (valIsUndefined) {\n\t      setLow = othIsReflexive && othIsDefined;\n\t    } else if (valIsNull) {\n\t      setLow = othIsReflexive && othIsDefined && !othIsNull;\n\t    } else if (valIsSymbol) {\n\t      setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;\n\t    } else if (othIsNull || othIsSymbol) {\n\t      setLow = false;\n\t    } else {\n\t      setLow = computed < value;\n\t    }\n\t    if (setLow) {\n\t      low = mid + 1;\n\t    } else {\n\t      high = mid;\n\t    }\n\t  }\n\t  return Math.min(high, MAX_ARRAY_INDEX);\n\t};\n\tconst uniq = (array, iteratee) => {\n\t  let index = -1;\n\t  let includes = (array, value) => {\n\t    const length = array == null ? 0 : array.length;\n\t    return !!length && array.indexOf(value) > -1;\n\t  };\n\t  iteratee = getIteratee(iteratee, 2);\n\t  let isCommon = true;\n\t  const {\n\t    length\n\t  } = array;\n\t  const result = [];\n\t  let seen = result;\n\t  if (length >= LARGE_ARRAY_SIZE) {\n\t    const set = iteratee ? null : createSet(array);\n\t    if (set) {\n\t      return setToArray(set);\n\t    }\n\t    isCommon = false;\n\t    includes = (cache, key) => cache.has(key);\n\t    seen = new SetCache();\n\t  } else {\n\t    seen = iteratee ? [] : result;\n\t  }\n\t  outer: while (++index < length) {\n\t    let value = array[index];\n\t    const computed = iteratee ? iteratee(value) : value;\n\t    value = value !== 0 ? value : 0;\n\t    if (isCommon && computed === computed) {\n\t      let seenIndex = seen.length;\n\t      while (seenIndex--) {\n\t        if (seen[seenIndex] === computed) {\n\t          continue outer;\n\t        }\n\t      }\n\t      if (iteratee) {\n\t        seen.push(computed);\n\t      }\n\t      result.push(value);\n\t    } else if (!includes(seen, computed)) {\n\t      if (seen !== result) {\n\t        seen.push(computed);\n\t      }\n\t      result.push(value);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst clone$1 = value => baseClone(value);\n\tconst cloneDeep = value => baseClone(value, true);\n\tconst isEmpty = value => {\n\t  if (value == null) {\n\t    return true;\n\t  }\n\t  if (isArrayLike(value) && (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function' || isTypedArray(value) || isArguments(value))) {\n\t    return !value.length;\n\t  }\n\t  const tag = getTag(value);\n\t  if (tag == '[object Map]' || tag == '[object Set]') {\n\t    return !value.size;\n\t  }\n\t  if (isPrototype(value)) {\n\t    return !baseKeys(value).length;\n\t  }\n\t  for (const key in value) {\n\t    if (hasOwnProperty.call(value, key)) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t};\n\tconst isEqual = (object, other) => baseIsEqual(object, other);\n\tconst isFunction = value => typeof value === 'function';\n\tconst isPlainObject = value => {\n\t  if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n\t    return false;\n\t  }\n\t  if (Object.getPrototypeOf(value) === null) {\n\t    return true;\n\t  }\n\t  let proto = value;\n\t  while (Object.getPrototypeOf(proto) !== null) {\n\t    proto = Object.getPrototypeOf(proto);\n\t  }\n\t  return Object.getPrototypeOf(value) === proto;\n\t};\n\tconst toArray$1 = value => {\n\t  if (!value) {\n\t    return [];\n\t  }\n\t  if (isArrayLike(value)) {\n\t    return isString(value) ? stringToArray(value) : copyArray(value);\n\t  }\n\t  if (Symbol.iterator && Symbol.iterator in Object(value)) {\n\t    const iterator = value[Symbol.iterator]();\n\t    let data;\n\t    const result = [];\n\t    while (!(data = iterator.next()).done) {\n\t      result.push(data.value);\n\t    }\n\t    return result;\n\t  }\n\t  const tag = getTag(value);\n\t  const func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;\n\t  return func(value);\n\t};\n\tfunction debounce(func, wait, opt) {\n\t  if (typeof func !== 'function') {\n\t    throw new TypeError('Expected a function');\n\t  }\n\t  let lastArgs;\n\t  let lastThis;\n\t  let maxWait;\n\t  let result;\n\t  let timerId;\n\t  let lastCallTime;\n\t  let lastInvokeTime = 0;\n\t  let leading = false;\n\t  let maxing = false;\n\t  let trailing = true;\n\t  const useRaf = !wait && wait !== 0 && window && typeof window.requestAnimationFrame === 'function';\n\t  wait = +wait || 0;\n\t  if (isObject(opt)) {\n\t    leading = !!opt.leading;\n\t    maxing = 'maxWait' in opt;\n\t    maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;\n\t    trailing = 'trailing' in opt ? !!opt.trailing : trailing;\n\t  }\n\t  function invokeFunc(time) {\n\t    const args = lastArgs;\n\t    const thisArg = lastThis;\n\t    lastArgs = lastThis = undefined;\n\t    lastInvokeTime = time;\n\t    result = func.apply(thisArg, args);\n\t    return result;\n\t  }\n\t  function startTimer(pendingFunc, wait) {\n\t    if (useRaf) {\n\t      window.cancelAnimationFrame(timerId);\n\t      return window.requestAnimationFrame(pendingFunc);\n\t    }\n\t    return setTimeout(pendingFunc, wait);\n\t  }\n\t  function cancelTimer(id) {\n\t    if (useRaf) {\n\t      return window.cancelAnimationFrame(id);\n\t    }\n\t    clearTimeout(id);\n\t  }\n\t  function leadingEdge(time) {\n\t    lastInvokeTime = time;\n\t    timerId = startTimer(timerExpired, wait);\n\t    return leading ? invokeFunc(time) : result;\n\t  }\n\t  function remainingWait(time) {\n\t    const timeSinceLastCall = time - lastCallTime;\n\t    const timeSinceLastInvoke = time - lastInvokeTime;\n\t    const timeWaiting = wait - timeSinceLastCall;\n\t    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n\t  }\n\t  function shouldInvoke(time) {\n\t    const timeSinceLastCall = time - lastCallTime;\n\t    const timeSinceLastInvoke = time - lastInvokeTime;\n\t    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n\t  }\n\t  function timerExpired() {\n\t    const time = Date.now();\n\t    if (shouldInvoke(time)) {\n\t      return trailingEdge(time);\n\t    }\n\t    timerId = startTimer(timerExpired, remainingWait(time));\n\t  }\n\t  function trailingEdge(time) {\n\t    timerId = undefined;\n\t    if (trailing && lastArgs) {\n\t      return invokeFunc(time);\n\t    }\n\t    lastArgs = lastThis = undefined;\n\t    return result;\n\t  }\n\t  function debounced(...args) {\n\t    const time = Date.now();\n\t    const isInvoking = shouldInvoke(time);\n\t    lastArgs = args;\n\t    lastThis = this;\n\t    lastCallTime = time;\n\t    if (isInvoking) {\n\t      if (timerId === undefined) {\n\t        return leadingEdge(lastCallTime);\n\t      }\n\t      if (maxing) {\n\t        timerId = startTimer(timerExpired, wait);\n\t        return invokeFunc(lastCallTime);\n\t      }\n\t    }\n\t    if (timerId === undefined) {\n\t      timerId = startTimer(timerExpired, wait);\n\t    }\n\t    return result;\n\t  }\n\t  debounced.cancel = () => {\n\t    if (timerId !== undefined) {\n\t      cancelTimer(timerId);\n\t    }\n\t    lastInvokeTime = 0;\n\t    lastArgs = lastCallTime = lastThis = timerId = undefined;\n\t  };\n\t  debounced.flush = () => timerId === undefined ? result : trailingEdge(Date.now());\n\t  debounced.pending = () => timerId !== undefined;\n\t  return debounced;\n\t}\n\tconst groupBy = (collection, iteratee) => {\n\t  iteratee = getIteratee(iteratee, 2);\n\t  return reduce(collection, (result, value) => {\n\t    const key = iteratee(value);\n\t    if (hasOwnProperty.call(result, key)) {\n\t      result[key].push(value);\n\t    } else {\n\t      assignValue(result, key, [value]);\n\t    }\n\t    return result;\n\t  }, {});\n\t};\n\tconst sortBy = (collection, iteratees = []) => {\n\t  if (collection == null) {\n\t    return [];\n\t  }\n\t  const length = iteratees.length;\n\t  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n\t    iteratees = [];\n\t  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n\t    iteratees = [iteratees[0]];\n\t  }\n\t  if (!Array.isArray(iteratees)) {\n\t    iteratees = [getIteratee(iteratees, 2)];\n\t  }\n\t  return baseOrderBy(collection, iteratees.flat(1), []);\n\t};\n\tconst flattenDeep = array => {\n\t  const length = array == null ? 0 : array.length;\n\t  return length ? baseFlatten(array, Infinity) : [];\n\t};\n\tconst without = (array, ...values) => isArrayLike(array) ? diff(array, values) : [];\n\tconst difference = (array, ...values) => isObjectLike(array) && isArrayLike(array) ? diff(array, values.flat(1)) : [];\n\tconst intersection = (...arrays) => {\n\t  const mapped = arrays.map(array => isObjectLike(array) && isArrayLike(array) ? array : []);\n\t  return mapped.length && mapped[0] === arrays[0] ? intersect(mapped) : [];\n\t};\n\tconst union = (...arrays) => {\n\t  const array = arrays.flat(1);\n\t  return uniq(array);\n\t};\n\tconst has = (object, key) => {\n\t  if (object == null) {\n\t    return false;\n\t  }\n\t  if (typeof key === 'string') {\n\t    key = key.split('.');\n\t  }\n\t  let index = -1;\n\t  let value = object;\n\t  while (++index < key.length) {\n\t    if (!value || !hasOwnProperty.call(value, key[index])) {\n\t      return false;\n\t    }\n\t    value = value[key[index]];\n\t  }\n\t  return true;\n\t};\n\tconst result = (object, path, defaultValue) => {\n\t  path = castPath(path, object);\n\t  let index = -1;\n\t  let length = path.length;\n\t  if (!length) {\n\t    length = 1;\n\t    object = undefined;\n\t  }\n\t  while (++index < length) {\n\t    let value = object == null ? undefined : object[toKey(path[index])];\n\t    if (value === undefined) {\n\t      index = length;\n\t      value = defaultValue;\n\t    }\n\t    object = typeof value === 'function' ? value.call(object) : value;\n\t  }\n\t  return object;\n\t};\n\tconst omit = (object, ...paths) => {\n\t  let result = {};\n\t  if (object == null) {\n\t    return result;\n\t  }\n\t  let isDeep = false;\n\t  paths = paths.flat(1).map(path => {\n\t    path = castPath(path, object);\n\t    isDeep || (isDeep = path.length > 1);\n\t    return path;\n\t  });\n\t  copyObject(object, getAllKeysIn(object), result);\n\t  if (isDeep) {\n\t    result = baseClone(result, true, true, true, value => isPlainObject(value) ? undefined : value);\n\t  }\n\t  let length = paths.length;\n\t  while (length--) {\n\t    unset(result, paths[length]);\n\t  }\n\t  return result;\n\t};\n\tconst pick = (object, ...paths) => {\n\t  return object == null ? {} : basePick(object, paths.flat(Infinity));\n\t};\n\tconst bindAll = (object, ...methodNames) => {\n\t  methodNames.flat(1).forEach(key => {\n\t    key = toKey(key);\n\t    assignValue(object, key, object[key].bind(object));\n\t  });\n\t  return object;\n\t};\n\tconst forIn = (object, iteratee = value => value) => {\n\t  let index = -1;\n\t  const iterable = Object(object);\n\t  const props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);\n\t  let length = props.length;\n\t  while (length--) {\n\t    const key = props[++index];\n\t    if (iteratee(iterable[key], key, iterable) === false) {\n\t      break;\n\t    }\n\t  }\n\t};\n\tconst camelCase = (string = '') => words(`${string}`.replace(/['\\u2019]/g, '')).reduce((result, word, index) => {\n\t  word = word.toLowerCase();\n\t  return result + (index ? upperFirst(word) : word);\n\t}, '');\n\tlet idCounter = 0;\n\tconst uniqueId = (prefix = '') => {\n\t  const id = ++idCounter;\n\t  return `${prefix}` + id;\n\t};\n\tconst merge = createAssigner((object, source, srcIndex, customizer) => {\n\t  baseMerge(object, source, srcIndex, customizer);\n\t}, true);\n\n\tclass Data {\n\t  constructor() {\n\t    this.map = new WeakMap();\n\t  }\n\t  has(obj, key) {\n\t    if (key === undefined) return this.map.has(obj);\n\t    return key in this.map.get(obj);\n\t  }\n\t  create(obj) {\n\t    if (!this.has(obj)) this.map.set(obj, Object.create(null));\n\t    return this.get(obj);\n\t  }\n\t  get(obj, key) {\n\t    if (!this.has(obj)) return undefined;\n\t    const data = this.map.get(obj);\n\t    if (key === undefined) return data;\n\t    return data[key];\n\t  }\n\t  set(obj, key, value) {\n\t    if (key === undefined) return;\n\t    const data = this.create(obj);\n\t    if (typeof key === 'string') {\n\t      data[key] = value;\n\t    } else {\n\t      Object.assign(data, key);\n\t    }\n\t  }\n\t  remove(obj, key) {\n\t    if (!this.has(obj)) return;\n\t    if (key === undefined) {\n\t      this.map.delete(obj);\n\t    } else {\n\t      const data = this.map.get(obj);\n\t      delete data[key];\n\t    }\n\t  }\n\t}\n\n\tconst dataPriv = new Data();\n\tconst dataUser = new Data();\n\n\tconst Event = function (src, props) {\n\t  // Allow instantiation without the 'new' keyword\n\t  if (!(this instanceof Event)) {\n\t    return new Event(src, props);\n\t  }\n\n\t  // Event object\n\t  if (src && src.type) {\n\t    this.originalEvent = src;\n\t    this.type = src.type;\n\n\t    // Events bubbling up the document may have been marked as prevented\n\t    // by a handler lower down the tree; reflect the correct value.\n\t    this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n\n\t    // Create target properties\n\t    this.target = src.target;\n\t    this.currentTarget = src.currentTarget;\n\t    this.relatedTarget = src.relatedTarget;\n\n\t    // Event type\n\t  } else {\n\t    this.type = src;\n\t  }\n\n\t  // Put explicitly provided properties onto the event object\n\t  if (props) {\n\t    Object.assign(this, props);\n\t  }\n\n\t  // Create a timestamp if incoming event doesn't have one\n\t  this.timeStamp = src && src.timeStamp || Date.now();\n\n\t  // Mark it as fixed\n\t  this.envelope = true;\n\t};\n\n\t// $.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tEvent.prototype = {\n\t  constructor: Event,\n\t  isDefaultPrevented: returnFalse,\n\t  isPropagationStopped: returnFalse,\n\t  isImmediatePropagationStopped: returnFalse,\n\t  preventDefault: function () {\n\t    const evt = this.originalEvent;\n\t    this.isDefaultPrevented = returnTrue;\n\t    if (evt) {\n\t      evt.preventDefault();\n\t    }\n\t  },\n\t  stopPropagation: function () {\n\t    const evt = this.originalEvent;\n\t    this.isPropagationStopped = returnTrue;\n\t    if (evt) {\n\t      evt.stopPropagation();\n\t    }\n\t  },\n\t  stopImmediatePropagation: function () {\n\t    const evt = this.originalEvent;\n\t    this.isImmediatePropagationStopped = returnTrue;\n\t    if (evt) {\n\t      evt.stopImmediatePropagation();\n\t    }\n\t    this.stopPropagation();\n\t  }\n\t};\n\n\t// Includes all common event props including KeyEvent and MouseEvent specific props\n\t['altKey', 'bubbles', 'cancelable', 'changedTouches', 'ctrlKey', 'detail', 'eventPhase', 'metaKey', 'pageX', 'pageY', 'shiftKey', 'view', 'char', 'code', 'charCode', 'key', 'keyCode', 'button', 'buttons', 'clientX', 'clientY', 'offsetX', 'offsetY', 'pointerId', 'pointerType', 'screenX', 'screenY', 'targetTouches', 'toElement', 'touches', 'which'].forEach(name => addProp(name));\n\tfunction addProp(name) {\n\t  Object.defineProperty(Event.prototype, name, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function () {\n\t      return this.originalEvent ? this.originalEvent[name] : undefined;\n\t    },\n\t    set: function (value) {\n\t      Object.defineProperty(this, name, {\n\t        enumerable: true,\n\t        configurable: true,\n\t        writable: true,\n\t        value: value\n\t      });\n\t    }\n\t  });\n\t}\n\tfunction returnTrue() {\n\t  return true;\n\t}\n\tfunction returnFalse() {\n\t  return false;\n\t}\n\n\t/*!\n\t * jQuery JavaScript Library v4.0.0-pre+c98597ea.dirty\n\t * https://jquery.com/\n\t *\n\t * Copyright OpenJS Foundation and other contributors\n\t * Released under the MIT license\n\t * https://jquery.org/license\n\t *\n\t * Date: 2023-11-24T14:04Z\n\t */\n\n\tconst document$1 = typeof window !== 'undefined' ? window.document : null;\n\tconst documentElement = document$1 && document$1.documentElement;\n\tconst rTypeNamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n\t// Only count HTML whitespace\n\t// Other whitespace should count in values\n\t// https://infra.spec.whatwg.org/#ascii-whitespace\n\tconst rNotHtmlWhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n\t// Define a local copy of $\n\tconst $ = function (selector) {\n\t  // The $ object is actually just the init constructor 'enhanced'\n\t  // Need init if $ is called (just allow error to be thrown if not included)\n\t  return new $.Dom(selector);\n\t};\n\t$.fn = $.prototype = {\n\t  constructor: $,\n\t  // The default length of a $ object is 0\n\t  length: 0\n\t};\n\n\t// A global GUID counter for objects\n\t$.guid = 1;\n\n\t// User data storage\n\t$.data = dataUser;\n\t$.merge = function (first, second) {\n\t  const len = +second.length;\n\t  let i = first.length;\n\t  for (let j = 0; j < len; j++) {\n\t    first[i++] = second[j];\n\t  }\n\t  first.length = i;\n\t  return first;\n\t};\n\t$.parseHTML = function (string) {\n\t  // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n\t  const context = document$1.implementation.createHTMLDocument();\n\t  // Set the base href for the created document so any parsed elements with URLs\n\t  // are based on the document's URL\n\t  const base = context.createElement('base');\n\t  base.href = document$1.location.href;\n\t  context.head.appendChild(base);\n\t  context.body.innerHTML = string;\n\t  // remove scripts\n\t  const scripts = context.getElementsByTagName('script');\n\t  for (let i = 0; i < scripts.length; i++) {\n\t    scripts[i].remove();\n\t  }\n\t  return Array.from(context.body.childNodes);\n\t};\n\tif (typeof Symbol === 'function') {\n\t  $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];\n\t}\n\t$.fn.toArray = function () {\n\t  return Array.from(this);\n\t};\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\t$.fn.pushStack = function (elements) {\n\t  // Build a new $ matched element set\n\t  const ret = $.merge(this.constructor(), elements);\n\t  // Add the old object onto the stack (as a reference)\n\t  ret.prevObject = this;\n\t  // Return the newly-formed element set\n\t  return ret;\n\t};\n\t$.fn.find = function (selector) {\n\t  const [el] = this;\n\t  const ret = this.pushStack([]);\n\t  if (!el) return ret;\n\t  // Early return if context is not an element, document or document fragment\n\t  const {\n\t    nodeType\n\t  } = el;\n\t  if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\t    return ret;\n\t  }\n\t  if (typeof selector !== 'string') {\n\t    if (el !== selector && el.contains(selector)) {\n\t      $.merge(ret, [selector]);\n\t    }\n\t  } else {\n\t    $.merge(ret, el.querySelectorAll(selector));\n\t  }\n\t  return ret;\n\t};\n\t$.fn.add = function (selector) {\n\t  const newElements = $(selector).toArray();\n\t  const prevElements = this.toArray();\n\t  const ret = this.pushStack([]);\n\t  $.merge(ret, uniq(prevElements.concat(newElements)));\n\t  return ret;\n\t};\n\t$.fn.addBack = function () {\n\t  return this.add(this.prevObject);\n\t};\n\t$.fn.filter = function (selector) {\n\t  const matches = [];\n\t  for (let i = 0; i < this.length; i++) {\n\t    const node = this[i];\n\t    if (!node.matches(selector)) continue;\n\t    matches.push(node);\n\t  }\n\t  return this.pushStack(matches);\n\t};\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n\t// Strict HTML recognition (trac-11290: must start with <)\n\t// Shortcut simple #id case for speed\n\tconst rQuickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\n\tfunction isObviousHtml(input) {\n\t  return input[0] === '<' && input[input.length - 1] === '>' && input.length >= 3;\n\t}\n\tconst Dom = function (selector) {\n\t  if (!selector) {\n\t    // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t    return this;\n\t  }\n\t  if (typeof selector === 'function') {\n\t    // HANDLE: $(function)\n\t    // Shortcut for document ready\n\t    throw new Error('function not supported');\n\t  }\n\t  if (arguments.length > 1) {\n\t    throw new Error('selector with context not supported');\n\t  }\n\t  if (selector.nodeType) {\n\t    // HANDLE: $(DOMElement)\n\t    this[0] = selector;\n\t    this.length = 1;\n\t    return this;\n\t  }\n\t  let match;\n\t  if (isObviousHtml(selector + '')) {\n\t    // Handle obvious HTML strings\n\t    // Assume that strings that start and end with <> are HTML and skip\n\t    // the regex check. This also handles browser-supported HTML wrappers\n\t    // like TrustedHTML.\n\t    match = [null, selector, null];\n\t  } else if (typeof selector === 'string') {\n\t    // Handle HTML strings or selectors\n\t    match = rQuickExpr.exec(selector);\n\t  } else {\n\t    // Array-like\n\t    return $.merge(this, selector);\n\t  }\n\t  if (!match || !match[1]) {\n\t    // HANDLE: $(expr)\n\t    return $root.find(selector);\n\t  }\n\t  // Match html or make sure no context is specified for #id\n\t  // Note: match[1] may be a string or a TrustedHTML wrapper\n\t  if (match[1]) {\n\t    // HANDLE: $(html) -> $(array)\n\t    $.merge(this, $.parseHTML(match[1]));\n\t    return this;\n\t  }\n\t  // HANDLE: $(#id)\n\t  const el = document$1.getElementById(match[2]);\n\t  if (el) {\n\t    // Inject the element directly into the $ object\n\t    this[0] = el;\n\t    this.length = 1;\n\t  }\n\t  return this;\n\t};\n\t$.Dom = Dom;\n\n\t// Give the init function the $ prototype for later instantiation\n\tDom.prototype = $.fn;\n\n\t// Events\n\n\t$.Event = Event;\n\t$.event = {\n\t  special: Object.create(null)\n\t};\n\t$.event.has = function (elem, eventType) {\n\t  const events = dataPriv.get(elem, 'events');\n\t  if (!events) return false;\n\t  if (!eventType) return true;\n\t  return Array.isArray(events[eventType]) && events[eventType].length > 0;\n\t};\n\t$.event.on = function (elem, types, selector, data, fn, one) {\n\t  // Types can be a map of types/handlers\n\t  if (typeof types === 'object') {\n\t    // ( types-Object, selector, data )\n\t    if (typeof selector !== 'string') {\n\t      // ( types-Object, data )\n\t      data = data || selector;\n\t      selector = undefined;\n\t    }\n\t    for (const type in types) {\n\t      $.event.on(elem, type, selector, data, types[type], one);\n\t    }\n\t    return elem;\n\t  }\n\t  if (data == null && fn == null) {\n\t    // ( types, fn )\n\t    fn = selector;\n\t    data = selector = undefined;\n\t  } else if (fn == null) {\n\t    if (typeof selector === 'string') {\n\t      // ( types, selector, fn )\n\t      fn = data;\n\t      data = undefined;\n\t    } else {\n\t      // ( types, data, fn )\n\t      fn = data;\n\t      data = selector;\n\t      selector = undefined;\n\t    }\n\t  }\n\t  if (!fn) {\n\t    return elem;\n\t  }\n\t  if (one === 1) {\n\t    const origFn = fn;\n\t    fn = function (event) {\n\t      // Can use an empty set, since event contains the info\n\t      $().off(event);\n\t      return origFn.apply(this, arguments);\n\t    };\n\n\t    // Use same guid so caller can remove using origFn\n\t    fn.guid = origFn.guid || (origFn.guid = $.guid++);\n\t  }\n\t  for (let i = 0; i < elem.length; i++) {\n\t    $.event.add(elem[i], types, fn, data, selector);\n\t  }\n\t};\n\t$.event.add = function (elem, types, handler, data, selector) {\n\t  // Only attach events to objects for which we can store data\n\t  if (typeof elem != 'object') {\n\t    return;\n\t  }\n\t  const elemData = dataPriv.create(elem);\n\n\t  // Caller can pass in an object of custom data in lieu of the handler\n\t  let handleObjIn;\n\t  if (handler.handler) {\n\t    handleObjIn = handler;\n\t    handler = handleObjIn.handler;\n\t    selector = handleObjIn.selector;\n\t  }\n\n\t  // Ensure that invalid selectors throw exceptions at attach time\n\t  // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t  if (selector) {\n\t    documentElement.matches(selector);\n\t  }\n\n\t  // Make sure that the handler has a unique ID, used to find/remove it later\n\t  if (!handler.guid) {\n\t    handler.guid = $.guid++;\n\t  }\n\n\t  // Init the element's event structure and main handler, if this is the first\n\t  let events;\n\t  if (!(events = elemData.events)) {\n\t    events = elemData.events = Object.create(null);\n\t  }\n\t  let eventHandle;\n\t  if (!(eventHandle = elemData.handle)) {\n\t    eventHandle = elemData.handle = function (e) {\n\t      // Discard the second event of a $.event.trigger() and\n\t      // when an event is called after a page has unloaded\n\t      return typeof $ !== 'undefined' ? $.event.dispatch.apply(elem, arguments) : undefined;\n\t    };\n\t  }\n\n\t  // Handle multiple events separated by a space\n\t  const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n\t  let i = typesArr.length;\n\t  while (i--) {\n\t    const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n\t    // There *must* be a type, no attaching namespace-only handlers\n\t    if (!origType) {\n\t      continue;\n\t    }\n\t    const namespaces = ns.split('.').sort();\n\t    // If event changes its type, use the special event handlers for the changed type\n\t    let special = $.event.special[origType];\n\t    // If selector defined, determine special event api type, otherwise given type\n\t    const type = special && (selector ? special.delegateType : special.bindType) || origType;\n\t    // Update special based on newly reset type\n\t    special = $.event.special[type];\n\t    // handleObj is passed to all event handlers\n\t    const handleObj = Object.assign({\n\t      type: type,\n\t      origType: origType,\n\t      data: data,\n\t      handler: handler,\n\t      guid: handler.guid,\n\t      selector: selector,\n\t      namespace: namespaces.join('.')\n\t    }, handleObjIn);\n\t    let handlers;\n\t    // Init the event handler queue if we're the first\n\t    if (!(handlers = events[type])) {\n\t      handlers = events[type] = [];\n\t      handlers.delegateCount = 0;\n\n\t      // Only use addEventListener if the special events handler returns false\n\t      if (!special || !special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n\t        if (elem.addEventListener) {\n\t          elem.addEventListener(type, eventHandle);\n\t        }\n\t      }\n\t    }\n\t    if (special && special.add) {\n\t      special.add.call(elem, handleObj);\n\t      if (!handleObj.handler.guid) {\n\t        handleObj.handler.guid = handler.guid;\n\t      }\n\t    }\n\n\t    // Add to the element's handler list, delegates in front\n\t    if (selector) {\n\t      handlers.splice(handlers.delegateCount++, 0, handleObj);\n\t    } else {\n\t      handlers.push(handleObj);\n\t    }\n\t  }\n\t};\n\n\t// Detach an event or set of events from an element\n\t$.event.remove = function (elem, types, handler, selector, mappedTypes) {\n\t  const elemData = dataPriv.get(elem);\n\t  if (!elemData || !elemData.events) return;\n\t  const events = elemData.events;\n\n\t  // Once for each type.namespace in types; type may be omitted\n\t  const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n\t  let i = typesArr.length;\n\t  while (i--) {\n\t    const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n\t    // Unbind all events (on this namespace, if provided) for the element\n\t    if (!origType) {\n\t      for (const type in events) {\n\t        $.event.remove(elem, type + typesArr[i], handler, selector, true);\n\t      }\n\t      continue;\n\t    }\n\t    const special = $.event.special[origType];\n\t    const type = special && (selector ? special.delegateType : special.bindType) || origType;\n\t    const handlers = events[type];\n\t    if (!handlers || handlers.length === 0) continue;\n\t    const namespaces = ns.split('.').sort();\n\t    const rNamespace = ns ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)') : null;\n\n\t    // Remove matching events\n\t    const origCount = handlers.length;\n\t    let j = origCount;\n\t    while (j--) {\n\t      const handleObj = handlers[j];\n\t      if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!rNamespace || rNamespace.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {\n\t        handlers.splice(j, 1);\n\t        if (handleObj.selector) {\n\t          handlers.delegateCount--;\n\t        }\n\t        if (special && special.remove) {\n\t          special.remove.call(elem, handleObj);\n\t        }\n\t      }\n\t    }\n\n\t    // Remove generic event handler if we removed something and no more handlers exist\n\t    // (avoids potential for endless recursion during removal of special event handlers)\n\t    if (origCount && handlers.length === 0) {\n\t      if (!special || !special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n\t        // This \"if\" is needed for plain objects\n\t        if (elem.removeEventListener) {\n\t          elem.removeEventListener(type, elemData.handle);\n\t        }\n\t      }\n\t      delete events[type];\n\t    }\n\t  }\n\n\t  // Remove data if it's no longer used\n\t  if (isEmpty(events)) {\n\t    dataPriv.remove(elem, 'handle');\n\t    dataPriv.remove(elem, 'events');\n\t  }\n\t};\n\t$.event.dispatch = function (nativeEvent) {\n\t  const elem = this;\n\t  // Make a writable $.Event from the native event object\n\t  const event = $.event.fix(nativeEvent);\n\t  event.delegateTarget = elem;\n\t  // Use the fix-ed $.Event rather than the (read-only) native event\n\t  const args = Array.from(arguments);\n\t  args[0] = event;\n\t  const eventsData = dataPriv.get(elem, 'events');\n\t  const handlers = eventsData && eventsData[event.type] || [];\n\t  const special = $.event.special[event.type];\n\n\t  // Call the preDispatch hook for the mapped type, and let it bail if desired\n\t  if (special && special.preDispatch) {\n\t    if (special.preDispatch.call(elem, event) === false) return;\n\t  }\n\n\t  // Determine handlers\n\t  const handlerQueue = $.event.handlers.call(elem, event, handlers);\n\n\t  // Run delegates first; they may want to stop propagation beneath us\n\t  let i = 0;\n\t  let matched;\n\t  while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n\t    event.currentTarget = matched.elem;\n\t    let j = 0;\n\t    let handleObj;\n\t    while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n\t      event.handleObj = handleObj;\n\t      event.data = handleObj.data;\n\t      const origSpecial = $.event.special[handleObj.origType];\n\t      let handler;\n\t      if (origSpecial && origSpecial.handle) {\n\t        handler = origSpecial.handle;\n\t      } else {\n\t        handler = handleObj.handler;\n\t      }\n\t      const ret = handler.apply(matched.elem, args);\n\t      if (ret !== undefined) {\n\t        if ((event.result = ret) === false) {\n\t          event.preventDefault();\n\t          event.stopPropagation();\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // Call the postDispatch hook for the mapped type\n\t  if (special && special.postDispatch) {\n\t    special.postDispatch.call(elem, event);\n\t  }\n\t  return event.result;\n\t};\n\t$.event.handlers = function (event, handlers) {\n\t  const delegateCount = handlers.delegateCount;\n\t  const handlerQueue = [];\n\n\t  // Find delegate handlers\n\t  if (delegateCount &&\n\t  // Support: Firefox <=42 - 66+\n\t  // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t  // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t  // Support: IE 11+\n\t  // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t  !(event.type === 'click' && event.button >= 1)) {\n\t    for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {\n\t      // Don't check non-elements (trac-13208)\n\t      // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n\t      if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {\n\t        const matchedHandlers = [];\n\t        const matchedSelectors = {};\n\t        for (let i = 0; i < delegateCount; i++) {\n\t          const handleObj = handlers[i];\n\t          // Don't conflict with Object.prototype properties (trac-13203)\n\t          const sel = handleObj.selector + ' ';\n\t          if (matchedSelectors[sel] === undefined) {\n\t            matchedSelectors[sel] = cur.matches(sel);\n\t          }\n\t          if (matchedSelectors[sel]) {\n\t            matchedHandlers.push(handleObj);\n\t          }\n\t        }\n\t        if (matchedHandlers.length) {\n\t          handlerQueue.push({\n\t            elem: cur,\n\t            handlers: matchedHandlers\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // Add the remaining (directly-bound) handlers\n\t  if (delegateCount < handlers.length) {\n\t    handlerQueue.push({\n\t      elem: this,\n\t      handlers: handlers.slice(delegateCount)\n\t    });\n\t  }\n\t  return handlerQueue;\n\t};\n\t$.event.fix = function (originalEvent) {\n\t  return originalEvent.envelope ? originalEvent : new Event(originalEvent);\n\t};\n\n\t// A central reference to the root $(document)\n\tconst $root = $(document$1);\n\n\tconst svg$1 = 'http://www.w3.org/2000/svg';\n\tconst xmlns = 'http://www.w3.org/2000/xmlns/';\n\tconst xml = 'http://www.w3.org/XML/1998/namespace';\n\tconst xlink = 'http://www.w3.org/1999/xlink';\n\tconst xhtml = 'http://www.w3.org/1999/xhtml';\n\n\tvar ns = {\n\t\t__proto__: null,\n\t\tsvg: svg$1,\n\t\txhtml: xhtml,\n\t\txlink: xlink,\n\t\txml: xml,\n\t\txmlns: xmlns\n\t};\n\n\t/**\n\t * @constant {boolean}\n\t * @description Indicates the environment supports SVG.\n\t */\n\tconst isSVGSupported = typeof window === 'object' && !!window.SVGAngle;\n\n\t/**\n\t * @constant {string}\n\t * @description The version of the SVG document.\n\t */\n\tconst SVG_VERSION = '1.1';\n\n\t/**\n\t * @constant {SVGSVGElement}\n\t * @description The detached SVG document for various internal purposes.\n\t * e.g. SVGMatrix has no constructor, so the only way to create it is\n\t * to create an SVG document and then call `createSVGMatrix()`.\n\t */\n\tconst internalSVGDocument = isSVGSupported ? createSVGDocument() : null;\n\n\t/**\n\t * @constant {SVGGElement}\n\t * @description The detached SVG group element for various internal purposes.\n\t */\n\tconst internalSVGGroup = isSVGSupported ? createSVGElement('g') : null;\n\n\t/**\n\t * @returns {SVGSVGElement}\n\t * @description Creates an SVG document.\n\t */\n\tfunction createSVGDocument() {\n\t  const svg = createSVGElement('svg');\n\t  svg.setAttributeNS(xmlns, 'xmlns:xlink', xlink);\n\t  svg.setAttribute('version', SVG_VERSION);\n\t  return svg;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @returns {SVGElement}\n\t * @description Creates an SVG element with the given name.\n\t */\n\tfunction createSVGElement(name) {\n\t  return document.createElementNS(svg$1, name);\n\t}\n\n\t/**\n\t * @param {SVGElement} node1\n\t * @param {SVGElement} node2\n\t * @returns {SVGElement|null}\n\t * @description Finds the common ancestor node of two nodes.\n\t */\n\tfunction getCommonAncestor(node1, node2) {\n\t  // Find the common ancestor node of two nodes.\n\t  let parent = node1;\n\t  do {\n\t    if (parent.contains(node2)) return parent;\n\t    parent = parent.parentNode;\n\t  } while (parent);\n\t  return null;\n\t}\n\n\t/**\n\t * @returns {SVGMatrix}\n\t * @description Creates an identity matrix.\n\t */\n\tfunction createIdentityMatrix() {\n\t  return internalSVGDocument.createSVGMatrix();\n\t}\n\n\t/**\n\t * @param {Partial<SVGMatrix>} matrixInit\n\t * @returns {SVGMatrix}\n\t * @description Creates a new SVGMatrix object.\n\t * If no matrix is provided, it returns the identity matrix.\n\t * If a matrix like object is provided, it sets the matrix values.\n\t */\n\tfunction createMatrix(matrixInit = {}) {\n\t  const matrix = internalSVGDocument.createSVGMatrix();\n\t  if (!matrixInit) return matrix;\n\t  if ('a' in matrixInit) matrix.a = matrixInit.a;\n\t  if ('b' in matrixInit) matrix.b = matrixInit.b;\n\t  if ('c' in matrixInit) matrix.c = matrixInit.c;\n\t  if ('d' in matrixInit) matrix.d = matrixInit.d;\n\t  if ('e' in matrixInit) matrix.e = matrixInit.e;\n\t  if ('f' in matrixInit) matrix.f = matrixInit.f;\n\t  return matrix;\n\t}\n\n\t/**\n\t * @returns {SVGTransform}\n\t * @description Creates a new SVGTransform object.\n\t */\n\tfunction createSVGTransform() {\n\t  return internalSVGDocument.createSVGTransform();\n\t}\n\n\t/**\n\t * @param {SVGElement} node\n\t * @returns {SVGMatrix|null}\n\t * @description Returns the transformation matrix of the given node.\n\t * If the node has no transformation, it returns null.\n\t */\n\tfunction getNodeMatrix(node) {\n\t  const consolidatedTransformation = node.transform.baseVal.consolidate();\n\t  return consolidatedTransformation ? consolidatedTransformation.matrix : null;\n\t}\n\n\t/**\n\t * @param {string} transformString\n\t * @returns {SVGMatrix}\n\t * @description Creates a matrix from the given transform string.\n\t */\n\tfunction createMatrixFromTransformString(transformString) {\n\t  internalSVGGroup.setAttribute('transform', transformString);\n\t  return getNodeMatrix(internalSVGGroup);\n\t}\n\n\t/**\n\t * @param {SVGElement} node\n\t * @param {Partial<SVGMatrix>} matrixInit\n\t * @param {boolean} override\n\t * @description Sets the transformation matrix of the given node.\n\t * We don't use `node.transform.baseVal` here (@see `transformNode`)\n\t * for the following reasons:\n\t * - Performance: while Chrome performs slightly better, Firefox\n\t *   and Safari are significantly slower\n\t *   https://www.measurethat.net/Benchmarks/Show/34447/1/overriding-svg-transform-attribute\n\t * - Limited support: JSDOM does not support `node.transform.baseVal`\n\t */\n\tfunction replaceTransformNode(node, matrixInit) {\n\t  node.setAttribute('transform', matrixToTransformString(matrixInit));\n\t}\n\n\t/**\n\t * @param {SVGElement} node\n\t * @param {Partial<SVGMatrix>} matrixInit\n\t * @description Applies a transformation matrix to the given node.\n\t * If the node already has a transformation, it appends the new transformation.\n\t * If the node has no transformation, it creates a new one.\n\t */\n\tfunction transformNode(node, matrixInit) {\n\t  const transform = createSVGTransform();\n\t  const matrix = isSVGMatrix(matrixInit) ? matrixInit : createMatrix(matrixInit);\n\t  transform.setMatrix(matrix);\n\t  node.transform.baseVal.appendItem(transform);\n\t}\n\tconst MATRIX_TYPE = '[object SVGMatrix]';\n\n\t/**\n\t * @param {any} obj\n\t * @returns {boolean}\n\t * @description Checks if the given object is an SVGMatrix.\n\t */\n\tfunction isSVGMatrix(obj) {\n\t  return Object.prototype.toString.call(obj) === MATRIX_TYPE;\n\t}\n\n\t/**\n\t * @param {Partial<SVGMatrix>} matrixInit\n\t * @returns {string}\n\t * @description Converts a matrix to a transform string.\n\t * If no matrix is provided, it returns the identity matrix string.\n\t */\n\tfunction matrixToTransformString(matrixInit = {}) {\n\t  const {\n\t    a = 1,\n\t    b = 0,\n\t    c = 0,\n\t    d = 1,\n\t    e = 0,\n\t    f = 0\n\t  } = matrixInit;\n\t  return `matrix(${a},${b},${c},${d},${e},${f})`;\n\t}\n\n\t/**\n\t * @param {SVGElement} node\n\t * @returns {SVGSVGElement|null}\n\t * @description Returns the root SVG element for the given node,\n\t * walking up through nested SVG elements.\n\t * Returns `null` if the node is not part of an SVG document.\n\t */\n\tfunction getRootSVG(node) {\n\t  let svg = node.ownerSVGElement;\n\t  if (!svg) {\n\t    // The node itself may be an <svg> element\n\t    return node instanceof SVGSVGElement ? node : null;\n\t  }\n\t  while (svg.ownerSVGElement) {\n\t    svg = svg.ownerSVGElement;\n\t  }\n\t  return svg;\n\t}\n\n\t/**\n\t *\n\t * @param {SVGElement} a\n\t * @param {SVGElement} b\n\t * @returns {SVGMatrix|null}\n\t * @description Finds the transformation matrix from `a` to `b`.\n\t * It requires that both elements to be visible (in the render tree)\n\t * in order to calculate the correct transformation matrix.\n\t */\n\tfunction getRelativeTransformation(a, b) {\n\t  // Elements must be part of an SVG document\n\t  const rootA = getRootSVG(a);\n\t  const rootB = getRootSVG(b);\n\t  if (!rootA || !rootB) return null;\n\t  // Different SVG documents, no transformation possible\n\t  if (rootA !== rootB) return null;\n\t  // Get the transformation matrix from `a` to `b`.\n\t  const am = b.getScreenCTM();\n\t  if (!am) return null;\n\t  const bm = a.getScreenCTM();\n\t  if (!bm) return null;\n\t  return am.inverse().multiply(bm);\n\t}\n\n\t/**\n\t * @param {SVGElement} a\n\t * @param {SVGElement} b\n\t * @returns {SVGMatrix|null}\n\t * @description Finds the transformation matrix from `a` to `b`.\n\t * A safe way to calculate the transformation matrix between two elements.\n\t * It does not require the elements to be visible (in the render tree).\n\t */\n\tfunction getRelativeTransformationSafe(a, b) {\n\t  if (a === b) {\n\t    // No transformation needed\n\t    return createIdentityMatrix();\n\t  }\n\t  const position = a.compareDocumentPosition(b);\n\t  if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n\t    // `b` is a descendant of `a`\n\t    return getLinealTransformation(a, b).inverse();\n\t  } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n\t    // `a` is a descendant of `b`\n\t    return getLinealTransformation(b, a);\n\t  }\n\t  const c = getCommonAncestor(a, b);\n\t  if (!c) {\n\t    // No common ancestor\n\t    return null;\n\t  }\n\t  const mca = getLinealTransformation(c, a);\n\t  const mcb = getLinealTransformation(c, b);\n\t  return mcb.inverse().multiply(mca);\n\t}\n\n\t/**\n\t * @param {SVGElement} descendant\n\t * @param {SVGElement} ancestor\n\t * @returns {SVGMatrix}\n\t * @description Finds the transformation matrix between the `ancestor` and `descendant`.\n\t */\n\tfunction getLinealTransformation(ancestor, descendant) {\n\t  const transformations = [];\n\t  let n = descendant;\n\t  while (n && n.nodeType === Node.ELEMENT_NODE && n !== ancestor) {\n\t    const nm = getNodeMatrix(n);\n\t    if (nm) {\n\t      transformations.unshift(nm);\n\t    }\n\t    n = n.parentNode;\n\t  }\n\t  return transformations.reduce((m, t) => m.multiply(t), createIdentityMatrix());\n\t}\n\n\t// Vectorizer.\n\t// -----------\n\n\tconst V = function () {\n\t  // SVG support is required.\n\t  if (!isSVGSupported) {\n\t    // Return a function that throws an error when it is used.\n\t    return function () {\n\t      throw new Error('SVG is required to use Vectorizer.');\n\t    };\n\t  }\n\n\t  // Declare shorthands to the most used math functions.\n\t  var math = Math;\n\t  var PI = math.PI;\n\t  var atan2 = math.atan2;\n\t  var sqrt = math.sqrt;\n\t  var min = math.min;\n\t  var max = math.max;\n\t  var cos = math.cos;\n\t  var sin = math.sin;\n\t  var V = function (el, attrs, children) {\n\t    // This allows using V() without the new keyword.\n\t    if (!(this instanceof V)) {\n\t      return V.apply(Object.create(V.prototype), arguments);\n\t    }\n\t    if (!el) return;\n\t    if (V.isV(el)) {\n\t      el = el.node;\n\t    }\n\t    attrs = attrs || {};\n\t    if (V.isString(el)) {\n\t      el = el.trim();\n\t      if (el.toLowerCase() === 'svg') {\n\t        // Create a new SVG canvas.\n\t        el = V.createSvgDocument();\n\t      } else if (el[0] === '<') {\n\t        // Create element from an SVG string.\n\t        // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n\t        var svgDoc = V.createSvgDocument(el);\n\n\t        // Note that `V()` might also return an array should the SVG string passed as\n\t        // the first argument contain more than one root element.\n\t        if (svgDoc.childNodes.length > 1) {\n\t          // Map child nodes to `V`s.\n\t          var arrayOfVels = [];\n\t          var i, len;\n\t          for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\t            var childNode = svgDoc.childNodes[i];\n\t            arrayOfVels.push(new V(document.importNode(childNode, true)));\n\t          }\n\t          return arrayOfVels;\n\t        }\n\t        el = document.importNode(svgDoc.firstChild, true);\n\t      } else {\n\t        el = createSVGElement(el);\n\t      }\n\t      V.ensureId(el);\n\t    }\n\t    this.node = el;\n\t    this.setAttributes(attrs);\n\t    if (children) {\n\t      this.append(children);\n\t    }\n\t    return this;\n\t  };\n\t  var VPrototype = V.prototype;\n\t  Object.defineProperty(VPrototype, 'id', {\n\t    enumerable: true,\n\t    get: function () {\n\t      return this.node.id;\n\t    },\n\t    set: function (id) {\n\t      this.node.id = id;\n\t    }\n\t  });\n\n\t  /**\n\t   * Calculates the transformation matrix from this element to the target element.\n\t   * @param {SVGElement|V} target - The target element.\n\t   * @param {Object} [opt] - Options object for transformation calculation.\n\t   * @param {boolean} [opt.safe] - Use a safe traversal method to compute the matrix.\n\t   * @returns {DOMMatrix} The transformation matrix from this element to the target element.\n\t   */\n\t  VPrototype.getTransformToElement = function (target, opt) {\n\t    const node = this.node;\n\t    const targetNode = V.toNode(target);\n\t    let m;\n\t    if (V.isSVGGraphicsElement(targetNode) && V.isSVGGraphicsElement(node)) {\n\t      if (opt && opt.safe) {\n\t        // Use the traversal method to get the transformation matrix.\n\t        m = getRelativeTransformationSafe(node, targetNode);\n\t      } else {\n\t        m = getRelativeTransformation(node, targetNode);\n\t      }\n\t    }\n\t    return m || createIdentityMatrix();\n\t  };\n\n\t  /**\n\t   * @param {SVGMatrix} matrix\n\t   * @param {Object=} opt\n\t   * @returns {Vectorizer|SVGMatrix} Setter / Getter\n\t   */\n\t  VPrototype.transform = function (matrix, opt) {\n\t    const node = this.node;\n\n\t    // Getter\n\t    if (V.isUndefined(matrix)) {\n\t      return getNodeMatrix(node) || createIdentityMatrix();\n\t    }\n\n\t    // Setter\n\t    if (opt && opt.absolute) {\n\t      replaceTransformNode(node, matrix);\n\t    } else {\n\t      transformNode(node, matrix);\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.translate = function (tx, ty, opt) {\n\t    opt = opt || {};\n\t    ty = ty || 0;\n\t    var transformAttr = this.attr('transform') || '';\n\t    var transform = V.parseTransformString(transformAttr);\n\t    transformAttr = transform.value;\n\t    // Is it a getter?\n\t    if (V.isUndefined(tx)) {\n\t      return transform.translate;\n\t    }\n\t    transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\t    var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n\t    var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n\t    var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n\t    // Note that `translate()` is always the first transformation. This is\n\t    // usually the desired case.\n\t    this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n\t    return this;\n\t  };\n\t  VPrototype.rotate = function (angle, cx, cy, opt) {\n\t    opt = opt || {};\n\t    var transformAttr = this.attr('transform') || '';\n\t    var transform = V.parseTransformString(transformAttr);\n\t    transformAttr = transform.value;\n\n\t    // Is it a getter?\n\t    if (V.isUndefined(angle)) {\n\t      return transform.rotate;\n\t    }\n\t    transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\t    angle %= 360;\n\t    var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n\t    var newOrigin = cx !== undefined && cy !== undefined ? ',' + cx + ',' + cy : '';\n\t    var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\t    this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n\t    return this;\n\t  };\n\n\t  // Note that `scale` as the only transformation does not combine with previous values.\n\t  VPrototype.scale = function (sx, sy) {\n\t    sy = V.isUndefined(sy) ? sx : sy;\n\t    var transformAttr = this.attr('transform') || '';\n\t    var transform = V.parseTransformString(transformAttr);\n\t    transformAttr = transform.value;\n\n\t    // Is it a getter?\n\t    if (V.isUndefined(sx)) {\n\t      return transform.scale;\n\t    }\n\t    transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\t    var newScale = 'scale(' + sx + ',' + sy + ')';\n\t    this.attr('transform', (transformAttr + ' ' + newScale).trim());\n\t    return this;\n\t  };\n\n\t  // Get SVGRect that contains coordinates and dimension of the real bounding box,\n\t  // i.e. after transformations are applied.\n\t  // If `target` is specified, bounding box will be computed relatively to `target` element.\n\t  VPrototype.bbox = function (withoutTransformations, target) {\n\t    var box;\n\t    var node = this.node;\n\t    var ownerSVGElement = node.ownerSVGElement;\n\n\t    // If the element is not in the live DOM, it does not have a bounding box defined and\n\t    // so fall back to 'zero' dimension element.\n\t    if (!ownerSVGElement) {\n\t      return new Rect(0, 0, 0, 0);\n\t    }\n\t    try {\n\t      box = node.getBBox();\n\t    } catch {\n\t      // Fallback for IE.\n\t      box = {\n\t        x: node.clientLeft,\n\t        y: node.clientTop,\n\t        width: node.clientWidth,\n\t        height: node.clientHeight\n\t      };\n\t    }\n\t    if (withoutTransformations) {\n\t      return new Rect(box);\n\t    }\n\t    var matrix = this.getTransformToElement(target || ownerSVGElement);\n\t    return V.transformRect(box, matrix);\n\t  };\n\n\t  // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n\t  // i.e. after transformations are applied.\n\t  // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n\t  // Takes an (Object) `opt` argument (optional) with the following attributes:\n\t  // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n\t  // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n\t  VPrototype.getBBox = function (opt) {\n\t    var options = {};\n\t    var outputBBox;\n\t    var node = this.node;\n\t    var ownerSVGElement = node.ownerSVGElement;\n\n\t    // If the element is not in the live DOM, it does not have a bounding box defined and\n\t    // so fall back to 'zero' dimension element.\n\t    // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n\t    if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n\t      return new Rect(0, 0, 0, 0);\n\t    }\n\t    if (opt) {\n\t      if (opt.target) {\n\t        // check if target exists\n\t        options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n\t      }\n\t      if (opt.recursive) {\n\t        options.recursive = opt.recursive;\n\t      }\n\t    }\n\t    if (!options.recursive) {\n\t      try {\n\t        outputBBox = node.getBBox();\n\t      } catch {\n\t        // Fallback for IE.\n\t        outputBBox = {\n\t          x: node.clientLeft,\n\t          y: node.clientTop,\n\t          width: node.clientWidth,\n\t          height: node.clientHeight\n\t        };\n\t      }\n\t      if (!options.target) {\n\t        // transform like this (that is, not at all)\n\t        return new Rect(outputBBox);\n\t      } else {\n\t        // transform like target\n\t        var matrix = this.getTransformToElement(options.target);\n\t        return V.transformRect(outputBBox, matrix);\n\t      }\n\t    } else {\n\t      // if we want to calculate the bbox recursively\n\t      // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n\t      // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n\t      // this happens even if we wrap a single svg element into a group!\n\t      // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n\t      var children = this.children();\n\t      var n = children.length;\n\t      if (n === 0) {\n\t        return this.getBBox({\n\t          target: options.target,\n\t          recursive: false\n\t        });\n\t      }\n\n\t      // recursion's initial pass-through setting:\n\t      // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n\t      if (!options.target) {\n\t        // transform children/descendants like this (their parent/ancestor)\n\t        options.target = this;\n\t      } // else transform children/descendants like target\n\n\t      for (var i = 0; i < n; i++) {\n\t        var currentChild = children[i];\n\t        var childBBox;\n\n\t        // if currentChild is not a group element, get its bbox with a nonrecursive call\n\t        if (currentChild.children().length === 0) {\n\t          childBBox = currentChild.getBBox({\n\t            target: options.target,\n\t            recursive: false\n\t          });\n\t        } else {\n\t          // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n\t          childBBox = currentChild.getBBox({\n\t            target: options.target,\n\t            recursive: true\n\t          });\n\t        }\n\t        if (!outputBBox) {\n\t          // if this is the first iteration\n\t          outputBBox = childBBox;\n\t        } else {\n\t          // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n\t          outputBBox = outputBBox.union(childBBox);\n\t        }\n\t      }\n\t      return outputBBox;\n\t    }\n\t  };\n\n\t  // Text() helpers\n\n\t  function createTextPathNode(attrs, vel) {\n\t    attrs || (attrs = {});\n\t    var textPathElement = V('textPath');\n\t    var d = attrs.d;\n\t    if (d && attrs['xlink:href'] === undefined) {\n\t      // If `opt.attrs` is a plain string, consider it to be directly the\n\t      // SVG path data for the text to go along (this is a shortcut).\n\t      // Otherwise if it is an object and contains the `d` property, then this is our path.\n\t      // Wrap the text in the SVG <textPath> element that points\n\t      // to a path defined by `opt.attrs` inside the `<defs>` element.\n\t      var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n\t      textPathElement.attr('xlink:href', '#' + linkedPath.id);\n\t    }\n\t    if (V.isObject(attrs)) {\n\t      // Set attributes on the `<textPath>`. The most important one\n\t      // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n\t      // Note that we also allow the following construct:\n\t      // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n\t      // In other words, one can completely skip the auto-creation of the path\n\t      // and use any other arbitrary path that is in the document.\n\t      textPathElement.attr(attrs);\n\t    }\n\t    return textPathElement.node;\n\t  }\n\t  function annotateTextLine(lineNode, lineAnnotations, opt) {\n\t    opt || (opt = {});\n\t    var includeAnnotationIndices = opt.includeAnnotationIndices;\n\t    var eol = opt.eol;\n\t    var lineHeight = opt.lineHeight;\n\t    var baseSize = opt.baseSize;\n\t    var maxFontSize = 0;\n\t    var fontMetrics = {};\n\t    var lastJ = lineAnnotations.length - 1;\n\t    for (var j = 0; j <= lastJ; j++) {\n\t      var annotation = lineAnnotations[j];\n\t      var fontSize = null;\n\t      if (V.isObject(annotation)) {\n\t        var annotationAttrs = annotation.attrs;\n\t        var vTSpan = V('tspan', annotationAttrs);\n\t        var tspanNode = vTSpan.node;\n\t        var t = annotation.t;\n\t        if (eol && j === lastJ) t += eol;\n\t        tspanNode.textContent = t;\n\t        // Per annotation className\n\t        var annotationClass = annotationAttrs['class'];\n\t        if (annotationClass) vTSpan.addClass(annotationClass);\n\t        // If `opt.includeAnnotationIndices` is `true`,\n\t        // set the list of indices of all the applied annotations\n\t        // in the `annotations` attribute. This list is a comma\n\t        // separated list of indices.\n\t        if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n\t        // Check for max font size\n\t        fontSize = parseFloat(annotationAttrs['font-size']);\n\t        if (!isFinite(fontSize)) fontSize = baseSize;\n\t        if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n\t      } else {\n\t        if (eol && j === lastJ) annotation += eol;\n\t        tspanNode = document.createTextNode(annotation || ' ');\n\t        if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n\t      }\n\t      lineNode.appendChild(tspanNode);\n\t    }\n\t    if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n\t    if (lineHeight) {\n\t      fontMetrics.lineHeight = lineHeight;\n\t    } else if (maxFontSize) {\n\t      fontMetrics.lineHeight = maxFontSize * 1.2;\n\t    }\n\t    return fontMetrics;\n\t  }\n\t  var emRegex = /em$/;\n\t  function convertEmToPx(em, fontSize) {\n\t    var numerical = parseFloat(em);\n\t    if (emRegex.test(em)) return numerical * fontSize;\n\t    return numerical;\n\t  }\n\t  function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n\t    if (!Array.isArray(linesMetrics)) return 0;\n\t    var n = linesMetrics.length;\n\t    if (!n) return 0;\n\t    var lineMetrics = linesMetrics[0];\n\t    var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n\t    var rLineHeights = 0;\n\t    var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n\t    for (var i = 1; i < n; i++) {\n\t      lineMetrics = linesMetrics[i];\n\t      var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n\t      rLineHeights += iLineHeight;\n\t    }\n\t    var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n\t    var dy;\n\t    switch (alignment) {\n\t      case 'middle':\n\t        dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n\t        break;\n\t      case 'bottom':\n\t        dy = -(0.25 * llMaxFont) - rLineHeights;\n\t        break;\n\t      case 'top':\n\t      default:\n\t        dy = 0.8 * flMaxFont;\n\t        break;\n\t    }\n\t    return dy;\n\t  }\n\t  VPrototype.text = function (content, opt) {\n\t    if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\t    opt || (opt = {});\n\n\t    // Backwards-compatibility: if no content was provided, treat it as an\n\t    // empty string so that subsequent string operations (e.g. split) do\n\t    // not throw and behaviour matches the previous implementation that\n\t    // always sanitised the input.\n\t    if (content == null) content = '';\n\t    if (opt.useNoBreakSpace) {\n\t      // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n\t      // IE would otherwise collapse all spaces into one.\n\t      content = V.sanitizeText(content);\n\t    }\n\t    // Should we allow the text to be selected?\n\t    var displayEmpty = opt.displayEmpty;\n\t    // End of Line character\n\t    var eol = opt.eol;\n\t    // Text along path\n\t    var textPath = opt.textPath;\n\t    // Vertical shift\n\t    var verticalAnchor = opt.textVerticalAnchor;\n\t    var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top';\n\t    // Horizontal shift applied to all the lines but the first.\n\t    var x = opt.x;\n\t    if (x === undefined) x = this.attr('x') || 0;\n\t    // Annotations\n\t    var iai = opt.includeAnnotationIndices;\n\t    var annotations = opt.annotations;\n\t    if (annotations && !V.isArray(annotations)) annotations = [annotations];\n\t    // Shift all the <tspan> but first by one line (`1em`)\n\t    var defaultLineHeight = opt.lineHeight;\n\t    var autoLineHeight = defaultLineHeight === 'auto';\n\t    var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n\t    // Clearing the element\n\t    this.empty();\n\t    this.attr({\n\t      // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n\t      'xml:space': 'preserve',\n\t      // An empty text gets rendered into the DOM in webkit-based browsers.\n\t      // In order to unify this behaviour across all browsers\n\t      // we rather hide the text element when it's empty.\n\t      'display': content || displayEmpty ? null : 'none'\n\t    });\n\n\t    // Set default font-size if none\n\t    var fontSize = parseFloat(this.attr('font-size'));\n\t    if (!fontSize) {\n\t      fontSize = 16;\n\t      if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n\t    }\n\t    var doc = document;\n\t    var containerNode;\n\t    if (textPath) {\n\t      // Now all the `<tspan>`s will be inside the `<textPath>`.\n\t      if (typeof textPath === 'string') textPath = {\n\t        d: textPath\n\t      };\n\t      containerNode = createTextPathNode(textPath, this);\n\t    } else {\n\t      containerNode = doc.createDocumentFragment();\n\t    }\n\t    var offset = 0;\n\t    var lines = content.split('\\n');\n\t    var linesMetrics = [];\n\t    var annotatedY;\n\t    for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n\t      var dy = lineHeight;\n\t      var lineClassName = 'v-line';\n\t      var lineNode = doc.createElementNS(svg$1, 'tspan');\n\t      var line = lines[i];\n\t      var lineMetrics;\n\t      if (line) {\n\t        if (annotations) {\n\t          // Find the *compacted* annotations for this line.\n\t          var lineAnnotations = V.annotateString(line, annotations, {\n\t            offset: -offset,\n\t            includeAnnotationIndices: iai\n\t          });\n\t          lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n\t            includeAnnotationIndices: iai,\n\t            eol: i !== lastI && eol,\n\t            lineHeight: autoLineHeight ? null : lineHeight,\n\t            baseSize: fontSize\n\t          });\n\t          // Get the line height based on the biggest font size in the annotations for this line.\n\t          var iLineHeight = lineMetrics.lineHeight;\n\t          if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n\t          if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n\t        } else {\n\t          if (eol && i !== lastI) line += eol;\n\t          lineNode.textContent = line;\n\t        }\n\t      } else {\n\t        // Make sure the textContent is never empty. If it is, add a dummy\n\t        // character and make it invisible, making the following lines correctly\n\t        // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n\t        lineNode.textContent = '-';\n\t        lineClassName += ' v-empty-line';\n\t        // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n\t        // is not applied in Firefox\n\t        var lineNodeStyle = lineNode.style;\n\t        lineNodeStyle.fillOpacity = 0;\n\t        lineNodeStyle.strokeOpacity = 0;\n\t        if (annotations) {\n\t          // Empty line with annotations.\n\t          lineMetrics = {};\n\t          lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n\t          let lineFontSize = fontSize;\n\t          // Check if any of the annotations overrides the font size.\n\t          for (let j = lineAnnotations.length; j > 0; j--) {\n\t            const attrs = lineAnnotations[j - 1].attrs;\n\t            if (!attrs || !('font-size' in attrs)) continue;\n\t            const fs = parseFloat(attrs['font-size']);\n\t            if (isFinite(fs)) {\n\t              lineFontSize = fs;\n\t              break;\n\t            }\n\t          }\n\t          if (autoLineHeight) {\n\t            if (i > 0) {\n\t              dy = lineFontSize * 1.2;\n\t            } else {\n\t              annotatedY = lineFontSize * 0.8;\n\t            }\n\t          }\n\t          // The font size is important for the native selection box height.\n\t          lineNode.setAttribute('font-size', lineFontSize);\n\t          lineMetrics.maxFontSize = lineFontSize;\n\t        }\n\t      }\n\t      if (lineMetrics) linesMetrics.push(lineMetrics);\n\t      if (i > 0) lineNode.setAttribute('dy', dy);\n\t      // Firefox requires 'x' to be set on the first line when inside a text path\n\t      if (i > 0 || textPath) lineNode.setAttribute('x', x);\n\t      lineNode.className.baseVal = lineClassName;\n\t      containerNode.appendChild(lineNode);\n\t      offset += line.length + 1; // + 1 = newline character.\n\t    }\n\t    // Y Alignment calculation\n\t    if (namedVerticalAnchor) {\n\t      if (annotations) {\n\t        dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n\t      } else if (verticalAnchor === 'top') {\n\t        // A shortcut for top alignment. It does not depend on font-size nor line-height\n\t        dy = '0.8em';\n\t      } else {\n\t        var rh; // remaining height\n\t        if (lastI > 0) {\n\t          rh = parseFloat(lineHeight) || 1;\n\t          rh *= lastI;\n\t          if (!emRegex.test(lineHeight)) rh /= fontSize;\n\t        } else {\n\t          // Single-line text\n\t          rh = 0;\n\t        }\n\t        switch (verticalAnchor) {\n\t          case 'middle':\n\t            dy = 0.3 - rh / 2 + 'em';\n\t            break;\n\t          case 'bottom':\n\t            dy = -rh - 0.3 + 'em';\n\t            break;\n\t        }\n\t      }\n\t    } else {\n\t      if (verticalAnchor === 0) {\n\t        dy = '0em';\n\t      } else if (verticalAnchor) {\n\t        dy = verticalAnchor;\n\t      } else {\n\t        // No vertical anchor is defined\n\t        dy = 0;\n\t        // Backwards compatibility - we change the `y` attribute instead of `dy`.\n\t        if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n\t      }\n\t    }\n\t    containerNode.firstChild.setAttribute('dy', dy);\n\t    // Appending lines to the element.\n\t    this.append(containerNode);\n\t    return this;\n\t  };\n\n\t  /**\n\t   * @public\n\t   * @param {string} name\n\t   * @returns {Vectorizer}\n\t   */\n\t  VPrototype.removeAttr = function (name) {\n\t    const trueName = attributeNames[name];\n\t    const {\n\t      ns,\n\t      local\n\t    } = V.qualifyAttr(trueName);\n\t    const el = this.node;\n\t    if (ns) {\n\t      if (el.hasAttributeNS(ns, local)) {\n\t        el.removeAttributeNS(ns, local);\n\t      }\n\t    } else if (el.hasAttribute(trueName)) {\n\t      el.removeAttribute(trueName);\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.attr = function (name, value) {\n\t    if (V.isUndefined(name)) {\n\t      // Return all attributes.\n\t      var attributes = this.node.attributes;\n\t      var attrs = {};\n\t      for (var i = 0; i < attributes.length; i++) {\n\t        attrs[attributes[i].name] = attributes[i].value;\n\t      }\n\t      return attrs;\n\t    }\n\t    if (V.isString(name) && V.isUndefined(value)) {\n\t      return this.node.getAttribute(attributeNames[name]);\n\t    }\n\t    if (typeof name === 'object') {\n\t      for (var attrName in name) {\n\t        if (name.hasOwnProperty(attrName)) {\n\t          this.setAttribute(attrName, name[attrName]);\n\t        }\n\t      }\n\t    } else {\n\t      this.setAttribute(name, value);\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.normalizePath = function () {\n\t    var tagName = this.tagName();\n\t    if (tagName === 'PATH') {\n\t      this.attr('d', V.normalizePathData(this.attr('d')));\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.remove = function () {\n\t    if (this.node.parentNode) {\n\t      this.node.parentNode.removeChild(this.node);\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.empty = function () {\n\t    while (this.node.firstChild) {\n\t      this.node.removeChild(this.node.firstChild);\n\t    }\n\t    return this;\n\t  };\n\n\t  /**\n\t   * @private\n\t   * @param {object} attrs\n\t   * @returns {Vectorizer}\n\t   */\n\t  VPrototype.setAttributes = function (attrs) {\n\t    for (var key in attrs) {\n\t      if (attrs.hasOwnProperty(key)) {\n\t        this.setAttribute(key, attrs[key]);\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.append = function (els) {\n\t    if (!V.isArray(els)) {\n\t      els = [els];\n\t    }\n\t    for (var i = 0, len = els.length; i < len; i++) {\n\t      this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.prepend = function (els) {\n\t    var child = this.node.firstChild;\n\t    return child ? V(child).before(els) : this.append(els);\n\t  };\n\t  VPrototype.before = function (els) {\n\t    var node = this.node;\n\t    var parent = node.parentNode;\n\t    if (parent) {\n\t      if (!V.isArray(els)) {\n\t        els = [els];\n\t      }\n\t      for (var i = 0, len = els.length; i < len; i++) {\n\t        parent.insertBefore(V.toNode(els[i]), node);\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.appendTo = function (node) {\n\t    V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n\t    return this;\n\t  };\n\t  VPrototype.svg = function () {\n\t    return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n\t  };\n\t  VPrototype.tagName = function () {\n\t    return this.node.tagName.toUpperCase();\n\t  };\n\t  VPrototype.defs = function () {\n\t    var context = this.svg() || this;\n\t    var defsNode = context.node.getElementsByTagName('defs')[0];\n\t    if (defsNode) return V(defsNode);\n\t    return V('defs').appendTo(context);\n\t  };\n\t  VPrototype.clone = function () {\n\t    var clone = V(this.node.cloneNode(true /* deep */));\n\t    // Note that clone inherits also ID. Therefore, we need to change it here.\n\t    clone.node.id = V.uniqueId();\n\t    return clone;\n\t  };\n\t  VPrototype.findOne = function (selector) {\n\t    var found = this.node.querySelector(selector);\n\t    return found ? V(found) : undefined;\n\t  };\n\t  VPrototype.find = function (selector) {\n\t    var vels = [];\n\t    var nodes = this.node.querySelectorAll(selector);\n\t    if (nodes) {\n\t      // Map DOM elements to `V`s.\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        vels.push(V(nodes[i]));\n\t      }\n\t    }\n\t    return vels;\n\t  };\n\n\t  // Returns an array of V elements made from children of this.node.\n\t  VPrototype.children = function () {\n\t    var children = this.node.childNodes;\n\t    var outputArray = [];\n\t    for (var i = 0; i < children.length; i++) {\n\t      var currentChild = children[i];\n\t      if (currentChild.nodeType === 1) {\n\t        outputArray.push(V(children[i]));\n\t      }\n\t    }\n\t    return outputArray;\n\t  };\n\n\t  // Returns the V element from parentNode of this.node.\n\t  VPrototype.parent = function () {\n\t    return V(this.node.parentNode) || null;\n\t  },\n\t  // Find an index of an element inside its container.\n\t  VPrototype.index = function () {\n\t    var index = 0;\n\t    var node = this.node.previousSibling;\n\t    while (node) {\n\t      // nodeType 1 for ELEMENT_NODE\n\t      if (node.nodeType === 1) index++;\n\t      node = node.previousSibling;\n\t    }\n\t    return index;\n\t  };\n\t  VPrototype.findParentByClass = function (className, terminator) {\n\t    var ownerSVGElement = this.node.ownerSVGElement;\n\t    var node = this.node.parentNode;\n\t    while (node && node !== terminator && node !== ownerSVGElement) {\n\t      var vel = V(node);\n\t      if (vel.hasClass(className)) {\n\t        return vel;\n\t      }\n\t      node = node.parentNode;\n\t    }\n\t    return null;\n\t  };\n\n\t  // https://jsperf.com/get-common-parent\n\t  VPrototype.contains = function (el) {\n\t    var a = this.node;\n\t    var b = V.toNode(el);\n\t    var bup = b && b.parentNode;\n\t    return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);\n\t  };\n\n\t  // Convert global point into the coordinate space of this element.\n\t  VPrototype.toLocalPoint = function (x, y) {\n\t    var svg = this.svg().node;\n\t    var p = svg.createSVGPoint();\n\t    p.x = x;\n\t    p.y = y;\n\t    try {\n\t      var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n\t      var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\t    } catch {\n\t      // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n\t      // We have to make do with the original coordinates.\n\t      return p;\n\t    }\n\t    return globalPoint.matrixTransform(globalToLocalMatrix);\n\t  };\n\t  VPrototype.translateCenterToPoint = function (p) {\n\t    var bbox = this.getBBox({\n\t      target: this.svg()\n\t    });\n\t    var center = bbox.center();\n\t    this.translate(p.x - center.x, p.y - center.y);\n\t    return this;\n\t  };\n\n\t  // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n\t  // of markers. The easiest way of understanding on what this does is to imagine the element is an\n\t  // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n\t  // being auto-oriented (properly rotated) towards the `reference` point.\n\t  // `target` is the element relative to which the transformations are applied. Usually a viewport.\n\t  VPrototype.translateAndAutoOrient = function (position, reference, target) {\n\t    position = new Point(position);\n\t    reference = new Point(reference);\n\t    target || (target = this.svg());\n\n\t    // Clean-up previously set transformations except the scale. If we didn't clean up the\n\t    // previous transformations then they'd add up with the old ones. Scale is an exception as\n\t    // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n\t    // element is scaled by the factor 2, not 8.\n\t    var scale = this.scale();\n\t    this.attr('transform', '');\n\t    var bbox = this.getBBox({\n\t      target: target\n\t    }).scale(scale.sx, scale.sy);\n\n\t    // 1. Translate to origin.\n\t    var translateToOrigin = V.createSVGTransform();\n\t    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n\t    // 2. Rotate around origin.\n\t    var rotateAroundOrigin = V.createSVGTransform();\n\t    var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n\t    if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n\t    // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n\t    var translateFromOrigin = V.createSVGTransform();\n\t    var finalPosition = position.clone().move(reference, bbox.width / 2);\n\t    translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n\t    // 4. Get the current transformation matrix of this node\n\t    var ctm = this.getTransformToElement(target);\n\n\t    // 5. Apply transformations and the scale\n\t    var transform = V.createSVGTransform();\n\t    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));\n\t    this.attr('transform', matrixToTransformString(transform.matrix));\n\t    return this;\n\t  };\n\t  VPrototype.animateAlongPath = function (attrs, path) {\n\t    path = V.toNode(path);\n\t    var id = V.ensureId(path);\n\t    var animateMotion = V('animateMotion', attrs);\n\t    var mpath = V('mpath', {\n\t      'xlink:href': '#' + id\n\t    });\n\t    animateMotion.append(mpath);\n\t    this.append(animateMotion);\n\t    try {\n\t      animateMotion.node.beginElement();\n\t    } catch {\n\t      // Fallback for IE 9.\n\t      // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n\t      if (document.documentElement.getAttribute('smiling') === 'fake') {\n\t        /* global getTargets:true, Animator:true, animators:true id2anim:true */\n\t        // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n\t        var animation = animateMotion.node;\n\t        animation.animators = [];\n\t        var animationID = animation.getAttribute('id');\n\t        if (animationID) id2anim[animationID] = animation;\n\t        var targets = getTargets(animation);\n\t        for (var i = 0, len = targets.length; i < len; i++) {\n\t          var target = targets[i];\n\t          var animator = new Animator(animation, target, i);\n\t          animators.push(animator);\n\t          animation.animators[i] = animator;\n\t          animator.register();\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  };\n\n\t  // Split a string into an array of tokens.\n\t  // https://infra.spec.whatwg.org/#ascii-whitespace\n\t  const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n\t  function getTokenList(str) {\n\t    if (!V.isString(str)) return [];\n\t    return str.trim().match(noHTMLWhitespaceRegex) || [];\n\t  }\n\t  VPrototype.hasClass = function (className) {\n\t    if (!V.isString(className)) return false;\n\t    return this.node.classList.contains(className.trim());\n\t  };\n\t  VPrototype.addClass = function (className) {\n\t    this.node.classList.add(...getTokenList(className));\n\t    return this;\n\t  };\n\t  VPrototype.removeClass = function (className) {\n\t    this.node.classList.remove(...getTokenList(className));\n\t    return this;\n\t  };\n\t  VPrototype.toggleClass = function (className, toAdd) {\n\t    const tokens = getTokenList(className);\n\t    for (let i = 0; i < tokens.length; i++) {\n\t      this.node.classList.toggle(tokens[i], toAdd);\n\t    }\n\t    return this;\n\t  };\n\n\t  // Interpolate path by discrete points. The precision of the sampling\n\t  // is controlled by `interval`. In other words, `sample()` will generate\n\t  // a point on the path starting at the beginning of the path going to the end\n\t  // every `interval` pixels.\n\t  // The sampler can be very useful for e.g. finding intersection between two\n\t  // paths (finding the two closest points from two samples).\n\t  VPrototype.sample = function (interval) {\n\t    interval = interval || 1;\n\t    var node = this.node;\n\t    var length = node.getTotalLength();\n\t    var samples = [];\n\t    var distance = 0;\n\t    var sample;\n\t    while (distance < length) {\n\t      sample = node.getPointAtLength(distance);\n\t      samples.push({\n\t        x: sample.x,\n\t        y: sample.y,\n\t        distance: distance\n\t      });\n\t      distance += interval;\n\t    }\n\t    return samples;\n\t  };\n\t  VPrototype.convertToPath = function () {\n\t    var path = V('path');\n\t    path.attr(this.attr());\n\t    var d = this.convertToPathData();\n\t    if (d) {\n\t      path.attr('d', d);\n\t    }\n\t    return path;\n\t  };\n\t  VPrototype.convertToPathData = function () {\n\t    var tagName = this.tagName();\n\t    switch (tagName) {\n\t      case 'PATH':\n\t        return this.attr('d');\n\t      case 'LINE':\n\t        return V.convertLineToPathData(this.node);\n\t      case 'POLYGON':\n\t        return V.convertPolygonToPathData(this.node);\n\t      case 'POLYLINE':\n\t        return V.convertPolylineToPathData(this.node);\n\t      case 'ELLIPSE':\n\t        return V.convertEllipseToPathData(this.node);\n\t      case 'CIRCLE':\n\t        return V.convertCircleToPathData(this.node);\n\t      case 'RECT':\n\t        return V.convertRectToPathData(this.node);\n\t    }\n\t    throw new Error(tagName + ' cannot be converted to PATH.');\n\t  };\n\t  V.prototype.toGeometryShape = function () {\n\t    var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n\t    switch (this.tagName()) {\n\t      case 'RECT':\n\t        x = parseFloat(this.attr('x')) || 0;\n\t        y = parseFloat(this.attr('y')) || 0;\n\t        width = parseFloat(this.attr('width')) || 0;\n\t        height = parseFloat(this.attr('height')) || 0;\n\t        return new Rect(x, y, width, height);\n\t      case 'CIRCLE':\n\t        cx = parseFloat(this.attr('cx')) || 0;\n\t        cy = parseFloat(this.attr('cy')) || 0;\n\t        r = parseFloat(this.attr('r')) || 0;\n\t        return new Ellipse$1({\n\t          x: cx,\n\t          y: cy\n\t        }, r, r);\n\t      case 'ELLIPSE':\n\t        cx = parseFloat(this.attr('cx')) || 0;\n\t        cy = parseFloat(this.attr('cy')) || 0;\n\t        rx = parseFloat(this.attr('rx')) || 0;\n\t        ry = parseFloat(this.attr('ry')) || 0;\n\t        return new Ellipse$1({\n\t          x: cx,\n\t          y: cy\n\t        }, rx, ry);\n\t      case 'POLYLINE':\n\t        points = V.getPointsFromSvgNode(this);\n\t        return new Polyline$1(points);\n\t      case 'POLYGON':\n\t        points = V.getPointsFromSvgNode(this);\n\t        if (points.length > 1) points.push(points[0]);\n\t        return new Polyline$1(points);\n\t      case 'PATH':\n\t        d = this.attr('d');\n\t        if (!Path$1.isDataSupported(d)) d = V.normalizePathData(d);\n\t        return new Path$1(d);\n\t      case 'LINE':\n\t        x1 = parseFloat(this.attr('x1')) || 0;\n\t        y1 = parseFloat(this.attr('y1')) || 0;\n\t        x2 = parseFloat(this.attr('x2')) || 0;\n\t        y2 = parseFloat(this.attr('y2')) || 0;\n\t        return new Line({\n\t          x: x1,\n\t          y: y1\n\t        }, {\n\t          x: x2,\n\t          y: y2\n\t        });\n\t    }\n\n\t    // Anything else is a rectangle\n\t    return this.getBBox();\n\t  };\n\n\t  // Find the intersection of a line starting in the center\n\t  // of the SVG `node` ending in the point `ref`.\n\t  // `target` is an SVG element to which `node`s transformations are relative to.\n\t  // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n\t  // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n\t  // an intersection is found. Returns `undefined` otherwise.\n\t  VPrototype.findIntersection = function (ref, target) {\n\t    var svg = this.svg().node;\n\t    target = target || svg;\n\t    var bbox = this.getBBox({\n\t      target: target\n\t    });\n\t    var center = bbox.center();\n\t    if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n\t    var spot;\n\t    var tagName = this.tagName();\n\n\t    // Little speed up optimization for `<rect>` element. We do not do conversion\n\t    // to path element and sampling but directly calculate the intersection through\n\t    // a transformed geometrical rectangle.\n\t    if (tagName === 'RECT') {\n\t      var gRect = new Rect(parseFloat(this.attr('x') || 0), parseFloat(this.attr('y') || 0), parseFloat(this.attr('width')), parseFloat(this.attr('height')));\n\t      // Get the rect transformation matrix with regards to the SVG document.\n\t      var rectMatrix = this.getTransformToElement(target);\n\t      // Decompose the matrix to find the rotation angle.\n\t      var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n\t      // Now we want to rotate the rectangle back so that we\n\t      // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n\t      var resetRotation = svg.createSVGTransform();\n\t      resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n\t      var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n\t      spot = new Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\t    } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\t      var pathNode = tagName === 'PATH' ? this : this.convertToPath();\n\t      var samples = pathNode.sample();\n\t      var minDistance = Infinity;\n\t      var closestSamples = [];\n\t      var i, sample, gp, centerDistance, refDistance, distance;\n\t      for (i = 0; i < samples.length; i++) {\n\t        sample = samples[i];\n\t        // Convert the sample point in the local coordinate system to the global coordinate system.\n\t        gp = V.createSVGPoint(sample.x, sample.y);\n\t        gp = gp.matrixTransform(this.getTransformToElement(target));\n\t        sample = new Point(gp);\n\t        centerDistance = sample.distance(center);\n\t        // Penalize a higher distance to the reference point by 10%.\n\t        // This gives better results. This is due to\n\t        // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n\t        refDistance = sample.distance(ref) * 1.1;\n\t        distance = centerDistance + refDistance;\n\t        if (distance < minDistance) {\n\t          minDistance = distance;\n\t          closestSamples = [{\n\t            sample: sample,\n\t            refDistance: refDistance\n\t          }];\n\t        } else if (distance < minDistance + 1) {\n\t          closestSamples.push({\n\t            sample: sample,\n\t            refDistance: refDistance\n\t          });\n\t        }\n\t      }\n\t      closestSamples.sort(function (a, b) {\n\t        return a.refDistance - b.refDistance;\n\t      });\n\t      if (closestSamples[0]) {\n\t        spot = closestSamples[0].sample;\n\t      }\n\t    }\n\t    return spot;\n\t  };\n\n\t  /**\n\t   * @private\n\t   * @param {string} name\n\t   * @param {string} value\n\t   * @returns {Vectorizer}\n\t   */\n\t  VPrototype.setAttribute = function (name, value) {\n\t    const el = this.node;\n\t    if (value === null) {\n\t      this.removeAttr(name);\n\t      return this;\n\t    }\n\t    const trueName = attributeNames[name];\n\t    const {\n\t      ns\n\t    } = V.qualifyAttr(trueName);\n\t    if (ns) {\n\t      // Attribute names can be namespaced. E.g. `image` elements\n\t      // have a `xlink:href` attribute to set the source of the image.\n\t      el.setAttributeNS(ns, trueName, value);\n\t    } else if (trueName === 'id') {\n\t      el.id = value;\n\t    } else {\n\t      el.setAttribute(trueName, value);\n\t    }\n\t    return this;\n\t  };\n\n\t  // Create an SVG document element.\n\t  // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n\t  V.createSvgDocument = function (content) {\n\t    if (content) {\n\t      const XMLString = `<svg xmlns=\"${svg$1}\" xmlns:xlink=\"${xlink}\" version=\"${SVG_VERSION}\">${content}</svg>`;\n\t      const {\n\t        documentElement\n\t      } = V.parseXML(XMLString, {\n\t        async: false\n\t      });\n\t      return documentElement;\n\t    }\n\t    return createSVGDocument();\n\t  };\n\t  V.createSVGStyle = function (stylesheet) {\n\t    const {\n\t      node\n\t    } = V('style', {\n\t      type: 'text/css'\n\t    }, [V.createCDATASection(stylesheet)]);\n\t    return node;\n\t  }, V.createCDATASection = function (data = '') {\n\t    const xml = document.implementation.createDocument(null, 'xml', null);\n\t    return xml.createCDATASection(data);\n\t  };\n\t  V.idCounter = 0;\n\n\t  // A function returning a unique identifier for this client session with every call.\n\t  V.uniqueId = function () {\n\t    return 'v-' + ++V.idCounter;\n\t  };\n\t  V.toNode = function (el) {\n\t    return V.isV(el) ? el.node : el.nodeName && el || el[0];\n\t  };\n\t  V.ensureId = function (node) {\n\t    node = V.toNode(node);\n\t    return node.id || (node.id = V.uniqueId());\n\t  };\n\n\t  // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n\t  // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n\t  // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n\t  // when you want to compare the actual DOM text content without having to add the unicode character in\n\t  // the place of all spaces.\n\t  /**\n\t   * @deprecated Use regular spaces and rely on xml:space=\"preserve\" instead.\n\t   */\n\t  V.sanitizeText = function (text) {\n\t    return (text || '').replace(/ /g, '\\u00A0');\n\t  };\n\t  V.isUndefined = function (value) {\n\t    return typeof value === 'undefined';\n\t  };\n\t  V.isString = function (value) {\n\t    return typeof value === 'string';\n\t  };\n\t  V.isObject = function (value) {\n\t    return value && typeof value === 'object';\n\t  };\n\t  V.isArray = Array.isArray;\n\t  V.parseXML = function (data, opt) {\n\t    opt = opt || {};\n\t    var xml;\n\t    try {\n\t      var parser = new DOMParser();\n\t      if (!V.isUndefined(opt.async)) {\n\t        parser.async = opt.async;\n\t      }\n\t      xml = parser.parseFromString(data, 'text/xml');\n\t    } catch {\n\t      xml = undefined;\n\t    }\n\t    if (!xml || xml.getElementsByTagName('parsererror').length) {\n\t      throw new Error('Invalid XML: ' + data);\n\t    }\n\t    return xml;\n\t  };\n\n\t  // Create an empty object which does not inherit any properties from `Object.prototype`.\n\t  // This is useful when we want to use an object as a dictionary without having to\n\t  // worry about inherited properties such as `toString`, `valueOf` etc.\n\t  const _attributeNames = Object.create(null);\n\n\t  // List of attributes for which not to split camel case words.\n\t  // It contains known SVG attribute names and may be extended with user-defined attribute names.\n\t  ['attributeName', 'baseFrequency', 'baseProfile', 'clipPathUnits', 'contentScriptType', 'contentStyleType', 'diffuseConstant', 'edgeMode', 'externalResourcesRequired', 'filterRes',\n\t  // deprecated\n\t  'filterUnits', 'gradientTransform', 'gradientUnits', 'kernelMatrix', 'kernelUnitLength', 'keyPoints', 'lengthAdjust', 'limitingConeAngle', 'markerHeight', 'markerUnits', 'markerWidth', 'maskContentUnits', 'maskUnits', 'numOctaves', 'pathLength', 'patternContentUnits', 'patternTransform', 'patternUnits', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'refX', 'refY', 'requiredExtensions', 'requiredFeatures', 'repeatCount', 'specularConstant', 'specularExponent', 'spreadMethod', 'startOffset', 'stdDeviation', 'stitchTiles', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textLength', 'viewBox', 'viewTarget',\n\t  // deprecated\n\t  'xChannelSelector', 'yChannelSelector', 'zoomAndPan' // deprecated\n\t  ].forEach(name => _attributeNames[name] = name);\n\t  _attributeNames['xlinkShow'] = 'xlink:show';\n\t  _attributeNames['xlinkRole'] = 'xlink:role';\n\t  _attributeNames['xlinkActuate'] = 'xlink:actuate';\n\t  _attributeNames['xlinkHref'] = 'xlink:href';\n\t  _attributeNames['xlinkType'] = 'xlink:type';\n\t  _attributeNames['xlinkTitle'] = 'xlink:title';\n\t  _attributeNames['xmlBase'] = 'xml:base';\n\t  _attributeNames['xmlLang'] = 'xml:lang';\n\t  _attributeNames['xmlSpace'] = 'xml:space';\n\t  const attributeNames = new Proxy(_attributeNames, {\n\t    get(cache, name) {\n\t      // The cache is a dictionary of attribute names. See `_attributeNames` above.\n\t      // If the attribute name is not in the cache, it means that it is not\n\t      // a camel-case attribute name. In that case, we need to convert\n\t      // the attribute name to dash-separated words.\n\t      if (!V.supportCamelCaseAttributes) return name;\n\t      if (name in cache) {\n\t        return cache[name];\n\t      }\n\t      // Convert camel case to dash-separated words.\n\t      return cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase();\n\t    }\n\t  });\n\n\t  // Dictionary of attribute names\n\t  Object.defineProperty(V, 'attributeNames', {\n\t    enumerable: true,\n\t    value: attributeNames,\n\t    writable: false\n\t  });\n\n\t  // Should camel case attributes be supported?\n\t  Object.defineProperty(V, 'supportCamelCaseAttributes', {\n\t    enumerable: true,\n\t    value: true,\n\t    writable: true\n\t  });\n\n\t  /**\n\t   * @param {string} name\n\t   * @returns {{ns: string|null, local: string}} namespace and attribute name\n\t   */\n\t  V.qualifyAttr = function (name) {\n\t    if (name.indexOf(':') !== -1) {\n\t      var combinedKey = name.split(':');\n\t      return {\n\t        ns: ns[combinedKey[0]],\n\t        local: combinedKey[1]\n\t      };\n\t    }\n\t    return {\n\t      ns: null,\n\t      local: name\n\t    };\n\t  };\n\n\t  // Note: This regex allows multiple commas as separator which is incorrect in SVG\n\t  // This regex is used by `split()`, so it doesn't need to use /g\n\t  V.transformSeparatorRegex = /[ ,]+/;\n\t  // Note: All following regexes are more restrictive than SVG specification\n\t  // ReDoS mitigation: Use an anchor at the beginning of the match\n\t  // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n\t  // ReDoS mitigation: Don't match initial `(` inside repeated part\n\t  // The following regexes need to use capturing groups (= cannot use /g)\n\t  V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n\t  V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n\t  V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n\t  V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n\t  V.transformStringToMatrix = function (transform) {\n\t    let matrix;\n\t    if (V.isString(transform)) {\n\t      matrix = createMatrixFromTransformString(transform);\n\t    }\n\t    return matrix || createIdentityMatrix();\n\t  };\n\t  V.matrixToTransformString = matrixToTransformString;\n\t  V.parseTransformString = function (transform) {\n\t    var translate, rotate, scale;\n\t    if (transform) {\n\t      var separator = V.transformSeparatorRegex;\n\n\t      // Special handling for `transform` with one or more matrix functions\n\t      if (transform.trim().indexOf('matrix') >= 0) {\n\t        // Convert EVERYTHING in `transform` string to a matrix\n\t        // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n\t        // Note: In non-matrix case, we only take first one of each (if any)\n\t        var matrix = V.transformStringToMatrix(transform);\n\t        var decomposedMatrix = V.decomposeMatrix(matrix);\n\n\t        // Extract `translate`, `scale`, `rotate` from matrix\n\t        translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n\t        scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n\t        rotate = [decomposedMatrix.rotation];\n\n\t        // Rewrite `transform` string in `translate scale rotate` format\n\t        var transformations = [];\n\t        if (translate[0] !== 0 || translate[1] !== 0) {\n\t          transformations.push('translate(' + translate + ')');\n\t        }\n\t        if (scale[0] !== 1 || scale[1] !== 1) {\n\t          transformations.push('scale(' + scale + ')');\n\t        }\n\t        if (rotate[0] !== 0) {\n\t          transformations.push('rotate(' + rotate + ')');\n\t        }\n\t        transform = transformations.join(' ');\n\t      } else {\n\t        // Extract `translate`, `rotate`, `scale` functions from `transform` string\n\t        // Note: We only detect the first match of each (if any)\n\t        // `match()` returns value of capturing group as `[1]`\n\t        const translateMatch = transform.match(V.transformTranslateRegex);\n\t        if (translateMatch) {\n\t          translate = translateMatch[1].split(separator);\n\t        }\n\t        const rotateMatch = transform.match(V.transformRotateRegex);\n\t        if (rotateMatch) {\n\t          rotate = rotateMatch[1].split(separator);\n\t        }\n\t        const scaleMatch = transform.match(V.transformScaleRegex);\n\t        if (scaleMatch) {\n\t          scale = scaleMatch[1].split(separator);\n\t        }\n\t      }\n\t    }\n\t    var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n\t    return {\n\t      value: transform,\n\t      translate: {\n\t        tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,\n\t        ty: translate && translate[1] ? parseInt(translate[1], 10) : 0\n\t      },\n\t      rotate: {\n\t        angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,\n\t        cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,\n\t        cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined\n\t      },\n\t      scale: {\n\t        sx: sx,\n\t        sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n\t      }\n\t    };\n\t  };\n\t  V.deltaTransformPoint = function (matrix, point) {\n\t    var dx = point.x * matrix.a + point.y * matrix.c + 0;\n\t    var dy = point.x * matrix.b + point.y * matrix.d + 0;\n\t    return {\n\t      x: dx,\n\t      y: dy\n\t    };\n\t  };\n\t  V.decomposeMatrix = function (matrix) {\n\t    // @see https://gist.github.com/2052247\n\n\t    // calculate delta transform point\n\t    var px = V.deltaTransformPoint(matrix, {\n\t      x: 0,\n\t      y: 1\n\t    });\n\t    var py = V.deltaTransformPoint(matrix, {\n\t      x: 1,\n\t      y: 0\n\t    });\n\n\t    // calculate skew\n\t    var skewX = 180 / PI * atan2(px.y, px.x) - 90;\n\t    var skewY = 180 / PI * atan2(py.y, py.x);\n\t    return {\n\t      translateX: matrix.e,\n\t      translateY: matrix.f,\n\t      scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n\t      scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n\t      skewX: skewX,\n\t      skewY: skewY,\n\t      rotation: skewX // rotation is the same as skew x\n\t    };\n\t  };\n\n\t  // Return the `scale` transformation from the following equation:\n\t  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t  V.matrixToScale = function (matrix) {\n\t    var a, b, c, d;\n\t    if (matrix) {\n\t      a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n\t      d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n\t      b = matrix.b;\n\t      c = matrix.c;\n\t    } else {\n\t      a = d = 1;\n\t    }\n\t    return {\n\t      sx: b ? sqrt(a * a + b * b) : a,\n\t      sy: c ? sqrt(c * c + d * d) : d\n\t    };\n\t  };\n\n\t  // Return the `rotate` transformation from the following equation:\n\t  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t  V.matrixToRotate = function (matrix) {\n\t    var p = {\n\t      x: 0,\n\t      y: 1\n\t    };\n\t    if (matrix) {\n\t      p = V.deltaTransformPoint(matrix, p);\n\t    }\n\t    return {\n\t      angle: normalizeAngle(toDeg(atan2(p.y, p.x)) - 90)\n\t    };\n\t  };\n\n\t  // Return the `translate` transformation from the following equation:\n\t  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t  V.matrixToTranslate = function (matrix) {\n\t    return {\n\t      tx: matrix && matrix.e || 0,\n\t      ty: matrix && matrix.f || 0\n\t    };\n\t  };\n\t  V.isV = function (object) {\n\t    return object instanceof V;\n\t  };\n\n\t  // For backwards compatibility:\n\t  V.isVElement = V.isV;\n\n\t  // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n\t  // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n\t  V.isSVGGraphicsElement = function (node) {\n\t    if (!node) return false;\n\t    node = V.toNode(node);\n\t    // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n\t    return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n\t  };\n\t  V.createSVGMatrix = createMatrix;\n\t  V.createSVGTransform = function (matrix) {\n\t    if (!V.isUndefined(matrix)) {\n\t      if (!isSVGMatrix(matrix)) {\n\t        matrix = createMatrix(matrix);\n\t      }\n\t      return internalSVGDocument.createSVGTransformFromMatrix(matrix);\n\t    }\n\t    return internalSVGDocument.createSVGTransform();\n\t  };\n\t  V.createSVGPoint = function (x, y) {\n\t    var p = internalSVGDocument.createSVGPoint();\n\t    p.x = x;\n\t    p.y = y;\n\t    return p;\n\t  };\n\t  V.transformRect = function (r, matrix) {\n\t    var p = internalSVGDocument.createSVGPoint();\n\t    p.x = r.x;\n\t    p.y = r.y;\n\t    var corner1 = p.matrixTransform(matrix);\n\t    p.x = r.x + r.width;\n\t    p.y = r.y;\n\t    var corner2 = p.matrixTransform(matrix);\n\t    p.x = r.x + r.width;\n\t    p.y = r.y + r.height;\n\t    var corner3 = p.matrixTransform(matrix);\n\t    p.x = r.x;\n\t    p.y = r.y + r.height;\n\t    var corner4 = p.matrixTransform(matrix);\n\t    var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n\t    var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n\t    var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n\t    var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\t    return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t  };\n\t  V.transformPoint = function (p, matrix) {\n\t    return new Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n\t  };\n\t  V.transformLine = function (l, matrix) {\n\t    return new Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));\n\t  };\n\t  V.transformPolyline = function (p, matrix) {\n\t    var inPoints = p instanceof Polyline$1 ? p.points : p;\n\t    if (!V.isArray(inPoints)) inPoints = [];\n\t    var outPoints = [];\n\t    for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n\t    return new Polyline$1(outPoints);\n\t  };\n\n\t  // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n\t  // an object (`{ fill: 'blue', stroke: 'red' }`).\n\t  V.styleToObject = function (styleString) {\n\t    var ret = {};\n\t    var styles = styleString.split(';');\n\t    for (var i = 0; i < styles.length; i++) {\n\t      var style = styles[i];\n\t      var pair = style.split('=');\n\t      ret[pair[0].trim()] = pair[1].trim();\n\t    }\n\t    return ret;\n\t  };\n\n\t  // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n\t  V.createSlicePathData = function (innerRadius, outerRadius, startAngle, endAngle) {\n\t    var svgArcMax = 2 * PI - 1e-6;\n\t    var r0 = innerRadius;\n\t    var r1 = outerRadius;\n\t    var a0 = startAngle;\n\t    var a1 = endAngle;\n\t    var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n\t    var df = da < PI ? '0' : '1';\n\t    var c0 = cos(a0);\n\t    var s0 = sin(a0);\n\t    var c1 = cos(a1);\n\t    var s1 = sin(a1);\n\t    return da >= svgArcMax ? r0 ? 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'M0,' + r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + -r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0 + 'Z' : 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'Z' : r0 ? 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L' + r0 * c1 + ',' + r0 * s1 + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0 + 'Z' : 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L0,0' + 'Z';\n\t  };\n\n\t  // Merge attributes from object `b` with attributes in object `a`.\n\t  // Note that this modifies the object `a`.\n\t  // Also important to note that attributes are merged but CSS classes are concatenated.\n\t  V.mergeAttrs = function (a, b) {\n\t    for (var attr in b) {\n\t      if (attr === 'class') {\n\t        // Concatenate classes.\n\t        a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n\t      } else if (attr === 'style') {\n\t        // `style` attribute can be an object.\n\t        if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n\t          // `style` stored in `a` is an object.\n\t          a[attr] = V.mergeAttrs(a[attr], b[attr]);\n\t        } else if (V.isObject(a[attr])) {\n\t          // `style` in `a` is an object but it's a string in `b`.\n\t          // Convert the style represented as a string to an object in `b`.\n\t          a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n\t        } else if (V.isObject(b[attr])) {\n\t          // `style` in `a` is a string, in `b` it's an object.\n\t          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n\t        } else {\n\t          // Both styles are strings.\n\t          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n\t        }\n\t      } else {\n\t        a[attr] = b[attr];\n\t      }\n\t    }\n\t    return a;\n\t  };\n\t  V.annotateString = function (t, annotations, opt) {\n\t    annotations = annotations || [];\n\t    opt = opt || {};\n\t    var offset = opt.offset || 0;\n\t    var compacted = [];\n\t    var batch;\n\t    var ret = [];\n\t    var item;\n\t    var prev;\n\t    for (var i = 0; i < t.length; i++) {\n\t      item = ret[i] = t[i];\n\t      for (var j = 0; j < annotations.length; j++) {\n\t        var annotation = annotations[j];\n\t        var start = annotation.start + offset;\n\t        var end = annotation.end + offset;\n\t        if (i >= start && i < end) {\n\t          // Annotation applies.\n\t          if (V.isObject(item)) {\n\t            // There is more than one annotation to be applied => Merge attributes.\n\t            item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n\t          } else {\n\t            item = ret[i] = {\n\t              t: t[i],\n\t              attrs: annotation.attrs\n\t            };\n\t          }\n\t          if (opt.includeAnnotationIndices) {\n\t            (item.annotations || (item.annotations = [])).push(j);\n\t          }\n\t        }\n\t      }\n\t      prev = ret[i - 1];\n\t      if (!prev) {\n\t        batch = item;\n\t      } else if (V.isObject(item) && V.isObject(prev)) {\n\t        // Both previous item and the current one are annotations. If the attributes\n\t        // didn't change, merge the text.\n\t        if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n\t          batch.t += item.t;\n\t        } else {\n\t          compacted.push(batch);\n\t          batch = item;\n\t        }\n\t      } else if (V.isObject(item)) {\n\t        // Previous item was a string, current item is an annotation.\n\t        compacted.push(batch);\n\t        batch = item;\n\t      } else if (V.isObject(prev)) {\n\t        // Previous item was an annotation, current item is a string.\n\t        compacted.push(batch);\n\t        batch = item;\n\t      } else {\n\t        // Both previous and current item are strings.\n\t        batch = (batch || '') + item;\n\t      }\n\t    }\n\t    if (batch) {\n\t      compacted.push(batch);\n\t    }\n\t    return compacted;\n\t  };\n\t  V.findAnnotationsAtIndex = function (annotations, index) {\n\t    var found = [];\n\t    if (annotations) {\n\t      annotations.forEach(function (annotation) {\n\t        if (annotation.start < index && index <= annotation.end) {\n\t          found.push(annotation);\n\t        }\n\t      });\n\t    }\n\t    return found;\n\t  };\n\t  V.findAnnotationsBetweenIndexes = function (annotations, start, end) {\n\t    var found = [];\n\t    if (annotations) {\n\t      annotations.forEach(function (annotation) {\n\t        if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) {\n\t          found.push(annotation);\n\t        }\n\t      });\n\t    }\n\t    return found;\n\t  };\n\n\t  // Shift all the text annotations after character `index` by `offset` positions.\n\t  V.shiftAnnotations = function (annotations, index, offset) {\n\t    if (annotations) {\n\t      annotations.forEach(function (annotation) {\n\t        if (annotation.start < index && annotation.end >= index) {\n\t          annotation.end += offset;\n\t        } else if (annotation.start >= index) {\n\t          annotation.start += offset;\n\t          annotation.end += offset;\n\t        }\n\t      });\n\t    }\n\t    return annotations;\n\t  };\n\t  V.convertLineToPathData = function (line) {\n\t    line = V(line);\n\t    var d = ['M', line.attr('x1') || '0', line.attr('y1') || '0', 'L', line.attr('x2') || '0', line.attr('y2') || '0'].join(' ');\n\t    return d;\n\t  };\n\t  V.convertPolygonToPathData = function (polygon) {\n\t    var points = V.getPointsFromSvgNode(polygon);\n\t    if (points.length === 0) return null;\n\t    return V.svgPointsToPath(points) + ' Z';\n\t  };\n\t  V.convertPolylineToPathData = function (polyline) {\n\t    var points = V.getPointsFromSvgNode(polyline);\n\t    if (points.length === 0) return null;\n\t    return V.svgPointsToPath(points);\n\t  };\n\t  V.svgPointsToPath = function (points) {\n\t    for (var i = 0, n = points.length; i < n; i++) {\n\t      points[i] = points[i].x + ' ' + points[i].y;\n\t    }\n\t    return 'M ' + points.join(' L');\n\t  };\n\t  V.getPointsFromSvgNode = function (node) {\n\t    node = V.toNode(node);\n\t    var points = [];\n\t    var nodePoints = node.points;\n\t    if (nodePoints) {\n\t      for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n\t        points.push(nodePoints.getItem(i));\n\t      }\n\t    }\n\t    return points;\n\t  };\n\t  V.KAPPA = 0.551784;\n\t  V.convertCircleToPathData = function (circle) {\n\t    circle = V(circle);\n\t    var cx = parseFloat(circle.attr('cx')) || 0;\n\t    var cy = parseFloat(circle.attr('cy')) || 0;\n\t    var r = parseFloat(circle.attr('r'));\n\t    var cd = r * V.KAPPA; // Control distance.\n\n\t    var d = ['M', cx, cy - r,\n\t    // Move to the first point.\n\t    'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy,\n\t    // I. Quadrant.\n\t    'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r,\n\t    // II. Quadrant.\n\t    'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy,\n\t    // III. Quadrant.\n\t    'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r,\n\t    // IV. Quadrant.\n\t    'Z'].join(' ');\n\t    return d;\n\t  };\n\t  V.convertEllipseToPathData = function (ellipse) {\n\t    ellipse = V(ellipse);\n\t    var cx = parseFloat(ellipse.attr('cx')) || 0;\n\t    var cy = parseFloat(ellipse.attr('cy')) || 0;\n\t    var rx = parseFloat(ellipse.attr('rx'));\n\t    var ry = parseFloat(ellipse.attr('ry')) || rx;\n\t    var cdx = rx * V.KAPPA; // Control distance x.\n\t    var cdy = ry * V.KAPPA; // Control distance y.\n\n\t    var d = ['M', cx, cy - ry,\n\t    // Move to the first point.\n\t    'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy,\n\t    // I. Quadrant.\n\t    'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry,\n\t    // II. Quadrant.\n\t    'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy,\n\t    // III. Quadrant.\n\t    'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry,\n\t    // IV. Quadrant.\n\t    'Z'].join(' ');\n\t    return d;\n\t  };\n\t  V.convertRectToPathData = function (rect) {\n\t    rect = V(rect);\n\t    return V.rectToPath({\n\t      x: parseFloat(rect.attr('x')) || 0,\n\t      y: parseFloat(rect.attr('y')) || 0,\n\t      width: parseFloat(rect.attr('width')) || 0,\n\t      height: parseFloat(rect.attr('height')) || 0,\n\t      rx: parseFloat(rect.attr('rx')) || 0,\n\t      ry: parseFloat(rect.attr('ry')) || 0\n\t    });\n\t  };\n\n\t  // Convert a rectangle to SVG path commands. `r` is an object of the form:\n\t  // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n\t  // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n\t  // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n\t  // that has only `rx` and `ry` attributes).\n\t  V.rectToPath = function (r) {\n\t    var d;\n\t    var x = r.x;\n\t    var y = r.y;\n\t    var width = r.width;\n\t    var height = r.height;\n\t    var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n\t    var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n\t    var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n\t    var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\t    if (topRx || bottomRx || topRy || bottomRy) {\n\t      d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];\n\t    } else {\n\t      d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];\n\t    }\n\t    return d.join(' ');\n\t  };\n\n\t  // Take a path data string\n\t  // Return a normalized path data string\n\t  // If data cannot be parsed, return 'M 0 0'\n\t  // Highly inspired by Raphael Library (www.raphael.com)\n\t  V.normalizePathData = function () {\n\t    var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n\t    var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n\t    var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\t    var math = Math;\n\t    var PI = math.PI;\n\t    var sin = math.sin;\n\t    var cos = math.cos;\n\t    var tan = math.tan;\n\t    var asin = math.asin;\n\t    var sqrt = math.sqrt;\n\t    var abs = math.abs;\n\t    function q2c(x1, y1, ax, ay, x2, y2) {\n\t      var _13 = 1 / 3;\n\t      var _23 = 2 / 3;\n\t      return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n\t    }\n\t    function rotate(x, y, rad) {\n\t      var X = x * cos(rad) - y * sin(rad);\n\t      var Y = x * sin(rad) + y * cos(rad);\n\t      return {\n\t        x: X,\n\t        y: Y\n\t      };\n\t    }\n\t    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t      // for more information of where this math came from visit:\n\t      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t      var _120 = PI * 120 / 180;\n\t      var rad = PI / 180 * (+angle || 0);\n\t      var res = [];\n\t      var xy;\n\t      if (!recursive) {\n\t        xy = rotate(x1, y1, -rad);\n\t        x1 = xy.x;\n\t        y1 = xy.y;\n\t        xy = rotate(x2, y2, -rad);\n\t        x2 = xy.x;\n\t        y2 = xy.y;\n\t        var x = (x1 - x2) / 2;\n\t        var y = (y1 - y2) / 2;\n\t        var h = x * x / (rx * rx) + y * y / (ry * ry);\n\t        if (h > 1) {\n\t          h = sqrt(h);\n\t          rx = h * rx;\n\t          ry = h * ry;\n\t        }\n\t        var rx2 = rx * rx;\n\t        var ry2 = ry * ry;\n\t        var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n\t        if (!Number.isFinite(k)) {\n\t          // Arc is a single point\n\t          return [x1, y1, x2, y2, x2, y2];\n\t        }\n\t        var cx = k * rx * y / ry + (x1 + x2) / 2;\n\t        var cy = k * -ry * x / rx + (y1 + y2) / 2;\n\t        var f1 = asin(((y1 - cy) / ry).toFixed(9));\n\t        var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\t        f1 = x1 < cx ? PI - f1 : f1;\n\t        f2 = x2 < cx ? PI - f2 : f2;\n\t        if (f1 < 0) f1 = PI * 2 + f1;\n\t        if (f2 < 0) f2 = PI * 2 + f2;\n\t        if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;\n\t        if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;\n\t      } else {\n\t        f1 = recursive[0];\n\t        f2 = recursive[1];\n\t        cx = recursive[2];\n\t        cy = recursive[3];\n\t      }\n\t      var df = f2 - f1;\n\t      if (abs(df) > _120) {\n\t        var f2old = f2;\n\t        var x2old = x2;\n\t        var y2old = y2;\n\t        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n\t        x2 = cx + rx * cos(f2);\n\t        y2 = cy + ry * sin(f2);\n\t        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t      }\n\t      df = f2 - f1;\n\t      var c1 = cos(f1);\n\t      var s1 = sin(f1);\n\t      var c2 = cos(f2);\n\t      var s2 = sin(f2);\n\t      var t = tan(df / 4);\n\t      var hx = 4 / 3 * (rx * t);\n\t      var hy = 4 / 3 * (ry * t);\n\t      var m1 = [x1, y1];\n\t      var m2 = [x1 + hx * s1, y1 - hy * c1];\n\t      var m3 = [x2 + hx * s2, y2 - hy * c2];\n\t      var m4 = [x2, y2];\n\t      m2[0] = 2 * m1[0] - m2[0];\n\t      m2[1] = 2 * m1[1] - m2[1];\n\t      if (recursive) {\n\t        return [m2, m3, m4].concat(res);\n\t      } else {\n\t        res = [m2, m3, m4].concat(res).join().split(',');\n\t        var newres = [];\n\t        var ii = res.length;\n\t        for (var i = 0; i < ii; i++) {\n\t          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t        }\n\t        return newres;\n\t      }\n\t    }\n\t    function parsePathString(pathString) {\n\t      if (!pathString) return null;\n\t      var paramCounts = {\n\t        a: 7,\n\t        c: 6,\n\t        h: 1,\n\t        l: 2,\n\t        m: 2,\n\t        q: 4,\n\t        s: 4,\n\t        t: 2,\n\t        v: 1,\n\t        z: 0\n\t      };\n\t      var data = [];\n\t      String(pathString).replace(pathCommand, function (a, b, c) {\n\t        var params = [];\n\t        var name = b.toLowerCase();\n\t        c.replace(pathValues, function (a, b) {\n\t          if (b) params.push(+b);\n\t        });\n\t        if (name === 'm' && params.length > 2) {\n\t          data.push([b].concat(params.splice(0, 2)));\n\t          name = 'l';\n\t          b = b === 'm' ? 'l' : 'L';\n\t        }\n\t        while (params.length >= paramCounts[name]) {\n\t          data.push([b].concat(params.splice(0, paramCounts[name])));\n\t          if (!paramCounts[name]) break;\n\t        }\n\t      });\n\t      return data;\n\t    }\n\t    function pathToAbsolute(pathArray) {\n\t      if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) {\n\t        // rough assumption\n\t        pathArray = parsePathString(pathArray);\n\t      }\n\n\t      // if invalid string, return 'M 0 0'\n\t      if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n\t      var res = [];\n\t      var x = 0;\n\t      var y = 0;\n\t      var mx = 0;\n\t      var my = 0;\n\t      var start = 0;\n\t      var pa0;\n\t      var ii = pathArray.length;\n\t      for (var i = start; i < ii; i++) {\n\t        var r = [];\n\t        res.push(r);\n\t        var pa = pathArray[i];\n\t        pa0 = pa[0];\n\t        if (pa0 != pa0.toUpperCase()) {\n\t          r[0] = pa0.toUpperCase();\n\t          var jj;\n\t          var j;\n\t          switch (r[0]) {\n\t            case 'A':\n\t              r[1] = pa[1];\n\t              r[2] = pa[2];\n\t              r[3] = pa[3];\n\t              r[4] = pa[4];\n\t              r[5] = pa[5];\n\t              r[6] = +pa[6] + x;\n\t              r[7] = +pa[7] + y;\n\t              break;\n\t            case 'V':\n\t              r[1] = +pa[1] + y;\n\t              break;\n\t            case 'H':\n\t              r[1] = +pa[1] + x;\n\t              break;\n\t            case 'M':\n\t              mx = +pa[1] + x;\n\t              my = +pa[2] + y;\n\t              jj = pa.length;\n\t              for (j = 1; j < jj; j++) {\n\t                r[j] = +pa[j] + (j % 2 ? x : y);\n\t              }\n\t              break;\n\t            default:\n\t              jj = pa.length;\n\t              for (j = 1; j < jj; j++) {\n\t                r[j] = +pa[j] + (j % 2 ? x : y);\n\t              }\n\t              break;\n\t          }\n\t        } else {\n\t          var kk = pa.length;\n\t          for (var k = 0; k < kk; k++) {\n\t            r[k] = pa[k];\n\t          }\n\t        }\n\t        switch (r[0]) {\n\t          case 'Z':\n\t            x = +mx;\n\t            y = +my;\n\t            break;\n\t          case 'H':\n\t            x = r[1];\n\t            break;\n\t          case 'V':\n\t            y = r[1];\n\t            break;\n\t          case 'M':\n\t            mx = r[r.length - 2];\n\t            my = r[r.length - 1];\n\t            x = r[r.length - 2];\n\t            y = r[r.length - 1];\n\t            break;\n\t          default:\n\t            x = r[r.length - 2];\n\t            y = r[r.length - 1];\n\t            break;\n\t        }\n\t      }\n\t      return res;\n\t    }\n\t    function normalize(path) {\n\t      var p = pathToAbsolute(path);\n\t      var attrs = {\n\t        x: 0,\n\t        y: 0,\n\t        bx: 0,\n\t        by: 0,\n\t        X: 0,\n\t        Y: 0,\n\t        qx: null,\n\t        qy: null\n\t      };\n\t      function processPath(path, d, pcom) {\n\t        var nx, ny;\n\t        if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\t        if (!(path[0] in {\n\t          T: 1,\n\t          Q: 1\n\t        })) {\n\t          d.qx = null;\n\t          d.qy = null;\n\t        }\n\t        switch (path[0]) {\n\t          case 'M':\n\t            d.X = path[1];\n\t            d.Y = path[2];\n\t            break;\n\t          case 'A':\n\t            if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n\t              // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n\t              // \"If either rx or ry is 0, then this arc is treated as a\n\t              // straight line segment (a \"lineto\") joining the endpoints.\"\n\t              path = ['L', path[6], path[7]];\n\t            } else {\n\t              path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n\t            }\n\t            break;\n\t          case 'S':\n\t            if (pcom === 'C' || pcom === 'S') {\n\t              // In 'S' case we have to take into account, if the previous command is C/S.\n\t              nx = d.x * 2 - d.bx; // And reflect the previous\n\t              ny = d.y * 2 - d.by; // command's control point relative to the current point.\n\t            } else {\n\t              // or some else or nothing\n\t              nx = d.x;\n\t              ny = d.y;\n\t            }\n\t            path = ['C', nx, ny].concat(path.slice(1));\n\t            break;\n\t          case 'T':\n\t            if (pcom === 'Q' || pcom === 'T') {\n\t              // In 'T' case we have to take into account, if the previous command is Q/T.\n\t              d.qx = d.x * 2 - d.qx; // And make a reflection similar\n\t              d.qy = d.y * 2 - d.qy; // to case 'S'.\n\t            } else {\n\t              // or something else or nothing\n\t              d.qx = d.x;\n\t              d.qy = d.y;\n\t            }\n\t            path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t            break;\n\t          case 'Q':\n\t            d.qx = path[1];\n\t            d.qy = path[2];\n\t            path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t            break;\n\t          case 'H':\n\t            path = ['L'].concat(path[1], d.y);\n\t            break;\n\t          case 'V':\n\t            path = ['L'].concat(d.x, path[1]);\n\t            break;\n\t          case 'L':\n\t            break;\n\t          case 'Z':\n\t            break;\n\t        }\n\t        return path;\n\t      }\n\t      function fixArc(pp, i) {\n\t        if (pp[i].length > 7) {\n\t          pp[i].shift();\n\t          var pi = pp[i];\n\t          while (pi.length) {\n\t            pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n\t            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n\t          }\n\t          pp.splice(i, 1);\n\t          ii = p.length;\n\t        }\n\t      }\n\t      var pcoms = []; // path commands of original path p\n\t      var pfirst = ''; // temporary holder for original path command\n\t      var pcom = ''; // holder for previous path command of original path\n\n\t      var ii = p.length;\n\t      for (var i = 0; i < ii; i++) {\n\t        if (p[i]) pfirst = p[i][0]; // save current path command\n\n\t        if (pfirst !== 'C') {\n\t          // C is not saved yet, because it may be result of conversion\n\t          pcoms[i] = pfirst; // Save current path command\n\t          if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n\t        }\n\t        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n\t        if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n\t        // which may produce multiple 'C's\n\t        // so we have to make sure that 'C' is also 'C' in original path\n\n\t        fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n\t        var seg = p[i];\n\t        var seglen = seg.length;\n\t        attrs.x = seg[seglen - 2];\n\t        attrs.y = seg[seglen - 1];\n\t        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n\t        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n\t      }\n\n\t      // make sure normalized path data string starts with an M segment\n\t      if (!p[0][0] || p[0][0] !== 'M') {\n\t        p.unshift(['M', 0, 0]);\n\t      }\n\t      return p;\n\t    }\n\t    return function (pathData) {\n\t      return normalize(pathData).join(',').split(',').join(' ');\n\t    };\n\t  }();\n\n\t  /**\n\t   *\n\t   * @param {SVGElement|V} node1\n\t   * @param {SVGElement|V} node2\n\t   * @returns {SVGElement|null}\n\t   */\n\t  V.getCommonAncestor = function (node1, node2) {\n\t    if (!node1 || !node2) return null;\n\t    return getCommonAncestor(V.toNode(node1), V.toNode(node2));\n\t  };\n\t  V.namespace = {\n\t    ...ns\n\t  };\n\t  V.g = g;\n\t  return V;\n\t}();\n\n\t// Manipulation\n\n\tfunction cleanNodesData(nodes) {\n\t  let i = nodes.length;\n\t  while (i--) cleanNodeData(nodes[i]);\n\t}\n\tfunction cleanNodeData(node) {\n\t  $.event.remove(node);\n\t  dataPriv.remove(node);\n\t  dataUser.remove(node);\n\t}\n\tfunction removeNodes(nodes) {\n\t  for (let i = 0; i < nodes.length; i++) {\n\t    const node = nodes[i];\n\t    if (node.parentNode) {\n\t      node.parentNode.removeChild(node);\n\t    }\n\t  }\n\t}\n\tfunction remove() {\n\t  for (let i = 0; i < this.length; i++) {\n\t    const node = this[i];\n\t    cleanNodeData(node);\n\t    cleanNodesData(node.getElementsByTagName('*'));\n\t  }\n\t  removeNodes(this);\n\t  return this;\n\t}\n\tfunction detach() {\n\t  removeNodes(this);\n\t  return this;\n\t}\n\tfunction empty() {\n\t  for (let i = 0; i < this.length; i++) {\n\t    const node = this[i];\n\t    if (node.nodeType === 1) {\n\t      cleanNodesData(node.getElementsByTagName('*'));\n\t      // Remove any remaining nodes\n\t      node.textContent = '';\n\t    }\n\t  }\n\t  return this;\n\t}\n\tfunction clone() {\n\t  const clones = [];\n\t  for (let i = 0; i < this.length; i++) {\n\t    clones.push(this[i].cloneNode(true));\n\t  }\n\t  return this.pushStack(clones);\n\t}\n\tfunction html(html) {\n\t  const [el] = this;\n\t  if (!el) return null;\n\t  if (arguments.length === 0) return el.innerHTML;\n\t  if (html === undefined) return this; // do nothing\n\t  cleanNodesData(el.getElementsByTagName('*'));\n\t  if (typeof html === 'string' || typeof html === 'number') {\n\t    el.innerHTML = html;\n\t  } else {\n\t    el.innerHTML = '';\n\t    return this.append(html);\n\t  }\n\t  return this;\n\t}\n\tfunction append(...nodes) {\n\t  const [parent] = this;\n\t  if (!parent) return this;\n\t  nodes.forEach(node => {\n\t    if (!node) return;\n\t    if (typeof node === 'string') {\n\t      parent.append(...$.parseHTML(node));\n\t    } else if (node.toString() === '[object Object]') {\n\t      // $ object\n\t      this.append(...Array.from(node));\n\t    } else if (Array.isArray(node)) {\n\t      this.append(...node);\n\t    } else {\n\t      // DOM node\n\t      parent.appendChild(node);\n\t    }\n\t  });\n\t  return this;\n\t}\n\tfunction prepend(...nodes) {\n\t  const [parent] = this;\n\t  if (!parent) return this;\n\t  nodes.forEach(node => {\n\t    if (!node) return;\n\t    if (typeof node === 'string') {\n\t      parent.prepend(...$.parseHTML(node));\n\t    } else if (node.toString() === '[object Object]') {\n\t      // $ object\n\t      this.prepend(...Array.from(node));\n\t    } else if (Array.isArray(node)) {\n\t      this.prepend(...node);\n\t    } else {\n\t      // DOM node\n\t      parent.insertBefore(node, parent.firstChild);\n\t    }\n\t  });\n\t  return this;\n\t}\n\tfunction appendTo(parent) {\n\t  $(parent).append(this);\n\t  return this;\n\t}\n\tfunction prependTo(parent) {\n\t  $(parent).prepend(this);\n\t  return this;\n\t}\n\n\t// Styles and attributes\n\n\tconst requireUnits = {};\n\t['width', 'height', 'top', 'bottom', 'left', 'right', 'padding', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight', 'margin', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight'].forEach(cssProp => {\n\t  requireUnits[cssProp] = true;\n\t});\n\tfunction setCSSProperty(el, name, value) {\n\t  if (typeof value === 'number' && requireUnits[camelCase(name)]) {\n\t    value += 'px';\n\t  }\n\t  el.style[name] = value;\n\t}\n\tfunction css(name, value) {\n\t  let styles;\n\t  if (typeof name === 'string') {\n\t    if (value === undefined) {\n\t      const [el] = this;\n\t      if (!el) return null;\n\t      return el.style[name];\n\t    } else {\n\t      styles = {\n\t        [name]: value\n\t      };\n\t    }\n\t  } else if (!name) {\n\t    throw new Error('no styles provided');\n\t  } else {\n\t    styles = name;\n\t  }\n\t  for (const style in styles) {\n\t    if (styles.hasOwnProperty(style)) {\n\t      for (let i = 0; i < this.length; i++) {\n\t        setCSSProperty(this[i], style, styles[style]);\n\t      }\n\t    }\n\t  }\n\t  return this;\n\t}\n\tfunction data(name, value) {\n\t  if (arguments.length < 2) {\n\t    const [el] = this;\n\t    if (!el) return null;\n\t    if (name === undefined) {\n\t      return el.dataset;\n\t    }\n\t    return el.dataset[name];\n\t  }\n\t  for (let i = 0; i < this.length; i++) {\n\t    this[i].dataset[name] = value;\n\t  }\n\t  return this;\n\t}\n\n\t// Classes\n\n\tfunction setNodesClass(method, nodes, args) {\n\t  for (let i = 0; i < nodes.length; i++) {\n\t    const node = nodes[i];\n\t    V.prototype[method].apply({\n\t      node\n\t    }, args);\n\t  }\n\t}\n\tfunction removeClass() {\n\t  setNodesClass('removeClass', this, arguments);\n\t  return this;\n\t}\n\tfunction addClass$1() {\n\t  setNodesClass('addClass', this, arguments);\n\t  return this;\n\t}\n\tfunction toggleClass() {\n\t  setNodesClass('toggleClass', this, arguments);\n\t  return this;\n\t}\n\tfunction hasClass() {\n\t  const [node] = this;\n\t  if (!node) return false;\n\t  return V.prototype.hasClass.apply({\n\t    node\n\t  }, arguments);\n\t}\n\n\t// Traversing\n\n\tfunction children(selector) {\n\t  const matches = [];\n\t  for (let i = 0; i < this.length; i++) {\n\t    const node = this[i];\n\t    let children = Array.from(node.children);\n\t    if (typeof selector === 'string') {\n\t      children = children.filter(child => child.matches(selector));\n\t    }\n\t    matches.push(...children);\n\t  }\n\t  return this.pushStack(matches);\n\t}\n\tfunction closest(selector) {\n\t  const closest = [];\n\t  for (let i = 0; i < this.length; i++) {\n\t    const el = this[i];\n\t    if (typeof selector === 'string') {\n\t      const closestEl = el.closest(selector);\n\t      if (closestEl) {\n\t        closest.push(closestEl);\n\t      }\n\t    } else {\n\t      const [ancestorEl] = $(selector);\n\t      if (ancestorEl && ancestorEl.contains(el)) {\n\t        closest.push(ancestorEl);\n\t      }\n\t    }\n\t  }\n\t  return this.pushStack(closest);\n\t}\n\n\t// Events\n\n\tfunction on(types, selector, data, fn) {\n\t  $.event.on(this, types, selector, data, fn);\n\t  return this;\n\t}\n\tfunction one(types, selector, data, fn) {\n\t  $.event.on(this, types, selector, data, fn, 1);\n\t  return this;\n\t}\n\tfunction off(types, selector, fn) {\n\t  if (types && types.preventDefault && types.handleObj) {\n\t    // ( event )  dispatched $.Event\n\t    const handleObj = types.handleObj;\n\t    $(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n\t    return this;\n\t  }\n\t  if (typeof types === 'object') {\n\t    // ( types-object [, selector] )\n\t    for (const type in types) {\n\t      this.off(type, selector, types[type]);\n\t    }\n\t    return this;\n\t  }\n\t  if (selector === false || typeof selector === 'function') {\n\t    // ( types [, fn] )\n\t    fn = selector;\n\t    selector = undefined;\n\t  }\n\t  for (let i = 0; i < this.length; i++) {\n\t    $.event.remove(this[i], types, fn, selector);\n\t  }\n\t  return this;\n\t}\n\n\t// Measurements\n\n\tfunction width() {\n\t  const [el] = this;\n\t  if (el === window) return el.document.documentElement.clientWidth;else if (!el) return undefined;\n\t  const styles = window.getComputedStyle(el);\n\t  const height = el.offsetWidth;\n\t  const borderTopWidth = parseFloat(styles.borderTopWidth);\n\t  const borderBottomWidth = parseFloat(styles.borderBottomWidth);\n\t  const paddingTop = parseFloat(styles.paddingTop);\n\t  const paddingBottom = parseFloat(styles.paddingBottom);\n\t  return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;\n\t}\n\tfunction height() {\n\t  const [el] = this;\n\t  if (el === window) return el.document.documentElement.clientHeight;\n\t  if (!el) return undefined;\n\t  const styles = window.getComputedStyle(el);\n\t  const width = el.offsetHeight;\n\t  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\t  const borderRightWidth = parseFloat(styles.borderRightWidth);\n\t  const paddingLeft = parseFloat(styles.paddingLeft);\n\t  const paddingRight = parseFloat(styles.paddingRight);\n\t  return width - borderLeftWidth - borderRightWidth - paddingLeft - paddingRight;\n\t}\n\tfunction position() {\n\t  const [el] = this;\n\t  if (!el) return;\n\t  const $el = $(el);\n\t  let offsetParent;\n\t  let offset;\n\t  let doc;\n\t  let parentOffset = {\n\t    top: 0,\n\t    left: 0\n\t  };\n\t  // position:fixed elements are offset from the viewport, which itself always has zero offset\n\t  if ($el.css('position') === 'fixed') {\n\t    // Assume position:fixed implies availability of getBoundingClientRect\n\t    offset = el.getBoundingClientRect();\n\t  } else {\n\t    offset = $el.offset();\n\t    // Account for the *real* offset parent, which can be the document or its root element\n\t    // when a statically positioned element is identified\n\t    doc = el.ownerDocument;\n\t    offsetParent = el.offsetParent || doc.documentElement;\n\t    const isStaticallyPositioned = el => {\n\t      const {\n\t        position\n\t      } = getComputedStyle(el);\n\t      return position === 'static';\n\t    };\n\t    while (offsetParent && offsetParent !== doc.documentElement && isStaticallyPositioned(offsetParent)) {\n\t      offsetParent = offsetParent.offsetParent || doc.documentElement;\n\t    }\n\t    if (offsetParent && offsetParent !== el && offsetParent.nodeType === 1 && !isStaticallyPositioned(offsetParent)) {\n\t      // Incorporate borders into its offset, since they are outside its content origin\n\t      const offsetParentStyles = window.getComputedStyle(offsetParent);\n\t      const borderTopWidth = parseFloat(offsetParentStyles.borderTopWidth) || 0;\n\t      const borderLeftWidth = parseFloat(offsetParentStyles.borderLeftWidth) || 0;\n\t      parentOffset = $(offsetParent).offset();\n\t      parentOffset.top += borderTopWidth;\n\t      parentOffset.left += borderLeftWidth;\n\t    }\n\t  }\n\t  const marginTop = parseFloat(window.getComputedStyle(el).marginTop) || 0;\n\t  const marginLeft = parseFloat(window.getComputedStyle(el).marginLeft) || 0;\n\t  // Subtract parent offsets and element margins\n\t  return {\n\t    top: offset.top - parentOffset.top - marginTop,\n\t    left: offset.left - parentOffset.left - marginLeft\n\t  };\n\t}\n\tfunction offset(coordinates) {\n\t  const [el] = this;\n\t  //  Getter\n\t  if (coordinates === undefined) {\n\t    if (!el) return null;\n\t    if (!el.getClientRects().length) {\n\t      return {\n\t        top: 0,\n\t        left: 0\n\t      };\n\t    }\n\t    const rect = el.getBoundingClientRect();\n\t    return {\n\t      top: rect.top + window.scrollY,\n\t      left: rect.left + window.scrollX\n\t    };\n\t  }\n\t  // Setter\n\t  if (!el) return this;\n\t  const currentStyle = window.getComputedStyle(el);\n\t  if (currentStyle.position === 'static') {\n\t    this.css('position', 'relative');\n\t  }\n\t  const currentOffset = this.offset();\n\t  const topDifference = coordinates.top - currentOffset.top;\n\t  const leftDifference = coordinates.left - currentOffset.left;\n\t  this.css({\n\t    top: (parseFloat(currentStyle.top) || 0) + topDifference + 'px',\n\t    left: (parseFloat(currentStyle.left) || 0) + leftDifference + 'px'\n\t  });\n\t  return this;\n\t}\n\n\tvar methods$1 = {\n\t\t__proto__: null,\n\t\taddClass: addClass$1,\n\t\tappend: append,\n\t\tappendTo: appendTo,\n\t\tchildren: children,\n\t\tclone: clone,\n\t\tclosest: closest,\n\t\tcss: css,\n\t\tdata: data,\n\t\tdetach: detach,\n\t\tempty: empty,\n\t\thasClass: hasClass,\n\t\theight: height,\n\t\thtml: html,\n\t\toff: off,\n\t\toffset: offset,\n\t\ton: on,\n\t\tone: one,\n\t\tposition: position,\n\t\tprepend: prepend,\n\t\tprependTo: prependTo,\n\t\tremove: remove,\n\t\tremoveClass: removeClass,\n\t\ttoggleClass: toggleClass,\n\t\twidth: width\n\t};\n\n\tconst animationKey = 'animationFrameId';\n\tconst cssReset = {};\n\tcssReset['transition-property'] = cssReset['transition-duration'] = cssReset['transition-delay'] = cssReset['transition-timing-function'] = cssReset['animation-name'] = cssReset['animation-duration'] = cssReset['animation-delay'] = cssReset['animation-timing-function'] = '';\n\tfunction animate(properties, opt = {}) {\n\t  this.stop();\n\t  for (let i = 0; i < this.length; i++) {\n\t    animateNode(this[i], properties, opt);\n\t  }\n\t  return this;\n\t}\n\tfunction animateNode(el, properties, opt = {}) {\n\t  let {\n\t    duration = 400,\n\t    delay = 0\n\t  } = opt;\n\t  const {\n\t    easing = 'ease-in-out',\n\t    complete\n\t  } = opt;\n\t  const delayId = setTimeout(function () {\n\t    const $el = $(el);\n\t    let fired = false;\n\t    let endEvent = 'transitionend';\n\n\t    // Convert milliseconds to seconds for CSS\n\t    duration = duration / 1000;\n\t    delay = delay / 1000;\n\n\t    // Set up CSS values for transition or keyframe animation\n\t    const cssValues = {};\n\t    if (typeof properties === 'string') {\n\t      // Keyframe animation\n\t      cssValues['animation-name'] = properties;\n\t      cssValues['animation-duration'] = duration + 's';\n\t      cssValues['animation-delay'] = delay + 's';\n\t      cssValues['animation-timing-function'] = easing;\n\t      endEvent = 'animationend';\n\t    } else {\n\t      // CSS transitions\n\t      const transitionProperties = [];\n\t      for (var key in properties) {\n\t        if (properties.hasOwnProperty(key)) {\n\t          cssValues[key] = properties[key];\n\t          transitionProperties.push(key);\n\t        }\n\t      }\n\t      if (duration > 0) {\n\t        cssValues['transition-property'] = transitionProperties.join(', ');\n\t        cssValues['transition-duration'] = duration + 's';\n\t        cssValues['transition-delay'] = delay + 's';\n\t        cssValues['transition-timing-function'] = easing;\n\t      }\n\t    }\n\t    const wrappedCallback = function (event) {\n\t      if (event) {\n\t        if (event.target !== event.currentTarget) return; // makes sure the event didn't bubble from \"below\"\n\t        event.target.removeEventListener(endEvent, wrappedCallback);\n\t      } else {\n\t        el.removeEventListener(endEvent, wrappedCallback); // triggered by setTimeout\n\t      }\n\t      fired = true;\n\t      $el.css(cssReset);\n\t      complete && complete.call(el);\n\t    };\n\t    if (duration > 0) {\n\t      el.addEventListener(endEvent, wrappedCallback);\n\t      // transitionEnd is not always firing on older Android phones\n\t      // so make sure it gets fired\n\t      const callbackId = setTimeout(function () {\n\t        if (fired) return;\n\t        wrappedCallback(null);\n\t      }, (duration + delay) * 1000 + 25);\n\t      dataPriv.set(el, animationKey, {\n\t        id: callbackId,\n\t        stop: () => {\n\t          clearTimeout(callbackId);\n\t          el.removeEventListener(endEvent, wrappedCallback);\n\t        }\n\t      });\n\t    }\n\t    $el.css(cssValues);\n\t    if (duration <= 0) {\n\t      wrappedCallback(null);\n\t    }\n\t  });\n\t  dataPriv.set(el, animationKey, {\n\t    stop: () => clearTimeout(delayId)\n\t  });\n\t}\n\tfunction stop() {\n\t  for (let i = 0; i < this.length; i++) {\n\t    const el = this[i];\n\t    const animation = dataPriv.get(el, animationKey);\n\t    if (!animation) continue;\n\t    animation.stop();\n\t    dataPriv.remove(el, animationKey);\n\t  }\n\t  this.css(cssReset);\n\t  return this;\n\t}\n\n\tvar animations = {\n\t\t__proto__: null,\n\t\tanimate: animate,\n\t\tstop: stop\n\t};\n\n\tconst propertySetters = {\n\t  outerWidth: 'offsetWidth',\n\t  outerHeight: 'offsetHeight',\n\t  innerWidth: 'clientWidth',\n\t  innerHeight: 'clientHeight',\n\t  scrollLeft: 'scrollLeft',\n\t  scrollTop: 'scrollTop',\n\t  val: 'value',\n\t  text: 'textContent'\n\t};\n\tconst propertiesMap = {\n\t  disabled: 'disabled',\n\t  value: 'value',\n\t  text: 'textContent'\n\t};\n\tfunction prop(name, value) {\n\t  if (!name) throw new Error('no property provided');\n\t  if (arguments.length === 1) {\n\t    const [el] = this;\n\t    if (!el) return null;\n\t    return el[name];\n\t  }\n\t  if (value === undefined) return this;\n\t  for (let i = 0; i < this.length; i++) {\n\t    this[i][name] = value;\n\t  }\n\t  return this;\n\t}\n\tfunction attr(name, value) {\n\t  let attributes;\n\t  if (typeof name === 'string') {\n\t    if (value === undefined) {\n\t      const [el] = this;\n\t      if (!el) return null;\n\t      return el.getAttribute(name);\n\t    } else {\n\t      attributes = {\n\t        [name]: value\n\t      };\n\t    }\n\t  } else if (!name) {\n\t    throw new Error('no attributes provided');\n\t  } else {\n\t    attributes = name;\n\t  }\n\t  for (const attr in attributes) {\n\t    if (attributes.hasOwnProperty(attr)) {\n\t      const value = attributes[attr];\n\t      if (propertiesMap[attr]) {\n\t        this.prop(propertiesMap[attr], value);\n\t        continue;\n\t      }\n\t      for (let i = 0; i < this.length; i++) {\n\t        if (value === null) {\n\t          this[i].removeAttribute(attr);\n\t        } else {\n\t          this[i].setAttribute(attr, value);\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return this;\n\t}\n\tconst methods = {\n\t  prop,\n\t  attr\n\t};\n\tObject.keys(propertySetters).forEach(methodName => {\n\t  methods[methodName] = function (...args) {\n\t    return this.prop(propertySetters[methodName], ...args);\n\t  };\n\t});\n\n\tconst config$3 = {\n\t  // How the cell attributes are merged when `cell.prop()` is called.\n\t  // DEFAULT: the arrays are merged into the source array.\n\t  cellMergeStrategy: null,\n\t  // How the cell default attributes are merged with the attributes provided\n\t  // in the cell constructor.\n\t  // DEFAULT: the arrays are merged by replacing the source array\n\t  // with the destination array.\n\t  cellDefaultsMergeStrategy: null,\n\t  // When set to `true` the cell selectors could be defined as CSS selectors.\n\t  // If not, only JSON Markup selectors are taken into account.\n\t  useCSSSelectors: false,\n\t  // The class name prefix config is for advanced use only.\n\t  // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n\t  classNamePrefix: 'joint-',\n\t  defaultTheme: 'default',\n\t  // The maximum delay required for two consecutive touchend events to be interpreted\n\t  // as a double-tap.\n\t  doubleTapInterval: 300,\n\t  // Name of the attribute used to store the layer id on the cell model.\n\t  layerAttribute: 'layer'\n\t};\n\n\t// TODO: should not read config outside the mvc package\n\n\t// Special events\n\n\tconst special = Object.create(null);\n\tspecial.load = {\n\t  // Prevent triggered image.load events from bubbling to window.load\n\t  noBubble: true\n\t};\n\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// so that event delegation works in $.\n\t// Do the same for pointerenter/pointerleave and pointerover/pointerout\n\t[['mouseenter', 'mouseover'], ['mouseleave', 'mouseout'], ['pointerenter', 'pointerover'], ['pointerleave', 'pointerout']].forEach(([orig, fix]) => {\n\t  special[orig] = {\n\t    delegateType: fix,\n\t    bindType: fix,\n\t    handle: function (event) {\n\t      const target = this;\n\t      const related = event.relatedTarget;\n\t      const handleObj = event.handleObj;\n\t      let ret;\n\t      // For mouseenter/leave call the handler if related is outside the target.\n\t      // NB: No relatedTarget if the mouse left/entered the browser window\n\t      if (!related || !target.contains(related)) {\n\t        event.type = handleObj.origType;\n\t        ret = handleObj.handler.apply(target, arguments);\n\t        event.type = fix;\n\t      }\n\t      return ret;\n\t    }\n\t  };\n\t});\n\n\t// Gestures\n\n\tconst maxDelay = config$3.doubleTapInterval;\n\tconst minDelay = 30;\n\tspecial.dbltap = {\n\t  bindType: 'touchend',\n\t  delegateType: 'touchend',\n\t  handle: function (event, ...args) {\n\t    const {\n\t      handleObj,\n\t      target\n\t    } = event;\n\t    const targetData = $.data.create(target);\n\t    const now = new Date().getTime();\n\t    const delta = 'lastTouch' in targetData ? now - targetData.lastTouch : 0;\n\t    if (delta < maxDelay && delta > minDelay) {\n\t      targetData.lastTouch = null;\n\t      event.type = handleObj.origType;\n\t      // let $ handle the triggering of \"dbltap\" event handlers\n\t      handleObj.handler.call(this, event, ...args);\n\t    } else {\n\t      targetData.lastTouch = now;\n\t    }\n\t  }\n\t};\n\n\tObject.assign($.fn, methods$1);\n\tObject.assign($.fn, animations);\n\tObject.assign($.fn, methods);\n\tObject.assign($.event.special, special);\n\n\tconst addClassNamePrefix = function (className) {\n\t  if (!className) return className;\n\t  return className.toString().split(' ').map(function (_className) {\n\t    if (_className.substr(0, config$3.classNamePrefix.length) !== config$3.classNamePrefix) {\n\t      _className = config$3.classNamePrefix + _className;\n\t    }\n\t    return _className;\n\t  }).join(' ');\n\t};\n\tconst removeClassNamePrefix = function (className) {\n\t  if (!className) return className;\n\t  return className.toString().split(' ').map(function (_className) {\n\t    if (_className.substr(0, config$3.classNamePrefix.length) === config$3.classNamePrefix) {\n\t      _className = _className.substr(config$3.classNamePrefix.length);\n\t    }\n\t    return _className;\n\t  }).join(' ');\n\t};\n\tconst parseDOMJSON = function (json, namespace) {\n\t  const selectors = {};\n\t  const groupSelectors = {};\n\t  const svgNamespace = V.namespace.svg;\n\t  const initialNS = namespace || svgNamespace;\n\t  const fragment = document.createDocumentFragment();\n\t  const parseNode = function (siblingsDef, parentNode, parentNS) {\n\t    for (let i = 0; i < siblingsDef.length; i++) {\n\t      const nodeDef = siblingsDef[i];\n\n\t      // Text node\n\t      if (typeof nodeDef === 'string') {\n\t        const textNode = document.createTextNode(nodeDef);\n\t        parentNode.appendChild(textNode);\n\t        continue;\n\t      }\n\n\t      // TagName\n\t      if (!nodeDef.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName');\n\t      const tagName = nodeDef.tagName;\n\n\t      // Namespace URI\n\t      const ns = nodeDef.hasOwnProperty('namespaceURI') ? nodeDef.namespaceURI : parentNS;\n\t      const node = document.createElementNS(ns, tagName);\n\t      const svg = ns === svgNamespace;\n\t      const wrapperNode = svg ? V(node) : $(node);\n\t      // Attributes\n\t      const attributes = nodeDef.attributes;\n\t      if (attributes) wrapperNode.attr(attributes);\n\t      // Style\n\t      const style = nodeDef.style;\n\t      if (style) $(node).css(style);\n\t      // ClassName\n\t      if (nodeDef.hasOwnProperty('className')) {\n\t        const className = nodeDef.className;\n\t        if (svg) {\n\t          node.className.baseVal = className;\n\t        } else {\n\t          node.className = className;\n\t        }\n\t      }\n\t      // TextContent\n\t      if (nodeDef.hasOwnProperty('textContent')) {\n\t        node.textContent = nodeDef.textContent;\n\t      }\n\t      // Selector\n\t      if (nodeDef.hasOwnProperty('selector')) {\n\t        const nodeSelector = nodeDef.selector;\n\t        if (selectors[nodeSelector]) throw new Error('json-dom-parser: selector must be unique');\n\t        selectors[nodeSelector] = node;\n\t        wrapperNode.attr('joint-selector', nodeSelector);\n\t      }\n\t      // Groups\n\t      if (nodeDef.hasOwnProperty('groupSelector')) {\n\t        let nodeGroups = nodeDef.groupSelector;\n\t        if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];\n\t        for (let j = 0; j < nodeGroups.length; j++) {\n\t          const nodeGroup = nodeGroups[j];\n\t          let group = groupSelectors[nodeGroup];\n\t          if (!group) group = groupSelectors[nodeGroup] = [];\n\t          group.push(node);\n\t        }\n\t      }\n\t      parentNode.appendChild(node);\n\n\t      // Children\n\t      const childrenDef = nodeDef.children;\n\t      if (Array.isArray(childrenDef)) {\n\t        parseNode(childrenDef, node, ns);\n\t      }\n\t    }\n\t  };\n\t  parseNode(json, fragment, initialNS);\n\t  return {\n\t    fragment: fragment,\n\t    selectors: selectors,\n\t    groupSelectors: groupSelectors\n\t  };\n\t};\n\n\t// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\n\tconst hashCode = function (str) {\n\t  let hash = 0;\n\t  if (str.length === 0) return hash;\n\t  for (let i = 0; i < str.length; i++) {\n\t    const c = str.charCodeAt(i);\n\t    hash = (hash << 5) - hash + c;\n\t    hash = hash & hash; // Convert to 32bit integer\n\t  }\n\t  return hash;\n\t};\n\tconst getByPath = function (obj, path, delimiter) {\n\t  var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t  var key;\n\t  var i = 0;\n\t  var length = keys.length;\n\t  while (i < length) {\n\t    key = keys[i++];\n\t    if (Object(obj) === obj && key in obj) {\n\t      obj = obj[key];\n\t    } else {\n\t      return undefined;\n\t    }\n\t  }\n\t  return obj;\n\t};\n\tconst isGetSafe = function (obj, key) {\n\t  // Prevent prototype pollution\n\t  // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n\t  if (typeof key !== 'string' && typeof key !== 'number') {\n\t    key = String(key);\n\t  }\n\t  if (key === 'constructor' && typeof obj[key] === 'function') {\n\t    return false;\n\t  }\n\t  if (key === '__proto__') {\n\t    return false;\n\t  }\n\t  return true;\n\t};\n\tconst setByPath = function (obj, path, value, delimiter) {\n\t  const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t  const last = keys.length - 1;\n\t  let diver = obj;\n\t  let i = 0;\n\t  for (; i < last; i++) {\n\t    const key = keys[i];\n\t    if (!isGetSafe(diver, key)) return obj;\n\t    const value = diver[key];\n\t    // diver creates an empty object if there is no nested object under such a key.\n\t    // This means that one can populate an empty nested object with setByPath().\n\t    diver = value || (diver[key] = {});\n\t  }\n\t  diver[keys[last]] = value;\n\t  return obj;\n\t};\n\tconst unsetByPath = function (obj, path, delimiter) {\n\t  const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t  const last = keys.length - 1;\n\t  let diver = obj;\n\t  let i = 0;\n\t  for (; i < last; i++) {\n\t    const key = keys[i];\n\t    if (!isGetSafe(diver, key)) return obj;\n\t    const value = diver[key];\n\t    if (!value) return obj;\n\t    diver = value;\n\t  }\n\t  delete diver[keys[last]];\n\t  return obj;\n\t};\n\tconst flattenObject = function (obj, delim, stop) {\n\t  delim = delim || '/';\n\t  var ret = {};\n\t  for (var key in obj) {\n\t    if (!obj.hasOwnProperty(key)) continue;\n\t    var shouldGoDeeper = typeof obj[key] === 'object';\n\t    if (shouldGoDeeper && stop && stop(obj[key])) {\n\t      shouldGoDeeper = false;\n\t    }\n\t    if (shouldGoDeeper) {\n\t      var flatObject = flattenObject(obj[key], delim, stop);\n\t      for (var flatKey in flatObject) {\n\t        if (!flatObject.hasOwnProperty(flatKey)) continue;\n\t        ret[key + delim + flatKey] = flatObject[flatKey];\n\t      }\n\t    } else {\n\t      ret[key] = obj[key];\n\t    }\n\t  }\n\t  return ret;\n\t};\n\tconst uuid = function () {\n\t  // credit: http://stackoverflow.com/posts/2117523/revisions\n\n\t  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0;\n\t    var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t};\n\n\t// Generates global unique id and stores it as a property of the object, if provided.\n\tconst guid = function (obj) {\n\t  guid.id = guid.id || 1;\n\t  if (obj === undefined) {\n\t    return 'j_' + guid.id++;\n\t  }\n\t  obj.id = obj.id === undefined ? 'j_' + guid.id++ : obj.id;\n\t  return obj.id;\n\t};\n\tconst toKebabCase = function (string) {\n\t  return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n\t};\n\tconst normalizeEvent = function (evt) {\n\t  if (evt.normalized) return evt;\n\t  const {\n\t    originalEvent,\n\t    target\n\t  } = evt;\n\n\t  // If the event is a touch event, normalize it to a mouse event.\n\t  const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n\t  if (touch) {\n\t    for (const property in touch) {\n\t      // copy all the properties from the first touch that are not\n\t      // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)\n\t      if (evt[property] === undefined) {\n\t        evt[property] = touch[property];\n\t      }\n\t    }\n\t  }\n\t  // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n\t  if (target) {\n\t    const useElement = target.correspondingUseElement;\n\t    if (useElement) evt.target = useElement;\n\t  }\n\t  evt.normalized = true;\n\t  return evt;\n\t};\n\tconst normalizeWheel = function (evt) {\n\t  // Sane values derived empirically\n\t  const PIXEL_STEP = 10;\n\t  const LINE_HEIGHT = 40;\n\t  const PAGE_HEIGHT = 800;\n\t  let sX = 0,\n\t    sY = 0,\n\t    pX = 0,\n\t    pY = 0;\n\n\t  // Legacy\n\t  if ('detail' in evt) {\n\t    sY = evt.detail;\n\t  }\n\t  if ('wheelDelta' in evt) {\n\t    sY = -evt.wheelDelta / 120;\n\t  }\n\t  if ('wheelDeltaY' in evt) {\n\t    sY = -evt.wheelDeltaY / 120;\n\t  }\n\t  if ('wheelDeltaX' in evt) {\n\t    sX = -evt.wheelDeltaX / 120;\n\t  }\n\n\t  // side scrolling on FF with DOMMouseScroll\n\t  if ('axis' in evt && evt.axis === evt.HORIZONTAL_AXIS) {\n\t    sX = sY;\n\t    sY = 0;\n\t  }\n\t  pX = 'deltaX' in evt ? evt.deltaX : sX * PIXEL_STEP;\n\t  pY = 'deltaY' in evt ? evt.deltaY : sY * PIXEL_STEP;\n\t  if ((pX || pY) && evt.deltaMode) {\n\t    if (evt.deltaMode == 1) {\n\t      pX *= LINE_HEIGHT;\n\t      pY *= LINE_HEIGHT;\n\t    } else {\n\t      pX *= PAGE_HEIGHT;\n\t      pY *= PAGE_HEIGHT;\n\t    }\n\t  }\n\n\t  // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases\n\t  if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {\n\t    pX = pY;\n\t    pY = 0;\n\t    sX = sY;\n\t    sY = 0;\n\t  }\n\n\t  // Fall-back if spin cannot be determined\n\t  if (pX && !sX) {\n\t    sX = pX < 1 ? -1 : 1;\n\t  }\n\t  if (pY && !sY) {\n\t    sY = pY < 1 ? -1 : 1;\n\t  }\n\t  return {\n\t    spinX: sX,\n\t    spinY: sY,\n\t    deltaX: pX,\n\t    deltaY: pY\n\t  };\n\t};\n\tconst cap = function (val, max) {\n\t  return val > max ? max : val < -max ? -max : val;\n\t};\n\tconst nextFrame = function () {\n\t  var raf;\n\t  if (typeof window !== 'undefined') {\n\t    raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t  }\n\t  if (!raf) {\n\t    var lastTime = 0;\n\t    raf = function (callback) {\n\t      var currTime = new Date().getTime();\n\t      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t      var id = setTimeout(function () {\n\t        callback(currTime + timeToCall);\n\t      }, timeToCall);\n\t      lastTime = currTime + timeToCall;\n\t      return id;\n\t    };\n\t  }\n\t  return function (callback, context, ...rest) {\n\t    return context !== undefined ? raf(callback.bind(context, ...rest)) : raf(callback);\n\t  };\n\t}();\n\tconst cancelFrame = function () {\n\t  var caf;\n\t  var client = typeof window != 'undefined';\n\t  if (client) {\n\t    caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame;\n\t  }\n\t  caf = caf || clearTimeout;\n\t  return client ? caf.bind(window) : caf;\n\t}();\n\tconst isPercentage = function (val) {\n\t  return isString(val) && val.slice(-1) === '%';\n\t};\n\tconst parseCssNumeric = function (val, restrictUnits) {\n\t  function getUnit(validUnitExp) {\n\t    // one or more numbers, followed by\n\t    // any number of (\n\t    //  `.`, followed by\n\t    //  one or more numbers\n\t    // ), followed by\n\t    // `validUnitExp`, followed by\n\t    // end of string\n\t    var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\t    if (!matches) return null;\n\t    return matches[1];\n\t  }\n\t  var number = parseFloat(val);\n\n\t  // if `val` cannot be parsed as a number, return `null`\n\t  if (Number.isNaN(number)) return null;\n\n\t  // else: we know `output.value`\n\t  var output = {};\n\t  output.value = number;\n\n\t  // determine the unit\n\t  var validUnitExp;\n\t  if (restrictUnits == null) {\n\t    // no restriction\n\t    // accept any unit, as well as no unit\n\t    validUnitExp = '[A-Za-z]*';\n\t  } else if (Array.isArray(restrictUnits)) {\n\t    // if this is an empty array, top restriction - return `null`\n\t    if (restrictUnits.length === 0) return null;\n\n\t    // else: restriction - an array of valid unit strings\n\t    validUnitExp = restrictUnits.join('|');\n\t  } else if (isString(restrictUnits)) {\n\t    // restriction - a single valid unit string\n\t    validUnitExp = restrictUnits;\n\t  }\n\t  var unit = getUnit(validUnitExp);\n\n\t  // if we found no matches for `restrictUnits`, return `null`\n\t  if (unit === null) return null;\n\n\t  // else: we know the unit\n\t  output.unit = unit;\n\t  return output;\n\t};\n\tconst NO_SPACE = 0;\n\tfunction splitWordWithEOL(word, eol) {\n\t  const eolWords = word.split(eol);\n\t  let n = 1;\n\t  for (let j = 0, jl = eolWords.length - 1; j < jl; j++) {\n\t    const replacement = [];\n\t    if (j > 0 || eolWords[0] !== '') replacement.push(NO_SPACE);\n\t    replacement.push(eol);\n\t    if (j < jl - 1 || eolWords[jl] !== '') replacement.push(NO_SPACE);\n\t    eolWords.splice(n, 0, ...replacement);\n\t    n += replacement.length + 1;\n\t  }\n\t  return eolWords.filter(word => word !== '');\n\t}\n\tfunction getLineHeight(heightValue, textElement) {\n\t  if (heightValue === null) {\n\t    // Default 1em lineHeight\n\t    return textElement.getBBox().height;\n\t  }\n\t  switch (heightValue.unit) {\n\t    case 'em':\n\t      return textElement.getBBox().height * heightValue.value;\n\t    case 'px':\n\t    case '':\n\t      return heightValue.value;\n\t  }\n\t}\n\tconst breakText = function (text, size, styles = {}, opt = {}) {\n\t  var width = size.width;\n\t  var height = size.height;\n\t  var svgDocument = opt.svgDocument || V('svg').node;\n\t  var textSpan = V('tspan').node;\n\t  var textElement = V('text').attr(styles).append(textSpan).node;\n\t  var textNode = document.createTextNode('');\n\n\t  // Prevent flickering\n\t  textElement.style.opacity = 0;\n\t  // Prevent FF from throwing an uncaught exception when `getBBox()`\n\t  // called on element that is not in the render tree (is not measurable).\n\t  // <tspan>.getComputedTextLength() returns always 0 in this case.\n\t  // Note that the `textElement` resp. `textSpan` can become hidden\n\t  // when it's appended to the DOM and a `display: none` CSS stylesheet\n\t  // rule gets applied.\n\t  textElement.style.display = 'block';\n\t  textSpan.style.display = 'block';\n\t  textSpan.appendChild(textNode);\n\t  svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n\t  if (!opt.svgDocument) {\n\t    document.body.appendChild(svgDocument);\n\t  }\n\t  const preserveSpaces = opt.preserveSpaces;\n\t  const space = ' ';\n\t  const separator = opt.separator || opt.separator === '' ? opt.separator : space;\n\t  // If separator is a RegExp, we use the space character to join words together again (not ideal)\n\t  const separatorChar = typeof separator === 'string' ? separator : space;\n\t  var eol = opt.eol || '\\n';\n\t  var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d\\u00C0-\\u1FFF\\u2800-\\uFFFD]/;\n\t  var maxLineCount = opt.maxLineCount;\n\t  if (!isNumber(maxLineCount)) maxLineCount = Infinity;\n\t  var words = text.split(separator);\n\t  var full = [];\n\t  var lines = [];\n\t  var p, h;\n\t  var lineHeight;\n\t  if (preserveSpaces) {\n\t    V(textSpan).attr('xml:space', 'preserve');\n\t  }\n\t  for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\t    var word = words[i];\n\t    if (!word && !preserveSpaces) continue;\n\t    if (typeof word !== 'string') continue;\n\t    var isEol = false;\n\t    if (eol && word.indexOf(eol) >= 0) {\n\t      // word contains end-of-line character\n\t      if (word.length > 1) {\n\t        // separate word and continue cycle\n\t        const eolWords = splitWordWithEOL(words[i], eol);\n\t        words.splice(i, 1, ...eolWords);\n\t        i--;\n\t        len = words.length;\n\t        continue;\n\t      } else {\n\t        // creates a new line\n\t        if (preserveSpaces && typeof words[i - 1] === 'string') {\n\t          words.splice(i, NO_SPACE, '', NO_SPACE);\n\t          len += 2;\n\t          i--;\n\t          continue;\n\t        }\n\t        lines[++l] = !preserveSpaces || typeof words[i + 1] === 'string' ? '' : undefined;\n\t        isEol = true;\n\t      }\n\t    }\n\t    if (!isEol) {\n\t      let data;\n\t      if (preserveSpaces) {\n\t        data = lines[l] !== undefined ? lines[l] + separatorChar + word : word;\n\t      } else {\n\t        data = lines[l] ? lines[l] + separatorChar + word : word;\n\t      }\n\t      textNode.data = data;\n\t      if (textSpan.getComputedTextLength() <= width) {\n\t        // the current line fits\n\t        lines[l] = data;\n\t        if (p || h) {\n\t          // We were partitioning. Put rest of the word onto next line\n\t          full[l++] = true;\n\n\t          // cancel partitioning and splitting by hyphens\n\t          p = 0;\n\t          h = 0;\n\t        }\n\t      } else {\n\t        if (!lines[l] || p) {\n\t          var partition = !!p;\n\t          p = word.length - 1;\n\t          if (partition || !p) {\n\t            // word has only one character.\n\t            if (!p) {\n\t              if (!lines[l]) {\n\t                // we won't fit this text within our rect\n\t                lines = [];\n\t                break;\n\t              }\n\n\t              // partitioning didn't help on the non-empty line\n\t              // try again, but this time start with a new line\n\n\t              // cancel partitions created\n\t              words.splice(i, 2, word + words[i + 1]);\n\n\t              // adjust word length\n\t              len--;\n\t              full[l++] = true;\n\t              i--;\n\t              continue;\n\t            }\n\n\t            // move last letter to the beginning of the next word\n\t            words[i] = word.substring(0, p);\n\t            const nextWord = words[i + 1];\n\t            words[i + 1] = word.substring(p) + (nextWord === undefined || nextWord === NO_SPACE ? '' : nextWord);\n\t          } else {\n\t            if (h) {\n\t              // cancel splitting and put the words together again\n\t              words.splice(i, 2, words[i] + words[i + 1]);\n\t              h = 0;\n\t            } else {\n\t              var hyphenIndex = word.search(hyphen);\n\t              if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n\t                h = hyphenIndex + 1;\n\t                p = 0;\n\t              }\n\n\t              // We initiate partitioning or splitting\n\t              // split the long word into two words\n\t              words.splice(i, 1, word.substring(0, h || p), word.substring(h || p));\n\t              // adjust words length\n\t              len++;\n\t            }\n\t            if (l && !full[l - 1]) {\n\t              // if the previous line is not full, try to fit max part of\n\t              // the current word there\n\t              l--;\n\t            }\n\t          }\n\t          if (!preserveSpaces || lines[l] !== '') {\n\t            i--;\n\t          }\n\t          continue;\n\t        }\n\t        l++;\n\t        i--;\n\t      }\n\t    }\n\t    var lastL = null;\n\t    if (lines.length > maxLineCount) {\n\t      lastL = maxLineCount - 1;\n\t    } else if (height !== undefined) {\n\t      // if size.height is defined we have to check whether the height of the entire\n\t      // text exceeds the rect height\n\n\t      if (lineHeight === undefined && textNode.data !== '') {\n\t        // use the same defaults as in V.prototype.text\n\t        if (styles.lineHeight === 'auto') {\n\t          lineHeight = getLineHeight({\n\t            value: 1.5,\n\t            unit: 'em'\n\t          }, textElement);\n\t        } else {\n\t          const parsed = parseCssNumeric(styles.lineHeight, ['em', 'px', '']);\n\t          lineHeight = getLineHeight(parsed, textElement);\n\t        }\n\t      }\n\t      if (lineHeight * lines.length > height) {\n\t        // remove overflowing lines\n\t        lastL = Math.floor(height / lineHeight) - 1;\n\t      }\n\t    }\n\t    if (lastL !== null) {\n\t      lines.splice(lastL + 1);\n\n\t      // add ellipsis\n\t      var ellipsis = opt.ellipsis;\n\t      if (!ellipsis || lastL < 0) break;\n\t      if (typeof ellipsis !== 'string') ellipsis = '\\u2026';\n\t      var lastLine = lines[lastL];\n\t      if (!lastLine && !isEol) break;\n\t      var k = lastLine.length;\n\t      var lastLineWithOmission, lastChar;\n\t      do {\n\t        lastChar = lastLine[k];\n\t        lastLineWithOmission = lastLine.substring(0, k);\n\t        if (!lastChar) {\n\t          lastLineWithOmission += separatorChar;\n\t        } else if (lastChar.match(separator)) {\n\t          lastLineWithOmission += lastChar;\n\t        }\n\t        lastLineWithOmission += ellipsis;\n\t        textNode.data = lastLineWithOmission;\n\t        if (textSpan.getComputedTextLength() <= width) {\n\t          lines[lastL] = lastLineWithOmission;\n\t          break;\n\t        }\n\t        k--;\n\t      } while (k >= 0);\n\t      break;\n\t    }\n\t  }\n\t  if (opt.svgDocument) {\n\t    // svg document was provided, remove the text element only\n\t    svgDocument.removeChild(textElement);\n\t  } else {\n\t    // clean svg document\n\t    document.body.removeChild(svgDocument);\n\t  }\n\t  return lines.join(eol);\n\t};\n\n\t// Sanitize HTML\n\t// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n\t// Parses a string into an array of DOM nodes.\n\t// Then outputs it back as a string.\n\tconst sanitizeHTML = function (html) {\n\t  // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n\t  const [outputEl] = $.parseHTML('<div>' + html + '</div>');\n\t  Array.from(outputEl.getElementsByTagName('*')).forEach(function (node) {\n\t    // for all nodes\n\t    const names = node.getAttributeNames();\n\t    names.forEach(function (name) {\n\t      const value = node.getAttribute(name);\n\t      // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n\t      // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n\t      if (name.startsWith('on') || value.startsWith('javascript:') || value.startsWith('data:') || value.startsWith('vbscript:')) {\n\t        node.removeAttribute(name);\n\t      }\n\t    });\n\t  });\n\t  return outputEl.innerHTML;\n\t};\n\n\t// Download `blob` as file with `fileName`.\n\t// Does not work in IE9.\n\tconst downloadBlob = function (blob, fileName) {\n\t  if (window.navigator.msSaveBlob) {\n\t    // requires IE 10+\n\t    // pulls up a save dialog\n\t    window.navigator.msSaveBlob(blob, fileName);\n\t  } else {\n\t    // other browsers\n\t    // downloads directly in Chrome and Safari\n\n\t    // presents a save/open dialog in Firefox\n\t    // Firefox bug: `from` field in save dialog always shows `from:blob:`\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n\t    var url = window.URL.createObjectURL(blob);\n\t    var link = document.createElement('a');\n\t    link.href = url;\n\t    link.download = fileName;\n\t    document.body.appendChild(link);\n\t    link.click();\n\t    document.body.removeChild(link);\n\t    window.URL.revokeObjectURL(url); // mark the url for garbage collection\n\t  }\n\t};\n\n\t// Download `dataUri` as file with `fileName`.\n\t// Does not work in IE9.\n\tconst downloadDataUri = function (dataUri, fileName) {\n\t  const blob = dataUriToBlob(dataUri);\n\t  downloadBlob(blob, fileName);\n\t};\n\n\t// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\n\tconst dataUriToBlob = function (dataUri) {\n\t  // first, make sure there are no newlines in the data uri\n\t  dataUri = dataUri.replace(/\\s/g, '');\n\t  dataUri = decodeURIComponent(dataUri);\n\t  var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n\t  var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n\t  var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n\t  var data = dataUri.slice(firstCommaIndex + 1);\n\t  var decodedString;\n\t  if (dataTypeString.indexOf('base64') >= 0) {\n\t    // data may be encoded in base64\n\t    decodedString = atob(data); // decode data\n\t  } else {\n\t    // convert the decoded string to UTF-8\n\t    decodedString = unescape(encodeURIComponent(data));\n\t  }\n\t  // write the bytes of the string to a typed array\n\t  var ia = new Uint8Array(decodedString.length);\n\t  for (var i = 0; i < decodedString.length; i++) {\n\t    ia[i] = decodedString.charCodeAt(i);\n\t  }\n\t  return new Blob([ia], {\n\t    type: mimeString\n\t  }); // return the typed array as Blob\n\t};\n\n\t// Read an image at `url` and return it as base64-encoded data uri.\n\t// The mime type of the image is inferred from the `url` file extension.\n\t// If data uri is provided as `url`, it is returned back unchanged.\n\t// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n\t// Works with IE9.\n\tconst imageToDataUri = function (url, callback) {\n\t  if (!url || url.substr(0, 'data:'.length) === 'data:') {\n\t    // No need to convert to data uri if it is already in data uri.\n\n\t    // This not only convenient but desired. For example,\n\t    // IE throws a security error if data:image/svg+xml is used to render\n\t    // an image to the canvas and an attempt is made to read out data uri.\n\t    // Now if our image is already in data uri, there is no need to render it to the canvas\n\t    // and so we can bypass this error.\n\n\t    // Keep the async nature of the function.\n\t    return setTimeout(function () {\n\t      callback(null, url);\n\t    }, 0);\n\t  }\n\n\t  // chrome, IE10+\n\t  var modernHandler = function (xhr, callback) {\n\t    if (xhr.status === 200) {\n\t      var reader = new FileReader();\n\t      reader.onload = function (evt) {\n\t        var dataUri = evt.target.result;\n\t        callback(null, dataUri);\n\t      };\n\t      reader.onerror = function () {\n\t        callback(new Error('Failed to load image ' + url));\n\t      };\n\t      reader.readAsDataURL(xhr.response);\n\t    } else {\n\t      callback(new Error('Failed to load image ' + url));\n\t    }\n\t  };\n\t  var legacyHandler = function (xhr, callback) {\n\t    var Uint8ToString = function (u8a) {\n\t      var CHUNK_SZ = 0x8000;\n\t      var c = [];\n\t      for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n\t        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n\t      }\n\t      return c.join('');\n\t    };\n\t    if (xhr.status === 200) {\n\t      var bytes = new Uint8Array(xhr.response);\n\t      var suffix = url.split('.').pop() || 'png';\n\t      var map = {\n\t        'svg': 'svg+xml'\n\t      };\n\t      var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n\t      var b64encoded = meta + btoa(Uint8ToString(bytes));\n\t      callback(null, b64encoded);\n\t    } else {\n\t      callback(new Error('Failed to load image ' + url));\n\t    }\n\t  };\n\t  var xhr = new XMLHttpRequest();\n\t  xhr.open('GET', url, true);\n\t  xhr.addEventListener('error', function () {\n\t    callback(new Error('Failed to load image ' + url));\n\t  });\n\t  xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\t  xhr.addEventListener('load', function () {\n\t    if (window.FileReader) {\n\t      modernHandler(xhr, callback);\n\t    } else {\n\t      legacyHandler(xhr, callback);\n\t    }\n\t  });\n\t  xhr.send();\n\t};\n\tconst getElementBBox = function (el) {\n\t  var $el = $(el);\n\t  if ($el.length === 0) {\n\t    throw new Error('Element not found');\n\t  }\n\t  var element = $el[0];\n\t  var doc = element.ownerDocument;\n\t  var clientBBox = element.getBoundingClientRect();\n\t  var strokeWidthX = 0;\n\t  var strokeWidthY = 0;\n\n\t  // Firefox correction\n\t  if (element.ownerSVGElement) {\n\t    var vel = V(element);\n\t    var bbox = vel.getBBox({\n\t      target: vel.svg()\n\t    });\n\n\t    // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n\t    // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n\t    strokeWidthX = clientBBox.width - bbox.width;\n\t    strokeWidthY = clientBBox.height - bbox.height;\n\t  }\n\t  return {\n\t    x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n\t    y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n\t    width: clientBBox.width - strokeWidthX,\n\t    height: clientBBox.height - strokeWidthY\n\t  };\n\t};\n\n\t// Highly inspired by the jquery.sortElements plugin by Padolsey.\n\t// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n\tconst sortElements = function (elements, comparator) {\n\t  elements = $(elements).toArray();\n\t  var placements = elements.map(function (sortElement) {\n\t    var parentNode = sortElement.parentNode;\n\t    // Since the element itself will change position, we have\n\t    // to have some way of storing it's original position in\n\t    // the DOM. The easiest way is to have a 'flag' node:\n\t    var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\t    return function () {\n\t      if (parentNode === this) {\n\t        throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n\t      }\n\n\t      // Insert before flag:\n\t      parentNode.insertBefore(this, nextSibling);\n\t      // Remove flag:\n\t      parentNode.removeChild(nextSibling);\n\t    };\n\t  });\n\t  elements.sort(comparator);\n\t  for (var i = 0; i < placements.length; i++) {\n\t    placements[i].call(elements[i]);\n\t  }\n\t  return elements;\n\t};\n\n\t// Sets attributes on the given element and its descendants based on the selector.\n\t// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\n\tconst setAttributesBySelector = function (element, attrs) {\n\t  var $element = $(element);\n\t  forIn(attrs, function (attrs, selector) {\n\t    var $elements = $element.find(selector).addBack().filter(selector);\n\t    // Make a special case for setting classes.\n\t    // We do not want to overwrite any existing class.\n\t    if (has(attrs, 'class')) {\n\t      $elements.addClass(attrs['class']);\n\t      attrs = omit(attrs, 'class');\n\t    }\n\t    $elements.attr(attrs);\n\t  });\n\t};\n\n\t// Return a new object with all four sides (top, right, bottom, left) in it.\n\t// Value of each side is taken from the given argument (either number or object).\n\t// Default value for a side is 0.\n\t// Examples:\n\t// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n\t// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n\t// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n\t// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n\t// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n\tconst normalizeSides = function (box) {\n\t  if (Object(box) !== box) {\n\t    // `box` is not an object\n\t    var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n\t    if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')\n\n\t    return {\n\t      top: val,\n\t      right: val,\n\t      bottom: val,\n\t      left: val\n\t    };\n\t  }\n\n\t  // `box` is an object\n\t  var top, right, bottom, left;\n\t  top = right = bottom = left = 0;\n\t  if (isFinite(box.vertical)) top = bottom = +box.vertical;\n\t  if (isFinite(box.horizontal)) right = left = +box.horizontal;\n\t  if (isFinite(box.top)) top = +box.top; // overwrite vertical\n\t  if (isFinite(box.right)) right = +box.right; // overwrite horizontal\n\t  if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical\n\t  if (isFinite(box.left)) left = +box.left; // overwrite horizontal\n\n\t  return {\n\t    top: top,\n\t    right: right,\n\t    bottom: bottom,\n\t    left: left\n\t  };\n\t};\n\tconst timing = {\n\t  linear: function (t) {\n\t    return t;\n\t  },\n\t  quad: function (t) {\n\t    return t * t;\n\t  },\n\t  cubic: function (t) {\n\t    return t * t * t;\n\t  },\n\t  inout: function (t) {\n\t    if (t <= 0) return 0;\n\t    if (t >= 1) return 1;\n\t    var t2 = t * t;\n\t    var t3 = t2 * t;\n\t    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n\t  },\n\t  exponential: function (t) {\n\t    return Math.pow(2, 10 * (t - 1));\n\t  },\n\t  bounce: function (t) {\n\t    for (var a = 0, b = 1; 1; a += b, b /= 2) {\n\t      if (t >= (7 - 4 * a) / 11) {\n\t        var q = (11 - 6 * a - 11 * t) / 4;\n\t        return -q * q + b * b;\n\t      }\n\t    }\n\t  },\n\t  reverse: function (f) {\n\t    return function (t) {\n\t      return 1 - f(1 - t);\n\t    };\n\t  },\n\t  reflect: function (f) {\n\t    return function (t) {\n\t      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n\t    };\n\t  },\n\t  clamp: function (f, n, x) {\n\t    n = n || 0;\n\t    x = x || 1;\n\t    return function (t) {\n\t      var r = f(t);\n\t      return r < n ? n : r > x ? x : r;\n\t    };\n\t  },\n\t  back: function (s) {\n\t    if (!s) s = 1.70158;\n\t    return function (t) {\n\t      return t * t * ((s + 1) * t - s);\n\t    };\n\t  },\n\t  elastic: function (x) {\n\t    if (!x) x = 1.5;\n\t    return function (t) {\n\t      return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n\t    };\n\t  }\n\t};\n\tconst interpolate = {\n\t  number: function (a, b) {\n\t    var d = b - a;\n\t    return function (t) {\n\t      return a + d * t;\n\t    };\n\t  },\n\t  object: function (a, b) {\n\t    var s = Object.keys(a);\n\t    return function (t) {\n\t      var i, p;\n\t      var r = {};\n\t      for (i = s.length - 1; i != -1; i--) {\n\t        p = s[i];\n\t        r[p] = a[p] + (b[p] - a[p]) * t;\n\t      }\n\t      return r;\n\t    };\n\t  },\n\t  hexColor: function (a, b) {\n\t    var ca = parseInt(a.slice(1), 16);\n\t    var cb = parseInt(b.slice(1), 16);\n\t    var ra = ca & 0x0000ff;\n\t    var rd = (cb & 0x0000ff) - ra;\n\t    var ga = ca & 0x00ff00;\n\t    var gd = (cb & 0x00ff00) - ga;\n\t    var ba = ca & 0xff0000;\n\t    var bd = (cb & 0xff0000) - ba;\n\t    return function (t) {\n\t      var r = ra + rd * t & 0x000000ff;\n\t      var g = ga + gd * t & 0x0000ff00;\n\t      var b = ba + bd * t & 0x00ff0000;\n\t      return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n\t    };\n\t  },\n\t  unit: function (a, b) {\n\t    var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n\t    var ma = r.exec(a);\n\t    var mb = r.exec(b);\n\t    var p = mb[1].indexOf('.');\n\t    var f = p > 0 ? mb[1].length - p - 1 : 0;\n\t    a = +ma[1];\n\t    var d = +mb[1] - a;\n\t    var u = ma[2];\n\t    return function (t) {\n\t      return (a + d * t).toFixed(f) + u;\n\t    };\n\t  }\n\t};\n\n\t// SVG filters.\n\t// (values in parentheses are default values)\n\tconst filter = {\n\t  // `color` ... outline color ('blue')\n\t  // `width`... outline width (1)\n\t  // `opacity` ... outline opacity (1)\n\t  // `margin` ... gap between outline and the element (2)\n\t  outline: function (args) {\n\t    var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\t    var margin = Number.isFinite(args.margin) ? args.margin : 2;\n\t    var width = Number.isFinite(args.width) ? args.width : 1;\n\t    return template(tpl)({\n\t      color: args.color || 'blue',\n\t      opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n\t      outerRadius: margin + width,\n\t      innerRadius: margin\n\t    });\n\t  },\n\t  // `color` ... color ('red')\n\t  // `width`... width (1)\n\t  // `blur` ... blur (0)\n\t  // `opacity` ... opacity (1)\n\t  highlight: function (args) {\n\t    var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\t    return template(tpl)({\n\t      color: args.color || 'red',\n\t      width: Number.isFinite(args.width) ? args.width : 1,\n\t      blur: Number.isFinite(args.blur) ? args.blur : 0,\n\t      opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n\t    });\n\t  },\n\t  // `x` ... horizontal blur (2)\n\t  // `y` ... vertical blur (optional)\n\t  blur: function (args) {\n\t    var x = Number.isFinite(args.x) ? args.x : 2;\n\t    return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n\t      stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n\t    });\n\t  },\n\t  // `dx` ... horizontal shift (0)\n\t  // `dy` ... vertical shift (0)\n\t  // `blur` ... blur (4)\n\t  // `color` ... color ('black')\n\t  // `opacity` ... opacity (1)\n\t  dropShadow: function (args) {\n\t    var tpl = 'SVGFEDropShadowElement' in window ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>' : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\t    return template(tpl)({\n\t      dx: args.dx || 0,\n\t      dy: args.dy || 0,\n\t      opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n\t      color: args.color || 'black',\n\t      blur: Number.isFinite(args.blur) ? args.blur : 4\n\t    });\n\t  },\n\t  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n\t  grayscale: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n\t      a: 0.2126 + 0.7874 * (1 - amount),\n\t      b: 0.7152 - 0.7152 * (1 - amount),\n\t      c: 0.0722 - 0.0722 * (1 - amount),\n\t      d: 0.2126 - 0.2126 * (1 - amount),\n\t      e: 0.7152 + 0.2848 * (1 - amount),\n\t      f: 0.0722 - 0.0722 * (1 - amount),\n\t      g: 0.2126 - 0.2126 * (1 - amount),\n\t      h: 0.0722 + 0.9278 * (1 - amount)\n\t    });\n\t  },\n\t  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n\t  sepia: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n\t      a: 0.393 + 0.607 * (1 - amount),\n\t      b: 0.769 - 0.769 * (1 - amount),\n\t      c: 0.189 - 0.189 * (1 - amount),\n\t      d: 0.349 - 0.349 * (1 - amount),\n\t      e: 0.686 + 0.314 * (1 - amount),\n\t      f: 0.168 - 0.168 * (1 - amount),\n\t      g: 0.272 - 0.272 * (1 - amount),\n\t      h: 0.534 - 0.534 * (1 - amount),\n\t      i: 0.131 + 0.869 * (1 - amount)\n\t    });\n\t  },\n\t  // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n\t  saturate: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n\t      amount: 1 - amount\n\t    });\n\t  },\n\t  // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n\t  hueRotate: function (args) {\n\t    return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n\t      angle: args.angle || 0\n\t    });\n\t  },\n\t  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n\t  invert: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n\t      amount: amount,\n\t      amount2: 1 - amount\n\t    });\n\t  },\n\t  // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n\t  brightness: function (args) {\n\t    return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n\t      amount: Number.isFinite(args.amount) ? args.amount : 1\n\t    });\n\t  },\n\t  // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n\t  contrast: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n\t      amount: amount,\n\t      amount2: .5 - amount / 2\n\t    });\n\t  }\n\t};\n\tconst format$1 = {\n\t  // Formatting numbers via the Python Format Specification Mini-language.\n\t  // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n\t  // Heavilly inspired by the D3.js library implementation.\n\t  number: function (specifier, value, locale) {\n\t    locale = locale || {\n\t      currency: ['$', ''],\n\t      decimal: '.',\n\t      thousands: ',',\n\t      grouping: [3]\n\t    };\n\n\t    // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n\t    // [[fill]align][sign][symbol][0][width][,][.precision][type]\n\t    var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\t    var match = re.exec(specifier);\n\t    var fill = match[1] || ' ';\n\t    var align = match[2] || '>';\n\t    var sign = match[3] || '';\n\t    var symbol = match[4] || '';\n\t    var zfill = match[5];\n\t    var width = +match[6];\n\t    var comma = match[7];\n\t    var precision = match[8];\n\t    var type = match[9];\n\t    var scale = 1;\n\t    var prefix = '';\n\t    var suffix = '';\n\t    var integer = false;\n\t    if (precision) precision = +precision.substring(1);\n\t    if (zfill || fill === '0' && align === '=') {\n\t      zfill = fill = '0';\n\t      align = '=';\n\t      if (comma) width -= Math.floor((width - 1) / 4);\n\t    }\n\t    switch (type) {\n\t      case 'n':\n\t        comma = true;\n\t        type = 'g';\n\t        break;\n\t      case '%':\n\t        scale = 100;\n\t        suffix = '%';\n\t        type = 'f';\n\t        break;\n\t      case 'p':\n\t        scale = 100;\n\t        suffix = '%';\n\t        type = 'r';\n\t        break;\n\t      case 'b':\n\t      case 'o':\n\t      case 'x':\n\t      case 'X':\n\t        if (symbol === '#') prefix = '0' + type.toLowerCase();\n\t        break;\n\t      case 'c':\n\t      case 'd':\n\t        integer = true;\n\t        precision = 0;\n\t        break;\n\t      case 's':\n\t        scale = -1;\n\t        type = 'r';\n\t        break;\n\t    }\n\t    if (symbol === '$') {\n\t      prefix = locale.currency[0];\n\t      suffix = locale.currency[1];\n\t    }\n\n\t    // If no precision is specified for `'r'`, fallback to general notation.\n\t    if (type == 'r' && !precision) type = 'g';\n\n\t    // Ensure that the requested precision is in the supported range.\n\t    if (precision != null) {\n\t      if (type == 'g') precision = Math.max(1, Math.min(21, precision));else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));\n\t    }\n\t    var zcomma = zfill && comma;\n\n\t    // Return the empty string for floats formatted as ints.\n\t    if (integer && value % 1) return '';\n\n\t    // Convert negative to positive, and record the sign prefix.\n\t    var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\t    var fullSuffix = suffix;\n\n\t    // Apply the scale, computing it from the value's exponent for si format.\n\t    // Preserve the existing suffix, if any, such as the currency symbol.\n\t    if (scale < 0) {\n\t      var unit = this.prefix(value, precision);\n\t      value = unit.scale(value);\n\t      fullSuffix = unit.symbol + suffix;\n\t    } else {\n\t      value *= scale;\n\t    }\n\n\t    // Convert to the desired precision.\n\t    value = this.convert(type, value, precision);\n\n\t    // Break the value into the integer part (before) and decimal part (after).\n\t    var i = value.lastIndexOf('.');\n\t    var before = i < 0 ? value : value.substring(0, i);\n\t    var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\t    function formatGroup(value) {\n\t      var i = value.length;\n\t      var t = [];\n\t      var j = 0;\n\t      var g = locale.grouping[0];\n\t      while (i > 0 && g > 0) {\n\t        t.push(value.substring(i -= g, i + g));\n\t        g = locale.grouping[j = (j + 1) % locale.grouping.length];\n\t      }\n\t      return t.reverse().join(locale.thousands);\n\t    }\n\n\t    // If the fill character is not `'0'`, grouping is applied before padding.\n\t    if (!zfill && comma && locale.grouping) {\n\t      before = formatGroup(before);\n\t    }\n\t    var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n\t    var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n\t    // If the fill character is `'0'`, grouping is applied after padding.\n\t    if (zcomma) before = formatGroup(padding + before);\n\n\t    // Apply prefix.\n\t    negative += prefix;\n\n\t    // Rejoin integer and decimal parts.\n\t    value = before + after;\n\t    return (align === '<' ? negative + value + padding : align === '>' ? padding + negative + value : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n\t  },\n\t  // Formatting string via the Python Format string.\n\t  // See https://docs.python.org/2/library/string.html#format-string-syntax)\n\t  string: function (formatString, value) {\n\t    var fieldDelimiterIndex;\n\t    var fieldDelimiter = '{';\n\t    var endPlaceholder = false;\n\t    var formattedStringArray = [];\n\t    while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\t      var pieceFormattedString, formatSpec, fieldName;\n\t      pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\t      if (endPlaceholder) {\n\t        formatSpec = pieceFormattedString.split(':');\n\t        fieldName = formatSpec.shift().split('.');\n\t        pieceFormattedString = value;\n\t        for (var i = 0; i < fieldName.length; i++) pieceFormattedString = pieceFormattedString[fieldName[i]];\n\t        if (formatSpec.length) pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n\t      }\n\t      formattedStringArray.push(pieceFormattedString);\n\t      formatString = formatString.slice(fieldDelimiterIndex + 1);\n\t      endPlaceholder = !endPlaceholder;\n\t      fieldDelimiter = endPlaceholder ? '}' : '{';\n\t    }\n\t    formattedStringArray.push(formatString);\n\t    return formattedStringArray.join('');\n\t  },\n\t  convert: function (type, value, precision) {\n\t    switch (type) {\n\t      case 'b':\n\t        return value.toString(2);\n\t      case 'c':\n\t        return String.fromCharCode(value);\n\t      case 'o':\n\t        return value.toString(8);\n\t      case 'x':\n\t        return value.toString(16);\n\t      case 'X':\n\t        return value.toString(16).toUpperCase();\n\t      case 'g':\n\t        return value.toPrecision(precision);\n\t      case 'e':\n\t        return value.toExponential(precision);\n\t      case 'f':\n\t        return value.toFixed(precision);\n\t      case 'r':\n\t        return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n\t      default:\n\t        return value + '';\n\t    }\n\t  },\n\t  round: function (value, precision) {\n\t    return precision ? Math.round(value * (precision = Math.pow(10, precision))) / precision : Math.round(value);\n\t  },\n\t  precision: function (value, precision) {\n\t    return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n\t  },\n\t  prefix: function (value, precision) {\n\t    var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', 'Âµ', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function (d, i) {\n\t      var k = Math.pow(10, Math.abs(8 - i) * 3);\n\t      return {\n\t        scale: i > 8 ? function (d) {\n\t          return d / k;\n\t        } : function (d) {\n\t          return d * k;\n\t        },\n\t        symbol: d\n\t      };\n\t    });\n\t    var i = 0;\n\t    if (value) {\n\t      if (value < 0) value *= -1;\n\t      if (precision) value = this.round(value, this.precision(value, precision));\n\t      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n\t      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n\t    }\n\t    return prefixes[8 + i / 3];\n\t  }\n\t};\n\n\t/*\n\t    Pre-compile the HTML to be used as a template.\n\t*/\n\tconst template = function (html) {\n\t  /*\n\t      Must support the variation in templating syntax found here:\n\t      https://lodash.com/docs#template\n\t  */\n\t  var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\t  return function (data) {\n\t    data = data || {};\n\t    return html.replace(regex, function (match) {\n\t      var args = Array.from(arguments);\n\t      var attr = args.slice(1, 4).find(function (_attr) {\n\t        return !!_attr;\n\t      });\n\t      var attrArray = attr.split('.');\n\t      var value = data[attrArray.shift()];\n\t      while (value !== undefined && attrArray.length) {\n\t        value = value[attrArray.shift()];\n\t      }\n\t      return value !== undefined ? value : '';\n\t    });\n\t  };\n\t};\n\n\t/**\n\t * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n\t */\n\tconst toggleFullScreen = function (el) {\n\t  var topDocument = window.top.document;\n\t  el = el || topDocument.body;\n\t  function prefixedResult(el, prop) {\n\t    var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n\t    for (var i = 0; i < prefixes.length; i++) {\n\t      var prefix = prefixes[i];\n\t      var propName = prefix ? prefix + prop : prop.substr(0, 1).toLowerCase() + prop.substr(1);\n\t      if (el[propName] !== undefined) {\n\t        return isFunction(el[propName]) ? el[propName]() : el[propName];\n\t      }\n\t    }\n\t  }\n\t  if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n\t    prefixedResult(topDocument, 'ExitFullscreen') ||\n\t    // Spec.\n\t    prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n\t  } else {\n\t    prefixedResult(el, 'RequestFullscreen') ||\n\t    // Spec.\n\t    prefixedResult(el, 'RequestFullScreen'); // Firefox\n\t  }\n\t};\n\tfunction findDifference(obj, baseObj, currentDepth, maxDepth) {\n\t  if (currentDepth === maxDepth) {\n\t    return {};\n\t  }\n\t  const diff = {};\n\t  Object.keys(obj).forEach(key => {\n\t    const objValue = obj[key];\n\t    const baseValue = baseObj[key];\n\t    if (!Array.isArray(objValue) && !Array.isArray(baseValue) && isObject(objValue) && isObject(baseValue)) {\n\t      const nestedDepth = currentDepth + 1;\n\t      const nestedDiff = findDifference(objValue, baseValue, nestedDepth, maxDepth);\n\t      if (Object.keys(nestedDiff).length > 0) {\n\t        diff[key] = nestedDiff;\n\t      } else if (currentDepth === 0 || nestedDepth === maxDepth) {\n\t        diff[key] = {};\n\t      }\n\t    } else if (!isEqual(objValue, baseValue)) {\n\t      diff[key] = objValue;\n\t    }\n\t  });\n\t  return diff;\n\t}\n\tfunction objectDifference(object, base, opt) {\n\t  const {\n\t    maxDepth = Number.POSITIVE_INFINITY\n\t  } = opt || {};\n\t  return findDifference(object, base, 0, maxDepth);\n\t}\n\tconst noop = function () {\n\t  // Do nothing.\n\t};\n\n\t// Events\n\t// ---------------\n\n\t// A module that can be mixed in to *any object* in order to provide it with\n\t// a custom event channel. You may bind a callback to an event with `on` or\n\t// remove with `off`; `trigger`-ing an event fires all callbacks in\n\t// succession.\n\t//\n\t//     const object = {};\n\t//     assign(object, Events);\n\t//     object.on('expand', function(){ alert('expanded'); });\n\t//     object.trigger('expand');\n\t//\n\tvar Events = {};\n\n\t// Regular expression used to split event strings.\n\tvar eventSplitter = /\\s+/;\n\n\t// A private global variable to share between listeners and listenees.\n\tvar _listening;\n\n\t// Iterates over the standard `event, callback` (as well as the fancy multiple\n\t// space-separated events `\"change blur\", callback` and jQuery-style event\n\t// maps `{event: callback}`).\n\tvar eventsApi = function (iteratee, events, name, callback, opts) {\n\t  var i = 0,\n\t    names;\n\t  if (name && typeof name === 'object') {\n\t    // Handle event maps.\n\t    if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n\t    for (names = Object.keys(name); i < names.length; i++) {\n\t      events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n\t    }\n\t  } else if (name && eventSplitter.test(name)) {\n\t    // Handle space-separated event names by delegating them individually.\n\t    for (names = name.split(eventSplitter); i < names.length; i++) {\n\t      events = iteratee(events, names[i], callback, opts);\n\t    }\n\t  } else {\n\t    // Finally, standard events.\n\t    events = iteratee(events, name, callback, opts);\n\t  }\n\t  return events;\n\t};\n\n\t// Bind an event to a `callback` function. Passing `\"all\"` will bind\n\t// the callback to all events fired.\n\tEvents.on = function (name, callback, context) {\n\t  this._events = eventsApi(onApi, this._events || {}, name, callback, {\n\t    context: context,\n\t    ctx: this,\n\t    listening: _listening\n\t  });\n\t  if (_listening) {\n\t    var listeners = this._listeners || (this._listeners = {});\n\t    listeners[_listening.id] = _listening;\n\t    // Allow the listening to use a counter, instead of tracking\n\t    // callbacks for library interop\n\t    _listening.interop = false;\n\t  }\n\t  return this;\n\t};\n\n\t// Inversion-of-control versions of `on`. Tell *this* object to listen to\n\t// an event in another object... keeping track of what it's listening to\n\t// for easier unbinding later.\n\tEvents.listenTo = function (obj, name, callback) {\n\t  if (!obj) return this;\n\t  var id = obj._listenId || (obj._listenId = uniqueId('l'));\n\t  var listeningTo = this._listeningTo || (this._listeningTo = {});\n\t  var listening = _listening = listeningTo[id];\n\n\t  // This object is not listening to any other events on `obj` yet.\n\t  // Setup the necessary references to track the listening callbacks.\n\t  if (!listening) {\n\t    this._listenId || (this._listenId = uniqueId('l'));\n\t    listening = _listening = listeningTo[id] = new Listening(this, obj);\n\t  }\n\n\t  // Bind callbacks on obj.\n\t  var error = tryCatchOn(obj, name, callback, this);\n\t  _listening = void 0;\n\t  if (error) throw error;\n\t  // If the target obj is not Events, track events manually.\n\t  if (listening.interop) listening.on(name, callback);\n\t  return this;\n\t};\n\n\t// The reducing API that adds a callback to the `events` object.\n\tvar onApi = function (events, name, callback, options) {\n\t  if (callback) {\n\t    var handlers = events[name] || (events[name] = []);\n\t    var context = options.context,\n\t      ctx = options.ctx,\n\t      listening = options.listening;\n\t    if (listening) listening.count++;\n\t    handlers.push({\n\t      callback: callback,\n\t      context: context,\n\t      ctx: context || ctx,\n\t      listening: listening\n\t    });\n\t  }\n\t  return events;\n\t};\n\n\t// An try-catch guarded #on function, to prevent poisoning the global\n\t// `_listening` variable.\n\tvar tryCatchOn = function (obj, name, callback, context) {\n\t  try {\n\t    obj.on(name, callback, context);\n\t  } catch (e) {\n\t    return e;\n\t  }\n\t};\n\n\t// Remove one or many callbacks. If `context` is null, removes all\n\t// callbacks with that function. If `callback` is null, removes all\n\t// callbacks for the event. If `name` is null, removes all bound\n\t// callbacks for all events.\n\tEvents.off = function (name, callback, context) {\n\t  if (!this._events) return this;\n\t  this._events = eventsApi(offApi, this._events, name, callback, {\n\t    context: context,\n\t    listeners: this._listeners\n\t  });\n\t  return this;\n\t};\n\n\t// Tell this object to stop listening to either specific events ... or\n\t// to every object it's currently listening to.\n\tEvents.stopListening = function (obj, name, callback) {\n\t  var listeningTo = this._listeningTo;\n\t  if (!listeningTo) return this;\n\t  var ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n\t  for (var i = 0; i < ids.length; i++) {\n\t    var listening = listeningTo[ids[i]];\n\n\t    // If listening doesn't exist, this object is not currently\n\t    // listening to obj. Break out early.\n\t    if (!listening) break;\n\t    listening.obj.off(name, callback, this);\n\t    if (listening.interop) listening.off(name, callback);\n\t  }\n\t  if (isEmpty(listeningTo)) this._listeningTo = void 0;\n\t  return this;\n\t};\n\n\t// The reducing API that removes a callback from the `events` object.\n\tvar offApi = function (events, name, callback, options) {\n\t  if (!events) return;\n\t  var context = options.context,\n\t    listeners = options.listeners;\n\t  var i = 0,\n\t    names;\n\n\t  // Delete all event listeners and \"drop\" events.\n\t  if (!name && !context && !callback) {\n\t    if (listeners != null) {\n\t      for (names = Object.keys(listeners); i < names.length; i++) {\n\t        listeners[names[i]].cleanup();\n\t      }\n\t    }\n\t    return;\n\t  }\n\t  names = name ? [name] : Object.keys(events);\n\t  for (; i < names.length; i++) {\n\t    name = names[i];\n\t    var handlers = events[name];\n\n\t    // Bail out if there are no events stored.\n\t    if (!handlers) break;\n\n\t    // Find any remaining events.\n\t    var remaining = [];\n\t    for (var j = 0; j < handlers.length; j++) {\n\t      var handler = handlers[j];\n\t      if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {\n\t        remaining.push(handler);\n\t      } else {\n\t        var listening = handler.listening;\n\t        if (listening) listening.off(name, callback);\n\t      }\n\t    }\n\n\t    // Replace events if there are any remaining.  Otherwise, clean up.\n\t    if (remaining.length) {\n\t      events[name] = remaining;\n\t    } else {\n\t      delete events[name];\n\t    }\n\t  }\n\t  return events;\n\t};\n\n\t// Bind an event to only be triggered a single time. After the first time\n\t// the callback is invoked, its listener will be removed. If multiple events\n\t// are passed in using the space-separated syntax, the handler will fire\n\t// once for each event, not once for a combination of all events.\n\tEvents.once = function (name, callback, context) {\n\t  // Map the event into a `{event: once}` object.\n\t  var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n\t  if (typeof name === 'string' && context == null) callback = void 0;\n\t  return this.on(events, callback, context);\n\t};\n\n\t// Inversion-of-control versions of `once`.\n\tEvents.listenToOnce = function (obj, name, callback) {\n\t  // Map the event into a `{event: once}` object.\n\t  var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n\t  return this.listenTo(obj, events);\n\t};\n\n\t// Reduces the event callbacks into a map of `{event: onceWrapper}`.\n\t// `offer` unbinds the `onceWrapper` after it has been called.\n\tvar onceMap = function (map, name, callback, offer) {\n\t  if (callback) {\n\t    var once = map[name] = onceInvoke(function () {\n\t      offer(name, once);\n\t      callback.apply(this, arguments);\n\t    });\n\t    once._callback = callback;\n\t  }\n\t  return map;\n\t};\n\n\t// Creates a function that is restricted to invoking 'func' once.\n\t// Repeat calls to the function return the value of the first invocation.\n\tvar onceInvoke = function (func) {\n\t  var result;\n\t  if (typeof func != 'function') {\n\t    throw new TypeError('Expected a function');\n\t  }\n\t  var n = 2;\n\t  return function () {\n\t    if (--n > 0) {\n\t      result = func.apply(this, arguments);\n\t    }\n\t    if (n <= 1) {\n\t      func = undefined;\n\t    }\n\t    return result;\n\t  };\n\t};\n\n\t// Trigger one or many events, firing all bound callbacks. Callbacks are\n\t// passed the same arguments as `trigger` is, apart from the event name\n\t// (unless you're listening on `\"all\"`, which will cause your callback to\n\t// receive the true name of the event as the first argument).\n\tEvents.trigger = function (name) {\n\t  if (!this._events) return this;\n\t  var length = Math.max(0, arguments.length - 1);\n\t  var args = Array(length);\n\t  for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\t  eventsApi(triggerApi, this._events, name, void 0, args);\n\t  return this;\n\t};\n\n\t// Handles triggering the appropriate event callbacks.\n\tvar triggerApi = function (objEvents, name, callback, args) {\n\t  if (objEvents) {\n\t    var events = objEvents[name];\n\t    var allEvents = objEvents.all;\n\t    if (events && allEvents) allEvents = allEvents.slice();\n\t    if (events) triggerEvents(events, args);\n\t    if (allEvents) triggerEvents(allEvents, [name].concat(args));\n\t  }\n\t  return objEvents;\n\t};\n\n\t// A difficult-to-believe, but optimized internal dispatch function for\n\t// triggering events. Tries to keep the usual cases speedy (most internal\n\t// events have 3 arguments).\n\tvar triggerEvents = function (events, args) {\n\t  var ev,\n\t    i = -1,\n\t    l = events.length,\n\t    a1 = args[0],\n\t    a2 = args[1],\n\t    a3 = args[2];\n\t  switch (args.length) {\n\t    case 0:\n\t      while (++i < l) (ev = events[i]).callback.call(ev.ctx);\n\t      return;\n\t    case 1:\n\t      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);\n\t      return;\n\t    case 2:\n\t      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\t      return;\n\t    case 3:\n\t      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\t      return;\n\t    default:\n\t      while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n\t      return;\n\t  }\n\t};\n\n\t// A listening class that tracks and cleans up memory bindings\n\t// when all callbacks have been offed.\n\tvar Listening = function (listener, obj) {\n\t  this.id = listener._listenId;\n\t  this.listener = listener;\n\t  this.obj = obj;\n\t  this.interop = true;\n\t  this.count = 0;\n\t  this._events = void 0;\n\t};\n\tListening.prototype.on = Events.on;\n\n\t// Offs a callback (or several).\n\t// Uses an optimized counter if the listenee uses Events.\n\t// Otherwise, falls back to manual tracking to support events\n\t// library interop.\n\tListening.prototype.off = function (name, callback) {\n\t  var cleanup;\n\t  if (this.interop) {\n\t    this._events = eventsApi(offApi, this._events, name, callback, {\n\t      context: void 0,\n\t      listeners: void 0\n\t    });\n\t    cleanup = !this._events;\n\t  } else {\n\t    this.count--;\n\t    cleanup = this.count === 0;\n\t  }\n\t  if (cleanup) this.cleanup();\n\t};\n\n\t// Cleans up memory bindings between the listener and the listenee.\n\tListening.prototype.cleanup = function () {\n\t  delete this.listener._listeningTo[this.obj._listenId];\n\t  if (!this.interop) delete this.obj._listeners[this.id];\n\t};\n\n\t// Aliases for backwards compatibility.\n\tEvents.bind = Events.on;\n\tEvents.unbind = Events.off;\n\n\t// Helpers\n\t// -------\n\n\t// Helper function to correctly set up the prototype chain for subclasses.\n\t// Similar to `goog.inherits`, but uses a hash of prototype properties and\n\t// class properties to be extended.\n\tvar extend = function (protoProps, staticProps) {\n\t  var parent = this;\n\t  var child;\n\n\t  // The constructor function for the new subclass is either defined by you\n\t  // (the \"constructor\" property in your `extend` definition), or defaulted\n\t  // by us to simply call the parent constructor.\n\t  if (protoProps && has(protoProps, 'constructor')) {\n\t    child = protoProps.constructor;\n\t  } else {\n\t    child = function () {\n\t      return parent.apply(this, arguments);\n\t    };\n\t  }\n\n\t  // Add static properties to the constructor function, if supplied.\n\t  assign(child, parent, staticProps);\n\n\t  // Set the prototype chain to inherit from `parent`, without calling\n\t  // `parent`'s constructor function and add the prototype properties.\n\t  child.prototype = Object.assign(Object.create(parent.prototype), protoProps);\n\t  child.prototype.constructor = child;\n\n\t  // Set a convenience property in case the parent's prototype is needed\n\t  // later.\n\t  child.__super__ = parent.prototype;\n\t  return child;\n\t};\n\n\t// Proxy class methods to functions, wrapping the model's\n\t// `attributes` object or collection's `models` array behind the scenes.\n\t//\n\t// `Function#apply` can be slow so we use the method's arg count, if we know it.\n\tvar addMethod = function (base, length, method, attribute) {\n\t  switch (length) {\n\t    case 1:\n\t      return function () {\n\t        return base[method](this[attribute]);\n\t      };\n\t    case 2:\n\t      return function (value) {\n\t        return base[method](this[attribute], value);\n\t      };\n\t    case 3:\n\t      return function (iteratee, context) {\n\t        return base[method](this[attribute], cb(iteratee, this), context);\n\t      };\n\t    case 4:\n\t      return function (iteratee, defaultVal, context) {\n\t        return base[method](this[attribute], cb(iteratee, this), defaultVal, context);\n\t      };\n\t    default:\n\t      return function () {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        args.unshift(this[attribute]);\n\t        return base[method].apply(base, args);\n\t      };\n\t  }\n\t};\n\tvar addMethodsUtil = function (Class, base, methods, attribute) {\n\t  forIn(methods, function (length, method) {\n\t    if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);\n\t  });\n\t};\n\n\t// Support `collection.sortBy('attr')`.\n\tvar cb = function (iteratee, instance) {\n\t  if (isFunction(iteratee)) return iteratee;\n\t  if (isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n\t  if (isString(iteratee)) return function (model) {\n\t    return model.get(iteratee);\n\t  };\n\t  return iteratee;\n\t};\n\tvar modelMatcher = function (attrs) {\n\t  var matcher = matches(attrs);\n\t  return function (model) {\n\t    return matcher(model.attributes);\n\t  };\n\t};\n\n\t// Model\n\t// --------------\n\n\t// **Models** are the basic data object in the framework --\n\t// frequently representing a row in a table in a database on your server.\n\t// A discrete chunk of data and a bunch of useful, related methods for\n\t// performing computations and transformations on that data.\n\n\t// Create a new model with the specified attributes. A client id (`cid`)\n\t// is automatically generated and assigned for you.\n\n\tvar Model = function (attributes, options) {\n\t  var attrs = attributes || {};\n\t  options || (options = {});\n\t  this.eventPrefix = options.eventPrefix || '';\n\t  this.preinitialize.apply(this, arguments);\n\t  this.cid = uniqueId(this.cidPrefix);\n\t  this.attributes = {};\n\t  if (options.collection) this.collection = options.collection;\n\t  this._setDefaults(attrs, options);\n\t  this.changed = {};\n\t  this.initialize.apply(this, arguments);\n\t};\n\n\t// Attach all inheritable methods to the Model prototype.\n\tassign(Model.prototype, Events, {\n\t  // A hash of attributes whose current and previous value differ.\n\t  changed: null,\n\t  // The value returned during the last failed validation.\n\t  validationError: null,\n\t  // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n\t  // CouchDB users may want to set this to `\"_id\"`.\n\t  idAttribute: 'id',\n\t  // The prefix is used to create the client id which is used to identify models locally.\n\t  // You may want to override this if you're experiencing name clashes with model ids.\n\t  cidPrefix: 'c',\n\t  // preinitialize is an empty function by default. You can override it with a function\n\t  // or object.  preinitialize will run before any instantiation logic is run in the Model.\n\t  preinitialize: function () {\n\t    // No implementation.\n\t  },\n\t  // Initialize is an empty function by default. Override it with your own\n\t  // initialization logic.\n\t  initialize: function () {\n\t    // No implementation.\n\t  },\n\t  // Return a copy of the model's `attributes` object.\n\t  toJSON: function (options) {\n\t    return clone$1(this.attributes);\n\t  },\n\t  // Get the value of an attribute.\n\t  get: function (attr) {\n\t    return this.attributes[attr];\n\t  },\n\t  // Returns `true` if the attribute contains a value that is not null\n\t  // or undefined.\n\t  has: function (attr) {\n\t    return this.get(attr) != null;\n\t  },\n\t  // Set a hash of model attributes on the object, firing `\"change\"`. This is\n\t  // the core primitive operation of a model, updating the data and notifying\n\t  // anyone who needs to know about the change in state. The heart of the beast.\n\t  set: function (key, val, options) {\n\t    if (key == null) return this;\n\n\t    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\t    var attrs;\n\t    if (typeof key === 'object') {\n\t      attrs = key;\n\t      options = val;\n\t    } else {\n\t      (attrs = {})[key] = val;\n\t    }\n\t    options || (options = {});\n\n\t    // Run validation.\n\t    if (!this._validate(attrs, options)) return false;\n\n\t    // Extract attributes and options.\n\t    var unset = options.unset;\n\t    var silent = options.silent;\n\t    var changes = [];\n\t    var changing = this._changing;\n\t    this._changing = true;\n\t    if (!changing) {\n\t      this._previousAttributes = clone$1(this.attributes);\n\t      this.changed = {};\n\t    }\n\t    var current = this.attributes;\n\t    var changed = this.changed;\n\t    var prev = this._previousAttributes;\n\n\t    // For each `set` attribute, update or delete the current value.\n\t    for (var attr in attrs) {\n\t      val = attrs[attr];\n\t      if (!isEqual(current[attr], val)) changes.push(attr);\n\t      if (!isEqual(prev[attr], val)) {\n\t        changed[attr] = val;\n\t      } else {\n\t        delete changed[attr];\n\t      }\n\t      unset ? delete current[attr] : current[attr] = val;\n\t    }\n\n\t    // Update the `id`.\n\t    if (this.idAttribute in attrs) {\n\t      var prevId = this.id;\n\t      this.id = this.get(this.idAttribute);\n\t      if (this.id !== prevId) {\n\t        this.trigger(this.eventPrefix + 'changeId', this, prevId, options);\n\t      }\n\t    }\n\n\t    // Trigger all relevant attribute changes.\n\t    if (!silent) {\n\t      if (changes.length) this._pending = options;\n\t      for (var i = 0; i < changes.length; i++) {\n\t        this.trigger(this.eventPrefix + 'change:' + changes[i], this, current[changes[i]], options);\n\t      }\n\t    }\n\n\t    // You might be wondering why there's a `while` loop here. Changes can\n\t    // be recursively nested within `\"change\"` events.\n\t    if (changing) return this;\n\t    if (!silent) {\n\t      while (this._pending) {\n\t        options = this._pending;\n\t        this._pending = false;\n\t        this.trigger(this.eventPrefix + 'change', this, options);\n\t      }\n\t    }\n\t    this._pending = false;\n\t    this._changing = false;\n\t    return this;\n\t  },\n\t  // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n\t  // if the attribute doesn't exist.\n\t  unset: function (attr, options) {\n\t    return this.set(attr, void 0, assign({}, options, {\n\t      unset: true\n\t    }));\n\t  },\n\t  // Clear all attributes on the model, firing `\"change\"`.\n\t  clear: function (options) {\n\t    var attrs = {};\n\t    for (var key in this.attributes) attrs[key] = void 0;\n\t    return this.set(attrs, assign({}, options, {\n\t      unset: true\n\t    }));\n\t  },\n\t  // Determine if the model has changed since the last `\"change\"` event.\n\t  // If you specify an attribute name, determine if that attribute has changed.\n\t  hasChanged: function (attr) {\n\t    if (attr == null) return !isEmpty(this.changed);\n\t    return has(this.changed, attr);\n\t  },\n\t  // Return an object containing all the attributes that have changed, or\n\t  // false if there are no changed attributes. Useful for determining what\n\t  // parts of a view need to be updated and/or what attributes need to be\n\t  // persisted to the server. Unset attributes will be set to undefined.\n\t  // You can also pass an attributes object to diff against the model,\n\t  // determining if there *would be* a change.\n\t  changedAttributes: function (diff) {\n\t    if (!diff) return this.hasChanged() ? clone$1(this.changed) : false;\n\t    var old = this._changing ? this._previousAttributes : this.attributes;\n\t    var changed = {};\n\t    var hasChanged;\n\t    for (var attr in diff) {\n\t      var val = diff[attr];\n\t      if (isEqual(old[attr], val)) continue;\n\t      changed[attr] = val;\n\t      hasChanged = true;\n\t    }\n\t    return hasChanged ? changed : false;\n\t  },\n\t  // Get the previous value of an attribute, recorded at the time the last\n\t  // `\"change\"` event was fired.\n\t  previous: function (attr) {\n\t    if (attr == null || !this._previousAttributes) return null;\n\t    return this._previousAttributes[attr];\n\t  },\n\t  // Get all of the attributes of the model at the time of the previous\n\t  // `\"change\"` event.\n\t  previousAttributes: function () {\n\t    return clone$1(this._previousAttributes);\n\t  },\n\t  // Create a new model with identical attributes to this one.\n\t  clone: function () {\n\t    return new this.constructor(this.attributes);\n\t  },\n\t  // Check if the model is currently in a valid state.\n\t  isValid: function (options) {\n\t    return this._validate({}, assign({}, options, {\n\t      validate: true\n\t    }));\n\t  },\n\t  // Run validation against the next complete set of model attributes,\n\t  // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n\t  _validate: function (attrs, options) {\n\t    if (!options.validate || !this.validate) return true;\n\t    attrs = assign({}, this.attributes, attrs);\n\t    var error = this.validationError = this.validate(attrs, options) || null;\n\t    if (!error) return true;\n\t    this.trigger('invalid', this, error, assign(options, {\n\t      validationError: error\n\t    }));\n\t    return false;\n\t  },\n\t  _setDefaults: function (ctorAttributes, options) {\n\t    const attributeDefaults = result(this, 'defaults');\n\t    // Just _.defaults would work fine, but the additional _.extends\n\t    // is in there for historical reasons. See #3843.\n\t    const attributes = defaults(assign({}, attributeDefaults, ctorAttributes), attributeDefaults);\n\t    this.set(attributes, options);\n\t  }\n\t});\n\n\t// Set up inheritance for the model.\n\tModel.extend = extend;\n\n\t// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n\t// of clones is exactly the same as the `cells.length`.\n\t// This function simply clones all the `cells`. However, it also reconstructs\n\t// all the `source/target` and `parent/embed` references within the `cells`.\n\t// This is the main difference from the `cell.clone()` method. The\n\t// `cell.clone()` method works on one single cell only.\n\t// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n\t// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n\t// the source and target of the link `L2` is changed to point to `A2` and `B2`.\n\tfunction cloneCells(cells) {\n\t  cells = uniq(cells);\n\n\t  // A map of the form [original cell ID] -> [clone] helping\n\t  // us to reconstruct references for source/target and parent/embeds.\n\t  // This is also the returned value.\n\t  const cloneMap = toArray$1(cells).reduce(function (map, cell) {\n\t    map[cell.id] = cell.clone();\n\t    return map;\n\t  }, {});\n\t  toArray$1(cells).forEach(function (cell) {\n\t    const clone = cloneMap[cell.id];\n\t    // assert(clone exists)\n\n\t    if (clone.isLink()) {\n\t      const source = clone.source();\n\t      const target = clone.target();\n\t      if (source.id && cloneMap[source.id]) {\n\t        // Source points to an element and the element is among the clones.\n\t        // => Update the source of the cloned link.\n\t        clone.prop('source/id', cloneMap[source.id].id);\n\t      }\n\t      if (target.id && cloneMap[target.id]) {\n\t        // Target points to an element and the element is among the clones.\n\t        // => Update the target of the cloned link.\n\t        clone.prop('target/id', cloneMap[target.id].id);\n\t      }\n\t    }\n\n\t    // Find the parent of the original cell\n\t    const parent = cell.get('parent');\n\t    if (parent && cloneMap[parent]) {\n\t      clone.set('parent', cloneMap[parent].id);\n\t    }\n\n\t    // Find the embeds of the original cell\n\t    const embeds = toArray$1(cell.get('embeds')).reduce(function (newEmbeds, embed) {\n\t      // Embedded cells that are not being cloned can not be carried\n\t      // over with other embedded cells.\n\t      if (cloneMap[embed]) {\n\t        newEmbeds.push(cloneMap[embed].id);\n\t      }\n\t      return newEmbeds;\n\t    }, []);\n\t    if (!isEmpty(embeds)) {\n\t      clone.set('embeds', embeds);\n\t    }\n\t  });\n\t  return cloneMap;\n\t}\n\n\tconst validPropertiesList = ['checked', 'selected', 'disabled', 'readOnly', 'contentEditable', 'value', 'indeterminate'];\n\tconst validProperties = validPropertiesList.reduce((acc, key) => {\n\t  acc[key] = true;\n\t  return acc;\n\t}, {});\n\tconst props$1 = {\n\t  qualify: function (properties) {\n\t    return isPlainObject(properties);\n\t  },\n\t  set: function (properties, _, node) {\n\t    Object.keys(properties).forEach(function (key) {\n\t      if (validProperties[key] && key in node) {\n\t        const value = properties[key];\n\t        if (node.tagName === 'SELECT' && Array.isArray(value)) {\n\t          Array.from(node.options).forEach(function (option, index) {\n\t            option.selected = value.includes(option.value);\n\t          });\n\t        } else {\n\t          node[key] = value;\n\t        }\n\t      }\n\t    });\n\t  }\n\t};\n\n\tfunction positionWrapper(axis, dimension, origin) {\n\t  return function (value, refBBox) {\n\t    var valuePercentage = isPercentage(value);\n\t    value = parseFloat(value);\n\t    if (valuePercentage) {\n\t      value /= 100;\n\t    }\n\t    var delta;\n\t    if (isFinite(value)) {\n\t      var refOrigin = refBBox[origin]();\n\t      if (valuePercentage || value > 0 && value < 1) {\n\t        delta = refOrigin[axis] + refBBox[dimension] * value;\n\t      } else {\n\t        delta = refOrigin[axis] + value;\n\t      }\n\t    }\n\t    var point = Point();\n\t    point[axis] = delta || 0;\n\t    return point;\n\t  };\n\t}\n\tfunction setWrapper(attrName, dimension) {\n\t  return function (value, refBBox) {\n\t    var isValuePercentage = isPercentage(value);\n\t    value = parseFloat(value);\n\t    if (isValuePercentage) {\n\t      value /= 100;\n\t    }\n\t    var attrs = {};\n\t    if (isFinite(value)) {\n\t      var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n\t      attrs[attrName] = attrValue;\n\t    }\n\t    return attrs;\n\t  };\n\t}\n\tconst legacyAttributesNS = {\n\t  // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n\t  // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n\t  // otherwise, `refX` is the left coordinate of the bounding box\n\t  'ref-x': {\n\t    position: positionWrapper('x', 'width', 'origin')\n\t  },\n\t  'ref-y': {\n\t    position: positionWrapper('y', 'height', 'origin')\n\t  },\n\t  // `ref-dx` and `ref-dy` define the offset of the sub-element relative to the right and/or bottom\n\t  // coordinate of the reference element.\n\n\t  'ref-dx': {\n\t    position: positionWrapper('x', 'width', 'corner')\n\t  },\n\t  'ref-dy': {\n\t    position: positionWrapper('y', 'height', 'corner')\n\t  },\n\t  // 'ref-width'/'ref-height' defines the width/height of the sub-element relatively to\n\t  // the reference element size\n\t  // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n\t  // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n\t  'ref-width': {\n\t    set: setWrapper('width', 'width')\n\t  },\n\t  'ref-height': {\n\t    set: setWrapper('height', 'height')\n\t  },\n\t  'ref-rx': {\n\t    set: setWrapper('rx', 'width')\n\t  },\n\t  'ref-ry': {\n\t    set: setWrapper('ry', 'height')\n\t  },\n\t  'ref-cx': {\n\t    set: setWrapper('cx', 'width')\n\t  },\n\t  'ref-cy': {\n\t    set: setWrapper('cy', 'height')\n\t  },\n\t  'ref-r-inscribed': {\n\t    set: function (attrName) {\n\t      var widthFn = setWrapper(attrName, 'width');\n\t      var heightFn = setWrapper(attrName, 'height');\n\t      return function (value, refBBox) {\n\t        var fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n\t        return fn(value, refBBox);\n\t      };\n\t    }('r')\n\t  },\n\t  'ref-r-circumscribed': {\n\t    set: function (value, refBBox) {\n\t      var isValuePercentage = isPercentage(value);\n\t      value = parseFloat(value);\n\t      if (isValuePercentage) {\n\t        value /= 100;\n\t      }\n\t      var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n\t      var rValue;\n\t      if (isFinite(value)) {\n\t        if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;else rValue = Math.max(value + diagonalLength, 0);\n\t      }\n\t      return {\n\t        r: rValue\n\t      };\n\t    }\n\t  }\n\t};\n\n\t// NOTE: refX & refY are SVG attributes that define the reference point of the marker.\n\t// That's why we need to define both variants: `refX` and `ref-x` (and `refY` and `ref-y`).\n\tlegacyAttributesNS['refX'] = legacyAttributesNS['ref-x'];\n\tlegacyAttributesNS['refY'] = legacyAttributesNS['ref-y'];\n\n\t// This allows to combine both absolute and relative positioning\n\t// refX: 50%, refX2: 20\n\tlegacyAttributesNS['ref-x2'] = legacyAttributesNS['ref-x'];\n\tlegacyAttributesNS['ref-y2'] = legacyAttributesNS['ref-y'];\n\tlegacyAttributesNS['ref-width2'] = legacyAttributesNS['ref-width'];\n\tlegacyAttributesNS['ref-height2'] = legacyAttributesNS['ref-height'];\n\n\t// Aliases\n\tlegacyAttributesNS['ref-r'] = legacyAttributesNS['ref-r-inscribed'];\n\n\tconst props = {\n\t  x: 'x',\n\t  y: 'y',\n\t  width: 'w',\n\t  height: 'h',\n\t  minimum: 's',\n\t  maximum: 'l',\n\t  diagonal: 'd'\n\t};\n\tconst propsList = Object.keys(props).map(key => props[key]).join('');\n\tconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\n\tconst findSpacesRegex = /\\s/g;\n\tconst parseFormulaRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, 'g');\n\tfunction throwInvalid(expression) {\n\t  throw new Error(`Invalid calc() expression: ${expression}`);\n\t}\n\n\t/*\n\t* Evaluate the given calc formula.\n\t* e.g. 'w + 10' in a rect 100x100 -> 110\n\t*/\n\tfunction evalCalcFormula(formula, rect) {\n\t  const match = parseFormulaRegExp.exec(formula.replace(findSpacesRegex, ''));\n\t  if (!match) throwInvalid(formula);\n\t  parseFormulaRegExp.lastIndex = 0; // reset regex results for the next run\n\t  const [, multiply, property, divide, add] = match;\n\t  const {\n\t    x,\n\t    y,\n\t    width,\n\t    height\n\t  } = rect;\n\t  let value = 0;\n\t  switch (property) {\n\t    case props.width:\n\t      {\n\t        value = width;\n\t        break;\n\t      }\n\t    case props.height:\n\t      {\n\t        value = height;\n\t        break;\n\t      }\n\t    case props.x:\n\t      {\n\t        value = x;\n\t        break;\n\t      }\n\t    case props.y:\n\t      {\n\t        value = y;\n\t        break;\n\t      }\n\t    case props.minimum:\n\t      {\n\t        value = Math.min(height, width);\n\t        break;\n\t      }\n\t    case props.maximum:\n\t      {\n\t        value = Math.max(height, width);\n\t        break;\n\t      }\n\t    case props.diagonal:\n\t      {\n\t        value = Math.sqrt(height * height + width * width);\n\t        break;\n\t      }\n\t  }\n\t  if (multiply) {\n\t    // e.g \"2*\"\n\t    value *= parseFloat(multiply);\n\t  }\n\t  if (divide) {\n\t    // e.g \"/2\"\n\t    value /= parseFloat(divide.slice(1));\n\t  }\n\t  if (add) {\n\t    value += evalAddExpression(add);\n\t  }\n\t  return value;\n\t}\n\tfunction evalAddExpression(addExpression) {\n\t  if (!addExpression) return 0;\n\t  const [sign] = addExpression;\n\t  switch (sign) {\n\t    case '+':\n\t      {\n\t        return parseFloat(addExpression.substr(1));\n\t      }\n\t    case '-':\n\t      {\n\t        return -parseFloat(addExpression.substr(1));\n\t      }\n\t  }\n\t  return parseFloat(addExpression);\n\t}\n\n\t/*\n\t* Check if the given value is a calc expression.\n\t* e.g. 'calc(10 + 100)' -> true\n\t*/\n\tfunction isCalcExpression(value) {\n\t  return typeof value === 'string' && value.includes('calc');\n\t}\n\tconst calcStart = 'calc(';\n\tconst calcStartOffset = calcStart.length;\n\n\t/*\n\t* Evaluate all calc formulas in the given expression.\n\t* e.g. 'calc(w + 10)' in rect 100x100 -> '110'\n\t*/\n\tfunction evalCalcExpression(expression, rect) {\n\t  let value = expression;\n\t  let startSearchIndex = 0;\n\t  do {\n\t    const calcIndex = value.indexOf(calcStart, startSearchIndex);\n\t    if (calcIndex === -1) return value;\n\t    let calcEndIndex = calcIndex + calcStartOffset;\n\t    let brackets = 1;\n\t    findClosingBracket: do {\n\t      switch (value[calcEndIndex]) {\n\t        case '(':\n\t          {\n\t            brackets++;\n\t            break;\n\t          }\n\t        case ')':\n\t          {\n\t            brackets--;\n\t            if (brackets === 0) break findClosingBracket;\n\t            break;\n\t          }\n\t        case undefined:\n\t          {\n\t            // Could not find the closing bracket.\n\t            throwInvalid(value);\n\t          }\n\t      }\n\t      calcEndIndex++;\n\t    } while (true);\n\t    // Get the calc() expression without nested calcs (recursion)\n\t    let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n\t    if (isCalcExpression(expression)) {\n\t      expression = evalCalcExpression(expression, rect);\n\t    }\n\t    // Eval the calc() expression without nested calcs.\n\t    const calcValue = String(evalCalcFormula(expression, rect));\n\t    // Replace the calc() expression and continue search\n\t    value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n\t    startSearchIndex = calcIndex + calcValue.length;\n\t  } while (true);\n\t}\n\n\tfunction isTextInUse(_value, _node, attrs) {\n\t  return attrs.text !== undefined;\n\t}\n\tconst FONT_ATTRIBUTES = ['font-weight', 'font-family', 'font-size', 'letter-spacing', 'text-transform'];\n\tconst textAttributesNS = {\n\t  'line-height': {\n\t    qualify: isTextInUse\n\t  },\n\t  'text-vertical-anchor': {\n\t    qualify: isTextInUse\n\t  },\n\t  'text-path': {\n\t    qualify: isTextInUse\n\t  },\n\t  'annotations': {\n\t    qualify: isTextInUse\n\t  },\n\t  'eol': {\n\t    qualify: isTextInUse\n\t  },\n\t  'display-empty': {\n\t    qualify: isTextInUse\n\t  },\n\t  'text': {\n\t    qualify: function (_text, _node, attrs) {\n\t      const textWrap = attrs['text-wrap'];\n\t      return !textWrap || !isPlainObject(textWrap);\n\t    },\n\t    unset: function (node) {\n\t      node.textContent = '';\n\t    },\n\t    set: function (text, refBBox, node, attrs) {\n\t      const cacheName = 'joint-text';\n\t      const cache = $.data.get(node, cacheName);\n\t      const lineHeight = attrs['line-height'];\n\t      const textVerticalAnchor = attrs['text-vertical-anchor'];\n\t      const displayEmpty = attrs['display-empty'];\n\t      const fontSize = attrs['font-size'];\n\t      const annotations = attrs.annotations;\n\t      const eol = attrs.eol;\n\t      const x = attrs.x;\n\t      let textPath = attrs['text-path'];\n\t      const useNoBreakSpace = attrs['use-no-break-space'] === true;\n\t      // Update the text only if there was a change in the string\n\t      // or any of its attributes.\n\t      const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize, useNoBreakSpace]);\n\t      if (cache === undefined || cache !== textHash) {\n\t        // Chrome bug:\n\t        // <tspan> positions defined as `em` are not updated\n\t        // when container `font-size` change.\n\t        if (fontSize) node.setAttribute('font-size', fontSize);\n\t        // Text Along Path Selector\n\t        if (isObject(textPath)) {\n\t          const pathSelector = textPath.selector;\n\t          if (typeof pathSelector === 'string') {\n\t            const pathNode = this.findNode(pathSelector);\n\t            if (pathNode instanceof SVGPathElement) {\n\t              textPath = assign({\n\t                'xlink:href': '#' + pathNode.id\n\t              }, textPath);\n\t            }\n\t          }\n\t        }\n\t        V(node).text('' + text, {\n\t          lineHeight,\n\t          annotations,\n\t          textPath,\n\t          x,\n\t          textVerticalAnchor,\n\t          eol,\n\t          displayEmpty,\n\t          useNoBreakSpace\n\t        });\n\t        $.data.set(node, cacheName, textHash);\n\t      }\n\t    }\n\t  },\n\t  'text-wrap': {\n\t    qualify: isPlainObject,\n\t    set: function (value, refBBox, node, attrs) {\n\t      var size = {};\n\t      // option `width`\n\t      var width = value.width || 0;\n\t      if (isPercentage(width)) {\n\t        size.width = refBBox.width * parseFloat(width) / 100;\n\t      } else if (isCalcExpression(width)) {\n\t        size.width = Number(evalCalcExpression(width, refBBox));\n\t      } else {\n\t        if (value.width === null) {\n\t          // breakText() requires width to be specified.\n\t          size.width = Infinity;\n\t        } else if (width <= 0) {\n\t          size.width = refBBox.width + width;\n\t        } else {\n\t          size.width = width;\n\t        }\n\t      }\n\t      // option `height`\n\t      var height = value.height || 0;\n\t      if (isPercentage(height)) {\n\t        size.height = refBBox.height * parseFloat(height) / 100;\n\t      } else if (isCalcExpression(height)) {\n\t        size.height = Number(evalCalcExpression(height, refBBox));\n\t      } else {\n\t        if (value.height === null) {\n\t          // if height is not specified breakText() does not\n\t          // restrict the height of the text.\n\t        } else if (height <= 0) {\n\t          size.height = refBBox.height + height;\n\t        } else {\n\t          size.height = height;\n\t        }\n\t      }\n\t      // option `text`\n\t      var wrappedText;\n\t      var text = value.text;\n\t      if (text === undefined) text = attrs.text;\n\t      if (text !== undefined) {\n\t        const breakTextFn = value.breakText || breakText;\n\t        const computedStyles = getComputedStyle(node);\n\t        const wrapFontAttributes = {};\n\t        // The font size attributes must be set on the node\n\t        // to get the correct text wrapping.\n\t        // TODO: set the native SVG attributes before special attributes\n\t        for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {\n\t          const name = FONT_ATTRIBUTES[i];\n\t          if (name in attrs) {\n\t            node.setAttribute(name, attrs[name]);\n\t          }\n\t          // Note: computedStyles is a live object\n\t          // i.e. the properties are evaluated when accessed.\n\t          wrapFontAttributes[name] = computedStyles[name];\n\t        }\n\n\t        // The `line-height` attribute in SVG is JoinJS specific.\n\t        // TODO: change the `lineHeight` to breakText option.\n\t        wrapFontAttributes.lineHeight = attrs['line-height'];\n\t        let svgDocument = this.paper.svg;\n\t        if (!svgDocument.checkVisibility()) {\n\t          // If the paper is visible, we can utilize\n\t          // its SVG element to measure the text size\n\t          // when breaking the text.\n\t          // Otherwise, we need to create a temporary\n\t          // SVG document and append it to the DOM,\n\t          // (the default behavior of `breakText`).\n\t          svgDocument = null;\n\t        }\n\t        wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {\n\t          svgDocument,\n\t          ellipsis: value.ellipsis,\n\t          hyphen: value.hyphen,\n\t          separator: value.separator,\n\t          maxLineCount: value.maxLineCount,\n\t          preserveSpaces: value.preserveSpaces\n\t        });\n\t      } else {\n\t        wrappedText = '';\n\t      }\n\t      textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n\t    },\n\t    // We expose the font attributes list to allow\n\t    // the user to take other custom font attributes into account\n\t    // when wrapping the text.\n\t    FONT_ATTRIBUTES\n\t  },\n\t  'title': {\n\t    qualify: function (title, node) {\n\t      // HTMLElement title is specified via an attribute (i.e. not an element)\n\t      return node instanceof SVGElement;\n\t    },\n\t    unset: function (node) {\n\t      $.data.remove(node, 'joint-title');\n\t      const titleNode = node.firstElementChild;\n\t      if (titleNode) {\n\t        titleNode.remove();\n\t      }\n\t    },\n\t    set: function (title, refBBox, node) {\n\t      var cacheName = 'joint-title';\n\t      var cache = $.data.get(node, cacheName);\n\t      if (cache === undefined || cache !== title) {\n\t        $.data.set(node, cacheName, title);\n\t        if (node.tagName === 'title') {\n\t          // The target node is a <title> element.\n\t          node.textContent = title;\n\t          return;\n\t        }\n\t        // Generally <title> element should be the first child element of its parent.\n\t        var firstChild = node.firstElementChild;\n\t        if (firstChild && firstChild.tagName === 'title') {\n\t          // Update an existing title\n\t          firstChild.textContent = title;\n\t        } else {\n\t          // Create a new title\n\t          var titleNode = document.createElementNS(node.namespaceURI, 'title');\n\t          titleNode.textContent = title;\n\t          node.insertBefore(titleNode, firstChild);\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\n\tfunction atConnectionWrapper(method, opt) {\n\t  var zeroVector = new Point(1, 0);\n\t  return function (value) {\n\t    var p, angle;\n\t    var tangent = this[method](value);\n\t    if (tangent) {\n\t      angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n\t      p = tangent.start;\n\t    } else {\n\t      p = this.path.start;\n\t      angle = 0;\n\t    }\n\t    if (angle === 0) return {\n\t      transform: 'translate(' + p.x + ',' + p.y + ')'\n\t    };\n\t    return {\n\t      transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')'\n\t    };\n\t  };\n\t}\n\tfunction isLinkView() {\n\t  return this.model.isLink();\n\t}\n\tconst connectionAttributesNS = {\n\t  'connection': {\n\t    qualify: isLinkView,\n\t    unset: 'd',\n\t    set: function ({\n\t      stubs = 0\n\t    }) {\n\t      let d;\n\t      if (isFinite(stubs) && stubs !== 0) {\n\t        let offset;\n\t        if (stubs < 0) {\n\t          offset = (this.getConnectionLength() + stubs) / 2;\n\t        } else {\n\t          offset = stubs;\n\t        }\n\t        const path = this.getConnection();\n\t        const segmentSubdivisions = this.getConnectionSubdivisions();\n\t        const sourceParts = path.divideAtLength(offset, {\n\t          segmentSubdivisions\n\t        });\n\t        const targetParts = path.divideAtLength(-offset, {\n\t          segmentSubdivisions\n\t        });\n\t        if (sourceParts && targetParts) {\n\t          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n\t        }\n\t      }\n\t      return {\n\t        d: d || this.getSerializedConnection()\n\t      };\n\t    }\n\t  },\n\t  'at-connection-length-keep-gradient': {\n\t    qualify: isLinkView,\n\t    unset: 'transform',\n\t    set: atConnectionWrapper('getTangentAtLength', {\n\t      rotate: true\n\t    })\n\t  },\n\t  'at-connection-length-ignore-gradient': {\n\t    qualify: isLinkView,\n\t    unset: 'transform',\n\t    set: atConnectionWrapper('getTangentAtLength', {\n\t      rotate: false\n\t    })\n\t  },\n\t  'at-connection-ratio-keep-gradient': {\n\t    qualify: isLinkView,\n\t    unset: 'transform',\n\t    set: atConnectionWrapper('getTangentAtRatio', {\n\t      rotate: true\n\t    })\n\t  },\n\t  'at-connection-ratio-ignore-gradient': {\n\t    qualify: isLinkView,\n\t    unset: 'transform',\n\t    set: atConnectionWrapper('getTangentAtRatio', {\n\t      rotate: false\n\t    })\n\t  }\n\t};\n\tconnectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];\n\tconnectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];\n\n\tfunction shapeWrapper(shapeConstructor, opt) {\n\t  var cacheName = 'joint-shape';\n\t  var resetOffset = opt && opt.resetOffset;\n\t  return function (value, refBBox, node) {\n\t    var cache = $.data.get(node, cacheName);\n\t    if (!cache || cache.value !== value) {\n\t      // only recalculate if value has changed\n\t      var cachedShape = shapeConstructor(value);\n\t      cache = {\n\t        value: value,\n\t        shape: cachedShape,\n\t        shapeBBox: cachedShape.bbox()\n\t      };\n\t      $.data.set(node, cacheName, cache);\n\t    }\n\t    var shape = cache.shape.clone();\n\t    var shapeBBox = cache.shapeBBox.clone();\n\t    var shapeOrigin = shapeBBox.origin();\n\t    var refOrigin = refBBox.origin();\n\t    shapeBBox.x = refOrigin.x;\n\t    shapeBBox.y = refOrigin.y;\n\t    var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n\t    // `maxRectScaleToFit` can give Infinity if width or height is 0\n\t    var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n\t    var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n\t    shape.scale(sx, sy, shapeOrigin);\n\t    if (resetOffset) {\n\t      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n\t    }\n\t    return shape;\n\t  };\n\t}\n\n\t// `d` attribute for SVGPaths\n\tfunction dWrapper(opt) {\n\t  function pathConstructor(value) {\n\t    return new Path$1(V.normalizePathData(value));\n\t  }\n\t  var shape = shapeWrapper(pathConstructor, opt);\n\t  return function (value, refBBox, node) {\n\t    var path = shape(value, refBBox, node);\n\t    return {\n\t      d: path.serialize()\n\t    };\n\t  };\n\t}\n\n\t// `points` attribute for SVGPolylines and SVGPolygons\n\tfunction pointsWrapper(opt) {\n\t  var shape = shapeWrapper(Polyline$1, opt);\n\t  return function (value, refBBox, node) {\n\t    var polyline = shape(value, refBBox, node);\n\t    return {\n\t      points: polyline.serialize()\n\t    };\n\t  };\n\t}\n\tconst shapeAttributesNS = {\n\t  'ref-d-reset-offset': {\n\t    unset: 'd',\n\t    set: dWrapper({\n\t      resetOffset: true\n\t    })\n\t  },\n\t  'ref-d-keep-offset': {\n\t    unset: 'd',\n\t    set: dWrapper({\n\t      resetOffset: false\n\t    })\n\t  },\n\t  'ref-points-reset-offset': {\n\t    unset: 'points',\n\t    set: pointsWrapper({\n\t      resetOffset: true\n\t    })\n\t  },\n\t  'ref-points-keep-offset': {\n\t    unset: 'points',\n\t    set: pointsWrapper({\n\t      resetOffset: false\n\t    })\n\t  }\n\t};\n\n\t// Aliases\n\tshapeAttributesNS['ref-d'] = shapeAttributesNS['ref-d-reset-offset'];\n\tshapeAttributesNS['ref-points'] = shapeAttributesNS['ref-points-reset-offset'];\n\n\tfunction contextMarker(context) {\n\t  var marker = {};\n\t  // Stroke\n\t  // The context 'fill' is disregarded here. The usual case is to use the marker with a connection\n\t  // (for which 'fill' attribute is set to 'none').\n\t  var stroke = context.stroke;\n\t  if (typeof stroke === 'string') {\n\t    marker['stroke'] = stroke;\n\t    marker['fill'] = stroke;\n\t  }\n\t  // Opacity\n\t  // Again the context 'fill-opacity' is ignored.\n\t  var strokeOpacity = context['stroke-opacity'];\n\t  if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n\t  if (strokeOpacity !== undefined) {\n\t    marker['stroke-opacity'] = strokeOpacity;\n\t    marker['fill-opacity'] = strokeOpacity;\n\t  }\n\t  return marker;\n\t}\n\tfunction setPaintURL(def) {\n\t  const {\n\t    paper\n\t  } = this;\n\t  const url = def.type === 'pattern' ? paper.definePattern(def) : paper.defineGradient(def);\n\t  return `url(#${url})`;\n\t}\n\tconst defsAttributesNS = {\n\t  'source-marker': {\n\t    qualify: isPlainObject,\n\t    unset: 'marker-start',\n\t    set: function (marker, refBBox, node, attrs) {\n\t      marker = assign(contextMarker(attrs), marker);\n\t      return {\n\t        'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')'\n\t      };\n\t    }\n\t  },\n\t  'target-marker': {\n\t    qualify: isPlainObject,\n\t    unset: 'marker-end',\n\t    set: function (marker, refBBox, node, attrs) {\n\t      marker = assign(contextMarker(attrs), {\n\t        'transform': 'rotate(180)'\n\t      }, marker);\n\t      return {\n\t        'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')'\n\t      };\n\t    }\n\t  },\n\t  'vertex-marker': {\n\t    qualify: isPlainObject,\n\t    unset: 'marker-mid',\n\t    set: function (marker, refBBox, node, attrs) {\n\t      marker = assign(contextMarker(attrs), marker);\n\t      return {\n\t        'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')'\n\t      };\n\t    }\n\t  },\n\t  'fill': {\n\t    qualify: isPlainObject,\n\t    set: setPaintURL\n\t  },\n\t  'stroke': {\n\t    qualify: isPlainObject,\n\t    set: setPaintURL\n\t  },\n\t  'filter': {\n\t    qualify: isPlainObject,\n\t    set: function (filter) {\n\t      return 'url(#' + this.paper.defineFilter(filter) + ')';\n\t    }\n\t  }\n\t};\n\n\t// Offset attributes require the cell view to be rendered before they can be applied\n\t// (they must be appended to the DOM).\n\n\tfunction offsetWrapper(axis, dimension, corner) {\n\t  return function (value, nodeBBox) {\n\t    var delta;\n\t    if (value === 'middle') {\n\t      delta = nodeBBox[dimension] / 2;\n\t    } else if (value === corner) {\n\t      delta = nodeBBox[dimension];\n\t    } else if (isFinite(value)) {\n\t      // TODO: or not to do a breaking change?\n\t      delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;\n\t    } else if (isPercentage(value)) {\n\t      delta = nodeBBox[dimension] * parseFloat(value) / 100;\n\t    } else {\n\t      delta = 0;\n\t    }\n\t    var point = new Point();\n\t    point[axis] = -(nodeBBox[axis] + delta);\n\t    return point;\n\t  };\n\t}\n\tconst offsetAttributesNS = {\n\t  // `x-alignment` when set to `middle` causes centering of the sub-element around its new x coordinate.\n\t  // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n\t  'x-alignment': {\n\t    offset: offsetWrapper('x', 'width', 'right')\n\t  },\n\t  // `y-alignment` when set to `middle` causes centering of the sub-element around its new y coordinate.\n\t  // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n\t  'y-alignment': {\n\t    offset: offsetWrapper('y', 'height', 'bottom')\n\t  },\n\t  'reset-offset': {\n\t    offset: function (val, nodeBBox) {\n\t      return val ? {\n\t        x: -nodeBBox.x,\n\t        y: -nodeBBox.y\n\t      } : {\n\t        x: 0,\n\t        y: 0\n\t      };\n\t    }\n\t  }\n\t};\n\n\tfunction setIfChangedWrapper(attribute) {\n\t  return function setIfChanged(value, _, node) {\n\t    const vel = V(node);\n\t    if (vel.attr(attribute) === value) return;\n\t    vel.attr(attribute, value);\n\t  };\n\t}\n\tconst attributesNS = {\n\t  'ref': {\n\t    // We do not set `ref` attribute directly on an element.\n\t    // The attribute itself does not qualify for relative positioning.\n\t  },\n\t  'href': {\n\t    set: setIfChangedWrapper('href')\n\t  },\n\t  'xlink:href': {\n\t    set: setIfChangedWrapper('xlink:href')\n\t  },\n\t  // `port` attribute contains the `id` of the port that the underlying magnet represents.\n\t  'port': {\n\t    set: function (port) {\n\t      return port === null || port.id === undefined ? port : port.id;\n\t    }\n\t  },\n\t  // `style` attribute is special in the sense that it sets the CSS style of the sub-element.\n\t  'style': {\n\t    qualify: isPlainObject,\n\t    set: function (styles, refBBox, node) {\n\t      $(node).css(styles);\n\t    }\n\t  },\n\t  'html': {\n\t    unset: function (node) {\n\t      $(node).empty();\n\t    },\n\t    set: function (html, refBBox, node) {\n\t      $(node).html(html + '');\n\t    }\n\t  },\n\t  // Properties setter (set various properties on the node)\n\t  props: props$1\n\t};\n\tassign(attributesNS, legacyAttributesNS);\n\tassign(attributesNS, textAttributesNS);\n\tassign(attributesNS, connectionAttributesNS);\n\tassign(attributesNS, shapeAttributesNS);\n\tassign(attributesNS, defsAttributesNS);\n\tassign(attributesNS, offsetAttributesNS);\n\tconst attributes = attributesNS;\n\n\t// Internal tags to identify objects as specific JointJS types.\n\t// Used instead of `instanceof` for performance and cross-frame safety.\n\n\t// dia.Cell\n\tconst CELL_MARKER = Symbol('joint.cellMarker');\n\n\t// dia.CellCollection\n\tconst CELL_COLLECTION_MARKER = Symbol('joint.cellCollectionMarker');\n\n\t// dia.GraphLayer\n\tconst GRAPH_LAYER_MARKER = Symbol('joint.graphLayerMarker');\n\n\t// dia.GraphLayerCollection\n\tconst GRAPH_LAYER_COLLECTION_MARKER = Symbol('joint.graphLayerCollectionMarker');\n\n\t// dia.CellView\n\tconst CELL_VIEW_MARKER = Symbol('joint.cellViewMarker');\n\n\t// dia.LayerView\n\tconst LAYER_VIEW_MARKER = Symbol('joint.layerViewMarker');\n\n\t// dia.GraphLayerView\n\tconst GRAPH_LAYER_VIEW_MARKER = Symbol('joint.graphLayerViewMarker');\n\n\t// Cell base model.\n\t// --------------------------\n\n\tconst attributesMerger = function (a, b) {\n\t  if (Array.isArray(a)) {\n\t    return cloneDeep(b);\n\t  }\n\t};\n\tfunction removeEmptyAttributes(obj) {\n\t  // Remove toplevel empty attributes\n\t  for (const key in obj) {\n\t    const objValue = obj[key];\n\t    const isRealObject = isObject(objValue) && !Array.isArray(objValue);\n\t    if (!isRealObject) continue;\n\t    if (isEmpty(objValue)) {\n\t      delete obj[key];\n\t    }\n\t  }\n\t}\n\tconst Cell = Model.extend({\n\t  cidPrefix: 'c',\n\t  // Default attributes are merged deeply instead of shallowly.\n\t  _setDefaults: function (ctorAttributes, options) {\n\t    let attributes;\n\t    const attributeDefaults = result(this, 'defaults');\n\t    if (attributeDefaults) {\n\t      const customizer = options && options.mergeArrays === true ? false : config$3.cellDefaultsMergeStrategy || attributesMerger;\n\t      attributes = merge({}, attributeDefaults, ctorAttributes, customizer);\n\t    } else {\n\t      attributes = ctorAttributes;\n\t    }\n\t    this.set(attributes, options);\n\t  },\n\t  translate: function (dx, dy, opt) {\n\t    throw new Error('Must define a translate() method.');\n\t  },\n\t  toJSON: function (opt) {\n\t    const {\n\t      ignoreDefaults,\n\t      ignoreEmptyAttributes = false\n\t    } = opt || {};\n\t    const defaults = result(this.constructor.prototype, 'defaults');\n\t    if (ignoreDefaults === false) {\n\t      // Return all attributes without omitting the defaults\n\t      const finalAttributes = cloneDeep(this.attributes);\n\t      if (!ignoreEmptyAttributes) return finalAttributes;\n\t      removeEmptyAttributes(finalAttributes);\n\t      return finalAttributes;\n\t    }\n\t    let defaultAttributes = {};\n\t    const attributes = cloneDeep(this.attributes);\n\t    if (ignoreDefaults === true) {\n\t      // Compare all attributes with the defaults\n\t      defaultAttributes = defaults;\n\t    } else {\n\t      // Compare only the specified attributes with the defaults, use `attrs` as a default if not specified\n\t      const differentiateKeys = Array.isArray(ignoreDefaults) ? ignoreDefaults : ['attrs'];\n\t      differentiateKeys.forEach(key => {\n\t        defaultAttributes[key] = defaults[key] || {};\n\t      });\n\t    }\n\n\t    // Omit `id` and `type` attribute from the defaults since it should be always present\n\t    const finalAttributes = objectDifference(attributes, omit(defaultAttributes, 'id', 'type'), {\n\t      maxDepth: 4\n\t    });\n\t    if (ignoreEmptyAttributes) {\n\t      removeEmptyAttributes(finalAttributes);\n\t    }\n\t    return finalAttributes;\n\t  },\n\t  initialize: function (attributes) {\n\t    const idAttribute = this.getIdAttribute();\n\t    if (!attributes || attributes[idAttribute] === undefined) {\n\t      this.set(idAttribute, this.generateId(), {\n\t        silent: true\n\t      });\n\t    }\n\t    this._transitionIds = {};\n\t    this._scheduledTransitionIds = {};\n\n\t    // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n\t    this.processPorts();\n\t    this.on('change:attrs', this.processPorts, this);\n\t  },\n\t  getIdAttribute: function () {\n\t    return this.idAttribute || 'id';\n\t  },\n\t  generateId: function () {\n\t    return uuid();\n\t  },\n\t  /**\n\t   * @deprecated\n\t   */\n\t  processPorts: function () {\n\t    // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n\t    // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n\t    // set to that port, we remove those links as well (to follow the same behaviour as\n\t    // with a removed element).\n\n\t    var previousPorts = this.ports;\n\n\t    // Collect ports from the `attrs` object.\n\t    var ports = {};\n\t    forIn(this.get('attrs'), function (attrs, selector) {\n\t      if (attrs && attrs.port) {\n\t        // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n\t        if (attrs.port.id !== undefined) {\n\t          ports[attrs.port.id] = attrs.port;\n\t        } else {\n\t          ports[attrs.port] = {\n\t            id: attrs.port\n\t          };\n\t        }\n\t      }\n\t    });\n\n\t    // Collect ports that have been removed (compared to the previous ports) - if any.\n\t    // Use hash table for quick lookup.\n\t    var removedPorts = {};\n\t    forIn(previousPorts, function (port, id) {\n\t      if (!ports[id]) removedPorts[id] = true;\n\t    });\n\n\t    // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n\t    if (this.graph && !isEmpty(removedPorts)) {\n\t      var inboundLinks = this.graph.getConnectedLinks(this, {\n\t        inbound: true\n\t      });\n\t      inboundLinks.forEach(function (link) {\n\t        if (removedPorts[link.get('target').port]) link.remove();\n\t      });\n\t      var outboundLinks = this.graph.getConnectedLinks(this, {\n\t        outbound: true\n\t      });\n\t      outboundLinks.forEach(function (link) {\n\t        if (removedPorts[link.get('source').port]) link.remove();\n\t      });\n\t    }\n\n\t    // Update the `ports` object.\n\t    this.ports = ports;\n\t  },\n\t  remove: function (opt = {}) {\n\t    const {\n\t      graph,\n\t      collection\n\t    } = this;\n\t    // If the cell is part of a graph, remove it using the graph API.\n\t    // To make sure the cell is removed in a batch operation.\n\t    if (graph) {\n\t      graph.removeCell(this, opt);\n\t    } else {\n\t      // The collection is a common mvc collection (not the graph collection).\n\t      if (collection) collection.remove(this, opt);\n\t    }\n\t    return this;\n\t  },\n\t  toFront: function (opt) {\n\t    const {\n\t      graph\n\t    } = this;\n\t    if (graph) {\n\t      opt = defaults(opt || {}, {\n\t        foregroundEmbeds: true\n\t      });\n\t      let cells;\n\t      if (opt.deep) {\n\t        cells = this.getEmbeddedCells({\n\t          deep: true,\n\t          breadthFirst: opt.breadthFirst !== false,\n\t          sortSiblings: opt.foregroundEmbeds\n\t        });\n\t        cells.unshift(this);\n\t      } else {\n\t        cells = [this];\n\t      }\n\t      const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n\t      const layerId = graph.getCellLayerId(this);\n\t      const maxZ = graph.maxZIndex(layerId);\n\t      let z = maxZ - cells.length + 1;\n\t      const layerCells = graph.getLayer(layerId).cellCollection.toArray();\n\t      let shouldUpdate = layerCells.indexOf(sortedCells[0]) !== layerCells.length - cells.length;\n\t      if (!shouldUpdate) {\n\t        shouldUpdate = sortedCells.some(function (cell, index) {\n\t          return cell.z() !== z + index;\n\t        });\n\t      }\n\t      if (shouldUpdate) {\n\t        this.startBatch('to-front');\n\t        z = z + cells.length;\n\t        sortedCells.forEach(function (cell, index) {\n\t          cell.set('z', z + index, opt);\n\t        });\n\t        this.stopBatch('to-front');\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  toBack: function (opt) {\n\t    const {\n\t      graph\n\t    } = this;\n\t    if (graph) {\n\t      opt = defaults(opt || {}, {\n\t        foregroundEmbeds: true\n\t      });\n\t      let cells;\n\t      if (opt.deep) {\n\t        cells = this.getEmbeddedCells({\n\t          deep: true,\n\t          breadthFirst: opt.breadthFirst !== false,\n\t          sortSiblings: opt.foregroundEmbeds\n\t        });\n\t        cells.unshift(this);\n\t      } else {\n\t        cells = [this];\n\t      }\n\t      const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n\t      const layerId = graph.getCellLayerId(this);\n\t      let z = graph.minZIndex(layerId);\n\t      const layerCells = graph.getLayer(layerId).cellCollection.toArray();\n\t      let shouldUpdate = layerCells.indexOf(sortedCells[0]) !== 0;\n\t      if (!shouldUpdate) {\n\t        shouldUpdate = sortedCells.some(function (cell, index) {\n\t          return cell.z() !== z + index;\n\t        });\n\t      }\n\t      if (shouldUpdate) {\n\t        this.startBatch('to-back');\n\t        z -= cells.length;\n\t        sortedCells.forEach(function (cell, index) {\n\t          cell.set('z', z + index, opt);\n\t        });\n\t        this.stopBatch('to-back');\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  parent: function (parent, opt) {\n\t    // getter\n\t    if (parent === undefined) return this.get('parent');\n\t    // setter\n\t    return this.set('parent', parent, opt);\n\t  },\n\t  embed: function (cell, opt = {}) {\n\t    const cells = Array.isArray(cell) ? cell : [cell];\n\t    if (!this.canEmbed(cells)) {\n\t      throw new Error('Recursive embedding not allowed.');\n\t    }\n\t    if (opt.reparent) {\n\t      const parents = uniq(cells.map(c => c.getParentCell()));\n\n\t      // Unembed cells from their current parents.\n\t      parents.forEach(parent => {\n\t        // Cell doesn't have to be embedded.\n\t        if (!parent) return;\n\n\t        // Pass all the `cells` since the `dia.Cell._unembedCells` method can handle cases\n\t        // where not all elements of `cells` are embedded in the same parent.\n\t        parent._unembedCells(cells, opt);\n\t      });\n\t    } else if (cells.some(c => c.isEmbedded() && this.id !== c.parent())) {\n\t      throw new Error('Embedding of already embedded cells is not allowed.');\n\t    }\n\t    this._embedCells(cells, opt);\n\t    return this;\n\t  },\n\t  unembed: function (cell, opt) {\n\t    const cells = Array.isArray(cell) ? cell : [cell];\n\t    this._unembedCells(cells, opt);\n\t    return this;\n\t  },\n\t  canEmbed: function (cell) {\n\t    const cells = Array.isArray(cell) ? cell : [cell];\n\t    return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n\t  },\n\t  _embedCells: function (cells, opt) {\n\t    const batchName = 'embed';\n\t    this.startBatch(batchName);\n\t    const embeds = assign([], this.get('embeds'));\n\t    cells.forEach(cell => {\n\t      // We keep all element ids after link ids.\n\t      embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n\t      cell.parent(this.id, opt);\n\t    });\n\t    this.set('embeds', uniq(embeds), opt);\n\t    this.stopBatch(batchName);\n\t  },\n\t  _unembedCells: function (cells, opt) {\n\t    const batchName = 'unembed';\n\t    this.startBatch(batchName);\n\t    cells.forEach(cell => cell.unset('parent', opt));\n\t    this.set('embeds', without(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n\t    this.stopBatch(batchName);\n\t  },\n\t  getParentCell: function () {\n\t    // unlike link.source/target, cell.parent stores id directly as a string\n\t    var parentId = this.parent();\n\t    var graph = this.graph;\n\t    return parentId && graph && graph.getCell(parentId) || null;\n\t  },\n\t  // Return an array of ancestor cells.\n\t  // The array is ordered from the parent of the cell\n\t  // to the most distant ancestor.\n\t  getAncestors: function () {\n\t    var ancestors = [];\n\t    if (!this.graph) {\n\t      return ancestors;\n\t    }\n\t    var parentCell = this.getParentCell();\n\t    while (parentCell) {\n\t      ancestors.push(parentCell);\n\t      parentCell = parentCell.getParentCell();\n\t    }\n\t    return ancestors;\n\t  },\n\t  getEmbeddedCells: function (opt) {\n\t    opt = opt || {};\n\n\t    // Cell models can only be retrieved when this element is part of a collection.\n\t    // There is no way this element knows about other cells otherwise.\n\t    // This also means that calling e.g. `translate()` on an element with embeds before\n\t    // adding it to a graph does not translate its embeds.\n\t    if (!this.graph) {\n\t      return [];\n\t    }\n\t    if (opt.deep) {\n\t      if (opt.breadthFirst) {\n\t        return this._getEmbeddedCellsBfs(opt.sortSiblings);\n\t      } else {\n\t        return this._getEmbeddedCellsDfs(opt.sortSiblings);\n\t      }\n\t    }\n\t    const embeddedIds = this.get('embeds');\n\t    if (isEmpty(embeddedIds)) {\n\t      return [];\n\t    }\n\t    let cells = embeddedIds.map(this.graph.getCell, this.graph);\n\t    if (opt.sortSiblings) {\n\t      cells = sortBy(cells, cell => cell.z());\n\t    }\n\t    return cells;\n\t  },\n\t  _getEmbeddedCellsBfs: function (sortSiblings) {\n\t    const cells = [];\n\t    const queue = [];\n\t    queue.push(this);\n\t    while (queue.length > 0) {\n\t      const current = queue.shift();\n\t      cells.push(current);\n\t      const embeddedCells = current.getEmbeddedCells({\n\t        sortSiblings: sortSiblings\n\t      });\n\t      queue.push(...embeddedCells);\n\t    }\n\t    cells.shift();\n\t    return cells;\n\t  },\n\t  _getEmbeddedCellsDfs: function (sortSiblings) {\n\t    const cells = [];\n\t    const stack = [];\n\t    stack.push(this);\n\t    while (stack.length > 0) {\n\t      const current = stack.pop();\n\t      cells.push(current);\n\t      const embeddedCells = current.getEmbeddedCells({\n\t        sortSiblings: sortSiblings\n\t      });\n\n\t      // When using the stack, cells that are embedded last are processed first.\n\t      // To maintain the original order, we need to push the cells in reverse order\n\t      for (let i = embeddedCells.length - 1; i >= 0; --i) {\n\t        stack.push(embeddedCells[i]);\n\t      }\n\t    }\n\t    cells.shift();\n\t    return cells;\n\t  },\n\t  isEmbeddedIn: function (cell, opt) {\n\t    var cellId = isString(cell) ? cell : cell.id;\n\t    var parentId = this.parent();\n\t    opt = assign({\n\t      deep: true\n\t    }, opt);\n\n\t    // See getEmbeddedCells().\n\t    if (this.graph && opt.deep) {\n\t      while (parentId) {\n\t        if (parentId === cellId) {\n\t          return true;\n\t        }\n\t        parentId = this.graph.getCell(parentId).parent();\n\t      }\n\t      return false;\n\t    } else {\n\t      // When this cell is not part of a collection check\n\t      // at least whether it's a direct child of given cell.\n\t      return parentId === cellId;\n\t    }\n\t  },\n\t  // Whether or not the cell is embedded in any other cell.\n\t  isEmbedded: function () {\n\t    return !!this.parent();\n\t  },\n\t  // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n\t  // Shallow cloning simply clones the cell and returns a new cell with different ID.\n\t  // Deep cloning clones the cell and all its embedded cells recursively.\n\t  clone: function (opt) {\n\t    opt = opt || {};\n\t    if (!opt.deep) {\n\t      // Shallow cloning.\n\n\t      // Preserve the original's `portLayoutNamespace` and `portLabelLayoutNamespace`.\n\t      const clone = new this.constructor(this.attributes, {\n\t        portLayoutNamespace: this.portLayoutNamespace,\n\t        portLabelLayoutNamespace: this.portLabelLayoutNamespace\n\t      });\n\t      // We don't want the clone to have the same ID as the original.\n\t      clone.set(this.getIdAttribute(), this.generateId());\n\t      // A shallow cloned element does not carry over the original embeds.\n\t      clone.unset('embeds');\n\t      // And can not be embedded in any cell\n\t      // as the clone is not part of the graph.\n\t      clone.unset('parent');\n\t      return clone;\n\t    } else {\n\t      // Deep cloning.\n\n\t      // For a deep clone, simply call `util.cloneCells()` with the cell and all its embedded cells.\n\t      return toArray$1(cloneCells([this].concat(this.getEmbeddedCells({\n\t        deep: true\n\t      }))));\n\t    }\n\t  },\n\t  // A convenient way to set nested properties.\n\t  // This method merges the properties you'd like to set with the ones\n\t  // stored in the cell and makes sure change events are properly triggered.\n\t  // You can either set a nested property with one object\n\t  // or use a property path.\n\t  // The most simple use case is:\n\t  // `cell.prop('name/first', 'John')` or\n\t  // `cell.prop({ name: { first: 'John' } })`.\n\t  // Nested arrays are supported too:\n\t  // `cell.prop('series/0/data/0/degree', 50)` or\n\t  // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n\t  prop: function (props, value, opt) {\n\t    var delim = '/';\n\t    var _isString = isString(props);\n\t    if (_isString || Array.isArray(props)) {\n\t      // Get/set an attribute by a special path syntax that delimits\n\t      // nested objects by the colon character.\n\n\t      if (arguments.length > 1) {\n\t        var path;\n\t        var pathArray;\n\t        if (_isString) {\n\t          path = props;\n\t          pathArray = path.split('/');\n\t        } else {\n\t          path = props.join(delim);\n\t          pathArray = props.slice();\n\t        }\n\t        var property = pathArray[0];\n\t        var pathArrayLength = pathArray.length;\n\t        const options = opt || {};\n\t        options.propertyPath = path;\n\t        options.propertyValue = value;\n\t        options.propertyPathArray = pathArray;\n\t        if (!('rewrite' in options)) {\n\t          options.rewrite = false;\n\t        }\n\t        var update = {};\n\t        // Initialize the nested object. Sub-objects are either arrays or objects.\n\t        // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n\t        // Note that this imposes a limitation on object keys one can use with Inspector.\n\t        // Pure integer keys will cause issues and are therefore not allowed.\n\t        var initializer = update;\n\t        var prevProperty = property;\n\t        for (var i = 1; i < pathArrayLength; i++) {\n\t          var pathItem = pathArray[i];\n\t          var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n\t          initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n\t          prevProperty = pathItem;\n\t        }\n\n\t        // Fill update with the `value` on `path`.\n\t        update = setByPath(update, pathArray, value, '/');\n\t        var baseAttributes = merge({}, this.attributes);\n\t        // if rewrite mode enabled, we replace value referenced by path with\n\t        // the new one (we don't merge).\n\t        options.rewrite && unsetByPath(baseAttributes, path, '/');\n\n\t        // Merge update with the model attributes.\n\t        var attributes = merge(baseAttributes, update, config$3.cellMergeStrategy);\n\t        // Finally, set the property to the updated attributes.\n\t        return this.set(property, attributes[property], options);\n\t      } else {\n\t        return getByPath(this.attributes, props, delim);\n\t      }\n\t    }\n\t    const options = value || {};\n\t    // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n\t    options.propertyPath = null;\n\t    options.propertyValue = props;\n\t    options.propertyPathArray = [];\n\t    if (!('rewrite' in options)) {\n\t      options.rewrite = false;\n\t    }\n\n\t    // Create a new object containing only the changed attributes.\n\t    const changedAttributes = {};\n\t    for (const key in props) {\n\t      // Merging the values of changed attributes with the current ones.\n\t      const {\n\t        changedValue\n\t      } = merge(merge({}, {\n\t        changedValue: this.attributes[key]\n\t      }), {\n\t        changedValue: props[key]\n\t      }, config$3.cellMergeStrategy);\n\t      changedAttributes[key] = changedValue;\n\t    }\n\t    return this.set(changedAttributes, options);\n\t  },\n\t  // A convenient way to unset nested properties\n\t  removeProp: function (path, opt) {\n\t    opt = opt || {};\n\t    var pathArray = Array.isArray(path) ? path : path.split('/');\n\n\t    // Once a property is removed from the `attrs` attribute\n\t    // the cellView will recognize a `dirty` flag and re-render itself\n\t    // in order to remove the attribute from SVG element.\n\t    var property = pathArray[0];\n\t    if (property === 'attrs') opt.dirty = true;\n\t    if (pathArray.length === 1) {\n\t      // A top level property\n\t      return this.unset(path, opt);\n\t    }\n\n\t    // A nested property\n\t    var nestedPath = pathArray.slice(1);\n\t    var propertyValue = this.get(property);\n\t    if (propertyValue === undefined || propertyValue === null) return this;\n\t    propertyValue = cloneDeep(propertyValue);\n\t    unsetByPath(propertyValue, nestedPath, '/');\n\t    return this.set(property, propertyValue, opt);\n\t  },\n\t  // A convenient way to set nested attributes.\n\t  attr: function (attrs, value, opt) {\n\t    var args = Array.from(arguments);\n\t    if (args.length === 0) {\n\t      return this.get('attrs');\n\t    }\n\t    if (Array.isArray(attrs)) {\n\t      args[0] = ['attrs'].concat(attrs);\n\t    } else if (isString(attrs)) {\n\t      // Get/set an attribute by a special path syntax that delimits\n\t      // nested objects by the colon character.\n\t      args[0] = 'attrs/' + attrs;\n\t    } else {\n\t      args[0] = {\n\t        'attrs': attrs\n\t      };\n\t    }\n\t    return this.prop.apply(this, args);\n\t  },\n\t  // A convenient way to unset nested attributes\n\t  removeAttr: function (path, opt) {\n\t    if (Array.isArray(path)) {\n\t      return this.removeProp(['attrs'].concat(path));\n\t    }\n\t    return this.removeProp('attrs/' + path, opt);\n\t  },\n\t  transition: function (path, value, opt, delim) {\n\t    delim = delim || '/';\n\t    var defaults = {\n\t      duration: 100,\n\t      delay: 10,\n\t      timingFunction: timing.linear,\n\t      valueFunction: interpolate.number\n\t    };\n\t    opt = assign(defaults, opt);\n\t    var firstFrameTime = 0;\n\t    var interpolatingFunction;\n\t    const transitionKey = Array.isArray(path) ? path.join(delim) : path;\n\t    var setter = function (runtime) {\n\t      var id, progress, propertyValue;\n\t      firstFrameTime = firstFrameTime || runtime;\n\t      runtime -= firstFrameTime;\n\t      progress = runtime / opt.duration;\n\t      if (progress < 1) {\n\t        this._transitionIds[transitionKey] = id = nextFrame(setter);\n\t      } else {\n\t        progress = 1;\n\t        delete this._transitionIds[transitionKey];\n\t      }\n\t      propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\t      opt.transitionId = id;\n\t      this.prop(path, propertyValue, opt);\n\t      if (!id) this.trigger('transition:end', this, transitionKey);\n\t    }.bind(this);\n\t    const {\n\t      _scheduledTransitionIds\n\t    } = this;\n\t    const initiator = callback => {\n\t      if (_scheduledTransitionIds[transitionKey]) {\n\t        _scheduledTransitionIds[transitionKey] = without(_scheduledTransitionIds[transitionKey], initialId);\n\t        if (_scheduledTransitionIds[transitionKey].length === 0) {\n\t          delete _scheduledTransitionIds[transitionKey];\n\t        }\n\t      }\n\t      this.stopPendingTransitions(path, delim);\n\t      interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n\t      this._transitionIds[transitionKey] = nextFrame(callback);\n\t      this.trigger('transition:start', this, transitionKey);\n\t    };\n\t    const initialId = setTimeout(initiator, opt.delay, setter);\n\t    _scheduledTransitionIds[transitionKey] || (_scheduledTransitionIds[transitionKey] = []);\n\t    _scheduledTransitionIds[transitionKey].push(initialId);\n\t    return initialId;\n\t  },\n\t  getTransitions: function () {\n\t    return union(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));\n\t  },\n\t  stopScheduledTransitions: function (path, delim = '/') {\n\t    const {\n\t      _scheduledTransitionIds = {}\n\t    } = this;\n\t    let transitions = Object.keys(_scheduledTransitionIds);\n\t    if (path) {\n\t      // Ensure all path segments are strings for `isEqual` comparison, since it strictly compares values\n\t      const pathArray = Array.isArray(path) ? path.map(item => String(item)) : path.split(delim);\n\t      transitions = transitions.filter(key => {\n\t        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n\t      });\n\t    }\n\t    transitions.forEach(key => {\n\t      const transitionIds = _scheduledTransitionIds[key];\n\t      // stop the initiator\n\t      transitionIds.forEach(transitionId => clearTimeout(transitionId));\n\t      delete _scheduledTransitionIds[key];\n\t      // Note: we could trigger transition:cancel` event here\n\t    });\n\t    return this;\n\t  },\n\t  stopPendingTransitions(path, delim = '/') {\n\t    const {\n\t      _transitionIds = {}\n\t    } = this;\n\t    let transitions = Object.keys(_transitionIds);\n\t    if (path) {\n\t      // Ensure all path segments are strings for `isEqual` comparison, since it strictly compares values\n\t      const pathArray = Array.isArray(path) ? path.map(item => String(item)) : path.split(delim);\n\t      transitions = transitions.filter(key => {\n\t        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n\t      });\n\t    }\n\t    transitions.forEach(key => {\n\t      const transitionId = _transitionIds[key];\n\t      // stop the setter\n\t      cancelFrame(transitionId);\n\t      delete _transitionIds[key];\n\t      this.trigger('transition:end', this, key);\n\t    });\n\t  },\n\t  stopTransitions: function (path, delim = '/') {\n\t    this.stopScheduledTransitions(path, delim);\n\t    this.stopPendingTransitions(path, delim);\n\t    return this;\n\t  },\n\t  // A shortcut making it easy to create constructs like the following:\n\t  // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.\n\t  addTo: function (graph, opt) {\n\t    graph.addCell(this, opt);\n\t    return this;\n\t  },\n\t  // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n\t  // making it easy to create constructs like the following:\n\t  // `cell.findView(paper).highlight()`\n\t  findView: function (paper) {\n\t    return paper.findViewByModel(this);\n\t  },\n\t  isElement: function () {\n\t    return false;\n\t  },\n\t  isLink: function () {\n\t    return false;\n\t  },\n\t  startBatch: function (name, opt) {\n\t    if (this.graph) {\n\t      this.graph.startBatch(name, assign({}, opt, {\n\t        cell: this\n\t      }));\n\t    }\n\t    return this;\n\t  },\n\t  stopBatch: function (name, opt) {\n\t    if (this.graph) {\n\t      this.graph.stopBatch(name, assign({}, opt, {\n\t        cell: this\n\t      }));\n\t    }\n\t    return this;\n\t  },\n\t  getChangeFlag: function (attributes) {\n\t    var flag = 0;\n\t    if (!attributes) return flag;\n\t    for (var key in attributes) {\n\t      if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n\t      flag |= attributes[key];\n\t    }\n\t    return flag;\n\t  },\n\t  angle: function () {\n\t    // To be overridden.\n\t    return 0;\n\t  },\n\t  position: function () {\n\t    // To be overridden.\n\t    return new Point(0, 0);\n\t  },\n\t  z: function () {\n\t    return this.get('z') || 0;\n\t  },\n\t  getPointFromConnectedLink: function () {\n\t    // To be overridden\n\t    return new Point();\n\t  },\n\t  getBBox: function () {\n\t    // To be overridden\n\t    return new Rect(0, 0, 0, 0);\n\t  },\n\t  getCenter: function () {\n\t    return this.getBBox().center();\n\t  },\n\t  getPointRotatedAroundCenter(angle, x, y) {\n\t    const point = new Point(x, y);\n\t    if (angle) point.rotate(this.getCenter(), angle);\n\t    return point;\n\t  },\n\t  getAbsolutePointFromRelative(x, y) {\n\t    // Rotate the position to take the model angle into account\n\t    return this.getPointRotatedAroundCenter(-this.angle(),\n\t    // Transform the relative position to absolute\n\t    this.position().offset(x, y));\n\t  },\n\t  getRelativePointFromAbsolute(x, y) {\n\t    return this\n\t    // Rotate the coordinates to mitigate the element's rotation.\n\t    .getPointRotatedAroundCenter(this.angle(), x, y)\n\t    // Transform the absolute position into relative\n\t    .difference(this.position());\n\t  },\n\t  layer: function (layerId, opt) {\n\t    const layerAttribute = config$3.layerAttribute;\n\n\t    // Getter:\n\n\t    // If `undefined` return the current layer ID\n\t    if (layerId === undefined) {\n\t      return this.get(layerAttribute) || null;\n\t    }\n\n\t    // Setter:\n\n\t    // If strictly `null` unset the layer\n\t    if (layerId === null) {\n\t      return this.unset(layerAttribute, opt);\n\t    }\n\n\t    // Otherwise set the layer ID\n\t    if (!isString(layerId)) {\n\t      throw new Error('dia.Cell: Layer id must be a string.');\n\t    }\n\t    return this.set(layerAttribute, layerId, opt);\n\t  }\n\t}, {\n\t  getAttributeDefinition: function (attrName) {\n\t    const defNS = this.attributes;\n\t    const globalDefNS = attributes;\n\t    const definition = defNS && defNS[attrName] || globalDefNS[attrName];\n\t    return definition !== undefined ? definition : null;\n\t  },\n\t  define: function (type, defaults, protoProps, staticProps) {\n\t    protoProps = assign({\n\t      defaults: defaultsDeep({\n\t        type: type\n\t      }, defaults, this.prototype.defaults)\n\t    }, protoProps);\n\t    var Cell = this.extend(protoProps, staticProps);\n\t    // es5 backward compatibility\n\t    // eslint-disable-next-line no-undef\n\t    if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n\t      // eslint-disable-next-line no-undef\n\t      setByPath(joint.shapes, type, Cell, '.');\n\t    }\n\t    return Cell;\n\t  }\n\t});\n\tObject.defineProperty(Cell.prototype, CELL_MARKER, {\n\t  value: true\n\t});\n\n\tconst wrapWith = function (object, methods, wrapper) {\n\t  if (isString(wrapper)) {\n\t    if (!wrappers[wrapper]) {\n\t      throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n\t    }\n\t    wrapper = wrappers[wrapper];\n\t  }\n\t  if (!isFunction(wrapper)) {\n\t    throw new Error('Wrapper must be a function.');\n\t  }\n\t  toArray$1(methods).forEach(function (method) {\n\t    object[method] = wrapper(object[method]);\n\t  });\n\t};\n\tconst wrappers = {\n\t  cells: function (fn) {\n\t    return function () {\n\t      var args = Array.from(arguments);\n\t      var n = args.length;\n\t      var cells = n > 0 && args[0] || [];\n\t      var opt = n > 1 && args[n - 1] || {};\n\t      if (!Array.isArray(cells)) {\n\t        if (opt instanceof Cell) {\n\t          cells = args;\n\t        } else if (cells instanceof Cell) {\n\t          if (args.length > 1) {\n\t            args.pop();\n\t          }\n\t          cells = args;\n\t        }\n\t      }\n\t      if (opt instanceof Cell) {\n\t        opt = {};\n\t      }\n\t      return fn.call(this, cells, opt);\n\t    };\n\t  }\n\t};\n\n\tfunction svg(strings, ...expressions) {\n\t  const svgParts = [];\n\t  strings.forEach((part, index) => {\n\t    svgParts.push(part);\n\t    if (index in expressions) {\n\t      svgParts.push(expressions[index]);\n\t    }\n\t  });\n\t  const markup = parseFromSVGString(svgParts.join(''));\n\t  return markup;\n\t}\n\tfunction parseFromSVGString(str) {\n\t  const parser = new DOMParser();\n\t  const markupString = `<svg>${str.trim()}</svg>`;\n\t  const xmldocument = parser.parseFromString(markupString.replace(/@/g, ''), 'application/xml');\n\t  if (xmldocument.getElementsByTagName('parsererror')[0]) {\n\t    throw new Error('Invalid SVG markup');\n\t  }\n\t  const document = parser.parseFromString(markupString, 'text/html');\n\t  const svg = document.querySelector('svg');\n\t  return build(svg);\n\t}\n\tfunction buildNode(node) {\n\t  const markupNode = {};\n\t  const {\n\t    tagName,\n\t    attributes,\n\t    namespaceURI,\n\t    style,\n\t    childNodes\n\t  } = node;\n\t  markupNode.namespaceURI = namespaceURI;\n\t  markupNode.tagName = namespaceURI === V.namespace.xhtml\n\t  // XHTML documents must use lower case for all HTML element and attribute names.\n\t  // The tagName property returns upper case value for HTML elements.\n\t  // e.g. <DIV> vs.<div/>\n\t  ? tagName.toLowerCase() : tagName;\n\t  const stylesObject = {};\n\t  for (var i = style.length; i--;) {\n\t    var nameString = style[i];\n\t    stylesObject[nameString] = style.getPropertyValue(nameString);\n\t  }\n\t  markupNode.style = stylesObject;\n\n\t  // selector fallbacks to tagName\n\t  const selectorAttribute = attributes.getNamedItem('@selector');\n\t  if (selectorAttribute) {\n\t    markupNode.selector = selectorAttribute.value;\n\t    attributes.removeNamedItem('@selector');\n\t  }\n\t  const groupSelectorAttribute = attributes.getNamedItem('@group-selector');\n\t  if (groupSelectorAttribute) {\n\t    const groupSelectors = groupSelectorAttribute.value.split(',');\n\t    markupNode.groupSelector = groupSelectors.map(s => s.trim());\n\t    attributes.removeNamedItem('@group-selector');\n\t  }\n\t  const className = attributes.getNamedItem('class');\n\t  if (className) {\n\t    markupNode.className = className.value;\n\t  }\n\t  const children = [];\n\t  childNodes.forEach(node => {\n\t    switch (node.nodeType) {\n\t      case Node.TEXT_NODE:\n\t        {\n\t          const trimmedText = node.data.replace(/\\s\\s+/g, ' ');\n\t          if (trimmedText.trim()) {\n\t            children.push(trimmedText);\n\t          }\n\t          break;\n\t        }\n\t      case Node.ELEMENT_NODE:\n\t        {\n\t          children.push(buildNode(node));\n\t          break;\n\t        }\n\t      default:\n\t        break;\n\t    }\n\t  });\n\t  if (children.length) {\n\t    markupNode.children = children;\n\t  }\n\t  const nodeAttrs = {};\n\t  Array.from(attributes).forEach(nodeAttribute => {\n\t    const {\n\t      name,\n\t      value\n\t    } = nodeAttribute;\n\t    nodeAttrs[name] = value;\n\t  });\n\t  if (Object.keys(nodeAttrs).length > 0) {\n\t    markupNode.attributes = nodeAttrs;\n\t  }\n\t  return markupNode;\n\t}\n\tfunction build(root) {\n\t  const markup = [];\n\t  Array.from(root.children).forEach(node => {\n\t    markup.push(buildNode(node));\n\t  });\n\t  return markup;\n\t}\n\n\tconst Positions = {\n\t  TOP: 'top',\n\t  RIGHT: 'right',\n\t  BOTTOM: 'bottom',\n\t  LEFT: 'left',\n\t  TOP_LEFT: 'top-left',\n\t  TOP_RIGHT: 'top-right',\n\t  BOTTOM_LEFT: 'bottom-left',\n\t  BOTTOM_RIGHT: 'bottom-right',\n\t  CENTER: 'center'\n\t};\n\tfunction getRectPoint(rect, position) {\n\t  const r = new Rect(rect);\n\t  switch (position) {\n\t    case undefined:\n\t      throw new Error('Position required');\n\n\t    // Middle Points\n\t    case Positions.LEFT:\n\t    case 'leftMiddle':\n\t      return r.leftMiddle();\n\t    case Positions.RIGHT:\n\t    case 'rightMiddle':\n\t      return r.rightMiddle();\n\t    case Positions.TOP:\n\t    case 'topMiddle':\n\t      return r.topMiddle();\n\t    case Positions.BOTTOM:\n\t    case 'bottomMiddle':\n\t      return r.bottomMiddle();\n\n\t    // Corners\n\t    case Positions.TOP_LEFT:\n\t    case 'topLeft':\n\t    case 'origin':\n\t      return r.topLeft();\n\t    case Positions.TOP_RIGHT:\n\t    case 'topRight':\n\t      return r.topRight();\n\t    case Positions.BOTTOM_LEFT:\n\t    case 'bottomLeft':\n\t      return r.bottomLeft();\n\t    case Positions.BOTTOM_RIGHT:\n\t    case 'bottomRight':\n\t    case 'corner':\n\t      return r.bottomRight();\n\n\t    // Center\n\t    case Positions.CENTER:\n\t      return r.center();\n\n\t    // TODO: calc(), percentage etc.\n\t    default:\n\t      throw new Error(`Unknown position: ${position}`);\n\t  }\n\t}\n\n\tvar index$6 = {\n\t\t__proto__: null,\n\t\taddClassNamePrefix: addClassNamePrefix,\n\t\tassign: assign,\n\t\tbindAll: bindAll,\n\t\tbreakText: breakText,\n\t\tcamelCase: camelCase,\n\t\tcancelFrame: cancelFrame,\n\t\tcap: cap,\n\t\tclone: clone$1,\n\t\tcloneCells: cloneCells,\n\t\tcloneDeep: cloneDeep,\n\t\tdataUriToBlob: dataUriToBlob,\n\t\tdebounce: debounce,\n\t\tdeepMixin: deepMixin,\n\t\tdeepSupplement: deepSupplement,\n\t\tdefaults: defaults,\n\t\tdefaultsDeep: defaultsDeep,\n\t\tdifference: difference,\n\t\tdownloadBlob: downloadBlob,\n\t\tdownloadDataUri: downloadDataUri,\n\t\tevalCalcExpression: evalCalcExpression,\n\t\tevalCalcFormula: evalCalcFormula,\n\t\tfilter: filter,\n\t\tflattenDeep: flattenDeep,\n\t\tflattenObject: flattenObject,\n\t\tforIn: forIn,\n\t\tformat: format$1,\n\t\tgetByPath: getByPath,\n\t\tgetElementBBox: getElementBBox,\n\t\tgetRectPoint: getRectPoint,\n\t\tgroupBy: groupBy,\n\t\tguid: guid,\n\t\thas: has,\n\t\thashCode: hashCode,\n\t\timageToDataUri: imageToDataUri,\n\t\tinterpolate: interpolate,\n\t\tintersection: intersection,\n\t\tinvoke: invoke,\n\t\tinvokeProperty: invokeProperty,\n\t\tisBoolean: isBoolean,\n\t\tisCalcExpression: isCalcExpression,\n\t\tisEmpty: isEmpty,\n\t\tisEqual: isEqual,\n\t\tisFunction: isFunction,\n\t\tisNumber: isNumber,\n\t\tisObject: isObject,\n\t\tisPercentage: isPercentage,\n\t\tisPlainObject: isPlainObject,\n\t\tisString: isString,\n\t\tmerge: merge,\n\t\tmixin: mixin,\n\t\tnextFrame: nextFrame,\n\t\tnoop: noop,\n\t\tnormalizeEvent: normalizeEvent,\n\t\tnormalizeSides: normalizeSides,\n\t\tnormalizeWheel: normalizeWheel,\n\t\tobjectDifference: objectDifference,\n\t\tomit: omit,\n\t\tparseCssNumeric: parseCssNumeric,\n\t\tparseDOMJSON: parseDOMJSON,\n\t\tpick: pick,\n\t\tremoveClassNamePrefix: removeClassNamePrefix,\n\t\tresult: result,\n\t\tsanitizeHTML: sanitizeHTML,\n\t\tsetAttributesBySelector: setAttributesBySelector,\n\t\tsetByPath: setByPath,\n\t\tsortBy: sortBy,\n\t\tsortElements: sortElements,\n\t\tsortedIndex: sortedIndex,\n\t\tsupplement: supplement,\n\t\tsvg: svg,\n\t\ttemplate: template,\n\t\ttiming: timing,\n\t\ttoArray: toArray$1,\n\t\ttoKebabCase: toKebabCase,\n\t\ttoggleFullScreen: toggleFullScreen,\n\t\tunion: union,\n\t\tuniq: uniq,\n\t\tuniqueId: uniqueId,\n\t\tunsetByPath: unsetByPath,\n\t\tuuid: uuid,\n\t\twithout: without,\n\t\twrapWith: wrapWith,\n\t\twrappers: wrappers\n\t};\n\n\tfunction parseCoordinate(coordinate, dimension, bbox, value) {\n\t  if (isPercentage(value)) {\n\t    return parseFloat(value) / 100 * bbox[dimension];\n\t  }\n\t  if (isCalcExpression(value)) {\n\t    return Number(evalCalcExpression(value, bbox));\n\t  }\n\t  if (typeof value === 'string') {\n\t    const num = Number(value);\n\t    if (isNaN(num)) {\n\t      throw new TypeError(`Cannot convert port coordinate ${coordinate}: \"${value}\" to a number`);\n\t    }\n\t    return num;\n\t  }\n\t  return value;\n\t}\n\tfunction portTransformAttrs(point, angle, opt) {\n\t  var trans = point.toJSON();\n\t  trans.angle = angle || 0;\n\t  return defaults({}, opt, trans);\n\t}\n\tfunction lineLayout(ports, p1, p2, elBBox) {\n\t  return ports.map(function (port, index, ports) {\n\t    var p = this.pointAt((index + 0.5) / ports.length);\n\t    // `dx`,`dy` per port offset option\n\t    if (port.dx || port.dy) {\n\t      p.offset(port.dx || 0, port.dy || 0);\n\t    }\n\t    return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n\t  }, line$1(p1, p2));\n\t}\n\tfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\t  var center = elBBox.center();\n\t  var ratio = elBBox.width / elBBox.height;\n\t  var p1 = elBBox.topMiddle();\n\t  var ellipse = Ellipse$1.fromRect(elBBox);\n\t  return ports.map(function (port, index, ports) {\n\t    var angle = startAngle + stepFn(index, ports.length);\n\t    var p2 = p1.clone().rotate(center, -angle).scale(ratio, 1, center);\n\t    var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n\t    // `dx`,`dy` per port offset option\n\t    if (port.dx || port.dy) {\n\t      p2.offset(port.dx || 0, port.dy || 0);\n\t    }\n\n\t    // `dr` delta radius option\n\t    if (port.dr) {\n\t      p2.move(center, port.dr);\n\t    }\n\t    return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n\t  });\n\t}\n\tfunction argTransform(bbox, args) {\n\t  const {\n\t    x,\n\t    y,\n\t    angle\n\t  } = args;\n\t  return {\n\t    x: parseCoordinate('x', 'width', bbox, x),\n\t    y: parseCoordinate('y', 'height', bbox, y),\n\t    angle\n\t  };\n\t}\n\n\t// Creates a point stored in arguments\n\tfunction argPoint(bbox, args) {\n\t  const {\n\t    x,\n\t    y\n\t  } = argTransform(bbox, args);\n\t  return new Point(x || 0, y || 0);\n\t}\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst absolute = function (ports, elBBox, opt) {\n\t  return ports.map(port => {\n\t    const transformation = argPoint(elBBox, port).round().toJSON();\n\t    transformation.angle = port.angle || 0;\n\t    return transformation;\n\t  });\n\t};\n\n\t/**\n\t * @deprecated\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst fn = function (ports, elBBox, opt) {\n\t  return opt.fn(ports, elBBox, opt);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst line = function (ports, elBBox, opt) {\n\t  var start = argPoint(elBBox, opt.start || elBBox.origin());\n\t  var end = argPoint(elBBox, opt.end || elBBox.corner());\n\t  return lineLayout(ports, start, end, elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst left$2 = function (ports, elBBox, opt) {\n\t  return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst right$2 = function (ports, elBBox, opt) {\n\t  return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst top$2 = function (ports, elBBox, opt) {\n\t  return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst bottom$2 = function (ports, elBBox, opt) {\n\t  return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst ellipseSpread = function (ports, elBBox, opt) {\n\t  var startAngle = opt.startAngle || 0;\n\t  var stepAngle = opt.step || 360 / ports.length;\n\t  return ellipseLayout(ports, elBBox, startAngle, function (index) {\n\t    return index * stepAngle;\n\t  });\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst ellipse = function (ports, elBBox, opt) {\n\t  var startAngle = opt.startAngle || 0;\n\t  var stepAngle = opt.step || 20;\n\t  return ellipseLayout(ports, elBBox, startAngle, function (index, count) {\n\t    return (index + 0.5 - count / 2) * stepAngle;\n\t  });\n\t};\n\n\tvar Port = {\n\t\t__proto__: null,\n\t\tabsolute: absolute,\n\t\tbottom: bottom$2,\n\t\tellipse: ellipse,\n\t\tellipseSpread: ellipseSpread,\n\t\tfn: fn,\n\t\tleft: left$2,\n\t\tline: line,\n\t\tright: right$2,\n\t\ttop: top$2\n\t};\n\n\tfunction labelAttributes(opt1, opt2) {\n\t  // use value from `opt2` if it is missing in `opt1`\n\t  // use value from this object if it is missing in `opt2` as well\n\t  return defaultsDeep({}, opt1, opt2, {\n\t    x: 0,\n\t    y: 0,\n\t    angle: 0,\n\t    attrs: {}\n\t  });\n\t}\n\tfunction getBBoxAngles(elBBox) {\n\t  var center = elBBox.center();\n\t  var tl = center.theta(elBBox.origin());\n\t  var bl = center.theta(elBBox.bottomLeft());\n\t  var br = center.theta(elBBox.corner());\n\t  var tr = center.theta(elBBox.topRight());\n\t  return [tl, tr, br, bl];\n\t}\n\tfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n\t  opt = defaults({}, opt, {\n\t    offset: 15\n\t  });\n\t  var angle = elBBox.center().theta(portPosition);\n\t  var tx, ty, y, textAnchor;\n\t  var offset = opt.offset;\n\t  var orientAngle = 0;\n\t  const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n\t  if (angle < bottomLeftAngle || angle > bottomRightAngle) {\n\t    y = '.3em';\n\t    tx = offset;\n\t    ty = 0;\n\t    textAnchor = 'start';\n\t  } else if (angle < topLeftAngle) {\n\t    tx = 0;\n\t    ty = -offset;\n\t    if (autoOrient) {\n\t      orientAngle = -90;\n\t      textAnchor = 'start';\n\t      y = '.3em';\n\t    } else {\n\t      textAnchor = 'middle';\n\t      y = '0';\n\t    }\n\t  } else if (angle < topRightAngle) {\n\t    y = '.3em';\n\t    tx = -offset;\n\t    ty = 0;\n\t    textAnchor = 'end';\n\t  } else {\n\t    tx = 0;\n\t    ty = offset;\n\t    if (autoOrient) {\n\t      orientAngle = 90;\n\t      textAnchor = 'start';\n\t      y = '.3em';\n\t    } else {\n\t      textAnchor = 'middle';\n\t      y = '.6em';\n\t    }\n\t  }\n\t  var round = Math.round;\n\t  return labelAttributes(opt, {\n\t    x: round(tx),\n\t    y: round(ty),\n\t    angle: orientAngle,\n\t    attrs: {\n\t      labelText: {\n\t        y,\n\t        textAnchor\n\t      }\n\t    }\n\t  });\n\t}\n\tfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n\t  opt = defaults({}, opt, {\n\t    offset: 15\n\t  });\n\t  var angle = elBBox.center().theta(portPosition);\n\t  var tx, ty, y, textAnchor;\n\t  var offset = opt.offset;\n\t  var orientAngle = 0;\n\t  const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n\t  if (angle < bottomLeftAngle || angle > bottomRightAngle) {\n\t    y = '.3em';\n\t    tx = -offset;\n\t    ty = 0;\n\t    textAnchor = 'end';\n\t  } else if (angle < topLeftAngle) {\n\t    tx = 0;\n\t    ty = offset;\n\t    if (autoOrient) {\n\t      orientAngle = 90;\n\t      textAnchor = 'start';\n\t      y = '.3em';\n\t    } else {\n\t      textAnchor = 'middle';\n\t      y = '.6em';\n\t    }\n\t  } else if (angle < topRightAngle) {\n\t    y = '.3em';\n\t    tx = offset;\n\t    ty = 0;\n\t    textAnchor = 'start';\n\t  } else {\n\t    tx = 0;\n\t    ty = -offset;\n\t    if (autoOrient) {\n\t      orientAngle = -90;\n\t      textAnchor = 'start';\n\t      y = '.3em';\n\t    } else {\n\t      textAnchor = 'middle';\n\t      y = '0';\n\t    }\n\t  }\n\t  var round = Math.round;\n\t  return labelAttributes(opt, {\n\t    x: round(tx),\n\t    y: round(ty),\n\t    angle: orientAngle,\n\t    attrs: {\n\t      labelText: {\n\t        y,\n\t        textAnchor\n\t      }\n\t    }\n\t  });\n\t}\n\tfunction radialLayout(portCenterOffset, autoOrient, opt) {\n\t  opt = defaults({}, opt, {\n\t    offset: 20\n\t  });\n\t  var origin = point(0, 0);\n\t  var angle = -portCenterOffset.theta(origin);\n\t  var orientAngle = angle;\n\t  var offset = portCenterOffset.clone().move(origin, opt.offset).difference(portCenterOffset).round();\n\t  var y = '.3em';\n\t  var textAnchor;\n\t  if ((angle + 90) % 180 === 0) {\n\t    textAnchor = autoOrient ? 'end' : 'middle';\n\t    if (!autoOrient && angle === -270) {\n\t      y = '0em';\n\t    }\n\t  } else if (angle > -270 && angle < -90) {\n\t    textAnchor = 'start';\n\t    orientAngle = angle - 180;\n\t  } else {\n\t    textAnchor = 'end';\n\t  }\n\t  var round = Math.round;\n\t  return labelAttributes(opt, {\n\t    x: round(offset.x),\n\t    y: round(offset.y),\n\t    angle: autoOrient ? orientAngle : 0,\n\t    attrs: {\n\t      labelText: {\n\t        y,\n\t        textAnchor\n\t      }\n\t    }\n\t  });\n\t}\n\tconst manual = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt);\n\t};\n\tconst left$1 = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt, {\n\t    x: -15,\n\t    attrs: {\n\t      labelText: {\n\t        y: '.3em',\n\t        textAnchor: 'end'\n\t      }\n\t    }\n\t  });\n\t};\n\tconst right$1 = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt, {\n\t    x: 15,\n\t    attrs: {\n\t      labelText: {\n\t        y: '.3em',\n\t        textAnchor: 'start'\n\t      }\n\t    }\n\t  });\n\t};\n\tconst top$1 = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt, {\n\t    y: -15,\n\t    attrs: {\n\t      labelText: {\n\t        y: '0',\n\t        textAnchor: 'middle'\n\t      }\n\t    }\n\t  });\n\t};\n\tconst bottom$1 = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt, {\n\t    y: 15,\n\t    attrs: {\n\t      labelText: {\n\t        y: '.6em',\n\t        textAnchor: 'middle'\n\t      }\n\t    }\n\t  });\n\t};\n\tconst outsideOriented = function (portPosition, elBBox, opt) {\n\t  return outsideLayout(portPosition, elBBox, true, opt);\n\t};\n\tconst outside = function (portPosition, elBBox, opt) {\n\t  return outsideLayout(portPosition, elBBox, false, opt);\n\t};\n\tconst insideOriented = function (portPosition, elBBox, opt) {\n\t  return insideLayout(portPosition, elBBox, true, opt);\n\t};\n\tconst inside = function (portPosition, elBBox, opt) {\n\t  return insideLayout(portPosition, elBBox, false, opt);\n\t};\n\tconst radial = function (portPosition, elBBox, opt) {\n\t  return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n\t};\n\tconst radialOriented = function (portPosition, elBBox, opt) {\n\t  return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n\t};\n\n\tvar PortLabel = {\n\t\t__proto__: null,\n\t\tbottom: bottom$1,\n\t\tinside: inside,\n\t\tinsideOriented: insideOriented,\n\t\tleft: left$1,\n\t\tmanual: manual,\n\t\toutside: outside,\n\t\toutsideOriented: outsideOriented,\n\t\tradial: radial,\n\t\tradialOriented: radialOriented,\n\t\tright: right$1,\n\t\ttop: top$1\n\t};\n\n\tconst DEFAULT_PORT_POSITION_NAME = 'left';\n\tconst DEFAULT_ABSOLUTE_PORT_POSITION_NAME = 'absolute';\n\tconst DEFAULT_PORT_LABEL_POSITION_NAME = 'left';\n\tconst PortData = function (model) {\n\t  const {\n\t    portLayoutNamespace = Port,\n\t    portLabelLayoutNamespace = PortLabel\n\t  } = model;\n\t  const clonedData = cloneDeep(model.get('ports')) || {};\n\t  this.ports = [];\n\t  this.portsMap = {};\n\t  this.groups = {};\n\t  this.portLayoutNamespace = portLayoutNamespace;\n\t  this.portLabelLayoutNamespace = portLabelLayoutNamespace;\n\t  this.metrics = {};\n\t  this.metricsKey = null;\n\t  this._init(clonedData);\n\t};\n\tPortData.prototype = {\n\t  hasPort: function (id) {\n\t    return id in this.portsMap;\n\t  },\n\t  getPort: function (id) {\n\t    const port = this.portsMap[id];\n\t    if (port) return port;\n\t    throw new Error('Element: unable to find port with id ' + id);\n\t  },\n\t  getPorts: function () {\n\t    return this.ports;\n\t  },\n\t  getGroup: function (name) {\n\t    return this.groups[name] || {};\n\t  },\n\t  getPortsByGroup: function (groupName) {\n\t    return this.ports.filter(function (port) {\n\t      return port.group === groupName;\n\t    });\n\t  },\n\t  // Calculate SVG transformations based on evaluated group + port data\n\t  // NOTE: This function is also called for ports without a group (groupName = undefined)\n\t  getGroupPortsMetrics: function (groupName, rect) {\n\t    const {\n\t      x = 0,\n\t      y = 0,\n\t      width = 0,\n\t      height = 0\n\t    } = rect;\n\t    const metricsKey = `${x}:${y}:${width}:${height}`;\n\t    if (this.metricsKey !== metricsKey) {\n\t      // Clear the cache (the element size has changed)\n\t      this.metrics = {};\n\t      this.metricsKey = metricsKey;\n\t    }\n\t    let groupPortsMetrics = this.metrics[groupName];\n\t    if (groupPortsMetrics) {\n\t      // Return cached metrics\n\t      return groupPortsMetrics;\n\t    }\n\n\t    // Calculate the metrics\n\t    groupPortsMetrics = this.resolveGroupPortsMetrics(groupName, new Rect(x, y, width, height));\n\t    this.metrics[groupName] = groupPortsMetrics;\n\t    return groupPortsMetrics;\n\t  },\n\t  resolveGroupPortsMetrics: function (groupName, elBBox) {\n\t    // `groupName` of `undefined` (= not a string) means \"the group of ports which do not have the `group` property\".\n\t    const isNoGroup = groupName === undefined;\n\t    const group = this.getGroup(groupName);\n\t    const ports = this.getPortsByGroup(groupName);\n\t    const portsArgs = ports.map(function (port) {\n\t      return port && port.position && port.position.args;\n\t    });\n\n\t    // Get an array of transformations of individual ports according to the group's port layout function:\n\t    let groupPortTransformations;\n\t    if (isNoGroup) {\n\t      // Apply default port layout function to the set of ports without `group` property.\n\t      const noGroup = this._evaluateGroup({});\n\t      groupPortTransformations = this._getGroupPortTransformations(noGroup, portsArgs, elBBox);\n\t    } else {\n\t      groupPortTransformations = this._getGroupPortTransformations(group, portsArgs, elBBox);\n\t    }\n\t    const accumulator = {\n\t      ports: ports,\n\t      result: {}\n\t    };\n\n\t    // For each individual port transformation, find the information necessary to calculate SVG transformations:\n\t    toArray$1(groupPortTransformations).reduce((res, portTransformation, index) => {\n\t      const port = res.ports[index];\n\t      const portId = port.id;\n\t      res.result[portId] = {\n\t        index,\n\t        portId,\n\t        portTransformation: portTransformation,\n\t        labelTransformation: this._getPortLabelTransformation(port, Point(portTransformation), elBBox),\n\t        portAttrs: port.attrs,\n\t        portSize: port.size,\n\t        labelSize: port.label.size\n\t      };\n\t      return res;\n\t    }, accumulator);\n\t    return accumulator.result;\n\t  },\n\t  _getGroupPortTransformations: function (group, portsArgs, elBBox) {\n\t    const groupPosition = group.position || {};\n\t    const groupPositionArgs = groupPosition.args || {};\n\t    const groupPositionLayoutCallback = groupPosition.layoutCallback;\n\t    return groupPositionLayoutCallback(portsArgs, elBBox, groupPositionArgs);\n\t  },\n\t  _getPortLabelTransformation: function (port, portPosition, elBBox) {\n\t    const portLabelPosition = port.label.position || {};\n\t    const portLabelPositionArgs = portLabelPosition.args || {};\n\t    const portLabelPositionLayoutCallback = portLabelPosition.layoutCallback;\n\t    if (portLabelPositionLayoutCallback) {\n\t      return portLabelPositionLayoutCallback(portPosition, elBBox, portLabelPositionArgs);\n\t    }\n\t    return null;\n\t  },\n\t  _init: function (data) {\n\t    // Prepare groups:\n\t    // NOTE: This overwrites passed group properties with evaluated group properties.\n\t    if (isObject(data.groups)) {\n\t      var groups = Object.keys(data.groups);\n\t      for (var i = 0, n = groups.length; i < n; i++) {\n\t        var key = groups[i];\n\t        this.groups[key] = this._evaluateGroup(data.groups[key]);\n\t      }\n\t    }\n\n\t    // Prepare ports:\n\t    // NOTE: This overwrites passed port properties with evaluated port properties, plus mixed-in evaluated group properties (see above).\n\t    var ports = toArray$1(data.items);\n\t    for (var j = 0, m = ports.length; j < m; j++) {\n\t      const resolvedPort = this._evaluatePort(ports[j]);\n\t      this.ports.push(resolvedPort);\n\t      this.portsMap[resolvedPort.id] = resolvedPort;\n\t    }\n\t  },\n\t  _evaluateGroup: function (group) {\n\t    return merge({}, group, {\n\t      position: this._evaluateGroupPositionProperty(group),\n\t      label: this._evaluateGroupLabelProperty(group)\n\t    });\n\t  },\n\t  _evaluateGroupPositionProperty: function (group) {\n\t    const namespace = this.portLayoutNamespace;\n\t    const groupPosition = group.position;\n\t    if (groupPosition === undefined) {\n\t      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_POSITION_NAME, 'Default port group');\n\t      return {\n\t        layoutCallback\n\t      };\n\t    } else if (isFunction(groupPosition)) {\n\t      return {\n\t        layoutCallback: groupPosition\n\t      };\n\t    } else if (isObject(groupPosition)) {\n\t      if (groupPosition.name) {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupPosition.name, 'Provided port group');\n\t        return {\n\t          layoutCallback,\n\t          args: groupPosition.args\n\t        };\n\t      } else {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_POSITION_NAME, 'Default port group');\n\t        return {\n\t          layoutCallback,\n\t          args: groupPosition.args\n\t        };\n\t      }\n\t    } else if (isString(groupPosition)) {\n\t      // TODO: Remove legacy signature (see `this._evaluateGroupLabelPositionProperty()`).\n\t      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupPosition, 'Provided port group');\n\t      return {\n\t        layoutCallback\n\t      };\n\t    } else if (Array.isArray(groupPosition)) {\n\t      // TODO: Remove legacy signature (see `this._evaluateGroupLabelPositionProperty()`).\n\t      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_ABSOLUTE_PORT_POSITION_NAME, 'Default absolute port group');\n\t      return {\n\t        layoutCallback,\n\t        args: {\n\t          x: groupPosition[0],\n\t          y: groupPosition[1]\n\t        }\n\t      };\n\t    } else {\n\t      throw new Error('dia.Element: Provided port group position value has an invalid type.');\n\t    }\n\t  },\n\t  _evaluateGroupLabelProperty: function (group) {\n\t    const groupLabel = group.label;\n\t    if (!groupLabel) {\n\t      return {\n\t        position: this._evaluateGroupLabelPositionProperty({})\n\t      };\n\t    }\n\t    return merge({}, groupLabel, {\n\t      position: this._evaluateGroupLabelPositionProperty(groupLabel)\n\t    });\n\t  },\n\t  _evaluateGroupLabelPositionProperty: function (groupLabel) {\n\t    const namespace = this.portLabelLayoutNamespace;\n\t    const groupLabelPosition = groupLabel.position;\n\t    if (groupLabelPosition === undefined) {\n\t      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_LABEL_POSITION_NAME, 'Default port group label');\n\t      return {\n\t        layoutCallback\n\t      };\n\t    } else if (isFunction(groupLabelPosition)) {\n\t      return {\n\t        layoutCallback: groupLabelPosition\n\t      };\n\t    } else if (isObject(groupLabelPosition)) {\n\t      if (groupLabelPosition.name) {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupLabelPosition.name, 'Provided port group label');\n\t        return {\n\t          layoutCallback,\n\t          args: groupLabelPosition.args\n\t        };\n\t      } else {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_LABEL_POSITION_NAME, 'Default port group label');\n\t        return {\n\t          layoutCallback,\n\t          args: groupLabelPosition.args\n\t        };\n\t      }\n\t    } else {\n\t      throw new Error('dia.Element: Provided port group label position value has an invalid type.');\n\t    }\n\t  },\n\t  _evaluatePort: function (port) {\n\t    const group = this.getGroup(port.group);\n\t    const evaluated = assign({}, port);\n\t    evaluated.markup = evaluated.markup || group.markup;\n\t    evaluated.attrs = merge({}, group.attrs, evaluated.attrs);\n\t    evaluated.position = this._evaluatePortPositionProperty(group, evaluated);\n\t    evaluated.label = this._evaluatePortLabelProperty(group, evaluated);\n\t    evaluated.z = this._evaluatePortZProperty(group, evaluated);\n\t    evaluated.size = assign({\n\t      width: 0,\n\t      height: 0\n\t    }, group.size, evaluated.size);\n\t    return evaluated;\n\t  },\n\t  _evaluatePortPositionProperty: function (group, port) {\n\t    return {\n\t      args: merge({},\n\t      // NOTE: `x != null` is equivalent to `x !== null && x !== undefined`.\n\t      group.position != null ? group.position.args : {},\n\t      // Port can overwrite `group.position.args` via `port.position.args` or `port.args`.\n\t      // TODO: Remove `port.args` backwards compatibility.\n\t      port.position != null && port.position.args != null ? port.position.args : port.args)\n\t    };\n\t  },\n\t  _evaluatePortLabelProperty: function (group, port) {\n\t    const groupLabel = group.label;\n\t    const portLabel = port.label;\n\t    if (!portLabel) {\n\t      return assign({}, groupLabel);\n\t    }\n\t    return merge({}, groupLabel, merge({}, portLabel, {\n\t      position: this._evaluatePortLabelPositionProperty(portLabel)\n\t    }));\n\t  },\n\t  _evaluatePortLabelPositionProperty: function (portLabel) {\n\t    const namespace = this.portLabelLayoutNamespace;\n\t    const portLabelPosition = portLabel.position;\n\t    if (portLabelPosition === undefined) {\n\t      return {};\n\t    } else if (isFunction(portLabelPosition)) {\n\t      return {\n\t        layoutCallback: portLabelPosition\n\t      };\n\t    } else if (isObject(portLabelPosition)) {\n\t      if (portLabelPosition.name) {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, portLabelPosition.name, 'Provided port label');\n\t        return {\n\t          layoutCallback,\n\t          args: portLabelPosition.args\n\t        };\n\t      } else {\n\t        return {\n\t          args: portLabelPosition.args\n\t        };\n\t      }\n\t    } else {\n\t      throw new Error('dia.Element: Provided port label position value has an invalid type.');\n\t    }\n\t  },\n\t  _evaluatePortZProperty: function (group, port) {\n\t    if (isNumber(port.z)) {\n\t      return port.z;\n\t    }\n\t    if (isNumber(group.z) || group.z === 'auto') {\n\t      return group.z;\n\t    }\n\t    return 'auto';\n\t  },\n\t  _resolveLayoutCallbackOrThrow: function (namespace, name, errorSubstring) {\n\t    const layoutCallback = namespace[name];\n\t    if (!layoutCallback) {\n\t      throw new Error(`dia.Element: ${errorSubstring} layout name is not recognized.`);\n\t    }\n\t    return layoutCallback;\n\t  }\n\t};\n\tconst elementPortPrototype = {\n\t  _initializePorts: function (options) {\n\t    if (options) {\n\t      // Override port layout namespaces if provided in options\n\t      if (options.portLayoutNamespace) {\n\t        this.portLayoutNamespace = options.portLayoutNamespace;\n\t      }\n\t      // Override port label layout namespaces if provided in options\n\t      if (options.portLabelLayoutNamespace) {\n\t        this.portLabelLayoutNamespace = options.portLabelLayoutNamespace;\n\t      }\n\t    }\n\t    this._createPortData();\n\t    this.on('change:ports', function () {\n\t      this._processRemovedPort();\n\t      this._createPortData();\n\t    }, this);\n\t  },\n\t  /**\n\t   * remove links tied wiht just removed element\n\t   * @private\n\t   */\n\t  _processRemovedPort: function () {\n\t    var current = this.get('ports') || {};\n\t    var currentItemsMap = {};\n\t    toArray$1(current.items).forEach(function (item) {\n\t      currentItemsMap[item.id] = true;\n\t    });\n\t    var previous = this.previous('ports') || {};\n\t    var removed = {};\n\t    toArray$1(previous.items).forEach(function (item) {\n\t      if (!currentItemsMap[item.id]) {\n\t        removed[item.id] = true;\n\t      }\n\t    });\n\t    var graph = this.graph;\n\t    if (graph && !isEmpty(removed)) {\n\t      var inboundLinks = graph.getConnectedLinks(this, {\n\t        inbound: true\n\t      });\n\t      inboundLinks.forEach(function (link) {\n\t        if (removed[link.get('target').port]) link.remove();\n\t      });\n\t      var outboundLinks = graph.getConnectedLinks(this, {\n\t        outbound: true\n\t      });\n\t      outboundLinks.forEach(function (link) {\n\t        if (removed[link.get('source').port]) link.remove();\n\t      });\n\t    }\n\t  },\n\t  /**\n\t   * @returns {boolean}\n\t   */\n\t  hasPorts: function () {\n\t    return this._portSettingsData.getPorts().length > 0;\n\t  },\n\t  /**\n\t   * @param {string} id\n\t   * @returns {boolean}\n\t   */\n\t  hasPort: function (id) {\n\t    return this._portSettingsData.hasPort(id);\n\t  },\n\t  /**\n\t   * @returns {Array<object>}\n\t   */\n\t  getPorts: function () {\n\t    return cloneDeep(this.prop('ports/items')) || [];\n\t  },\n\t  /**\n\t   * @returns {Array<object>}\n\t   */\n\t  getGroupPorts: function (groupName) {\n\t    const groupPorts = toArray$1(this.prop(['ports', 'items'])).filter(port => port.group === groupName);\n\t    return cloneDeep(groupPorts);\n\t  },\n\t  /**\n\t   * @param {string} id\n\t   * @returns {object}\n\t   */\n\t  getPort: function (id) {\n\t    const port = toArray$1(this.prop('ports/items')).find(port => port.id && port.id === id);\n\t    return cloneDeep(port);\n\t  },\n\t  getPortGroupNames: function () {\n\t    return Object.keys(this._portSettingsData.groups);\n\t  },\n\t  /**\n\t   * @param {string} groupName\n\t   * @returns {Object<portId, {x: number, y: number, angle: number}>}\n\t   */\n\t  getPortsPositions: function (groupName) {\n\t    const portsMetrics = this.getGroupPortsMetrics(groupName);\n\t    const portsPosition = {};\n\t    for (const portId in portsMetrics) {\n\t      const {\n\t        portTransformation: {\n\t          x,\n\t          y,\n\t          angle\n\t        }\n\t      } = portsMetrics[portId];\n\t      portsPosition[portId] = {\n\t        x: x,\n\t        y: y,\n\t        angle\n\t      };\n\t    }\n\t    return portsPosition;\n\t  },\n\t  getPortMetrics: function (portId) {\n\t    const port = this._portSettingsData.getPort(portId);\n\t    return this.getGroupPortsMetrics(port.group)[portId];\n\t  },\n\t  getGroupPortsMetrics: function (groupName) {\n\t    return this._portSettingsData.getGroupPortsMetrics(groupName, this.size());\n\t  },\n\t  getPortRelativePosition: function (portId) {\n\t    const {\n\t      portTransformation: {\n\t        x,\n\t        y,\n\t        angle\n\t      }\n\t    } = this.getPortMetrics(portId);\n\t    return {\n\t      x,\n\t      y,\n\t      angle\n\t    };\n\t  },\n\t  getPortRelativeRect(portId) {\n\t    const {\n\t      portTransformation: {\n\t        x,\n\t        y,\n\t        angle\n\t      },\n\t      portSize: {\n\t        width,\n\t        height\n\t      }\n\t    } = this.getPortMetrics(portId);\n\t    const portRect = {\n\t      x: x - width / 2,\n\t      y: y - height / 2,\n\t      width,\n\t      height,\n\t      angle\n\t    };\n\t    return portRect;\n\t  },\n\t  /**\n\t   * @param {string} portId\n\t   * @returns {Point}\n\t   * @description Returns the port center in the graph coordinate system.\n\t   * The port center is in the graph coordinate system, and the position\n\t   * already takes into account the element rotation.\n\t   **/\n\t  getPortCenter(portId) {\n\t    const elementBBox = this.getBBox();\n\t    const portPosition = this.getPortRelativePosition(portId);\n\t    const portCenter = new Point(portPosition).offset(elementBBox.x, elementBBox.y);\n\t    const angle = this.angle();\n\t    if (angle) portCenter.rotate(elementBBox.center(), -angle);\n\t    return portCenter;\n\t  },\n\t  /**\n\t   * @param {string} portId\n\t   * @param {object} [opt]\n\t   * @param {boolean} [opt.rotate] - If true, the port bounding box is rotated\n\t   * around the port center.\n\t   * @returns {Rect}\n\t   * @description Returns the bounding box of the port in the graph coordinate system.\n\t   * The port center is rotated around the element center, but the port bounding box\n\t   * is not rotated (unless `opt.rotate` is set to true).\n\t   */\n\t  getPortBBox: function (portId, opt) {\n\t    const portRect = this.getPortRelativeRect(portId);\n\t    const elementBBox = this.getBBox();\n\t    // Note: the `angle` property of the `port` is ignore here for now\n\t    const portBBox = new Rect(portRect);\n\t    portBBox.offset(elementBBox.x, elementBBox.y);\n\t    const angle = this.angle();\n\t    if (angle) {\n\t      portBBox.moveAroundPoint(elementBBox.center(), -angle);\n\t    }\n\t    if (opt && opt.rotate) {\n\t      portBBox.rotateAroundCenter(angle);\n\t    }\n\t    return portBBox;\n\t  },\n\t  /**\n\t   * @param {string|Port} port port id or port\n\t   * @returns {number} port index\n\t   */\n\t  getPortIndex: function (port) {\n\t    var id = isObject(port) ? port.id : port;\n\t    if (!this._isValidPortId(id)) {\n\t      return -1;\n\t    }\n\t    return toArray$1(this.prop('ports/items')).findIndex(function (item) {\n\t      return item.id === id;\n\t    });\n\t  },\n\t  /**\n\t   * @param {object} port\n\t   * @param {object} [opt]\n\t   * @returns {joint.dia.Element}\n\t   */\n\t  addPort: function (port, opt) {\n\t    if (!isObject(port) || Array.isArray(port)) {\n\t      throw new Error('Element: addPort requires an object.');\n\t    }\n\t    var ports = assign([], this.prop('ports/items'));\n\t    ports.push(port);\n\t    this.prop('ports/items', ports, opt);\n\t    return this;\n\t  },\n\t  /**\n\t   * @param {string|Port|number} before\n\t   * @param {object} port\n\t   * @param {object} [opt]\n\t   * @returns {joint.dia.Element}\n\t   */\n\t  insertPort: function (before, port, opt) {\n\t    const index = typeof before === 'number' ? before : this.getPortIndex(before);\n\t    if (!isObject(port) || Array.isArray(port)) {\n\t      throw new Error('dia.Element: insertPort requires an object.');\n\t    }\n\t    const ports = assign([], this.prop('ports/items'));\n\t    ports.splice(index, 0, port);\n\t    this.prop('ports/items', ports, opt);\n\t    return this;\n\t  },\n\t  /**\n\t   * @param {string} portId\n\t   * @param {string|object=} path\n\t   * @param {*=} value\n\t   * @param {object=} opt\n\t   * @returns {joint.dia.Element}\n\t   */\n\t  portProp: function (portId, path, value, opt) {\n\t    var index = this.getPortIndex(portId);\n\t    if (index === -1) {\n\t      throw new Error('Element: unable to find port with id ' + portId);\n\t    }\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    if (Array.isArray(path)) {\n\t      args[0] = ['ports', 'items', index].concat(path);\n\t    } else if (isString(path)) {\n\t      // Get/set an attribute by a special path syntax that delimits\n\t      // nested objects by the colon character.\n\t      args[0] = ['ports/items/', index, '/', path].join('');\n\t    } else {\n\t      args = ['ports/items/' + index];\n\t      if (isPlainObject(path)) {\n\t        args.push(path);\n\t        args.push(value);\n\t      }\n\t    }\n\t    return this.prop.apply(this, args);\n\t  },\n\t  _validatePorts: function () {\n\t    var portsAttr = this.get('ports') || {};\n\t    var errorMessages = [];\n\t    portsAttr = portsAttr || {};\n\t    var ports = toArray$1(portsAttr.items);\n\t    ports.forEach(function (p) {\n\t      if (typeof p !== 'object') {\n\t        errorMessages.push('Element: invalid port ', p);\n\t      }\n\t      if (!this._isValidPortId(p.id)) {\n\t        p.id = this.generatePortId();\n\t      }\n\t    }, this);\n\t    if (uniq(ports, 'id').length !== ports.length) {\n\t      errorMessages.push('Element: found id duplicities in ports.');\n\t    }\n\t    return errorMessages;\n\t  },\n\t  generatePortId: function () {\n\t    return this.generateId();\n\t  },\n\t  /**\n\t   * @param {string} id port id\n\t   * @returns {boolean}\n\t   * @private\n\t   */\n\t  _isValidPortId: function (id) {\n\t    return id !== null && id !== undefined && !isObject(id);\n\t  },\n\t  addPorts: function (ports, opt) {\n\t    if (ports.length) {\n\t      this.prop('ports/items', assign([], this.prop('ports/items')).concat(ports), opt);\n\t    }\n\t    return this;\n\t  },\n\t  removePort: function (port, opt) {\n\t    const options = opt || {};\n\t    const index = this.getPortIndex(port);\n\t    if (index !== -1) {\n\t      const ports = assign([], this.prop(['ports', 'items']));\n\t      ports.splice(index, 1);\n\t      options.rewrite = true;\n\t      this.startBatch('port-remove');\n\t      this.prop(['ports', 'items'], ports, options);\n\t      this.stopBatch('port-remove');\n\t    }\n\t    return this;\n\t  },\n\t  removePorts: function (portsForRemoval, opt) {\n\t    let options, newPorts;\n\t    if (Array.isArray(portsForRemoval)) {\n\t      options = opt || {};\n\t      if (portsForRemoval.length === 0) return this.this;\n\t      const currentPorts = assign([], this.prop(['ports', 'items']));\n\t      newPorts = currentPorts.filter(function (cp) {\n\t        return !portsForRemoval.some(function (rp) {\n\t          const rpId = isObject(rp) ? rp.id : rp;\n\t          return cp.id === rpId;\n\t        });\n\t      });\n\t    } else {\n\t      options = portsForRemoval || {};\n\t      newPorts = [];\n\t    }\n\t    this.startBatch('port-remove');\n\t    options.rewrite = true;\n\t    this.prop(['ports', 'items'], newPorts, options);\n\t    this.stopBatch('port-remove');\n\t    return this;\n\t  },\n\t  /**\n\t   * @private\n\t   */\n\t  _createPortData: function () {\n\t    var err = this._validatePorts();\n\t    if (err.length > 0) {\n\t      this.set('ports', this.previous('ports'));\n\t      throw new Error(err.join(' '));\n\t    }\n\t    var prevPortData;\n\t    if (this._portSettingsData) {\n\t      prevPortData = this._portSettingsData.getPorts();\n\t    }\n\t    this._portSettingsData = new PortData(this);\n\t    var curPortData = this._portSettingsData.getPorts();\n\t    if (prevPortData) {\n\t      var added = curPortData.filter(function (item) {\n\t        if (!prevPortData.find(function (prevPort) {\n\t          return prevPort.id === item.id;\n\t        })) {\n\t          return item;\n\t        }\n\t      });\n\t      var removed = prevPortData.filter(function (item) {\n\t        if (!curPortData.find(function (curPort) {\n\t          return curPort.id === item.id;\n\t        })) {\n\t          return item;\n\t        }\n\t      });\n\t      if (removed.length > 0) {\n\t        this.trigger('ports:remove', this, removed);\n\t      }\n\t      if (added.length > 0) {\n\t        this.trigger('ports:add', this, added);\n\t      }\n\t    }\n\t  }\n\t};\n\tconst elementViewPortPrototype = {\n\t  portContainerMarkup: 'g',\n\t  portMarkup: [{\n\t    tagName: 'circle',\n\t    selector: 'circle',\n\t    attributes: {\n\t      'r': 10,\n\t      'fill': '#FFFFFF',\n\t      'stroke': '#000000'\n\t    }\n\t  }],\n\t  portLabelMarkup: [{\n\t    tagName: 'text',\n\t    selector: 'text',\n\t    attributes: {\n\t      'fill': '#000000'\n\t    }\n\t  }],\n\t  /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n\t  _portElementsCache: null,\n\t  /**\n\t   * @private\n\t   */\n\t  _initializePorts: function () {\n\t    this._cleanPortsCache();\n\t  },\n\t  /**\n\t   * @typedef {Object} Port\n\t   *\n\t   * @property {string} id\n\t   * @property {Object} position\n\t   * @property {Object} label\n\t   * @property {Object} attrs\n\t   * @property {string} markup\n\t   * @property {string} group\n\t   */\n\n\t  /**\n\t   * @private\n\t   */\n\t  _refreshPorts: function () {\n\t    this._removePorts();\n\t    this._cleanPortsCache();\n\t    this._renderPorts();\n\t  },\n\t  _cleanPortsCache: function () {\n\t    this._portElementsCache = {};\n\t  },\n\t  /**\n\t   * @private\n\t   */\n\t  _renderPorts: function () {\n\t    // references to rendered elements without z-index\n\t    var elementReferences = [];\n\t    var elem = this._getContainerElement();\n\t    for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n\t      elementReferences.push(elem.node.childNodes[i]);\n\t    }\n\t    var portsGropsByZ = groupBy(this.model._portSettingsData.getPorts(), 'z');\n\t    var withoutZKey = 'auto';\n\n\t    // render non-z first\n\t    toArray$1(portsGropsByZ[withoutZKey]).forEach(function (port) {\n\t      var portElement = this._getPortElement(port);\n\t      elem.append(portElement);\n\t      elementReferences.push(portElement);\n\t    }, this);\n\t    var groupNames = Object.keys(portsGropsByZ);\n\t    for (var k = 0; k < groupNames.length; k++) {\n\t      var groupName = groupNames[k];\n\t      if (groupName !== withoutZKey) {\n\t        var z = parseInt(groupName, 10);\n\t        this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n\t      }\n\t    }\n\t    this._updatePorts();\n\t  },\n\t  /**\n\t   * @returns {V}\n\t   * @private\n\t   */\n\t  _getContainerElement: function () {\n\t    return this.rotatableNode || this.vel;\n\t  },\n\t  /**\n\t   * @param {Array<Port>}ports\n\t   * @param {number} z\n\t   * @param refs\n\t   * @private\n\t   */\n\t  _appendPorts: function (ports, z, refs) {\n\t    var containerElement = this._getContainerElement();\n\t    var portElements = toArray$1(ports).map(this._getPortElement, this);\n\t    if (refs[z] || z < 0) {\n\t      V(refs[Math.max(z, 0)]).before(portElements);\n\t    } else {\n\t      containerElement.append(portElements);\n\t    }\n\t  },\n\t  /**\n\t   * Try to get element from cache,\n\t   * @param port\n\t   * @returns {*}\n\t   * @private\n\t   */\n\t  _getPortElement: function (port) {\n\t    if (this._portElementsCache[port.id]) {\n\t      return this._portElementsCache[port.id].portElement;\n\t    }\n\t    return this._createPortElement(port);\n\t  },\n\t  findPortNodes: function (portId, selector) {\n\t    const portCache = this._portElementsCache[portId];\n\t    if (!portCache) return [];\n\t    if (!selector) return [portCache.portContentElement.node];\n\t    const portRoot = portCache.portElement.node;\n\t    const portSelectors = portCache.portSelectors;\n\t    return this.findBySelector(selector, portRoot, portSelectors);\n\t  },\n\t  findPortNode: function (portId, selector) {\n\t    const [node = null] = this.findPortNodes(portId, selector);\n\t    return node;\n\t  },\n\t  /**\n\t   * @private\n\t   */\n\t  _updatePorts: function () {\n\t    // layout ports without group\n\t    this._updatePortGroup(undefined);\n\t    // layout ports with explicit group\n\t    var groupsNames = Object.keys(this.model._portSettingsData.groups);\n\t    groupsNames.forEach(this._updatePortGroup, this);\n\t  },\n\t  /**\n\t   * @private\n\t   */\n\t  _removePorts: function () {\n\t    invoke(this._portElementsCache, 'portElement.remove');\n\t  },\n\t  /**\n\t   * @param {Port} port\n\t   * @returns {V}\n\t   * @private\n\t   */\n\t  _createPortElement: function (port) {\n\t    let portElement;\n\t    let labelElement;\n\t    let labelSelectors;\n\t    let portSelectors;\n\t    var portContainerElement = V(this.portContainerMarkup).addClass('joint-port');\n\t    var portMarkup = this._getPortMarkup(port);\n\t    if (Array.isArray(portMarkup)) {\n\t      var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n\t      var portFragment = portDoc.fragment;\n\t      if (portFragment.childNodes.length > 1) {\n\t        portElement = V('g').append(portFragment);\n\t      } else {\n\t        portElement = V(portFragment.firstChild);\n\t      }\n\t      portSelectors = portDoc.selectors;\n\t    } else {\n\t      portElement = V(portMarkup);\n\t      if (Array.isArray(portElement)) {\n\t        portElement = V('g').append(portElement);\n\t      }\n\t    }\n\t    if (!portElement) {\n\t      throw new Error('ElementView: Invalid port markup.');\n\t    }\n\t    portElement.attr({\n\t      'port': port.id,\n\t      'port-group': port.group\n\t    });\n\n\t    // If the port ID is a number, we need to add\n\t    // extra information to the port element to distinguish\n\t    // between ports with the same ID but different types.\n\t    if (isNumber(port.id)) {\n\t      portElement.attr('port-id-type', 'number');\n\t    }\n\t    const labelMarkupDef = this._getPortLabelMarkup(port.label);\n\t    if (Array.isArray(labelMarkupDef)) {\n\t      // JSON Markup\n\t      const {\n\t        fragment,\n\t        selectors\n\t      } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n\t      const childCount = fragment.childNodes.length;\n\t      if (childCount > 0) {\n\t        labelSelectors = selectors;\n\t        labelElement = childCount === 1 ? V(fragment.firstChild) : V('g').append(fragment);\n\t      }\n\t    } else {\n\t      // String Markup\n\t      labelElement = V(labelMarkupDef);\n\t      if (Array.isArray(labelElement)) {\n\t        labelElement = V('g').append(labelElement);\n\t      }\n\t    }\n\t    var portContainerSelectors;\n\t    if (portSelectors && labelSelectors) {\n\t      for (var key in labelSelectors) {\n\t        if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');\n\t      }\n\t      portContainerSelectors = assign({}, portSelectors, labelSelectors);\n\t    } else {\n\t      portContainerSelectors = portSelectors || labelSelectors || {};\n\t    }\n\n\t    // The `portRootSelector` points to the root SVGNode of the port.\n\t    // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n\t    // Or the single SVGNode of the port.\n\t    const portRootSelector = 'portRoot';\n\t    // The `labelRootSelector` points to the root SVGNode of the label.\n\t    const labelRootSelector = 'labelRoot';\n\t    // The `labelTextSelector` points to all text SVGNodes of the label.\n\t    const labelTextSelector = 'labelText';\n\t    if (!(portRootSelector in portContainerSelectors)) {\n\t      portContainerSelectors[portRootSelector] = portElement.node;\n\t    }\n\t    if (labelElement) {\n\t      const labelNode = labelElement.node;\n\t      if (!(labelRootSelector in portContainerSelectors)) {\n\t        portContainerSelectors[labelRootSelector] = labelNode;\n\t      }\n\t      if (!(labelTextSelector in portContainerSelectors)) {\n\t        // If the label is a <text> element, we can use it directly.\n\t        // Otherwise, we need to find the <text> element within the label.\n\t        const labelTextNode = labelElement.tagName() === 'TEXT' ? labelNode : Array.from(labelNode.querySelectorAll('text'));\n\t        portContainerSelectors[labelTextSelector] = labelTextNode;\n\t        if (!labelSelectors) labelSelectors = {};\n\t        labelSelectors[labelTextSelector] = labelTextNode;\n\t      }\n\t    }\n\t    portContainerElement.append(portElement.addClass('joint-port-body'));\n\t    if (labelElement) {\n\t      portContainerElement.append(labelElement.addClass('joint-port-label'));\n\t    }\n\t    this._portElementsCache[port.id] = {\n\t      portElement: portContainerElement,\n\t      portLabelElement: labelElement,\n\t      portSelectors: portContainerSelectors,\n\t      portLabelSelectors: labelSelectors,\n\t      portContentElement: portElement,\n\t      portContentSelectors: portSelectors\n\t    };\n\t    return portContainerElement;\n\t  },\n\t  /**\n\t   * @param {string=} groupName\n\t   * @private\n\t   */\n\t  _updatePortGroup: function (groupName) {\n\t    const portsMetrics = this.model.getGroupPortsMetrics(groupName);\n\t    const portsIds = Object.keys(portsMetrics);\n\t    for (let i = 0, n = portsIds.length; i < n; i++) {\n\t      const portId = portsIds[i];\n\t      const metrics = portsMetrics[portId];\n\t      const cached = this._portElementsCache[portId] || {};\n\t      const portTransformation = metrics.portTransformation;\n\t      const labelTransformation = metrics.labelTransformation;\n\t      if (labelTransformation && cached.portLabelElement) {\n\t        this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n\t          rootBBox: new Rect(metrics.labelSize),\n\t          selectors: cached.portLabelSelectors\n\t        });\n\t        this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);\n\t      }\n\t      this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n\t        rootBBox: new Rect(metrics.portSize),\n\t        selectors: cached.portSelectors\n\t      });\n\t      this.applyPortTransform(cached.portElement, portTransformation);\n\t    }\n\t  },\n\t  /**\n\t   * @param {Vectorizer} element\n\t   * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n\t   * @param {number=} initialAngle\n\t   * @constructor\n\t   */\n\t  applyPortTransform: function (element, transformData, initialAngle) {\n\t    var matrix = V.createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);\n\t    element.transform(matrix, {\n\t      absolute: true\n\t    });\n\t  },\n\t  /**\n\t   * @param {Port} port\n\t   * @returns {string}\n\t   * @private\n\t   */\n\t  _getPortMarkup: function (port) {\n\t    return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n\t  },\n\t  /**\n\t   * @param {Object} label\n\t   * @returns {string}\n\t   * @private\n\t   */\n\t  _getPortLabelMarkup: function (label) {\n\t    return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n\t  }\n\t};\n\n\t// Element base model.\n\t// -----------------------------\n\n\tconst Element$1 = Cell.extend({\n\t  defaults: {\n\t    position: {\n\t      x: 0,\n\t      y: 0\n\t    },\n\t    size: {\n\t      width: 1,\n\t      height: 1\n\t    },\n\t    angle: 0\n\t  },\n\t  initialize: function (attributes, options) {\n\t    this._initializePorts(options);\n\t    Cell.prototype.initialize.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @abstract\n\t   */\n\t  _initializePorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  _refreshPorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  isElement: function () {\n\t    return true;\n\t  },\n\t  position: function (x, y, opt) {\n\t    const isSetter = isNumber(y);\n\t    opt = (isSetter ? opt : x) || {};\n\t    const {\n\t      parentRelative,\n\t      deep,\n\t      restrictedArea\n\t    } = opt;\n\n\t    // option `parentRelative` for setting the position relative to the element's parent.\n\t    let parentPosition;\n\t    if (parentRelative) {\n\t      // Getting the parent's position requires the collection.\n\t      // Cell.parent() holds cell id only.\n\t      if (!this.graph) throw new Error('Element must be part of a graph.');\n\t      const parent = this.getParentCell();\n\t      if (parent && !parent.isLink()) {\n\t        parentPosition = parent.get('position');\n\t      }\n\t    }\n\t    if (isSetter) {\n\t      if (parentPosition) {\n\t        x += parentPosition.x;\n\t        y += parentPosition.y;\n\t      }\n\t      if (deep || restrictedArea) {\n\t        const {\n\t          x: x0,\n\t          y: y0\n\t        } = this.get('position');\n\t        this.translate(x - x0, y - y0, opt);\n\t      } else {\n\t        this.set('position', {\n\t          x,\n\t          y\n\t        }, opt);\n\t      }\n\t      return this;\n\t    } else {\n\t      // Getter returns a geometry point.\n\n\t      const elementPosition = Point(this.get('position'));\n\t      return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;\n\t    }\n\t  },\n\t  translate: function (tx, ty, opt) {\n\t    tx = tx || 0;\n\t    ty = ty || 0;\n\t    if (tx === 0 && ty === 0) {\n\t      // Like nothing has happened.\n\t      return this;\n\t    }\n\t    opt = opt || {};\n\t    // Pass the initiator of the translation.\n\t    opt.translateBy = opt.translateBy || this.id;\n\t    var position = this.get('position') || {\n\t      x: 0,\n\t      y: 0\n\t    };\n\t    var ra = opt.restrictedArea;\n\t    if (ra && opt.translateBy === this.id) {\n\t      if (typeof ra === 'function') {\n\t        var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\t        tx = newPosition.x - position.x;\n\t        ty = newPosition.y - position.y;\n\t      } else {\n\t        // We are restricting the translation for the element itself only. We get\n\t        // the bounding box of the element including all its embeds.\n\t        // All embeds have to be translated the exact same way as the element.\n\t        var bbox = this.getBBox({\n\t          deep: true\n\t        });\n\t        //- - - - - - - - - - - - -> ra.x + ra.width\n\t        // - - - -> position.x      |\n\t        // -> bbox.x\n\t        //                âââââââ   |\n\t        //         ââââââââââââââ\n\t        //         âââââââââ        |\n\t        //   âââââââââââââââ\n\t        //   ââââââââ               |\n\t        //   <-dx->                     | restricted area right border\n\t        //         <-width->        |   â translated element\n\t        //   <- - bbox.width - ->       â embedded element\n\t        var dx = position.x - bbox.x;\n\t        var dy = position.y - bbox.y;\n\t        // Find the maximal/minimal coordinates that the element can be translated\n\t        // while complies the restrictions.\n\t        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n\t        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n\t        // recalculate the translation taking the restrictions into account.\n\t        tx = x - position.x;\n\t        ty = y - position.y;\n\t      }\n\t    }\n\t    var translatedPosition = {\n\t      x: position.x + tx,\n\t      y: position.y + ty\n\t    };\n\n\t    // To find out by how much an element was translated in event 'change:position' handlers.\n\t    opt.tx = tx;\n\t    opt.ty = ty;\n\t    if (opt.transition) {\n\t      if (!isObject(opt.transition)) opt.transition = {};\n\t      this.transition('position', translatedPosition, assign({}, opt.transition, {\n\t        valueFunction: interpolate.object\n\t      }));\n\n\t      // Recursively call `translate()` on all the embeds cells.\n\t      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\t    } else {\n\t      this.startBatch('translate', opt);\n\t      this.set('position', translatedPosition, opt);\n\t      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\t      this.stopBatch('translate', opt);\n\t    }\n\t    return this;\n\t  },\n\t  size: function (width, height, opt) {\n\t    var currentSize = this.get('size');\n\t    // Getter\n\t    // () signature\n\t    if (width === undefined) {\n\t      return {\n\t        width: currentSize.width,\n\t        height: currentSize.height\n\t      };\n\t    }\n\t    // Setter\n\t    // (size, opt) signature\n\t    if (isObject(width)) {\n\t      opt = height;\n\t      height = isNumber(width.height) ? width.height : currentSize.height;\n\t      width = isNumber(width.width) ? width.width : currentSize.width;\n\t    }\n\t    return this.resize(width, height, opt);\n\t  },\n\t  resize: function (width, height, opt) {\n\t    opt = opt || {};\n\t    this.startBatch('resize', opt);\n\t    if (opt.direction) {\n\t      var currentSize = this.get('size');\n\t      switch (opt.direction) {\n\t        case 'left':\n\t        case 'right':\n\t          // Don't change height when resizing horizontally.\n\t          height = currentSize.height;\n\t          break;\n\t        case 'top':\n\t        case 'bottom':\n\t          // Don't change width when resizing vertically.\n\t          width = currentSize.width;\n\t          break;\n\t      }\n\n\t      // Get the angle and clamp its value between 0 and 360 degrees.\n\t      var angle = normalizeAngle(this.get('angle') || 0);\n\n\t      // This is a rectangle in size of the un-rotated element.\n\t      var bbox = this.getBBox();\n\t      var origin;\n\t      if (angle) {\n\t        var quadrant = {\n\t          'top-right': 0,\n\t          'right': 0,\n\t          'top-left': 1,\n\t          'top': 1,\n\t          'bottom-left': 2,\n\t          'left': 2,\n\t          'bottom-right': 3,\n\t          'bottom': 3\n\t        }[opt.direction];\n\t        if (opt.absolute) {\n\t          // We are taking the element's rotation into account\n\t          quadrant += Math.floor((angle + 45) / 90);\n\t          quadrant %= 4;\n\t        }\n\n\t        // Pick the corner point on the element, which meant to stay on its place before and\n\t        // after the rotation.\n\t        var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n\t        // Find  an image of the previous indent point. This is the position, where is the\n\t        // point actually located on the screen.\n\t        var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n\t        // Every point on the element rotates around a circle with the centre of rotation\n\t        // in the middle of the element while the whole element is being rotated. That means\n\t        // that the distance from a point in the corner of the element (supposed its always rect) to\n\t        // the center of the element doesn't change during the rotation and therefore it equals\n\t        // to a distance on un-rotated element.\n\t        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\t        var radius = Math.sqrt(width * width + height * height) / 2;\n\n\t        // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n\t        // and ending at the center of the element. We call this angle `alpha`.\n\n\t        // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n\t        // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n\t        //\n\t        // 3 | 2\n\t        // --c-- Quadrant positions around the element's center `c`\n\t        // 0 | 1\n\t        //\n\t        var alpha = quadrant * Math.PI / 2;\n\n\t        // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n\t        // going through the center of the element) and line crossing the indent of the fixed point and the center\n\t        // of the element. This is the angle we need but on the un-rotated element.\n\t        alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n\t        // Lastly we have to deduct the original angle the element was rotated by and that's it.\n\t        alpha -= toRad(angle);\n\n\t        // With this angle and distance we can easily calculate the centre of the un-rotated element.\n\t        // Note that fromPolar constructor accepts an angle in radians.\n\t        var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n\t        // The top left corner on the un-rotated element has to be half a width on the left\n\t        // and half a height to the top from the center. This will be the origin of rectangle\n\t        // we were looking for.\n\t        origin = Point(center).offset(width / -2, height / -2);\n\t      } else {\n\t        // calculation for the origin Point when there is no rotation of the element\n\t        origin = bbox.topLeft();\n\t        switch (opt.direction) {\n\t          case 'top':\n\t          case 'top-right':\n\t            origin.offset(0, bbox.height - height);\n\t            break;\n\t          case 'left':\n\t          case 'bottom-left':\n\t            origin.offset(bbox.width - width, 0);\n\t            break;\n\t          case 'top-left':\n\t            origin.offset(bbox.width - width, bbox.height - height);\n\t            break;\n\t        }\n\t      }\n\n\t      // Resize the element (before re-positioning it).\n\t      this.set('size', {\n\t        width: width,\n\t        height: height\n\t      }, opt);\n\n\t      // Finally, re-position the element.\n\t      this.position(origin.x, origin.y, opt);\n\t    } else {\n\t      // Resize the element.\n\t      this.set('size', {\n\t        width: width,\n\t        height: height\n\t      }, opt);\n\t    }\n\t    this.stopBatch('resize', opt);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin, opt) {\n\t    var scaledBBox = this.getBBox().scale(sx, sy, origin);\n\t    this.startBatch('scale', opt);\n\t    this.position(scaledBBox.x, scaledBBox.y, opt);\n\t    this.resize(scaledBBox.width, scaledBBox.height, opt);\n\t    this.stopBatch('scale');\n\t    return this;\n\t  },\n\t  fitEmbeds: function (opt) {\n\t    return this.fitToChildren(opt);\n\t  },\n\t  fitToChildren: function (opt = {}) {\n\t    // Getting the children's size and position requires the collection.\n\t    // Cell.get('embeds') holds an array of cell ids only.\n\t    const {\n\t      graph\n\t    } = this;\n\t    if (!graph) throw new Error('Element must be part of a graph.');\n\n\t    // Get element children, optionally filtered according to `opt.filter`.\n\t    const filteredChildElements = this._getFilteredChildElements(opt.filter);\n\t    this.startBatch('fit-embeds', opt);\n\t    if (opt.deep) {\n\t      // `opt.deep = true` means \"fit to all descendants\".\n\t      // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n\t      // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element)\n\t      // - omit `opt.minRect` - it only makes sense for the first level of recursion if there are no filtered children, but in this case we do have filtered children\n\t      invoke(filteredChildElements, 'fitToChildren', omit(opt, 'minRect'));\n\t    }\n\n\t    // Set new size and position of this element, based on:\n\t    // - union of bboxes of filtered element children\n\t    // - inflated by given `opt.padding`\n\t    // - containing at least `opt.minRect` (if this is the first level of recursion and there are no filtered children)\n\t    this._fitToElements(Object.assign({\n\t      elements: filteredChildElements\n\t    }, opt));\n\t    this.stopBatch('fit-embeds');\n\t    return this;\n\t  },\n\t  fitParent: function (opt = {}) {\n\t    const {\n\t      graph\n\t    } = this;\n\t    if (!graph) throw new Error('Element must be part of a graph.');\n\n\t    // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n\t    // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n\t    if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;\n\n\t    // If this element has no parent, there is nothing for us to do.\n\t    const parentElement = this.getParentCell();\n\t    if (!parentElement || !parentElement.isElement()) return this;\n\n\t    // Get element children of parent element (i.e. this element + any sibling elements), optionally filtered according to `opt.filter`.\n\t    const filteredSiblingElements = parentElement._getFilteredChildElements(opt.filter);\n\t    this.startBatch('fit-parent', opt);\n\n\t    // Set new size and position of parent element, based on:\n\t    // - union of bboxes of filtered element children of parent element (i.e. this element + any sibling elements)\n\t    // - inflated by given `opt.padding`\n\t    // - containing at least `opt.minRect` (if this is the first level of recursion and there are no filtered siblings)\n\t    parentElement._fitToElements(Object.assign({\n\t      elements: filteredSiblingElements\n\t    }, opt));\n\t    if (opt.deep) {\n\t      // `opt.deep = true` means \"fit all ancestors to their respective children\".\n\t      // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n\t      // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up\n\t      // - omit `opt.minRect` - `minRect` is not relevant for the parent of parent element (and upwards)\n\t      parentElement.fitParent(omit(opt, 'minRect'));\n\t    }\n\t    this.stopBatch('fit-parent');\n\t    return this;\n\t  },\n\t  _getFilteredChildElements: function (filter) {\n\t    let filterFn;\n\t    if (typeof filter === 'function') {\n\t      filterFn = cell => cell.isElement() && filter(cell);\n\t    } else {\n\t      filterFn = cell => cell.isElement();\n\t    }\n\t    return this.getEmbeddedCells().filter(filterFn);\n\t  },\n\t  // Assumption: This element is part of a graph.\n\t  _fitToElements: function (opt = {}) {\n\t    let minBBox = null;\n\t    if (opt.minRect) {\n\t      // Coerce `opt.minRect` to g.Rect\n\t      // (missing properties are taken from this element's current bbox).\n\t      const minRect = assign(this.getBBox(), opt.minRect);\n\t      minBBox = new Rect(minRect);\n\t    }\n\t    const elementsBBox = this.graph.getCellsBBox(opt.elements);\n\t    // If no `opt.elements` were provided, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).\n\t    if (!elementsBBox) {\n\t      this._setBBox(minBBox, opt);\n\t      return;\n\t    }\n\t    const {\n\t      expandOnly,\n\t      shrinkOnly\n\t    } = opt;\n\t    // This combination is meaningless, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).\n\t    if (expandOnly && shrinkOnly) {\n\t      this._setBBox(minBBox, opt);\n\t      return;\n\t    }\n\n\t    // Calculate new size and position of this element based on:\n\t    // - union of bboxes of `opt.elements`\n\t    // - inflated by normalized `opt.padding` (missing sides = 0)\n\t    let {\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    } = elementsBBox;\n\t    const {\n\t      left,\n\t      right,\n\t      top,\n\t      bottom\n\t    } = normalizeSides(opt.padding);\n\t    x -= left;\n\t    y -= top;\n\t    width += left + right;\n\t    height += bottom + top;\n\t    let contentBBox = new Rect(x, y, width, height);\n\t    if (expandOnly) {\n\t      // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n\t      contentBBox = this.getBBox().union(contentBBox);\n\t    } else if (shrinkOnly) {\n\t      // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n\t      const intersectionBBox = this.getBBox().intersect(contentBBox);\n\t      // If all children are outside this element's current bbox, then `intersectionBBox` is `null`.\n\t      // That does not make sense, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).\n\t      if (!intersectionBBox) {\n\t        this._setBBox(minBBox, opt);\n\t        return;\n\t      }\n\t      contentBBox = intersectionBBox;\n\t    }\n\n\t    // Set the new size and position of this element.\n\t    // - if `opt.minRect` was provided, add it via union to calculated bbox\n\t    let resultBBox = contentBBox;\n\t    if (minBBox) {\n\t      resultBBox = resultBBox.union(minBBox);\n\t    }\n\t    this._setBBox(resultBBox, opt);\n\t  },\n\t  _setBBox: function (bbox, opt) {\n\t    if (!bbox) return;\n\t    const {\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    } = bbox;\n\t    this.set({\n\t      position: {\n\t        x,\n\t        y\n\t      },\n\t      size: {\n\t        width,\n\t        height\n\t      }\n\t    }, opt);\n\t  },\n\t  // Rotate element by `angle` degrees, optionally around `origin` point.\n\t  // If `origin` is not provided, it is considered to be the center of the element.\n\t  // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n\t  // the difference from the previous angle.\n\t  rotate: function (angle, absolute, origin, opt) {\n\t    if (origin) {\n\t      var center = this.getCenter();\n\t      var size = this.get('size');\n\t      var position = this.get('position');\n\t      center.rotate(origin, this.get('angle') - angle);\n\t      var dx = center.x - size.width / 2 - position.x;\n\t      var dy = center.y - size.height / 2 - position.y;\n\t      this.startBatch('rotate', {\n\t        angle: angle,\n\t        absolute: absolute,\n\t        origin: origin\n\t      });\n\t      this.position(position.x + dx, position.y + dy, opt);\n\t      this.rotate(angle, absolute, null, opt);\n\t      this.stopBatch('rotate');\n\t    } else {\n\t      this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n\t    }\n\t    return this;\n\t  },\n\t  angle: function () {\n\t    return normalizeAngle(this.get('angle') || 0);\n\t  },\n\t  getBBox: function (opt = {}) {\n\t    const {\n\t      graph,\n\t      attributes\n\t    } = this;\n\t    const {\n\t      deep,\n\t      rotate\n\t    } = opt;\n\t    if (deep && graph) {\n\t      // Get all the embedded elements using breadth first algorithm.\n\t      const elements = this.getEmbeddedCells({\n\t        deep: true,\n\t        breadthFirst: true\n\t      });\n\t      // Add the model itself.\n\t      elements.push(this);\n\t      // Note: the default of getCellsBBox() is rotate=true and can't be\n\t      // changed without a breaking change\n\t      return graph.getCellsBBox(elements, opt);\n\t    }\n\t    const {\n\t      angle = 0,\n\t      position: {\n\t        x,\n\t        y\n\t      },\n\t      size: {\n\t        width,\n\t        height\n\t      }\n\t    } = attributes;\n\t    const bbox = new Rect(x, y, width, height);\n\t    if (rotate) {\n\t      bbox.rotateAroundCenter(angle);\n\t    }\n\t    return bbox;\n\t  },\n\t  getCenter: function () {\n\t    const {\n\t      position: {\n\t        x,\n\t        y\n\t      },\n\t      size: {\n\t        width,\n\t        height\n\t      }\n\t    } = this.attributes;\n\t    return new Point(x + width / 2, y + height / 2);\n\t  },\n\t  getPointFromConnectedLink: function (link, endType) {\n\t    // Center of the model\n\t    var bbox = this.getBBox();\n\t    var center = bbox.center();\n\t    // Center of a port\n\t    var endDef = link.get(endType);\n\t    if (!endDef) return center;\n\t    var portId = endDef.port;\n\t    if (!portId || !this.hasPort(portId)) return center;\n\t    return this.getPortCenter(portId);\n\t  }\n\t});\n\tassign(Element$1.prototype, elementPortPrototype);\n\n\t// Link base model.\n\t// --------------------------\n\n\tconst Link$1 = Cell.extend({\n\t  // may be overwritten by user to change default label (its markup, size, attrs, position)\n\t  defaultLabel: undefined,\n\t  // deprecated\n\t  // may be overwritten by user to change default label markup\n\t  // lower priority than defaultLabel.markup\n\t  labelMarkup: undefined,\n\t  // private\n\t  _builtins: {\n\t    defaultLabel: {\n\t      // builtin default markup:\n\t      // used if neither defaultLabel.markup\n\t      // nor label.markup is set\n\t      markup: [{\n\t        tagName: 'rect',\n\t        selector: 'rect' // faster than tagName CSS selector\n\t      }, {\n\t        tagName: 'text',\n\t        selector: 'text' // faster than tagName CSS selector\n\t      }],\n\t      // builtin default attributes:\n\t      // applied only if builtin default markup is used\n\t      attrs: {\n\t        text: {\n\t          fill: '#000000',\n\t          fontSize: 14,\n\t          textAnchor: 'middle',\n\t          textVerticalAnchor: 'middle',\n\t          pointerEvents: 'none'\n\t        },\n\t        rect: {\n\t          ref: 'text',\n\t          fill: '#ffffff',\n\t          rx: 3,\n\t          ry: 3,\n\t          x: 'calc(x)',\n\t          y: 'calc(y)',\n\t          width: 'calc(w)',\n\t          height: 'calc(h)'\n\t        }\n\t      },\n\t      // builtin default position:\n\t      // used if neither defaultLabel.position\n\t      // nor label.position is set\n\t      position: {\n\t        distance: 0.5\n\t      }\n\t    }\n\t  },\n\t  defaults: {\n\t    source: {},\n\t    target: {}\n\t  },\n\t  isLink: function () {\n\t    return true;\n\t  },\n\t  disconnect: function (opt) {\n\t    return this.set({\n\t      source: {\n\t        x: 0,\n\t        y: 0\n\t      },\n\t      target: {\n\t        x: 0,\n\t        y: 0\n\t      }\n\t    }, opt);\n\t  },\n\t  source: function (source, args, opt) {\n\t    // getter\n\t    if (source === undefined) {\n\t      return clone$1(this.get('source'));\n\t    }\n\n\t    // setter\n\t    var setSource;\n\t    var setOpt;\n\n\t    // `source` is a cell\n\t    // take only its `id` and combine with `args`\n\t    var isCellProvided = source instanceof Cell;\n\t    if (isCellProvided) {\n\t      // three arguments\n\t      setSource = clone$1(args) || {};\n\t      setSource.id = source.id;\n\t      setOpt = opt;\n\t      return this.set('source', setSource, setOpt);\n\t    }\n\n\t    // `source` is a point-like object\n\t    // for example, a g.Point\n\t    // take only its `x` and `y` and combine with `args`\n\t    var isPointProvided = !isPlainObject(source);\n\t    if (isPointProvided) {\n\t      // three arguments\n\t      setSource = clone$1(args) || {};\n\t      setSource.x = source.x;\n\t      setSource.y = source.y;\n\t      setOpt = opt;\n\t      return this.set('source', setSource, setOpt);\n\t    }\n\n\t    // `source` is an object\n\t    // no checking\n\t    // two arguments\n\t    setSource = source;\n\t    setOpt = args;\n\t    return this.set('source', setSource, setOpt);\n\t  },\n\t  target: function (target, args, opt) {\n\t    // getter\n\t    if (target === undefined) {\n\t      return clone$1(this.get('target'));\n\t    }\n\n\t    // setter\n\t    var setTarget;\n\t    var setOpt;\n\n\t    // `target` is a cell\n\t    // take only its `id` argument and combine with `args`\n\t    var isCellProvided = target instanceof Cell;\n\t    if (isCellProvided) {\n\t      // three arguments\n\t      setTarget = clone$1(args) || {};\n\t      setTarget.id = target.id;\n\t      setOpt = opt;\n\t      return this.set('target', setTarget, setOpt);\n\t    }\n\n\t    // `target` is a point-like object\n\t    // for example, a g.Point\n\t    // take only its `x` and `y` and combine with `args`\n\t    var isPointProvided = !isPlainObject(target);\n\t    if (isPointProvided) {\n\t      // three arguments\n\t      setTarget = clone$1(args) || {};\n\t      setTarget.x = target.x;\n\t      setTarget.y = target.y;\n\t      setOpt = opt;\n\t      return this.set('target', setTarget, setOpt);\n\t    }\n\n\t    // `target` is an object\n\t    // no checking\n\t    // two arguments\n\t    setTarget = target;\n\t    setOpt = args;\n\t    return this.set('target', setTarget, setOpt);\n\t  },\n\t  router: function (name, args, opt) {\n\t    // getter\n\t    if (name === undefined) {\n\t      var router = this.get('router');\n\t      if (!router) {\n\t        return null;\n\t      }\n\t      if (typeof router === 'object') return clone$1(router);\n\t      return router; // e.g. a function\n\t    }\n\n\t    // setter\n\t    var isRouterProvided = typeof name === 'object' || typeof name === 'function';\n\t    var localRouter = isRouterProvided ? name : {\n\t      name: name,\n\t      args: args\n\t    };\n\t    var localOpt = isRouterProvided ? args : opt;\n\t    return this.set('router', localRouter, localOpt);\n\t  },\n\t  connector: function (name, args, opt) {\n\t    // getter\n\t    if (name === undefined) {\n\t      var connector = this.get('connector');\n\t      if (!connector) {\n\t        return null;\n\t      }\n\t      if (typeof connector === 'object') return clone$1(connector);\n\t      return connector; // e.g. a function\n\t    }\n\n\t    // setter\n\t    var isConnectorProvided = typeof name === 'object' || typeof name === 'function';\n\t    var localConnector = isConnectorProvided ? name : {\n\t      name: name,\n\t      args: args\n\t    };\n\t    var localOpt = isConnectorProvided ? args : opt;\n\t    return this.set('connector', localConnector, localOpt);\n\t  },\n\t  // Labels API\n\n\t  // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n\t  label: function (idx, label, opt) {\n\t    var labels = this.labels();\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : 0;\n\t    if (idx < 0) idx = labels.length + idx;\n\n\t    // getter\n\t    if (arguments.length <= 1) return this.prop(['labels', idx]);\n\t    // setter\n\t    return this.prop(['labels', idx], label, opt);\n\t  },\n\t  labels: function (labels, opt) {\n\t    // getter\n\t    if (arguments.length === 0) {\n\t      labels = this.get('labels');\n\t      if (!Array.isArray(labels)) return [];\n\t      return labels.slice();\n\t    }\n\t    // setter\n\t    if (!Array.isArray(labels)) labels = [];\n\t    return this.set('labels', labels, opt);\n\t  },\n\t  hasLabels: function () {\n\t    const {\n\t      labels\n\t    } = this.attributes;\n\t    return Array.isArray(labels) && labels.length > 0;\n\t  },\n\t  insertLabel: function (idx, label, opt) {\n\t    if (!label) throw new Error('dia.Link: no label provided');\n\t    var labels = this.labels();\n\t    var n = labels.length;\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : n;\n\t    if (idx < 0) idx = n + idx + 1;\n\t    labels.splice(idx, 0, label);\n\t    return this.labels(labels, opt);\n\t  },\n\t  // convenience function\n\t  // add label to end of labels array\n\t  appendLabel: function (label, opt) {\n\t    return this.insertLabel(-1, label, opt);\n\t  },\n\t  removeLabel: function (idx, opt) {\n\t    var labels = this.labels();\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : -1;\n\t    labels.splice(idx, 1);\n\t    return this.labels(labels, opt);\n\t  },\n\t  // Vertices API\n\n\t  vertex: function (idx, vertex, opt) {\n\t    var vertices = this.vertices();\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : 0;\n\t    if (idx < 0) idx = vertices.length + idx;\n\n\t    // getter\n\t    if (arguments.length <= 1) return this.prop(['vertices', idx]);\n\n\t    // setter\n\t    var setVertex = this._normalizeVertex(vertex);\n\t    return this.prop(['vertices', idx], setVertex, opt);\n\t  },\n\t  vertices: function (vertices, opt) {\n\t    // getter\n\t    if (arguments.length === 0) {\n\t      vertices = this.get('vertices');\n\t      if (!Array.isArray(vertices)) return [];\n\t      return vertices.slice();\n\t    }\n\n\t    // setter\n\t    if (!Array.isArray(vertices)) vertices = [];\n\t    var setVertices = [];\n\t    for (var i = 0; i < vertices.length; i++) {\n\t      var vertex = vertices[i];\n\t      var setVertex = this._normalizeVertex(vertex);\n\t      setVertices.push(setVertex);\n\t    }\n\t    return this.set('vertices', setVertices, opt);\n\t  },\n\t  insertVertex: function (idx, vertex, opt) {\n\t    if (!vertex) throw new Error('dia.Link: no vertex provided');\n\t    var vertices = this.vertices();\n\t    var n = vertices.length;\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : n;\n\t    if (idx < 0) idx = n + idx + 1;\n\t    var setVertex = this._normalizeVertex(vertex);\n\t    vertices.splice(idx, 0, setVertex);\n\t    return this.vertices(vertices, opt);\n\t  },\n\t  removeVertex: function (idx, opt) {\n\t    var vertices = this.vertices();\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : -1;\n\t    vertices.splice(idx, 1);\n\t    return this.vertices(vertices, opt);\n\t  },\n\t  _normalizeVertex: function (vertex) {\n\t    // is vertex a point-like object?\n\t    // for example, a g.Point\n\t    var isPointProvided = !isPlainObject(vertex);\n\t    if (isPointProvided) return {\n\t      x: vertex.x,\n\t      y: vertex.y\n\t    };\n\n\t    // else: return vertex unchanged\n\t    return vertex;\n\t  },\n\t  // Transformations\n\n\t  translate: function (tx, ty, opt) {\n\t    // enrich the option object\n\t    opt = opt || {};\n\t    opt.translateBy = opt.translateBy || this.id;\n\t    opt.tx = tx;\n\t    opt.ty = ty;\n\t    return this.applyToPoints(function (p) {\n\t      return {\n\t        x: (p.x || 0) + tx,\n\t        y: (p.y || 0) + ty\n\t      };\n\t    }, opt);\n\t  },\n\t  scale: function (sx, sy, origin, opt) {\n\t    return this.applyToPoints(function (p) {\n\t      return Point(p).scale(sx, sy, origin).toJSON();\n\t    }, opt);\n\t  },\n\t  applyToPoints: function (fn, opt) {\n\t    if (!isFunction(fn)) {\n\t      throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');\n\t    }\n\t    var attrs = {};\n\t    var {\n\t      source,\n\t      target\n\t    } = this.attributes;\n\t    if (!source.id) {\n\t      attrs.source = fn(source);\n\t    }\n\t    if (!target.id) {\n\t      attrs.target = fn(target);\n\t    }\n\t    var vertices = this.vertices();\n\t    if (vertices.length > 0) {\n\t      attrs.vertices = vertices.map(fn);\n\t    }\n\t    return this.set(attrs, opt);\n\t  },\n\t  getSourcePoint: function () {\n\t    var sourceCell = this.getSourceCell();\n\t    if (!sourceCell) return new Point(this.source());\n\t    return sourceCell.getPointFromConnectedLink(this, 'source');\n\t  },\n\t  getTargetPoint: function () {\n\t    var targetCell = this.getTargetCell();\n\t    if (!targetCell) return new Point(this.target());\n\t    return targetCell.getPointFromConnectedLink(this, 'target');\n\t  },\n\t  getPointFromConnectedLink: function /* link, endType */\n\t  () {\n\t    return this.getPolyline().pointAt(0.5);\n\t  },\n\t  getPolyline: function () {\n\t    const points = [this.getSourcePoint(), ...this.vertices().map(Point), this.getTargetPoint()];\n\t    return new Polyline$1(points);\n\t  },\n\t  getBBox: function () {\n\t    return this.getPolyline().bbox();\n\t  },\n\t  reparent: function (opt) {\n\t    var newParent;\n\t    if (this.graph) {\n\t      var source = this.getSourceElement();\n\t      var target = this.getTargetElement();\n\t      var prevParent = this.getParentCell();\n\t      if (source && target) {\n\t        if (source === target || source.isEmbeddedIn(target)) {\n\t          newParent = target;\n\t        } else if (target.isEmbeddedIn(source)) {\n\t          newParent = source;\n\t        } else {\n\t          newParent = this.graph.getCommonAncestor(source, target);\n\t        }\n\t      }\n\t      if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n\t        // Unembed the link if source and target has no common ancestor\n\t        // or common ancestor changed\n\t        prevParent.unembed(this, opt);\n\t      }\n\t      if (newParent) {\n\t        newParent.embed(this, opt);\n\t      }\n\t    }\n\t    return newParent;\n\t  },\n\t  hasLoop: function (opt) {\n\t    opt = opt || {};\n\t    var {\n\t      source,\n\t      target\n\t    } = this.attributes;\n\t    var sourceId = source.id;\n\t    var targetId = target.id;\n\t    if (!sourceId || !targetId) {\n\t      // Link \"pinned\" to the paper does not have a loop.\n\t      return false;\n\t    }\n\t    var loop = sourceId === targetId;\n\n\t    // Note that there in the deep mode a link can have a loop,\n\t    // even if it connects only a parent and its embed.\n\t    // A loop \"target equals source\" is valid in both shallow and deep mode.\n\t    if (!loop && opt.deep && this.graph) {\n\t      var sourceElement = this.getSourceCell();\n\t      var targetElement = this.getTargetCell();\n\t      loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n\t    }\n\t    return loop;\n\t  },\n\t  // unlike source(), this method returns null if source is a point\n\t  getSourceCell: function () {\n\t    const {\n\t      graph,\n\t      attributes\n\t    } = this;\n\t    var source = attributes.source;\n\t    return source && source.id && graph && graph.getCell(source.id) || null;\n\t  },\n\t  getSourceElement: function () {\n\t    var cell = this;\n\t    var visited = {};\n\t    do {\n\t      if (visited[cell.id]) return null;\n\t      visited[cell.id] = true;\n\t      cell = cell.getSourceCell();\n\t    } while (cell && cell.isLink());\n\t    return cell;\n\t  },\n\t  // unlike target(), this method returns null if target is a point\n\t  getTargetCell: function () {\n\t    const {\n\t      graph,\n\t      attributes\n\t    } = this;\n\t    var target = attributes.target;\n\t    return target && target.id && graph && graph.getCell(target.id) || null;\n\t  },\n\t  getTargetElement: function () {\n\t    var cell = this;\n\t    var visited = {};\n\t    do {\n\t      if (visited[cell.id]) return null;\n\t      visited[cell.id] = true;\n\t      cell = cell.getTargetCell();\n\t    } while (cell && cell.isLink());\n\t    return cell;\n\t  },\n\t  // Returns the common ancestor for the source element,\n\t  // target element and the link itself.\n\t  getRelationshipAncestor: function () {\n\t    var connectionAncestor;\n\t    if (this.graph) {\n\t      var cells = [this, this.getSourceElement(),\n\t      // null if source is a point\n\t      this.getTargetElement() // null if target is a point\n\t      ].filter(function (item) {\n\t        return !!item;\n\t      });\n\t      connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n\t    }\n\t    return connectionAncestor || null;\n\t  },\n\t  // Is source, target and the link itself embedded in a given cell?\n\t  isRelationshipEmbeddedIn: function (cell) {\n\t    var cellId = isString(cell) || isNumber(cell) ? cell : cell.id;\n\t    var ancestor = this.getRelationshipAncestor();\n\t    return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n\t  },\n\t  // Get resolved default label.\n\t  _getDefaultLabel: function () {\n\t    var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};\n\t    var label = {};\n\t    label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;\n\t    label.position = defaultLabel.position;\n\t    label.attrs = defaultLabel.attrs;\n\t    label.size = defaultLabel.size;\n\t    return label;\n\t  }\n\t}, {\n\t  endsEqual: function (a, b) {\n\t    var portsEqual = a.port === b.port || !a.port && !b.port;\n\t    return a.id === b.id && portsEqual;\n\t  }\n\t});\n\n\tconst env = {\n\t  _results: {},\n\t  _tests: {\n\t    svgforeignobject: function () {\n\t      return !!document.createElementNS && /SVGForeignObject/.test({}.toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\n\t    },\n\t    // works for: (1) macOS Safari, (2) any WKWebView, (3) any iOS browser (including Safari, CriOS, EdgiOS, OPR, FxiOS)\n\t    isAppleWebKit: function () {\n\t      const userAgent = navigator.userAgent;\n\t      const isAppleWebKit = /applewebkit/i.test(userAgent);\n\t      const isChromium = /chrome/i.test(userAgent); // e.g. Chrome, Edge, Opera, SamsungBrowser\n\t      return isAppleWebKit && !isChromium;\n\t    }\n\t  },\n\t  addTest: function (name, fn) {\n\t    return this._tests[name] = fn;\n\t  },\n\t  test: function (name) {\n\t    var fn = this._tests[name];\n\t    if (!fn) {\n\t      throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n\t    }\n\t    var result = this._results[name];\n\t    if (typeof result !== 'undefined') {\n\t      return result;\n\t    }\n\t    try {\n\t      result = fn();\n\t    } catch {\n\t      result = false;\n\t    }\n\n\t    // Cache the test result.\n\t    this._results[name] = result;\n\t    return result;\n\t  }\n\t};\n\n\t// ELEMENTS\n\n\tconst Rectangle = Element$1.define('standard.Rectangle', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      strokeWidth: 2,\n\t      stroke: '#000000',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Circle = Element$1.define('standard.Circle', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      cx: 'calc(s/2)',\n\t      cy: 'calc(s/2)',\n\t      r: 'calc(s/2)',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'circle',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Ellipse = Element$1.define('standard.Ellipse', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      cx: 'calc(w/2)',\n\t      cy: 'calc(h/2)',\n\t      rx: 'calc(w/2)',\n\t      ry: 'calc(h/2)',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'ellipse',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Path = Element$1.define('standard.Path', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      d: 'M 0 0 H calc(w) V calc(h) H 0 Z',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Polygon = Element$1.define('standard.Polygon', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'polygon',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Polyline = Element$1.define('standard.Polyline', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'polyline',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Image = Element$1.define('standard.Image', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    image: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)'\n\t      // xlinkHref: '[URL]'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'top',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h+10)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'image',\n\t    selector: 'image'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst BorderedImage = Element$1.define('standard.BorderedImage', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    border: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      stroke: '#333333',\n\t      strokeWidth: 2\n\t    },\n\t    background: {\n\t      width: 'calc(w-1)',\n\t      height: 'calc(h-1)',\n\t      x: 0.5,\n\t      y: 0.5,\n\t      fill: '#FFFFFF'\n\t    },\n\t    image: {\n\t      // xlinkHref: '[URL]'\n\t      width: 'calc(w-1)',\n\t      height: 'calc(h-1)',\n\t      x: 0.5,\n\t      y: 0.5\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'top',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h+10)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'background',\n\t    attributes: {\n\t      'stroke': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'image',\n\t    selector: 'image'\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'border',\n\t    attributes: {\n\t      'fill': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst EmbeddedImage = Element$1.define('standard.EmbeddedImage', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF',\n\t      strokeWidth: 2\n\t    },\n\t    image: {\n\t      // xlinkHref: '[URL]'\n\t      width: 'calc(0.3*w)',\n\t      height: 'calc(h-20)',\n\t      x: 10,\n\t      y: 10,\n\t      preserveAspectRatio: 'xMidYMin'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'top',\n\t      textAnchor: 'left',\n\t      x: 'calc(0.3*w+20)',\n\t      // 10 + 10\n\t      y: 10,\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'image',\n\t    selector: 'image'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst InscribedImage = Element$1.define('standard.InscribedImage', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    border: {\n\t      rx: 'calc(w/2)',\n\t      ry: 'calc(h/2)',\n\t      cx: 'calc(w/2)',\n\t      cy: 'calc(h/2)',\n\t      stroke: '#333333',\n\t      strokeWidth: 2\n\t    },\n\t    background: {\n\t      rx: 'calc(w/2)',\n\t      ry: 'calc(h/2)',\n\t      cx: 'calc(w/2)',\n\t      cy: 'calc(h/2)',\n\t      fill: '#FFFFFF'\n\t    },\n\t    image: {\n\t      // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n\t      width: 'calc(0.68*w)',\n\t      height: 'calc(0.68*h)',\n\t      // The image offset is calculated as (100% - 68%) / 2\n\t      x: 'calc(0.16*w)',\n\t      y: 'calc(0.16*h)',\n\t      preserveAspectRatio: 'xMidYMid'\n\t      // xlinkHref: '[URL]'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'top',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h+10)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'ellipse',\n\t    selector: 'background'\n\t  }, {\n\t    tagName: 'image',\n\t    selector: 'image'\n\t  }, {\n\t    tagName: 'ellipse',\n\t    selector: 'border',\n\t    attributes: {\n\t      'fill': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst HeaderedRectangle = Element$1.define('standard.HeaderedRectangle', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      strokeWidth: 2,\n\t      stroke: '#000000',\n\t      fill: '#FFFFFF'\n\t    },\n\t    header: {\n\t      width: 'calc(w)',\n\t      height: 30,\n\t      strokeWidth: 2,\n\t      stroke: '#000000',\n\t      fill: '#FFFFFF'\n\t    },\n\t    headerText: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 15,\n\t      fontSize: 16,\n\t      fill: '#333333'\n\t    },\n\t    bodyText: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2+15)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'header'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'headerText'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'bodyText'\n\t  }]\n\t});\n\tvar CYLINDER_TILT = 10;\n\tconst Cylinder = Element$1.define('standard.Cylinder', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      lateralArea: CYLINDER_TILT,\n\t      fill: '#FFFFFF',\n\t      stroke: '#333333',\n\t      strokeWidth: 2\n\t    },\n\t    top: {\n\t      cx: 'calc(w/2)',\n\t      cy: CYLINDER_TILT,\n\t      rx: 'calc(w/2)',\n\t      ry: CYLINDER_TILT,\n\t      fill: '#FFFFFF',\n\t      stroke: '#333333',\n\t      strokeWidth: 2\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h+15)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'ellipse',\n\t    selector: 'top'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }],\n\t  topRy: function (t, opt) {\n\t    // getter\n\t    if (t === undefined) return this.attr('body/lateralArea');\n\n\t    // setter\n\t    var bodyAttrs = {\n\t      lateralArea: t\n\t    };\n\t    var isPercentageSetter = isPercentage(t);\n\t    var ty = isPercentageSetter ? `calc(${parseFloat(t) / 100}*h)` : t;\n\t    var topAttrs = {\n\t      cy: ty,\n\t      ry: ty\n\t    };\n\t    return this.attr({\n\t      body: bodyAttrs,\n\t      top: topAttrs\n\t    }, opt);\n\t  }\n\t}, {\n\t  attributes: {\n\t    'lateral-area': {\n\t      set: function (t, refBBox) {\n\t        var isPercentageSetter = isPercentage(t);\n\t        if (isPercentageSetter) t = parseFloat(t) / 100;\n\t        var x = refBBox.x;\n\t        var y = refBBox.y;\n\t        var w = refBBox.width;\n\t        var h = refBBox.height;\n\n\t        // curve control point variables\n\t        var rx = w / 2;\n\t        var ry = isPercentageSetter ? h * t : t;\n\t        var kappa = V.KAPPA;\n\t        var cx = kappa * rx;\n\t        var cy = kappa * (isPercentageSetter ? h * t : t);\n\n\t        // shape variables\n\t        var xLeft = x;\n\t        var xCenter = x + w / 2;\n\t        var xRight = x + w;\n\t        var ySideTop = y + ry;\n\t        var yCurveTop = ySideTop - ry;\n\t        var ySideBottom = y + h - ry;\n\t        var yCurveBottom = y + h;\n\n\t        // return calculated shape\n\t        var data = ['M', xLeft, ySideTop, 'L', xLeft, ySideBottom, 'C', x, ySideBottom + cy, xCenter - cx, yCurveBottom, xCenter, yCurveBottom, 'C', xCenter + cx, yCurveBottom, xRight, ySideBottom + cy, xRight, ySideBottom, 'L', xRight, ySideTop, 'C', xRight, ySideTop - cy, xCenter + cx, yCurveTop, xCenter, yCurveTop, 'C', xCenter - cx, yCurveTop, xLeft, ySideTop - cy, xLeft, ySideTop, 'Z'];\n\t        return {\n\t          d: data.join(' ')\n\t        };\n\t      },\n\t      unset: 'd'\n\t    }\n\t  }\n\t});\n\tvar foLabelMarkup = {\n\t  tagName: 'foreignObject',\n\t  selector: 'foreignObject',\n\t  attributes: {\n\t    'overflow': 'hidden'\n\t  },\n\t  children: [{\n\t    tagName: 'div',\n\t    namespaceURI: 'http://www.w3.org/1999/xhtml',\n\t    selector: 'label',\n\t    style: {\n\t      width: '100%',\n\t      height: '100%',\n\t      position: 'static',\n\t      backgroundColor: 'transparent',\n\t      textAlign: 'center',\n\t      margin: 0,\n\t      padding: '0px 5px',\n\t      boxSizing: 'border-box',\n\t      display: 'flex',\n\t      alignItems: 'center',\n\t      justifyContent: 'center'\n\t    }\n\t  }]\n\t};\n\tvar svgLabelMarkup = {\n\t  tagName: 'text',\n\t  selector: 'label',\n\t  attributes: {\n\t    'text-anchor': 'middle'\n\t  }\n\t};\n\tvar labelMarkup = env.test('svgforeignobject') ? foLabelMarkup : svgLabelMarkup;\n\tconst TextBlock = Element$1.define('standard.TextBlock', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      stroke: '#333333',\n\t      fill: '#ffffff',\n\t      strokeWidth: 2\n\t    },\n\t    foreignObject: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)'\n\t    },\n\t    label: {\n\t      style: {\n\t        fontSize: 14\n\t      }\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'body'\n\t  }, labelMarkup]\n\t}, {\n\t  attributes: {\n\t    text: {\n\t      set: function (text, refBBox, node, attrs) {\n\t        if (node instanceof HTMLElement) {\n\t          node.textContent = text;\n\t        } else {\n\t          // No foreign object\n\t          var style = attrs['style'] || {};\n\t          var wrapValue = {\n\t            text,\n\t            width: -5,\n\t            height: '100%'\n\t          };\n\t          var wrapAttrs = assign({\n\t            'text-vertical-anchor': 'middle'\n\t          }, style);\n\t          attributes['text-wrap'].set.call(this, wrapValue, refBBox, node, wrapAttrs);\n\t          return {\n\t            fill: style.color || null\n\t          };\n\t        }\n\t      },\n\t      unset: function (node) {\n\t        node.textContent = '';\n\t        if (node instanceof SVGElement) {\n\t          return 'fill';\n\t        }\n\t      },\n\t      position: function (text, refBBox, node) {\n\t        // No foreign object\n\t        if (node instanceof SVGElement) return refBBox.center();\n\t      }\n\t    }\n\t  }\n\t});\n\n\t// LINKS\n\n\tconst Link = Link$1.define('standard.Link', {\n\t  attrs: {\n\t    line: {\n\t      connection: true,\n\t      stroke: '#333333',\n\t      strokeWidth: 2,\n\t      strokeLinejoin: 'round',\n\t      targetMarker: {\n\t        'type': 'path',\n\t        'd': 'M 10 -5 0 0 10 5 z'\n\t      }\n\t    },\n\t    wrapper: {\n\t      connection: true,\n\t      strokeWidth: 10,\n\t      strokeLinejoin: 'round'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'wrapper',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'cursor': 'pointer',\n\t      'stroke': 'transparent',\n\t      'stroke-linecap': 'round'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'line',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'pointer-events': 'none'\n\t    }\n\t  }]\n\t});\n\tconst DoubleLink = Link$1.define('standard.DoubleLink', {\n\t  attrs: {\n\t    line: {\n\t      connection: true,\n\t      stroke: '#DDDDDD',\n\t      strokeWidth: 4,\n\t      strokeLinejoin: 'round',\n\t      targetMarker: {\n\t        type: 'path',\n\t        stroke: '#000000',\n\t        d: 'M 10 -3 10 -10 -2 0 10 10 10 3'\n\t      }\n\t    },\n\t    outline: {\n\t      connection: true,\n\t      stroke: '#000000',\n\t      strokeWidth: 6,\n\t      strokeLinejoin: 'round'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'outline',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'line',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'pointer-events': 'none'\n\t    }\n\t  }]\n\t});\n\tconst ShadowLink = Link$1.define('standard.ShadowLink', {\n\t  attrs: {\n\t    line: {\n\t      connection: true,\n\t      stroke: '#FF0000',\n\t      strokeWidth: 20,\n\t      strokeLinejoin: 'round',\n\t      targetMarker: {\n\t        'type': 'path',\n\t        'stroke': 'none',\n\t        'd': 'M 0 -10 -10 0 0 10 z'\n\t      },\n\t      sourceMarker: {\n\t        'type': 'path',\n\t        'stroke': 'none',\n\t        'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n\t      }\n\t    },\n\t    shadow: {\n\t      connection: true,\n\t      transform: 'translate(3,6)',\n\t      stroke: '#000000',\n\t      strokeOpacity: 0.2,\n\t      strokeWidth: 20,\n\t      strokeLinejoin: 'round',\n\t      targetMarker: {\n\t        'type': 'path',\n\t        'd': 'M 0 -10 -10 0 0 10 z',\n\t        'stroke': 'none'\n\t      },\n\t      sourceMarker: {\n\t        'type': 'path',\n\t        'stroke': 'none',\n\t        'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n\t      }\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'shadow',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'pointer-events': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'line',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'cursor': 'pointer'\n\t    }\n\t  }]\n\t});\n\n\tvar standard = {\n\t\t__proto__: null,\n\t\tBorderedImage: BorderedImage,\n\t\tCircle: Circle,\n\t\tCylinder: Cylinder,\n\t\tDoubleLink: DoubleLink,\n\t\tEllipse: Ellipse,\n\t\tEmbeddedImage: EmbeddedImage,\n\t\tHeaderedRectangle: HeaderedRectangle,\n\t\tImage: Image,\n\t\tInscribedImage: InscribedImage,\n\t\tLink: Link,\n\t\tPath: Path,\n\t\tPolygon: Polygon,\n\t\tPolyline: Polyline,\n\t\tRectangle: Rectangle,\n\t\tShadowLink: ShadowLink,\n\t\tTextBlock: TextBlock\n\t};\n\n\tvar index$5 = {\n\t\t__proto__: null,\n\t\tstandard: standard\n\t};\n\n\tconst CornerTypes = {\n\t  POINT: 'point',\n\t  CUBIC: 'cubic',\n\t  LINE: 'line',\n\t  GAP: 'gap'\n\t};\n\tconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n\tconst CORNER_RADIUS$1 = 10;\n\tconst PRECISION$1 = 1;\n\tconst straight = function (sourcePoint, targetPoint, routePoints = [], opt = {}) {\n\t  const {\n\t    cornerType = CornerTypes.POINT,\n\t    cornerRadius = CORNER_RADIUS$1,\n\t    cornerPreserveAspectRatio = false,\n\t    precision = PRECISION$1,\n\t    raw = false\n\t  } = opt;\n\t  if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n\t    // unknown `cornerType` provided => error\n\t    throw new Error('Invalid `cornerType` provided to `straight` connector.');\n\t  }\n\t  let path;\n\t  if (cornerType === CornerTypes.POINT || !cornerRadius) {\n\t    // default option => normal connector\n\t    // simply connect all points with straight lines\n\t    const points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n\t    const polyline = new Polyline$1(points);\n\t    path = new Path$1(polyline);\n\t  } else {\n\t    // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n\t    path = new Path$1();\n\n\t    // add initial gap segment = to source point\n\t    path.appendSegment(Path$1.createSegment('M', sourcePoint));\n\t    let nextDistance;\n\t    const routePointsLength = routePoints.length;\n\t    for (let i = 0; i < routePointsLength; i++) {\n\t      const curr = new Point(routePoints[i]);\n\t      const prev = routePoints[i - 1] || sourcePoint;\n\t      const next = routePoints[i + 1] || targetPoint;\n\t      const prevDistance = nextDistance || curr.distance(prev) / 2; // try to re-use previously-computed `nextDistance`\n\t      nextDistance = curr.distance(next) / 2;\n\t      let startMove, endMove;\n\t      if (!cornerPreserveAspectRatio) {\n\t        // `startMove` and `endMove` may be different\n\t        // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n\t        startMove = -Math.min(cornerRadius, prevDistance);\n\t        endMove = -Math.min(cornerRadius, nextDistance);\n\t      } else {\n\t        // force `startMove` and `endMove` to be the same\n\t        startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n\t      }\n\n\t      // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n\t      // - find a point lying on the line `prev - startMove` such that...\n\t      // - ...the point lies `abs(startMove)` distance away from `curr`...\n\t      // - ...and its coordinates are rounded to whole numbers\n\t      const cornerStart = curr.clone().move(prev, startMove).round(precision);\n\t      const cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n\t      // add in-between straight segment = from previous route point to corner start point\n\t      // (may have zero length)\n\t      path.appendSegment(Path$1.createSegment('L', cornerStart));\n\n\t      // add corner segment = from corner start point to corner end point\n\t      switch (cornerType) {\n\t        case CornerTypes.CUBIC:\n\t          {\n\t            // corner is rounded\n\t            const _13 = 1 / 3;\n\t            const _23 = 2 / 3;\n\t            const control1 = new Point(_13 * cornerStart.x + _23 * curr.x, _23 * curr.y + _13 * cornerStart.y);\n\t            const control2 = new Point(_13 * cornerEnd.x + _23 * curr.x, _23 * curr.y + _13 * cornerEnd.y);\n\t            path.appendSegment(Path$1.createSegment('C', control1, control2, cornerEnd));\n\t            break;\n\t          }\n\t        case CornerTypes.LINE:\n\t          {\n\t            // corner has bevel\n\t            path.appendSegment(Path$1.createSegment('L', cornerEnd));\n\t            break;\n\t          }\n\t        case CornerTypes.GAP:\n\t          {\n\t            // corner has empty space\n\t            path.appendSegment(Path$1.createSegment('M', cornerEnd));\n\t            break;\n\t          }\n\t        // default: no segment is created\n\t      }\n\t    }\n\n\t    // add final straight segment = from last corner end point to target point\n\t    // (= or from start point to end point, if there are no route points)\n\t    // (may have zero length)\n\t    path.appendSegment(Path$1.createSegment('L', targetPoint));\n\t  }\n\t  return raw ? path : path.serialize();\n\t};\n\n\t// default size of jump if not specified in options\n\tvar JUMP_SIZE = 5;\n\n\t// available jump types\n\t// first one taken as default\n\tvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n\t// default radius\n\tvar RADIUS = 0;\n\n\t// takes care of math. error for case when jump is too close to end of line\n\tvar CLOSE_PROXIMITY_PADDING = 1;\n\n\t// list of connector types not to jump over.\n\tvar IGNORED_CONNECTORS = ['smooth'];\n\n\t// internal constants for round segment\n\tvar _13 = 1 / 3;\n\tvar _23 = 2 / 3;\n\tfunction sortPointsAscending(p1, p2) {\n\t  let {\n\t    x: x1,\n\t    y: y1\n\t  } = p1;\n\t  let {\n\t    x: x2,\n\t    y: y2\n\t  } = p2;\n\t  if (x1 > x2) {\n\t    let swap = x1;\n\t    x1 = x2;\n\t    x2 = swap;\n\t    swap = y1;\n\t    y1 = y2;\n\t    y2 = swap;\n\t  }\n\t  if (y1 > y2) {\n\t    let swap = x1;\n\t    x1 = x2;\n\t    x2 = swap;\n\t    swap = y1;\n\t    y1 = y2;\n\t    y2 = swap;\n\t  }\n\t  return [new Point(x1, y1), new Point(x2, y2)];\n\t}\n\tfunction overlapExists(line1, line2) {\n\t  const [{\n\t    x: x1,\n\t    y: y1\n\t  }, {\n\t    x: x2,\n\t    y: y2\n\t  }] = sortPointsAscending(line1.start, line1.end);\n\t  const [{\n\t    x: x3,\n\t    y: y3\n\t  }, {\n\t    x: x4,\n\t    y: y4\n\t  }] = sortPointsAscending(line2.start, line2.end);\n\t  const xMatch = x1 <= x4 && x3 <= x2;\n\t  const yMatch = y1 <= y4 && y3 <= y2;\n\t  return xMatch && yMatch;\n\t}\n\n\t/**\n\t * Transform start/end and route into series of lines\n\t * @param {g.point} sourcePoint start point\n\t * @param {g.point} targetPoint end point\n\t * @param {g.point[]} route optional list of route\n\t * @return {g.line[]} [description]\n\t */\n\tfunction createLines(sourcePoint, targetPoint, route) {\n\t  // make a flattened array of all points\n\t  var points = [].concat(sourcePoint, route, targetPoint);\n\t  return points.reduce(function (resultLines, point, idx) {\n\t    // if there is a next point, make a line with it\n\t    var nextPoint = points[idx + 1];\n\t    if (nextPoint != null) {\n\t      resultLines[idx] = line$1(point, nextPoint);\n\t    }\n\t    return resultLines;\n\t  }, []);\n\t}\n\tfunction setupUpdating(jumpOverLinkView) {\n\t  var paper = jumpOverLinkView.paper;\n\t  var updateList = paper._jumpOverUpdateList;\n\n\t  // first time setup for this paper\n\t  if (updateList == null) {\n\t    updateList = paper._jumpOverUpdateList = [];\n\t    var graph = paper.model;\n\t    graph.on('batch:stop', function () {\n\t      if (this.hasActiveBatch()) return;\n\t      updateJumpOver(paper);\n\t    });\n\t    graph.on('reset', function () {\n\t      updateList = paper._jumpOverUpdateList = [];\n\t    });\n\t  }\n\n\t  // add this link to a list so it can be updated when some other link is updated\n\t  if (updateList.indexOf(jumpOverLinkView) < 0) {\n\t    updateList.push(jumpOverLinkView);\n\n\t    // watch for change of connector type or removal of link itself\n\t    // to remove the link from a list of jump over connectors\n\t    jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function () {\n\t      updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n\t    });\n\t  }\n\t}\n\n\t/**\n\t * Handler for a batch:stop event to force\n\t * update of all registered links with jump over connector\n\t * @param {object} batchEvent optional object with info about batch\n\t */\n\tfunction updateJumpOver(paper) {\n\t  var updateList = paper._jumpOverUpdateList;\n\t  for (var i = 0; i < updateList.length; i++) {\n\t    const linkView = updateList[i];\n\t    const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n\t    linkView.requestUpdate(updateFlag);\n\t  }\n\t}\n\n\t/**\n\t * Utility function to collect all intersection points of a single\n\t * line against group of other lines.\n\t * @param {g.line} line where to find points\n\t * @param {g.line[]} crossCheckLines lines to cross\n\t * @return {g.point[]} list of intersection points\n\t */\n\tfunction findLineIntersections(line, crossCheckLines) {\n\t  return toArray$1(crossCheckLines).reduce(function (res, crossCheckLine) {\n\t    var intersection = line.intersection(crossCheckLine);\n\t    if (intersection) {\n\t      res.push(intersection);\n\t    }\n\t    return res;\n\t  }, []);\n\t}\n\n\t/**\n\t * Sorting function for list of points by their distance.\n\t * @param {g.point} p1 first point\n\t * @param {g.point} p2 second point\n\t * @return {number} squared distance between points\n\t */\n\tfunction sortPoints(p1, p2) {\n\t  return line$1(p1, p2).squaredLength();\n\t}\n\n\t/**\n\t * Split input line into multiple based on intersection points.\n\t * @param {g.line} line input line to split\n\t * @param {g.point[]} intersections points where to split the line\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @return {g.line[]} list of lines being split\n\t */\n\tfunction createJumps(line, intersections, jumpSize) {\n\t  return intersections.reduce(function (resultLines, point$1, idx) {\n\t    // skipping points that were merged with the previous line\n\t    // to make bigger arc over multiple lines that are close to each other\n\t    if (point$1.skip === true) {\n\t      return resultLines;\n\t    }\n\n\t    // always grab the last line from buffer and modify it\n\t    var lastLine = resultLines.pop() || line;\n\n\t    // calculate start and end of jump by moving by a given size of jump\n\t    var jumpStart = point(point$1).move(lastLine.start, -jumpSize);\n\t    var jumpEnd = point(point$1).move(lastLine.start, +jumpSize);\n\n\t    // now try to look at the next intersection point\n\t    var nextPoint = intersections[idx + 1];\n\t    if (nextPoint != null) {\n\t      var distance = jumpEnd.distance(nextPoint);\n\t      if (distance <= jumpSize) {\n\t        // next point is close enough, move the jump end by this\n\t        // difference and mark the next point to be skipped\n\t        jumpEnd = nextPoint.move(lastLine.start, distance);\n\t        nextPoint.skip = true;\n\t      }\n\t    } else {\n\t      // this block is inside of `else` as an optimization so the distance is\n\t      // not calculated when we know there are no other intersection points\n\t      var endDistance = jumpStart.distance(lastLine.end);\n\t      // if the end is too close to possible jump, draw remaining line instead of a jump\n\t      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n\t        resultLines.push(lastLine);\n\t        return resultLines;\n\t      }\n\t    }\n\t    var startDistance = jumpEnd.distance(lastLine.start);\n\t    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n\t      // if the start of line is too close to jump, draw that line instead of a jump\n\t      resultLines.push(lastLine);\n\t      return resultLines;\n\t    }\n\n\t    // finally create a jump line\n\t    var jumpLine = line$1(jumpStart, jumpEnd);\n\t    // it's just simple line but with a `isJump` property\n\t    jumpLine.isJump = true;\n\t    resultLines.push(line$1(lastLine.start, jumpStart), jumpLine, line$1(jumpEnd, lastLine.end));\n\t    return resultLines;\n\t  }, []);\n\t}\n\n\t/**\n\t * Assemble `D` attribute of a SVG path by iterating given lines.\n\t * @param {g.line[]} lines source lines to use\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @param {number} radius the radius\n\t * @return {string}\n\t */\n\tfunction buildPath(lines, jumpSize, jumpType, radius) {\n\t  var path = new Path$1();\n\t  var segment;\n\n\t  // first move to the start of a first line\n\t  segment = Path$1.createSegment('M', lines[0].start);\n\t  path.appendSegment(segment);\n\n\t  // make a paths from lines\n\t  toArray$1(lines).forEach(function (line, index) {\n\t    if (line.isJump) {\n\t      var angle, diff;\n\t      var control1, control2;\n\t      if (jumpType === 'arc') {\n\t        // approximates semicircle with 2 curves\n\t        angle = -90;\n\t        // determine rotation of arc based on difference between points\n\t        diff = line.start.difference(line.end);\n\t        // make sure the arc always points up (or right)\n\t        var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n\t        if (xAxisRotate) angle += 180;\n\t        var midpoint = line.midpoint();\n\t        var centerLine = new Line(midpoint, line.end).rotate(midpoint, angle);\n\t        var halfLine;\n\n\t        // first half\n\t        halfLine = new Line(line.start, midpoint);\n\t        control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n\t        control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\t        segment = Path$1.createSegment('C', control1, control2, centerLine.end);\n\t        path.appendSegment(segment);\n\n\t        // second half\n\t        halfLine = new Line(midpoint, line.end);\n\t        control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n\t        control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\t        segment = Path$1.createSegment('C', control1, control2, line.end);\n\t        path.appendSegment(segment);\n\t      } else if (jumpType === 'gap') {\n\t        segment = Path$1.createSegment('M', line.end);\n\t        path.appendSegment(segment);\n\t      } else if (jumpType === 'cubic') {\n\t        // approximates semicircle with 1 curve\n\t        angle = line.start.theta(line.end);\n\t        var xOffset = jumpSize * 0.6;\n\t        var yOffset = jumpSize * 1.35;\n\n\t        // determine rotation of arc based on difference between points\n\t        diff = line.start.difference(line.end);\n\t        // make sure the arc always points up (or right)\n\t        xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n\t        if (xAxisRotate) yOffset *= -1;\n\t        control1 = Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n\t        control2 = Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\t        segment = Path$1.createSegment('C', control1, control2, line.end);\n\t        path.appendSegment(segment);\n\t      }\n\t    } else {\n\t      var nextLine = lines[index + 1];\n\t      if (radius == 0 || !nextLine || nextLine.isJump) {\n\t        segment = Path$1.createSegment('L', line.end);\n\t        path.appendSegment(segment);\n\t      } else {\n\t        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n\t      }\n\t    }\n\t  });\n\t  return path;\n\t}\n\tfunction buildRoundedSegment(offset, path, curr, prev, next) {\n\t  var prevDistance = curr.distance(prev) / 2;\n\t  var nextDistance = curr.distance(next) / 2;\n\t  var startMove = -Math.min(offset, prevDistance);\n\t  var endMove = -Math.min(offset, nextDistance);\n\t  var roundedStart = curr.clone().move(prev, startMove).round();\n\t  var roundedEnd = curr.clone().move(next, endMove).round();\n\t  var control1 = new Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);\n\t  var control2 = new Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);\n\t  var segment;\n\t  segment = Path$1.createSegment('L', roundedStart);\n\t  path.appendSegment(segment);\n\t  segment = Path$1.createSegment('C', control1, control2, roundedEnd);\n\t  path.appendSegment(segment);\n\t}\n\n\t/**\n\t * Actual connector function that will be run on every update.\n\t * @param {g.point} sourcePoint start point of this link\n\t * @param {g.point} targetPoint end point of this link\n\t * @param {g.point[]} route of this link\n\t * @param {object} opt options\n\t * @property {number} size optional size of a jump arc\n\t * @return {string} created `D` attribute of SVG path\n\t */\n\tconst jumpover = function (sourcePoint, targetPoint, route, opt) {\n\t  setupUpdating(this);\n\t  var raw = opt.raw;\n\t  var jumpSize = opt.size || JUMP_SIZE;\n\t  var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n\t  var radius = opt.radius || RADIUS;\n\t  var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n\t  // grab the first jump type as a default if specified one is invalid\n\t  if (JUMP_TYPES.indexOf(jumpType) === -1) {\n\t    jumpType = JUMP_TYPES[0];\n\t  }\n\t  var paper = this.paper;\n\t  var graph = paper.model;\n\t  var allLinks = graph.getLinks();\n\n\t  // there is just one link, draw it directly\n\t  if (allLinks.length === 1) {\n\t    return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);\n\t  }\n\t  var thisModel = this.model;\n\t  var thisIndex = allLinks.indexOf(thisModel);\n\t  var defaultConnector = paper.options.defaultConnector || {};\n\n\t  // not all links are meant to be jumped over.\n\t  var links = allLinks.filter(function (link, idx) {\n\t    var connector = link.get('connector') || defaultConnector;\n\n\t    // avoid jumping over links with connector type listed in `ignored connectors`.\n\t    if (toArray$1(ignoreConnectors).includes(connector.name)) {\n\t      return false;\n\t    }\n\t    // filter out links that are above this one and  have the same connector type\n\t    // otherwise there would double hoops for each intersection\n\t    if (idx > thisIndex) {\n\t      return connector.name !== 'jumpover';\n\t    }\n\t    return true;\n\t  });\n\n\t  // find views for all links\n\t  var linkViews = links.map(function (link) {\n\t    return paper.findViewByModel(link);\n\t  });\n\n\t  // create lines for this link\n\t  var thisLines = createLines(sourcePoint, targetPoint, route);\n\n\t  // create lines for all other links\n\t  var linkLines = linkViews.map(function (linkView) {\n\t    if (linkView == null) {\n\t      return [];\n\t    }\n\t    if (linkView === this) {\n\t      return thisLines;\n\t    }\n\t    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);\n\t  }, this);\n\n\t  // transform lines for this link by splitting with jump lines at\n\t  // points of intersection with other links\n\t  var jumpingLines = thisLines.reduce(function (resultLines, thisLine) {\n\t    // iterate all links and grab the intersections with this line\n\t    // these are then sorted by distance so the line can be split more easily\n\t    var intersections = links.reduce(function (res, link, i) {\n\t      // don't intersection with itself\n\t      if (link !== thisModel) {\n\t        const linkLinesToTest = linkLines[i].slice();\n\t        const overlapIndex = linkLinesToTest.findIndex(line => overlapExists(thisLine, line));\n\n\t        // Overlap occurs and the end point of one segment lies on thisLine\n\t        if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n\t          // Remove the next segment because there will never be a jump\n\t          linkLinesToTest.splice(overlapIndex + 1, 1);\n\t        }\n\t        const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n\t        res.push.apply(res, lineIntersections);\n\t      }\n\t      return res;\n\t    }, []).sort(function (a, b) {\n\t      return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n\t    });\n\t    if (intersections.length > 0) {\n\t      // split the line based on found intersection points\n\t      resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n\t    } else {\n\t      // without any intersection the line goes uninterrupted\n\t      resultLines.push(thisLine);\n\t    }\n\t    return resultLines;\n\t  }, []);\n\t  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n\t  return raw ? path : path.serialize();\n\t};\n\n\tconst normal$1 = function (sourcePoint, targetPoint, route = [], opt = {}) {\n\t  const {\n\t    raw\n\t  } = opt;\n\t  const localOpt = {\n\t    cornerType: 'point',\n\t    raw\n\t  };\n\t  return straight(sourcePoint, targetPoint, route, localOpt);\n\t};\n\n\tconst CORNER_RADIUS = 10;\n\tconst PRECISION = 0;\n\tconst rounded = function (sourcePoint, targetPoint, route = [], opt = {}) {\n\t  const {\n\t    radius = CORNER_RADIUS,\n\t    raw\n\t  } = opt;\n\t  const localOpt = {\n\t    cornerType: 'cubic',\n\t    cornerRadius: radius,\n\t    precision: PRECISION,\n\t    raw\n\t  };\n\t  return straight(sourcePoint, targetPoint, route, localOpt);\n\t};\n\n\tconst smooth = function (sourcePoint, targetPoint, route, opt) {\n\t  var raw = opt && opt.raw;\n\t  var path;\n\t  if (route && route.length !== 0) {\n\t    var points = [sourcePoint].concat(route).concat([targetPoint]);\n\t    var curves = Curve.throughPoints(points);\n\t    path = new Path$1(curves);\n\t  } else {\n\t    // if we have no route, use a default cubic bezier curve\n\t    // cubic bezier requires two control points\n\t    // the control points have `x` midway between source and target\n\t    // this produces an S-like curve\n\n\t    path = new Path$1();\n\t    var segment;\n\t    segment = Path$1.createSegment('M', sourcePoint);\n\t    path.appendSegment(segment);\n\t    if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {\n\t      var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\t      segment = Path$1.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n\t      path.appendSegment(segment);\n\t    } else {\n\t      var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\t      segment = Path$1.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n\t      path.appendSegment(segment);\n\t    }\n\t  }\n\t  return raw ? path : path.serialize();\n\t};\n\n\tconst Directions$2 = {\n\t  AUTO: 'auto',\n\t  HORIZONTAL: 'horizontal',\n\t  VERTICAL: 'vertical',\n\t  CLOSEST_POINT: 'closest-point',\n\t  OUTWARDS: 'outwards'\n\t};\n\tconst TangentDirections = {\n\t  UP: 'up',\n\t  DOWN: 'down',\n\t  LEFT: 'left',\n\t  RIGHT: 'right',\n\t  AUTO: 'auto',\n\t  CLOSEST_POINT: 'closest-point',\n\t  OUTWARDS: 'outwards'\n\t};\n\tconst curve = function (sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n\t  const raw = Boolean(opt.raw);\n\t  // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n\t  // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n\t  // tension - a Catmull-Rom curve tension parameter.\n\t  // sourceTangent - a tangent vector along the curve at the sourcePoint.\n\t  // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n\t  // targetTangent - a tangent vector along the curve at the targetPoint.\n\t  // targetDirection - a unit direction vector along the curve at the targetPoint.\n\t  // precision - a rounding precision for path values.\n\t  const {\n\t    direction = Directions$2.AUTO,\n\t    precision = 3\n\t  } = opt;\n\t  const options = {\n\t    coeff: opt.distanceCoefficient || 0.6,\n\t    angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n\t    tau: opt.tension || 0.5,\n\t    sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n\t    targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,\n\t    rotate: Boolean(opt.rotate)\n\t  };\n\t  if (typeof opt.sourceDirection === 'string') options.sourceDirection = opt.sourceDirection;else if (typeof opt.sourceDirection === 'number') options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);else options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n\t  if (typeof opt.targetDirection === 'string') options.targetDirection = opt.targetDirection;else if (typeof opt.targetDirection === 'number') options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);else options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n\t  const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new Point(p));\n\n\t  // The calculation of a sourceTangent\n\t  let sourceTangent;\n\t  if (options.sourceTangent) {\n\t    sourceTangent = options.sourceTangent;\n\t  } else {\n\t    const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n\t    const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n\t    const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n\t    const angle = angleBetweenVectors(sourceDirection, pointsVector);\n\t    if (angle > Math.PI / 4) {\n\t      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n\t      sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n\t    } else {\n\t      sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n\t    }\n\t  }\n\n\t  // The calculation of a targetTangent\n\t  let targetTangent;\n\t  if (options.targetTangent) {\n\t    targetTangent = options.targetTangent;\n\t  } else {\n\t    const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n\t    const last = completeRoute.length - 1;\n\t    const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n\t    const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n\t    const angle = angleBetweenVectors(targetDirection, pointsVector);\n\t    if (angle > Math.PI / 4) {\n\t      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n\t      targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n\t    } else {\n\t      targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n\t    }\n\t  }\n\t  const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n\t  const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n\t  const path = new Path$1(bezierCurves).round(precision);\n\t  return raw ? path : path.serialize();\n\t};\n\tcurve.Directions = Directions$2;\n\tcurve.TangentDirections = TangentDirections;\n\tfunction getHorizontalSourceDirection(linkView, route, options) {\n\t  const {\n\t    sourceBBox\n\t  } = linkView;\n\t  let sourceSide;\n\t  let rotation;\n\t  if (!linkView.sourceView) {\n\t    if (sourceBBox.x > route[1].x) sourceSide = 'right';else sourceSide = 'left';\n\t  } else {\n\t    rotation = linkView.sourceView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t      const sourcePoint = route[0].clone();\n\t      sourcePoint.rotate(sourceBBox.center(), rotation);\n\t      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t    } else {\n\t      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (sourceSide) {\n\t    case 'left':\n\t      direction = new Point(-1, 0);\n\t      break;\n\t    case 'right':\n\t    default:\n\t      direction = new Point(1, 0);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getHorizontalTargetDirection(linkView, route, options) {\n\t  const {\n\t    targetBBox\n\t  } = linkView;\n\t  let targetSide;\n\t  let rotation;\n\t  if (!linkView.targetView) {\n\t    if (targetBBox.x > route[route.length - 2].x) targetSide = 'left';else targetSide = 'right';\n\t  } else {\n\t    rotation = linkView.targetView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t      const targetPoint = route[route.length - 1].clone();\n\t      targetPoint.rotate(targetBBox.center(), rotation);\n\t      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t    } else {\n\t      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (targetSide) {\n\t    case 'left':\n\t      direction = new Point(-1, 0);\n\t      break;\n\t    case 'right':\n\t    default:\n\t      direction = new Point(1, 0);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getVerticalSourceDirection(linkView, route, options) {\n\t  const {\n\t    sourceBBox\n\t  } = linkView;\n\t  let sourceSide;\n\t  let rotation;\n\t  if (!linkView.sourceView) {\n\t    if (sourceBBox.y > route[1].y) sourceSide = 'bottom';else sourceSide = 'top';\n\t  } else {\n\t    rotation = linkView.sourceView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t      const sourcePoint = route[0].clone();\n\t      sourcePoint.rotate(sourceBBox.center(), rotation);\n\t      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t    } else {\n\t      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (sourceSide) {\n\t    case 'top':\n\t      direction = new Point(0, -1);\n\t      break;\n\t    case 'bottom':\n\t    default:\n\t      direction = new Point(0, 1);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getVerticalTargetDirection(linkView, route, options) {\n\t  const {\n\t    targetBBox\n\t  } = linkView;\n\t  let targetSide;\n\t  let rotation;\n\t  if (!linkView.targetView) {\n\t    if (targetBBox.y > route[route.length - 2].y) targetSide = 'top';else targetSide = 'bottom';\n\t  } else {\n\t    rotation = linkView.targetView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t      const targetPoint = route[route.length - 1].clone();\n\t      targetPoint.rotate(targetBBox.center(), rotation);\n\t      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t    } else {\n\t      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (targetSide) {\n\t    case 'top':\n\t      direction = new Point(0, -1);\n\t      break;\n\t    case 'bottom':\n\t    default:\n\t      direction = new Point(0, 1);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getAutoSourceDirection(linkView, route, options) {\n\t  const {\n\t    sourceBBox\n\t  } = linkView;\n\t  let sourceSide;\n\t  let rotation;\n\t  if (!linkView.sourceView) {\n\t    sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n\t  } else {\n\t    rotation = linkView.sourceView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t      const sourcePoint = route[0].clone();\n\t      sourcePoint.rotate(sourceBBox.center(), rotation);\n\t      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t    } else {\n\t      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (sourceSide) {\n\t    case 'top':\n\t      direction = new Point(0, -1);\n\t      break;\n\t    case 'bottom':\n\t      direction = new Point(0, 1);\n\t      break;\n\t    case 'right':\n\t      direction = new Point(1, 0);\n\t      break;\n\t    case 'left':\n\t      direction = new Point(-1, 0);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getAutoTargetDirection(linkView, route, options) {\n\t  const {\n\t    targetBBox\n\t  } = linkView;\n\t  let targetSide;\n\t  let rotation;\n\t  if (!linkView.targetView) {\n\t    targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n\t  } else {\n\t    rotation = linkView.targetView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t      const targetPoint = route[route.length - 1].clone();\n\t      targetPoint.rotate(targetBBox.center(), rotation);\n\t      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t    } else {\n\t      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (targetSide) {\n\t    case 'top':\n\t      direction = new Point(0, -1);\n\t      break;\n\t    case 'bottom':\n\t      direction = new Point(0, 1);\n\t      break;\n\t    case 'right':\n\t      direction = new Point(1, 0);\n\t      break;\n\t    case 'left':\n\t      direction = new Point(-1, 0);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getClosestPointSourceDirection(linkView, route, options) {\n\t  return route[1].difference(route[0]).normalize();\n\t}\n\tfunction getClosestPointTargetDirection(linkView, route, options) {\n\t  const last = route.length - 1;\n\t  return route[last - 1].difference(route[last]).normalize();\n\t}\n\tfunction getOutwardsSourceDirection(linkView, route, options) {\n\t  const {\n\t    sourceBBox\n\t  } = linkView;\n\t  const sourceCenter = sourceBBox.center();\n\t  return route[0].difference(sourceCenter).normalize();\n\t}\n\tfunction getOutwardsTargetDirection(linkView, route, options) {\n\t  const {\n\t    targetBBox\n\t  } = linkView;\n\t  const targetCenter = targetBBox.center();\n\t  return route[route.length - 1].difference(targetCenter).normalize();\n\t}\n\tfunction getSourceTangentDirection(linkView, route, direction, options) {\n\t  if (options.sourceDirection) {\n\t    switch (options.sourceDirection) {\n\t      case TangentDirections.UP:\n\t        return new Point(0, -1);\n\t      case TangentDirections.DOWN:\n\t        return new Point(0, 1);\n\t      case TangentDirections.LEFT:\n\t        return new Point(-1, 0);\n\t      case TangentDirections.RIGHT:\n\t        return new Point(1, 0);\n\t      case TangentDirections.AUTO:\n\t        return getAutoSourceDirection(linkView, route, options);\n\t      case TangentDirections.CLOSEST_POINT:\n\t        return getClosestPointSourceDirection(linkView, route, options);\n\t      case TangentDirections.OUTWARDS:\n\t        return getOutwardsSourceDirection(linkView, route, options);\n\t      default:\n\t        return options.sourceDirection;\n\t    }\n\t  }\n\t  switch (direction) {\n\t    case Directions$2.HORIZONTAL:\n\t      return getHorizontalSourceDirection(linkView, route, options);\n\t    case Directions$2.VERTICAL:\n\t      return getVerticalSourceDirection(linkView, route, options);\n\t    case Directions$2.CLOSEST_POINT:\n\t      return getClosestPointSourceDirection(linkView, route, options);\n\t    case Directions$2.OUTWARDS:\n\t      return getOutwardsSourceDirection(linkView, route, options);\n\t    case Directions$2.AUTO:\n\t    default:\n\t      return getAutoSourceDirection(linkView, route, options);\n\t  }\n\t}\n\tfunction getTargetTangentDirection(linkView, route, direction, options) {\n\t  if (options.targetDirection) {\n\t    switch (options.targetDirection) {\n\t      case TangentDirections.UP:\n\t        return new Point(0, -1);\n\t      case TangentDirections.DOWN:\n\t        return new Point(0, 1);\n\t      case TangentDirections.LEFT:\n\t        return new Point(-1, 0);\n\t      case TangentDirections.RIGHT:\n\t        return new Point(1, 0);\n\t      case TangentDirections.AUTO:\n\t        return getAutoTargetDirection(linkView, route, options);\n\t      case TangentDirections.CLOSEST_POINT:\n\t        return getClosestPointTargetDirection(linkView, route, options);\n\t      case TangentDirections.OUTWARDS:\n\t        return getOutwardsTargetDirection(linkView, route, options);\n\t      default:\n\t        return options.targetDirection;\n\t    }\n\t  }\n\t  switch (direction) {\n\t    case Directions$2.HORIZONTAL:\n\t      return getHorizontalTargetDirection(linkView, route, options);\n\t    case Directions$2.VERTICAL:\n\t      return getVerticalTargetDirection(linkView, route, options);\n\t    case Directions$2.CLOSEST_POINT:\n\t      return getClosestPointTargetDirection(linkView, route, options);\n\t    case Directions$2.OUTWARDS:\n\t      return getOutwardsTargetDirection(linkView, route, options);\n\t    case Directions$2.AUTO:\n\t    default:\n\t      return getAutoTargetDirection(linkView, route, options);\n\t  }\n\t}\n\tfunction rotateVector(vector, angle) {\n\t  const cos = Math.cos(angle);\n\t  const sin = Math.sin(angle);\n\t  const x = cos * vector.x - sin * vector.y;\n\t  const y = sin * vector.x + cos * vector.y;\n\t  vector.x = x;\n\t  vector.y = y;\n\t}\n\tfunction angleBetweenVectors(v1, v2) {\n\t  let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n\t  if (cos < -1) cos = -1;\n\t  if (cos > 1) cos = 1;\n\t  return Math.acos(cos);\n\t}\n\tfunction determinant(v1, v2) {\n\t  return v1.x * v2.y - v1.y * v2.x;\n\t}\n\tfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n\t  const {\n\t    tau,\n\t    coeff\n\t  } = options;\n\t  const distances = [];\n\t  const tangents = [];\n\t  const catmullRomCurves = [];\n\t  const n = points.length - 1;\n\t  for (let i = 0; i < n; i++) {\n\t    distances[i] = points[i].distance(points[i + 1]);\n\t  }\n\t  tangents[0] = sourceTangent;\n\t  tangents[n] = targetTangent;\n\n\t  // The calculation of tangents of vertices\n\t  for (let i = 1; i < n; i++) {\n\t    let tpPrev;\n\t    let tpNext;\n\t    if (i === 1) {\n\t      tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n\t    } else {\n\t      tpPrev = points[i - 1].clone();\n\t    }\n\t    if (i === n - 1) {\n\t      tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n\t    } else {\n\t      tpNext = points[i + 1].clone();\n\t    }\n\t    const v1 = tpPrev.difference(points[i]).normalize();\n\t    const v2 = tpNext.difference(points[i]).normalize();\n\t    const vAngle = angleBetweenVectors(v1, v2);\n\t    let rot = (Math.PI - vAngle) / 2;\n\t    const vectorDeterminant = determinant(v1, v2);\n\t    const pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n\t    if (vectorDeterminant < 0) {\n\t      rot = -rot;\n\t    }\n\t    if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) {\n\t      rot = rot - Math.PI;\n\t    }\n\t    const t = v2.clone();\n\t    rotateVector(t, rot);\n\t    const t1 = t.clone();\n\t    const t2 = t.clone();\n\t    const scaleFactor1 = distances[i - 1] * coeff;\n\t    const scaleFactor2 = distances[i] * coeff;\n\t    t1.scale(scaleFactor1, scaleFactor1);\n\t    t2.scale(scaleFactor2, scaleFactor2);\n\t    tangents[i] = [t1, t2];\n\t  }\n\n\t  // The building of a Catmull-Rom curve based of tangents of points\n\t  for (let i = 0; i < n; i++) {\n\t    let p0;\n\t    let p3;\n\t    if (i === 0) {\n\t      p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n\t    } else {\n\t      p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n\t    }\n\t    if (i === n - 1) {\n\t      p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n\t    } else {\n\t      p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n\t    }\n\t    catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n\t  }\n\t  return catmullRomCurves;\n\t}\n\n\t// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\n\tfunction catmullRomToBezier(points, options) {\n\t  const {\n\t    tau\n\t  } = options;\n\t  const bcp1 = new Point();\n\t  bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n\t  bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\t  const bcp2 = new Point();\n\t  bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n\t  bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n\t  return new Curve(points[1], bcp1, bcp2, points[2]);\n\t}\n\n\tvar connectors = {\n\t\t__proto__: null,\n\t\tcurve: curve,\n\t\tjumpover: jumpover,\n\t\tnormal: normal$1,\n\t\trounded: rounded,\n\t\tsmooth: smooth,\n\t\tstraight: straight\n\t};\n\n\t// ViewBase\n\t// -------------\n\n\t// ViewBases are almost more convention than they are actual code. A View\n\t// is simply a JavaScript object that represents a logical chunk of UI in the\n\t// DOM. This might be a single item, an entire list, a sidebar or panel, or\n\t// even the surrounding frame which wraps your whole app. Defining a chunk of\n\t// UI as a **View** allows you to define your DOM events declaratively, without\n\t// having to worry about render order ... and makes it easy for the view to\n\t// react to specific changes in the state of your models.\n\n\t// Creating a ViewBase creates its initial element outside of the DOM,\n\t// if an existing element is not provided...\n\tvar ViewBase = function (options) {\n\t  this.cid = options && options.cid || uniqueId('view');\n\t  this.preinitialize.apply(this, arguments);\n\t  assign(this, pick(options, viewOptions));\n\t  this._ensureElement();\n\t  this.initialize.apply(this, arguments);\n\t};\n\n\t// Cached regex to split keys for `delegate`.\n\tvar delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n\t// List of view options to be set as properties.\n\t// TODO: `style` attribute is not supported in ViewBase class yet, but only in View class that extends ViewBase.\n\tvar viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events', 'style'];\n\n\t// Set up all inheritable **ViewBase** properties and methods.\n\tassign(ViewBase.prototype, Events, {\n\t  // The default `tagName` of a View's element is `\"div\"`.\n\t  tagName: 'div',\n\t  // mvc.$ delegate for element lookup, scoped to DOM elements within the\n\t  // current view. This should be preferred to global lookups where possible.\n\t  $: function (selector) {\n\t    return this.$el.find(selector);\n\t  },\n\t  // preinitialize is an empty function by default. You can override it with a function\n\t  // or object.  preinitialize will run before any instantiation logic is run in the View\n\t  preinitialize: function () {\n\t    // No implementation.\n\t  },\n\t  // Initialize is an empty function by default. Override it with your own\n\t  // initialization logic.\n\t  initialize: function () {\n\t    // No implementation.\n\t  },\n\t  // **render** is the core function that your view should override, in order\n\t  // to populate its element (`this.el`), with the appropriate HTML. The\n\t  // convention is for **render** to always return `this`.\n\t  render: function () {\n\t    return this;\n\t  },\n\t  // Remove this view by taking the element out of the DOM, and removing any\n\t  // applicable Events listeners.\n\t  remove: function () {\n\t    this._removeElement();\n\t    this.stopListening();\n\t    return this;\n\t  },\n\t  // Remove this view's element from the document and all event listeners\n\t  // attached to it. Exposed for subclasses using an alternative DOM\n\t  // manipulation API.\n\t  _removeElement: function () {\n\t    this.$el.remove();\n\t  },\n\t  // Change the view's element (`this.el` property) and re-delegate the\n\t  // view's events on the new element.\n\t  setElement: function (element) {\n\t    this.undelegateEvents();\n\t    this._setElement(element);\n\t    this.delegateEvents();\n\t    return this;\n\t  },\n\t  // Creates the `this.el` and `this.$el` references for this view using the\n\t  // given `el`. `el` can be a CSS selector or an HTML string, a mvc.$\n\t  // context or an element. Subclasses can override this to utilize an\n\t  // alternative DOM manipulation API and are only required to set the\n\t  // `this.el` property.\n\t  _setElement: function (el) {\n\t    this.$el = el instanceof $ ? el : $(el);\n\t    this.el = this.$el[0];\n\t  },\n\t  // Set callbacks, where `this.events` is a hash of\n\t  //\n\t  // *{\"event selector\": \"callback\"}*\n\t  //\n\t  //     {\n\t  //       'mousedown .title':  'edit',\n\t  //       'click .button':     'save',\n\t  //       'click .open':       function(e) { ... }\n\t  //     }\n\t  //\n\t  // pairs. Callbacks will be bound to the view, with `this` set properly.\n\t  // Uses event delegation for efficiency.\n\t  // Omitting the selector binds the event to `this.el`.\n\t  delegateEvents: function (events) {\n\t    events || (events = result(this, 'events'));\n\t    if (!events) return this;\n\t    this.undelegateEvents();\n\t    for (var key in events) {\n\t      var method = events[key];\n\t      if (!isFunction(method)) method = this[method];\n\t      if (!method) continue;\n\t      var match = key.match(delegateEventSplitter);\n\t      this.delegate(match[1], match[2], method.bind(this));\n\t    }\n\t    return this;\n\t  },\n\t  // Add a single event listener to the view's element (or a child element\n\t  // using `selector`). This only works for delegate-able events: not `focus`,\n\t  // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n\t  delegate: function (eventName, selector, listener) {\n\t    this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\n\t    return this;\n\t  },\n\t  // Clears all callbacks previously bound to the view by `delegateEvents`.\n\t  // You usually don't need to use this, but may wish to if you have multiple\n\t  // viewbases attached to the same DOM element.\n\t  undelegateEvents: function () {\n\t    if (this.$el) this.$el.off('.delegateEvents' + this.cid);\n\t    return this;\n\t  },\n\t  // A finer-grained `undelegateEvents` for removing a single delegated event.\n\t  // `selector` and `listener` are both optional.\n\t  undelegate: function (eventName, selector, listener) {\n\t    this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\n\t    return this;\n\t  },\n\t  // Produces a DOM element to be assigned to your view. Exposed for\n\t  // subclasses using an alternative DOM manipulation API.\n\t  _createElement: function (tagName) {\n\t    return document.createElement(tagName);\n\t  },\n\t  // Ensure that the View has a DOM element to render into.\n\t  // If `this.el` is a string, pass it through `$()`, take the first\n\t  // matching element, and re-assign it to `el`. Otherwise, create\n\t  // an element from the `id`, `className` and `tagName` properties.\n\t  _ensureElement: function () {\n\t    if (!this.el) {\n\t      var attrs = assign({}, result(this, 'attributes'));\n\t      if (this.id) attrs.id = result(this, 'id');\n\t      if (this.className) attrs['class'] = result(this, 'className');\n\t      this.setElement(this._createElement(result(this, 'tagName')));\n\t      this._setAttributes(attrs);\n\t    } else {\n\t      this.setElement(result(this, 'el'));\n\t    }\n\t  },\n\t  // Set attributes from a hash on this view's element.  Exposed for\n\t  // subclasses using an alternative DOM manipulation API.\n\t  _setAttributes: function (attributes) {\n\t    this.$el.attr(attributes);\n\t  }\n\t});\n\n\t// Set up inheritance for the view.\n\tViewBase.extend = extend;\n\n\tconst views = {};\n\tconst View = ViewBase.extend({\n\t  options: {},\n\t  theme: null,\n\t  themeClassNamePrefix: addClassNamePrefix('theme-'),\n\t  requireSetThemeOverride: false,\n\t  defaultTheme: config$3.defaultTheme,\n\t  children: null,\n\t  childNodes: null,\n\t  DETACHABLE: true,\n\t  UPDATE_PRIORITY: 2,\n\t  /** @deprecated is no longer used (moved to Paper) */\n\t  FLAG_INSERT: 1 << 30,\n\t  /** @deprecated is no longer used */\n\t  FLAG_REMOVE: 1 << 29,\n\t  /** @deprecated is no longer used */\n\t  FLAG_INIT: 1 << 28,\n\t  constructor: function (options) {\n\t    this.requireSetThemeOverride = options && !!options.theme;\n\t    this.options = assign({}, this.options, options);\n\t    ViewBase.call(this, options);\n\t  },\n\t  initialize: function () {\n\t    views[this.cid] = this;\n\t    this.setTheme(this.options.theme || this.defaultTheme);\n\t    this.init();\n\t  },\n\t  unmount: function () {\n\t    if (this.svgElement) {\n\t      this.vel.remove();\n\t    } else {\n\t      this.$el.remove();\n\t    }\n\t  },\n\t  isMounted: function () {\n\t    return this.el.parentNode !== null;\n\t  },\n\t  renderChildren: function (children) {\n\t    children || (children = result(this, 'children'));\n\t    if (children) {\n\t      var isSVG = this.svgElement;\n\t      var namespace = V.namespace[isSVG ? 'svg' : 'xhtml'];\n\t      var doc = parseDOMJSON(children, namespace);\n\t      (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n\t      this.childNodes = doc.selectors;\n\t    }\n\t    return this;\n\t  },\n\t  findAttributeNode: function (attributeName, node) {\n\t    let currentNode = node;\n\t    while (currentNode && currentNode.nodeType === 1) {\n\t      // attribute found\n\t      // (empty value does not count as attribute found)\n\t      if (currentNode.getAttribute(attributeName)) return currentNode;\n\t      // do not climb up the DOM\n\t      if (currentNode === this.el) return null;\n\t      // try parent node\n\t      currentNode = currentNode.parentNode;\n\t    }\n\t    return null;\n\t  },\n\t  findAttribute: function (attributeName, node) {\n\t    const matchedNode = this.findAttributeNode(attributeName, node);\n\t    return matchedNode && matchedNode.getAttribute(attributeName);\n\t  },\n\t  // Override the mvc ViewBase `_ensureElement()` method in order to create an\n\t  // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n\t  // Expose class name setter as a separate method.\n\t  _ensureElement: function () {\n\t    if (!this.el) {\n\t      var tagName = result(this, 'tagName');\n\t      var attrs = assign({}, result(this, 'attributes'));\n\t      var style = assign({}, result(this, 'style'));\n\t      if (this.id) attrs.id = result(this, 'id');\n\t      this.setElement(this._createElement(tagName));\n\t      this._setAttributes(attrs);\n\t      this._setStyle(style);\n\t    } else {\n\t      this.setElement(result(this, 'el'));\n\t    }\n\t    this._ensureElClassName();\n\t  },\n\t  _setAttributes: function (attrs) {\n\t    if (this.svgElement) {\n\t      this.vel.attr(attrs);\n\t    } else {\n\t      this.$el.attr(attrs);\n\t    }\n\t  },\n\t  _setStyle: function (style) {\n\t    this.$el.css(style);\n\t  },\n\t  _createElement: function (tagName) {\n\t    if (this.svgElement) {\n\t      return document.createElementNS(V.namespace.svg, tagName);\n\t    } else {\n\t      return document.createElement(tagName);\n\t    }\n\t  },\n\t  // Utilize an alternative DOM manipulation API by\n\t  // adding an element reference wrapped in Vectorizer.\n\t  _setElement: function (el) {\n\t    this.$el = el instanceof $ ? el : $(el);\n\t    this.el = this.$el[0];\n\t    if (this.svgElement) this.vel = V(this.el);\n\t  },\n\t  _ensureElClassName: function () {\n\t    var className = result(this, 'className');\n\t    if (!className) return;\n\t    var prefixedClassName = addClassNamePrefix(className);\n\t    // Note: className removal here kept for backwards compatibility only\n\t    if (this.svgElement) {\n\t      this.vel.removeClass(className).addClass(prefixedClassName);\n\t    } else {\n\t      this.$el.removeClass(className).addClass(prefixedClassName);\n\t    }\n\t  },\n\t  init: function () {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t  },\n\t  onRender: function () {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t  },\n\t  confirmUpdate: function () {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t    return 0;\n\t  },\n\t  setTheme: function (theme, opt) {\n\t    opt = opt || {};\n\n\t    // Theme is already set, override is required, and override has not been set.\n\t    // Don't set the theme.\n\t    if (this.theme && this.requireSetThemeOverride && !opt.override) {\n\t      return this;\n\t    }\n\t    this.removeThemeClassName();\n\t    this.addThemeClassName(theme);\n\t    this.onSetTheme(this.theme /* oldTheme */, theme /* newTheme */);\n\t    this.theme = theme;\n\t    return this;\n\t  },\n\t  addThemeClassName: function (theme) {\n\t    theme = theme || this.theme;\n\t    if (!theme) return this;\n\t    var className = this.themeClassNamePrefix + theme;\n\t    if (this.svgElement) {\n\t      this.vel.addClass(className);\n\t    } else {\n\t      this.$el.addClass(className);\n\t    }\n\t    return this;\n\t  },\n\t  removeThemeClassName: function (theme) {\n\t    theme = theme || this.theme;\n\t    var className = this.themeClassNamePrefix + theme;\n\t    if (this.svgElement) {\n\t      this.vel.removeClass(className);\n\t    } else {\n\t      this.$el.removeClass(className);\n\t    }\n\t    return this;\n\t  },\n\t  onSetTheme: function (oldTheme, newTheme) {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t  },\n\t  remove: function () {\n\t    this.onRemove();\n\t    this.undelegateDocumentEvents();\n\t    views[this.cid] = null;\n\t    ViewBase.prototype.remove.apply(this, arguments);\n\t    return this;\n\t  },\n\t  onRemove: function () {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t  },\n\t  getEventNamespace: function () {\n\t    // Returns a per-session unique namespace\n\t    return '.joint-event-ns-' + this.cid;\n\t  },\n\t  delegateElementEvents: function (element, events, data) {\n\t    if (!events) return this;\n\t    data || (data = {});\n\t    var eventNS = this.getEventNamespace();\n\t    for (var eventName in events) {\n\t      var method = events[eventName];\n\t      if (typeof method !== 'function') method = this[method];\n\t      if (!method) continue;\n\t      $(element).on(eventName + eventNS, data, method.bind(this));\n\t    }\n\t    return this;\n\t  },\n\t  undelegateElementEvents: function (element) {\n\t    $(element).off(this.getEventNamespace());\n\t    return this;\n\t  },\n\t  delegateDocumentEvents: function (events, data) {\n\t    events || (events = result(this, 'documentEvents'));\n\t    return this.delegateElementEvents(document, events, data);\n\t  },\n\t  undelegateDocumentEvents: function () {\n\t    return this.undelegateElementEvents(document);\n\t  },\n\t  eventData: function (evt, data) {\n\t    if (!evt) throw new Error('eventData(): event object required.');\n\t    var currentData = evt.data;\n\t    var key = '__' + this.cid + '__';\n\t    if (data === undefined) {\n\t      if (!currentData) return {};\n\t      return currentData[key] || {};\n\t    }\n\t    currentData || (currentData = evt.data = {});\n\t    currentData[key] || (currentData[key] = {});\n\t    assign(currentData[key], data);\n\t    return this;\n\t  },\n\t  stopPropagation: function (evt) {\n\t    this.eventData(evt, {\n\t      propagationStopped: true\n\t    });\n\t    return this;\n\t  },\n\t  isPropagationStopped: function (evt) {\n\t    return !!this.eventData(evt).propagationStopped;\n\t  }\n\t}, {\n\t  extend: function () {\n\t    var args = Array.from(arguments);\n\n\t    // Deep clone the prototype and static properties objects.\n\t    // This prevents unexpected behavior where some properties are overwritten outside of this function.\n\t    var protoProps = args[0] && assign({}, args[0]) || {};\n\t    var staticProps = args[1] && assign({}, args[1]) || {};\n\n\t    // Need the real render method so that we can wrap it and call it later.\n\t    var renderFn = protoProps.render || this.prototype && this.prototype.render || null;\n\n\t    /*\n\t        Wrap the real render method so that:\n\t            .. `onRender` is always called.\n\t            .. `this` is always returned.\n\t    */\n\t    protoProps.render = function () {\n\t      if (typeof renderFn === 'function') {\n\t        // Call the original render method.\n\t        renderFn.apply(this, arguments);\n\t      }\n\t      if (this.render.__render__ === renderFn) {\n\t        // Should always call onRender() method.\n\t        // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n\t        this.onRender();\n\t      }\n\n\t      // Should always return itself.\n\t      return this;\n\t    };\n\t    protoProps.render.__render__ = renderFn;\n\t    return ViewBase.extend.call(this, protoProps, staticProps);\n\t  }\n\t});\n\n\tclass Listener {\n\t  constructor(...callbackArguments) {\n\t    this.callbackArguments = callbackArguments;\n\t  }\n\t  listenTo(object, evt, ...args) {\n\t    const {\n\t      callbackArguments\n\t    } = this;\n\t    // signature 1 - (object, eventHashMap, context)\n\t    if (evt && typeof evt === 'object') {\n\t      const [context = null] = args;\n\t      Object.entries(evt).forEach(([eventName, cb]) => {\n\t        if (typeof cb !== 'function') return;\n\t        // Invoke the callback with callbackArguments passed first\n\t        if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n\t        Events.listenTo.call(this, object, eventName, cb);\n\t      });\n\t    }\n\t    // signature 2 - (object, event, callback, context)\n\t    else if (typeof evt === 'string' && typeof args[0] === 'function') {\n\t      // eslint-disable-next-line prefer-const\n\t      let [cb, context = null] = args;\n\t      // Invoke the callback with callbackArguments passed first\n\t      if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n\t      Events.listenTo.call(this, object, evt, cb);\n\t    }\n\t  }\n\t  stopListening() {\n\t    Events.stopListening.call(this);\n\t  }\n\t}\n\n\t// Collection\n\t// -------------------\n\n\t// If models tend to represent a single row of data, a Collection is\n\t// more analogous to a table full of data ... or a small slice or page of that\n\t// table, or a collection of rows that belong together for a particular reason\n\t// -- all of the messages in this particular folder, all of the documents\n\t// belonging to this particular author, and so on. Collections maintain\n\t// indexes of their models, both in order, and for lookup by `id`.\n\n\t// Create a new **Collection**, perhaps to contain a specific type of `model`.\n\t// If a `comparator` is specified, the Collection will maintain\n\t// its models in sort order, as they're added and removed.\n\tvar Collection = function (models, options) {\n\t  options || (options = {});\n\t  this.preinitialize.apply(this, arguments);\n\t  if (options.model) this.model = options.model;\n\t  if (options.comparator !== void 0) this.comparator = options.comparator;\n\t  this._reset();\n\t  this.initialize.apply(this, arguments);\n\t  if (models) this.reset(models, assign({\n\t    silent: true\n\t  }, options));\n\t};\n\n\t// Default options for `Collection#set`.\n\tvar setOptions = {\n\t  add: true,\n\t  remove: true,\n\t  merge: true\n\t};\n\tvar addOptions = {\n\t  add: true,\n\t  remove: false\n\t};\n\n\t// Splices `insert` into `array` at index `at`.\n\tvar splice = function (array, insert, at) {\n\t  at = Math.min(Math.max(at, 0), array.length);\n\t  var tail = Array(array.length - at);\n\t  var length = insert.length;\n\t  var i;\n\t  for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\n\t  for (i = 0; i < length; i++) array[i + at] = insert[i];\n\t  for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\n\t};\n\n\t// Define the Collection's inheritable methods.\n\tassign(Collection.prototype, Events, {\n\t  // The default model for a collection is just a **Model**.\n\t  // This should be overridden in most cases.\n\t  model: Model,\n\t  // preinitialize is an empty function by default. You can override it with a function\n\t  // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n\t  preinitialize: function () {\n\t    // No implementation.\n\t  },\n\t  // Initialize is an empty function by default. Override it with your own\n\t  // initialization logic.\n\t  initialize: function () {\n\t    // No implementation.\n\t  },\n\t  // The JSON representation of a Collection is an array of the\n\t  // models' attributes.\n\t  toJSON: function (options) {\n\t    return this.map(function (model) {\n\t      return model.toJSON(options);\n\t    });\n\t  },\n\t  // Add a model, or list of models to the set. `models` may be\n\t  // Models or raw JavaScript objects to be converted to Models, or any\n\t  // combination of the two.\n\t  add: function (models, options) {\n\t    return this.set(models, assign({\n\t      merge: false\n\t    }, options, addOptions));\n\t  },\n\t  // Remove a model, or a list of models from the set.\n\t  remove: function (models, options) {\n\t    options = assign({}, options);\n\t    var singular = !Array.isArray(models);\n\t    models = singular ? [models] : models.slice();\n\t    var removed = this._removeModels(models, options);\n\t    if (!options.silent && removed.length) {\n\t      options.changes = {\n\t        added: [],\n\t        merged: [],\n\t        removed: removed\n\t      };\n\t      this.trigger('update', this, options);\n\t    }\n\t    return singular ? removed[0] : removed;\n\t  },\n\t  // Update a collection by `set`-ing a new list of models, adding new ones,\n\t  // removing models that are no longer present, and merging models that\n\t  // already exist in the collection, as necessary. Similar to **Model#set**,\n\t  // the core operation for updating the data contained by the collection.\n\t  set: function (models, options) {\n\t    if (models == null) return;\n\t    options = assign({}, setOptions, options);\n\t    var singular = !Array.isArray(models);\n\t    models = singular ? [models] : models.slice();\n\t    var at = options.at;\n\t    if (at != null) at = +at;\n\t    if (at > this.length) at = this.length;\n\t    if (at < 0) at += this.length + 1;\n\t    var set = [];\n\t    var toAdd = [];\n\t    var toMerge = [];\n\t    var toRemove = [];\n\t    var modelMap = {};\n\t    var add = options.add;\n\t    var merge = options.merge;\n\t    var remove = options.remove;\n\t    var sort = false;\n\t    var sortable = this.comparator && at == null && options.sort !== false;\n\t    var sortAttr = isString(this.comparator) ? this.comparator : null;\n\n\t    // Turn bare objects into model references, and prevent invalid models\n\t    // from being added.\n\t    var model, i;\n\t    for (i = 0; i < models.length; i++) {\n\t      model = models[i];\n\n\t      // If a duplicate is found, prevent it from being added and\n\t      // optionally merge it into the existing model.\n\t      var existing = this.get(model);\n\t      if (existing) {\n\t        if (merge && model !== existing) {\n\t          var attrs = this._isModel(model) ? model.attributes : model;\n\t          existing.set(attrs, options);\n\t          toMerge.push(existing);\n\t          if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n\t        }\n\t        if (!modelMap[existing.cid]) {\n\t          modelMap[existing.cid] = true;\n\t          set.push(existing);\n\t        }\n\t        models[i] = existing;\n\n\t        // If this is a new, valid model, push it to the `toAdd` list.\n\t      } else if (add) {\n\t        model = models[i] = this._prepareModel(model, options);\n\t        if (model) {\n\t          toAdd.push(model);\n\t          this._addReference(model, options);\n\t          modelMap[model.cid] = true;\n\t          set.push(model);\n\t        }\n\t      }\n\t    }\n\n\t    // Remove stale models.\n\t    if (remove) {\n\t      for (i = 0; i < this.length; i++) {\n\t        model = this.models[i];\n\t        if (!modelMap[model.cid]) toRemove.push(model);\n\t      }\n\t      if (toRemove.length) this._removeModels(toRemove, options);\n\t    }\n\n\t    // See if sorting is needed, update `length` and splice in new models.\n\t    var orderChanged = false;\n\t    var replace = !sortable && add && remove;\n\t    if (set.length && replace) {\n\t      orderChanged = this.length !== set.length || this.models.some(function (m, index) {\n\t        return m !== set[index];\n\t      });\n\t      this.models.length = 0;\n\t      splice(this.models, set, 0);\n\t      this.length = this.models.length;\n\t    } else if (toAdd.length) {\n\t      if (sortable) sort = true;\n\t      splice(this.models, toAdd, at == null ? this.length : at);\n\t      this.length = this.models.length;\n\t    }\n\n\t    // Silently sort the collection if appropriate.\n\t    if (sort) this.sort({\n\t      silent: true\n\t    });\n\n\t    // Unless silenced, it's time to fire all appropriate add/sort/update events.\n\t    if (!options.silent) {\n\t      for (i = 0; i < toAdd.length; i++) {\n\t        if (at != null) options.index = at + i;\n\t        model = toAdd[i];\n\t        model.trigger(model.eventPrefix + 'add', model, this, options);\n\t      }\n\t      if (sort || orderChanged) this.trigger('sort', this, options);\n\t      if (toAdd.length || toRemove.length || toMerge.length) {\n\t        options.changes = {\n\t          added: toAdd,\n\t          removed: toRemove,\n\t          merged: toMerge\n\t        };\n\t        this.trigger('update', this, options);\n\t      }\n\t    }\n\n\t    // Return the added (or merged) model (or models).\n\t    return singular ? models[0] : models;\n\t  },\n\t  // When you have more items than you want to add or remove individually,\n\t  // you can reset the entire set with a new list of models, without firing\n\t  // any granular `add` or `remove` events. Fires `reset` when finished.\n\t  // Useful for bulk operations and optimizations.\n\t  reset: function (models, options) {\n\t    options = options ? clone$1(options) : {};\n\t    for (var i = 0; i < this.models.length; i++) {\n\t      this._removeReference(this.models[i], options);\n\t    }\n\t    options.previousModels = this.models;\n\t    this._reset();\n\t    models = this.add(models, assign({\n\t      silent: true\n\t    }, options));\n\t    if (!options.silent) this.trigger('reset', this, options);\n\t    return models;\n\t  },\n\t  // Add a model to the end of the collection.\n\t  push: function (model, options) {\n\t    return this.add(model, assign({\n\t      at: this.length\n\t    }, options));\n\t  },\n\t  // Remove a model from the end of the collection.\n\t  pop: function (options) {\n\t    var model = this.at(this.length - 1);\n\t    return this.remove(model, options);\n\t  },\n\t  // Add a model to the beginning of the collection.\n\t  unshift: function (model, options) {\n\t    return this.add(model, assign({\n\t      at: 0\n\t    }, options));\n\t  },\n\t  // Remove a model from the beginning of the collection.\n\t  shift: function (options) {\n\t    var model = this.at(0);\n\t    return this.remove(model, options);\n\t  },\n\t  // Slice out a sub-array of models from the collection.\n\t  slice: function () {\n\t    return Array.prototype.slice.apply(this.models, arguments);\n\t  },\n\t  // Get a model from the set by id, cid, model object with id or cid\n\t  // properties, or an attributes object that is transformed through modelId.\n\t  get: function (obj) {\n\t    if (obj == null) return void 0;\n\t    return this._byId.get(obj) || this._byId.get(this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)) || obj.cid && this._byId.get(obj.cid);\n\t  },\n\t  // Returns `true` if the model is in the collection.\n\t  has: function (obj) {\n\t    return this.get(obj) != null;\n\t  },\n\t  // Get the model at the given index.\n\t  at: function (index) {\n\t    if (index < 0) index += this.length;\n\t    return this.models[index];\n\t  },\n\t  // Force the collection to re-sort itself. You don't need to call this under\n\t  // normal circumstances, as the set will maintain sort order as each item\n\t  // is added.\n\t  sort: function (options) {\n\t    var comparator = this.comparator;\n\t    if (!comparator) throw new Error('Cannot sort a set without a comparator');\n\t    options || (options = {});\n\t    var length = comparator.length;\n\t    if (isFunction(comparator)) comparator = comparator.bind(this);\n\n\t    // Run sort based on type of `comparator`.\n\t    if (length === 1 || isString(comparator)) {\n\t      this.models = this.sortBy(comparator);\n\t    } else {\n\t      this.models.sort(comparator);\n\t    }\n\t    if (!options.silent) this.trigger('sort', this, options);\n\t    return this;\n\t  },\n\t  // Create a new collection with an identical list of models as this one.\n\t  clone: function () {\n\t    return new this.constructor(this.models, {\n\t      model: this.model,\n\t      comparator: this.comparator\n\t    });\n\t  },\n\t  // Define how to uniquely identify models in the collection.\n\t  modelId: function (attrs, idAttribute) {\n\t    var _this$model$prototype;\n\t    return attrs[idAttribute || ((_this$model$prototype = this.model.prototype) === null || _this$model$prototype === void 0 ? void 0 : _this$model$prototype.idAttribute) || 'id'];\n\t  },\n\t  // Get an iterator of all models in this collection.\n\t  values: function () {\n\t    return new CollectionIterator(this, ITERATOR_VALUES);\n\t  },\n\t  // Get an iterator of all model IDs in this collection.\n\t  keys: function () {\n\t    return new CollectionIterator(this, ITERATOR_KEYS);\n\t  },\n\t  // Get an iterator of all [ID, model] tuples in this collection.\n\t  entries: function () {\n\t    return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n\t  },\n\t  // Iterate over elements of the collection, and invoke fn for each element\n\t  each: function (fn, context) {\n\t    this.models.forEach(fn, context);\n\t  },\n\t  // Iterate over elements of collection, and return an array of all elements fn returns truthy for\n\t  filter: function (fn, context) {\n\t    return this.models.filter(fn, context);\n\t  },\n\t  find: function (fn, context) {\n\t    return this.models.find(fn, context);\n\t  },\n\t  findIndex: function (fn, context) {\n\t    return this.models.findIndex(fn, context);\n\t  },\n\t  // Return the first model of the collection\n\t  first: function () {\n\t    return this.models[0];\n\t  },\n\t  // Return true if value is in the collection\n\t  includes: function (value) {\n\t    return this.models.includes(value);\n\t  },\n\t  // Return the last model of the collection\n\t  last: function () {\n\t    return this.models[this.models.length - 1];\n\t  },\n\t  // Return true if collection has no elements\n\t  isEmpty: function () {\n\t    return !this.models.length;\n\t  },\n\t  // Create an array of values by running each element in the collection through fn\n\t  map: function (fn, context) {\n\t    return this.models.map(fn, context);\n\t  },\n\t  // Runs \"reducer\" fn over all elements in the collection, in ascending-index order, and accumulates them into a single value\n\t  reduce: function (fn, initAcc = this.first()) {\n\t    return this.models.reduce(fn, initAcc);\n\t  },\n\t  // Private method to reset all internal state. Called when the collection\n\t  // is first initialized or reset.\n\t  _reset: function () {\n\t    this.length = 0;\n\t    this.models = [];\n\t    this._byId = new Map();\n\t  },\n\t  // Prepare a hash of attributes (or other model) to be added to this\n\t  // collection.\n\t  _prepareModel: function (attrs, options) {\n\t    if (this._isModel(attrs)) {\n\t      if (!options.dry && !attrs.collection) attrs.collection = this;\n\t      return attrs;\n\t    }\n\t    options = options ? clone$1(options) : {};\n\t    if (!options.dry) options.collection = this;\n\t    var model;\n\t    if (this.model.prototype) {\n\t      model = new this.model(attrs, options);\n\t    } else {\n\t      // ES class methods didn't have prototype\n\t      model = this.model(attrs, options);\n\t    }\n\t    if (!model.validationError) return model;\n\t    this.trigger('invalid', this, model.validationError, options);\n\t    return false;\n\t  },\n\t  // Internal method called by both remove and set.\n\t  _removeModels: function (models, options) {\n\t    var removed = [];\n\t    for (var i = 0; i < models.length; i++) {\n\t      var model = this.get(models[i]);\n\t      if (!model) continue;\n\t      var index = this.models.indexOf(model);\n\t      this.models.splice(index, 1);\n\t      this.length--;\n\n\t      // Remove references before triggering 'remove' event to prevent an\n\t      // infinite loop. #3693\n\t      this._byId.delete(model.cid);\n\t      var id = this.modelId(model.attributes, model.idAttribute);\n\t      if (id != null) this._byId.delete(id);\n\t      if (!options.silent) {\n\t        options.index = index;\n\t        model.trigger(model.eventPrefix + 'remove', model, this, options);\n\t      }\n\t      removed.push(model);\n\t      this._removeReference(model, options);\n\t    }\n\t    if (models.length > 0 && !options.silent) delete options.index;\n\t    return removed;\n\t  },\n\t  // Method for checking whether an object should be considered a model for\n\t  // the purposes of adding to the collection.\n\t  _isModel: function (model) {\n\t    return model instanceof Model;\n\t  },\n\t  // Internal method to create a model's ties to a collection.\n\t  _addReference: function (model, options) {\n\t    this._byId.set(model.cid, model);\n\t    var id = this.modelId(model.attributes, model.idAttribute);\n\t    if (id != null) this._byId.set(id, model);\n\t    model.on('all', this._onModelEvent, this);\n\t  },\n\t  // Internal method to sever a model's ties to a collection.\n\t  _removeReference: function (model, options) {\n\t    this._byId.delete(model.cid);\n\t    var id = this.modelId(model.attributes, model.idAttribute);\n\t    if (id != null) this._byId.delete(id);\n\t    if (!options.dry && this === model.collection) delete model.collection;\n\t    model.off('all', this._onModelEvent, this);\n\t  },\n\t  // Internal method called every time a model in the set fires an event.\n\t  // Sets need to update their indexes when models change ids. All other\n\t  // events simply proxy through. \"add\" and \"remove\" events that originate\n\t  // in other collections are ignored.\n\t  _onModelEvent: function (event, model, collection, options) {\n\t    if (model) {\n\t      if ((event === model.eventPrefix + 'add' || event === model.eventPrefix + 'remove') && collection !== this) return;\n\t      if (event === 'changeId') {\n\t        var prevId = this.modelId(model.previousAttributes(), model.idAttribute);\n\t        var id = this.modelId(model.attributes, model.idAttribute);\n\t        if (prevId != null) this._byId.delete(prevId);\n\t        if (id != null) this._byId.set(id, model);\n\t      }\n\t    }\n\t    this.trigger.apply(this, arguments);\n\t  }\n\t});\n\n\t// Defining an @@iterator method implements JavaScript's Iterable protocol.\n\t// In modern ES2015 browsers, this value is found at Symbol.iterator.\n\tvar $$iterator = typeof Symbol === 'function' && Symbol.iterator;\n\tif ($$iterator) {\n\t  Collection.prototype[$$iterator] = Collection.prototype.values;\n\t}\n\n\t// CollectionIterator\n\t// ------------------\n\n\t// A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n\t// use of `for of` loops in modern browsers and interoperation between\n\t// Collection and other JavaScript functions and third-party libraries\n\t// which can operate on Iterables.\n\tvar CollectionIterator = function (collection, kind) {\n\t  this._collection = collection;\n\t  this._kind = kind;\n\t  this._index = 0;\n\t};\n\n\t// This \"enum\" defines the three possible kinds of values which can be emitted\n\t// by a CollectionIterator that correspond to the values(), keys() and entries()\n\t// methods on Collection, respectively.\n\tvar ITERATOR_VALUES = 1;\n\tvar ITERATOR_KEYS = 2;\n\tvar ITERATOR_KEYSVALUES = 3;\n\n\t// All Iterators should themselves be Iterable.\n\tif ($$iterator) {\n\t  CollectionIterator.prototype[$$iterator] = function () {\n\t    return this;\n\t  };\n\t}\n\tCollectionIterator.prototype.next = function () {\n\t  if (this._collection) {\n\t    // Only continue iterating if the iterated collection is long enough.\n\t    if (this._index < this._collection.length) {\n\t      var model = this._collection.at(this._index);\n\t      this._index++;\n\n\t      // Construct a value depending on what kind of values should be iterated.\n\t      var value;\n\t      if (this._kind === ITERATOR_VALUES) {\n\t        value = model;\n\t      } else {\n\t        var id = this._collection.modelId(model.attributes, model.idAttribute);\n\t        if (this._kind === ITERATOR_KEYS) {\n\t          value = id;\n\t        } else {\n\t          // ITERATOR_KEYSVALUES\n\t          value = [id, model];\n\t        }\n\t      }\n\t      return {\n\t        value: value,\n\t        done: false\n\t      };\n\t    }\n\n\t    // Once exhausted, remove the reference to the collection so future\n\t    // calls to the next method always return done.\n\t    this._collection = void 0;\n\t  }\n\t  return {\n\t    value: void 0,\n\t    done: true\n\t  };\n\t};\n\n\t//  Methods that we want to implement on the Collection.\n\tvar collectionMethods = {\n\t  toArray: 1,\n\t  sortBy: 3\n\t};\n\n\t// Mix in each method as a proxy to `Collection#models`.\n\n\tvar config$2 = [Collection, collectionMethods, 'models'];\n\tfunction addMethods(config) {\n\t  var Base = config[0],\n\t    methods = config[1],\n\t    attribute = config[2];\n\t  const methodsToAdd = {\n\t    sortBy,\n\t    toArray: toArray$1\n\t  };\n\t  addMethodsUtil(Base, methodsToAdd, methods, attribute);\n\t}\n\taddMethods(config$2);\n\n\t// Set up inheritance for the collection.\n\tCollection.extend = extend;\n\n\tvar index$4 = {\n\t\t__proto__: null,\n\t\t$: $,\n\t\tCollection: Collection,\n\t\tData: Data,\n\t\tEvent: Event,\n\t\tEvents: Events,\n\t\tListener: Listener,\n\t\tModel: Model,\n\t\tView: View,\n\t\tViewBase: ViewBase,\n\t\tviews: views\n\t};\n\n\tfunction toArray(obj) {\n\t  if (!obj) return [];\n\t  if (Array.isArray(obj)) return obj;\n\t  return [obj];\n\t}\n\tconst HighlighterView = View.extend({\n\t  tagName: 'g',\n\t  svgElement: true,\n\t  className: 'highlight',\n\t  HIGHLIGHT_FLAG: 1,\n\t  UPDATE_PRIORITY: 3,\n\t  DETACHABLE: false,\n\t  UPDATABLE: true,\n\t  MOUNTABLE: true,\n\t  cellView: null,\n\t  nodeSelector: null,\n\t  node: null,\n\t  updateRequested: false,\n\t  postponedUpdate: false,\n\t  transformGroup: null,\n\t  detachedTransformGroup: null,\n\t  requestUpdate(cellView, nodeSelector) {\n\t    const {\n\t      paper\n\t    } = cellView;\n\t    this.cellView = cellView;\n\t    this.nodeSelector = nodeSelector;\n\t    if (paper) {\n\t      this.updateRequested = true;\n\t      paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n\t    }\n\t  },\n\t  confirmUpdate() {\n\t    // The cellView is now rendered/updated since it has a higher update priority.\n\t    this.updateRequested = false;\n\t    const {\n\t      cellView,\n\t      nodeSelector\n\t    } = this;\n\t    if (cellView.isMounted()) {\n\t      this.update(cellView, nodeSelector);\n\t      this.mount();\n\t      this.transform();\n\t    } else {\n\t      this.postponedUpdate = true;\n\t    }\n\t    return 0;\n\t  },\n\t  findNode(cellView, nodeSelector = null) {\n\t    let el;\n\t    if (typeof nodeSelector === 'string') {\n\t      el = cellView.findNode(nodeSelector);\n\t    } else if (isPlainObject(nodeSelector)) {\n\t      const isLink = cellView.model.isLink();\n\t      const {\n\t        label = null,\n\t        port,\n\t        selector\n\t      } = nodeSelector;\n\t      if (isLink && label !== null) {\n\t        // Link Label Selector\n\t        el = cellView.findLabelNode(label, selector);\n\t      } else if (!isLink && port) {\n\t        // Element Port Selector\n\t        el = cellView.findPortNode(port, selector);\n\t      } else {\n\t        // Cell Selector\n\t        el = cellView.findNode(selector);\n\t      }\n\t    } else if (nodeSelector) {\n\t      el = V.toNode(nodeSelector);\n\t      if (!(el instanceof SVGElement) || !cellView.el.contains(el)) el = null;\n\t    }\n\t    return el ? el : null;\n\t  },\n\t  getNodeMatrix(cellView, node) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      layer\n\t    } = options;\n\t    const {\n\t      rotatableNode\n\t    } = cellView;\n\t    const nodeMatrix = cellView.getNodeMatrix(node);\n\t    if (rotatableNode) {\n\t      if (layer) {\n\t        if (rotatableNode.contains(node)) {\n\t          return nodeMatrix;\n\t        }\n\t        // The node is outside of the rotatable group.\n\t        // Compensate the rotation set by transformGroup.\n\t        return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);\n\t      } else {\n\t        return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);\n\t      }\n\t    }\n\t    return nodeMatrix;\n\t  },\n\t  mount() {\n\t    const {\n\t      MOUNTABLE,\n\t      cellView,\n\t      el,\n\t      options,\n\t      transformGroup,\n\t      detachedTransformGroup,\n\t      postponedUpdate,\n\t      nodeSelector\n\t    } = this;\n\t    if (!MOUNTABLE || transformGroup) return;\n\t    if (postponedUpdate) {\n\t      // The cellView was not mounted when the update was requested.\n\t      // The update was postponed until the cellView is mounted.\n\t      this.update(cellView, nodeSelector);\n\t      this.transform();\n\t      return;\n\t    }\n\t    const {\n\t      paper\n\t    } = cellView;\n\t    const {\n\t      layer: layerName,\n\t      z\n\t    } = options;\n\t    if (layerName) {\n\t      let vGroup;\n\t      if (detachedTransformGroup) {\n\t        vGroup = detachedTransformGroup;\n\t        this.detachedTransformGroup = null;\n\t      } else {\n\t        vGroup = V('g').addClass('highlight-transform').append(el);\n\t      }\n\t      this.transformGroup = vGroup;\n\t      paper.getLayerView(layerName).insertSortedNode(vGroup.node, z);\n\t    } else {\n\t      const children = cellView.el.children;\n\t      const index = Math.max(z, 0);\n\t      const beforeChild = children[index];\n\n\t      // If the provided `z` is a number and there is an element on the index,\n\t      // we need to insert the highlighter before the element on the index.\n\t      // Otherwise, the highlighter will be appended as the last child.\n\t      const toBeInserted = isNumber(z) && beforeChild;\n\t      const isElementAtTargetPosition = toBeInserted\n\t      // If the element is being inserted, check if it is not already at the correct position.\n\t      ? el === beforeChild\n\t      // If the element is being appended, check if it is not already last child.\n\t      : !el.nextElementSibling;\n\n\t      // If the element is already mounted and does not require repositioning, do nothing.\n\t      if (el.parentNode && isElementAtTargetPosition) return;\n\t      if (toBeInserted) {\n\t        cellView.el.insertBefore(el, beforeChild);\n\t      } else {\n\t        cellView.el.appendChild(el);\n\t      }\n\t    }\n\t  },\n\t  unmount() {\n\t    const {\n\t      MOUNTABLE,\n\t      transformGroup,\n\t      vel,\n\t      options\n\t    } = this;\n\t    if (!MOUNTABLE) return;\n\t    if (options.layer) {\n\t      if (!transformGroup) return;\n\t      // else: if `transformGroup` is not null, it means the highlighter\n\t      // has not been mounted yet\n\t      this.transformGroup = null;\n\t      this.detachedTransformGroup = transformGroup;\n\t      transformGroup.remove();\n\t    } else {\n\t      vel.remove();\n\t    }\n\t  },\n\t  transform() {\n\t    const {\n\t      transformGroup,\n\t      cellView,\n\t      updateRequested\n\t    } = this;\n\t    if (!transformGroup || cellView.model.isLink() || updateRequested) return;\n\t    const translateMatrix = cellView.getRootTranslateMatrix();\n\t    const rotateMatrix = cellView.getRootRotateMatrix();\n\t    const transformMatrix = translateMatrix.multiply(rotateMatrix);\n\t    transformGroup.attr('transform', V.matrixToTransformString(transformMatrix));\n\t  },\n\t  update() {\n\t    const {\n\t      node: prevNode,\n\t      cellView,\n\t      nodeSelector,\n\t      updateRequested,\n\t      id\n\t    } = this;\n\t    if (updateRequested) return;\n\t    this.postponedUpdate = false;\n\t    const node = this.node = this.findNode(cellView, nodeSelector);\n\t    if (prevNode) {\n\t      this.unhighlight(cellView, prevNode);\n\t    }\n\t    if (node) {\n\t      this.highlight(cellView, node);\n\t      this.mount();\n\t    } else {\n\t      this.unmount();\n\t      cellView.notify('cell:highlight:invalid', id, this);\n\t    }\n\t  },\n\t  onRemove() {\n\t    const {\n\t      node,\n\t      cellView,\n\t      id,\n\t      constructor\n\t    } = this;\n\t    if (node) {\n\t      this.unhighlight(cellView, node);\n\t    }\n\t    this.unmount();\n\t    constructor._removeRef(cellView, id);\n\t  },\n\t  highlight(_cellView, _node) {\n\t    // to be overridden\n\t  },\n\t  unhighlight(_cellView, _node) {\n\t    // to be overridden\n\t  },\n\t  // Update Attributes\n\n\t  listenToUpdateAttributes(cellView) {\n\t    const attributes = result(this, 'UPDATE_ATTRIBUTES');\n\t    if (!Array.isArray(attributes) || attributes.length === 0) return;\n\t    this.listenTo(cellView.model, 'change', this.onCellAttributeChange);\n\t  },\n\t  onCellAttributeChange() {\n\t    const {\n\t      cellView\n\t    } = this;\n\t    if (!cellView) return;\n\t    const {\n\t      model,\n\t      paper\n\t    } = cellView;\n\t    const attributes = result(this, 'UPDATE_ATTRIBUTES');\n\t    if (!attributes.some(attribute => model.hasChanged(attribute))) return;\n\t    paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n\t  }\n\t}, {\n\t  _views: {},\n\t  // Used internally by CellView highlight()\n\t  highlight: function (cellView, node, opt) {\n\t    const id = this.uniqueId(node, opt);\n\t    this.add(cellView, node, id, opt);\n\t  },\n\t  // Used internally by CellView unhighlight()\n\t  unhighlight: function (cellView, node, opt) {\n\t    const id = this.uniqueId(node, opt);\n\t    this.remove(cellView, id);\n\t  },\n\t  get(cellView, id = null) {\n\t    const {\n\t      cid\n\t    } = cellView;\n\t    const {\n\t      _views\n\t    } = this;\n\t    const refs = _views[cid];\n\t    if (id === null) {\n\t      // all highlighters\n\t      const views = [];\n\t      if (!refs) return views;\n\t      for (const hid in refs) {\n\t        const ref = refs[hid];\n\t        if (ref instanceof this) {\n\t          views.push(ref);\n\t        }\n\t      }\n\t      return views;\n\t    } else {\n\t      // single highlighter\n\t      if (!refs) return null;\n\t      if (id in refs) {\n\t        const ref = refs[id];\n\t        if (ref instanceof this) return ref;\n\t      }\n\t      return null;\n\t    }\n\t  },\n\t  // Check if the cellView has a highlighter with the given `id`.\n\t  // If no `id` is provided, it checks if the cellView has any highlighter.\n\t  has(cellView, id = null) {\n\t    const {\n\t      cid\n\t    } = cellView;\n\t    const {\n\t      _views\n\t    } = this;\n\t    const refs = _views[cid];\n\t    if (!refs) return false;\n\t    if (id === null) {\n\t      // any highlighter\n\t      for (const hid in refs) {\n\t        if (refs[hid] instanceof this) return true;\n\t      }\n\t      return false;\n\t    } else {\n\t      // single highlighter\n\t      if (id in refs) {\n\t        if (refs[id] instanceof this) return true;\n\t      }\n\t      return false;\n\t    }\n\t  },\n\t  add(cellView, nodeSelector, id, opt = {}) {\n\t    if (!id) throw new Error('dia.HighlighterView: An ID required.');\n\t    // Search the existing view amongst all the highlighters\n\t    const previousView = HighlighterView.get(cellView, id);\n\t    if (previousView) previousView.remove();\n\t    const view = new this(opt);\n\t    view.id = id;\n\t    this._addRef(cellView, id, view);\n\t    view.requestUpdate(cellView, nodeSelector);\n\t    view.listenToUpdateAttributes(cellView);\n\t    return view;\n\t  },\n\t  _addRef(cellView, id, view) {\n\t    const {\n\t      cid\n\t    } = cellView;\n\t    const {\n\t      _views\n\t    } = this;\n\t    let refs = _views[cid];\n\t    if (!refs) refs = _views[cid] = {};\n\t    refs[id] = view;\n\t  },\n\t  _removeRef(cellView, id) {\n\t    const {\n\t      cid\n\t    } = cellView;\n\t    const {\n\t      _views\n\t    } = this;\n\t    const refs = _views[cid];\n\t    if (!refs) return;\n\t    if (id) delete refs[id];\n\t    for (const _ in refs) return;\n\t    delete _views[cid];\n\t  },\n\t  remove(cellView, id = null) {\n\t    toArray(this.get(cellView, id)).forEach(view => {\n\t      view.remove();\n\t    });\n\t  },\n\t  getAll(paper, id = null) {\n\t    const views = [];\n\t    const {\n\t      _views\n\t    } = this;\n\t    for (const cid in _views) {\n\t      for (const hid in _views[cid]) {\n\t        const view = _views[cid][hid];\n\t        if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {\n\t          views.push(view);\n\t        }\n\t      }\n\t    }\n\t    return views;\n\t  },\n\t  removeAll(paper, id = null) {\n\t    this.getAll(paper, id).forEach(view => view.remove());\n\t  },\n\t  update(cellView, id = null, dirty = false) {\n\t    toArray(this.get(cellView, id)).forEach(view => {\n\t      if (dirty || view.UPDATABLE) view.update();\n\t    });\n\t  },\n\t  transform(cellView, id = null) {\n\t    toArray(this.get(cellView, id)).forEach(view => {\n\t      if (view.UPDATABLE) view.transform();\n\t    });\n\t  },\n\t  unmount(cellView, id = null) {\n\t    toArray(this.get(cellView, id)).forEach(view => view.unmount());\n\t  },\n\t  mount(cellView, id = null) {\n\t    toArray(this.get(cellView, id)).forEach(view => view.mount());\n\t  },\n\t  uniqueId(node, opt = '') {\n\t    return V.ensureId(node) + JSON.stringify(opt);\n\t  }\n\t});\n\n\tconst stroke$1 = HighlighterView.extend({\n\t  tagName: 'path',\n\t  className: 'highlight-stroke',\n\t  attributes: {\n\t    'pointer-events': 'none',\n\t    'fill': 'none'\n\t  },\n\t  options: {\n\t    padding: 3,\n\t    rx: 0,\n\t    ry: 0,\n\t    useFirstSubpath: false,\n\t    attrs: {\n\t      'stroke-width': 3,\n\t      'stroke': '#FEB663'\n\t    }\n\t  },\n\t  getPathData(cellView, node) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      useFirstSubpath\n\t    } = options;\n\t    let d;\n\t    try {\n\t      const vNode = V(node);\n\t      d = vNode.convertToPathData().trim();\n\t      if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n\t        const secondSubpathIndex = d.search(/.M/i) + 1;\n\t        if (secondSubpathIndex > 0) {\n\t          d = d.substr(0, secondSubpathIndex);\n\t        }\n\t      }\n\t    } catch {\n\t      // Failed to get path data from magnet element.\n\t      // Draw a rectangle around the node instead.\n\t      const nodeBBox = cellView.getNodeBoundingRect(node);\n\t      d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n\t    }\n\t    return d;\n\t  },\n\t  highlightConnection(cellView) {\n\t    this.vel.attr('d', cellView.getSerializedConnection());\n\t  },\n\t  highlightNode(cellView, node) {\n\t    const {\n\t      vel,\n\t      options\n\t    } = this;\n\t    const {\n\t      padding,\n\t      layer\n\t    } = options;\n\t    let highlightMatrix = this.getNodeMatrix(cellView, node);\n\t    // Add padding to the highlight element.\n\t    if (padding) {\n\t      if (!layer && node === cellView.el) {\n\t        // If the highlighter is appended to the cellView\n\t        // and we measure the size of the cellView wrapping group\n\t        // it's necessary to remove the highlighter first\n\t        vel.remove();\n\t      }\n\t      let nodeBBox = cellView.getNodeBoundingRect(node);\n\t      const cx = nodeBBox.x + nodeBBox.width / 2;\n\t      const cy = nodeBBox.y + nodeBBox.height / 2;\n\t      nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n\t      const width = Math.max(nodeBBox.width, 1);\n\t      const height = Math.max(nodeBBox.height, 1);\n\t      const sx = (width + padding) / width;\n\t      const sy = (height + padding) / height;\n\t      const paddingMatrix = V.createSVGMatrix({\n\t        a: sx,\n\t        b: 0,\n\t        c: 0,\n\t        d: sy,\n\t        e: cx - sx * cx,\n\t        f: cy - sy * cy\n\t      });\n\t      highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n\t    }\n\t    vel.attr({\n\t      'd': this.getPathData(cellView, node),\n\t      'transform': V.matrixToTransformString(highlightMatrix)\n\t    });\n\t  },\n\t  highlight(cellView, node) {\n\t    const {\n\t      vel,\n\t      options\n\t    } = this;\n\t    vel.attr(options.attrs);\n\t    if (options.nonScalingStroke) {\n\t      vel.attr('vector-effect', 'non-scaling-stroke');\n\t    }\n\t    if (cellView.isNodeConnection(node)) {\n\t      this.highlightConnection(cellView);\n\t    } else {\n\t      this.highlightNode(cellView, node);\n\t    }\n\t  }\n\t});\n\n\tconst MASK_CLIP = 20;\n\tfunction forEachDescendant(vel, fn) {\n\t  const descendants = vel.children();\n\t  while (descendants.length > 0) {\n\t    const descendant = descendants.shift();\n\t    if (fn(descendant)) {\n\t      descendants.push(...descendant.children());\n\t    }\n\t  }\n\t}\n\tconst mask = HighlighterView.extend({\n\t  tagName: 'rect',\n\t  className: 'highlight-mask',\n\t  attributes: {\n\t    'pointer-events': 'none'\n\t  },\n\t  options: {\n\t    padding: 3,\n\t    maskClip: MASK_CLIP,\n\t    deep: false,\n\t    attrs: {\n\t      'stroke': '#FEB663',\n\t      'stroke-width': 3,\n\t      'stroke-linecap': 'butt',\n\t      'stroke-linejoin': 'miter'\n\t    }\n\t  },\n\t  VISIBLE: 'white',\n\t  INVISIBLE: 'black',\n\t  MASK_ROOT_ATTRIBUTE_BLACKLIST: ['marker-start', 'marker-end', 'marker-mid', 'transform', 'stroke-dasharray', 'class'],\n\t  MASK_CHILD_ATTRIBUTE_BLACKLIST: ['stroke', 'fill', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill-opacity', 'marker-start', 'marker-end', 'marker-mid', 'class'],\n\t  // TODO: change the list to a function callback\n\t  MASK_REPLACE_TAGS: ['FOREIGNOBJECT', 'IMAGE', 'USE', 'TEXT', 'TSPAN', 'TEXTPATH'],\n\t  // TODO: change the list to a function callback\n\t  MASK_REMOVE_TAGS: ['TEXT', 'TSPAN', 'TEXTPATH'],\n\t  transformMaskChild(cellView, childEl) {\n\t    const {\n\t      MASK_CHILD_ATTRIBUTE_BLACKLIST,\n\t      MASK_REPLACE_TAGS,\n\t      MASK_REMOVE_TAGS\n\t    } = this;\n\t    const childTagName = childEl.tagName();\n\t    // Do not include the element in the mask's image\n\t    if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n\t      childEl.remove();\n\t      return false;\n\t    }\n\t    // Replace the element with a rectangle\n\t    if (MASK_REPLACE_TAGS.includes(childTagName)) {\n\t      // Note: clone() method does not change the children ids\n\t      const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n\t      if (originalChild) {\n\t        const {\n\t          node: originalNode\n\t        } = originalChild;\n\t        let childBBox = cellView.getNodeBoundingRect(originalNode);\n\t        if (cellView.model.isElement()) {\n\t          childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n\t        }\n\t        const replacement = V('rect', childBBox.toJSON());\n\t        const {\n\t          x: ox,\n\t          y: oy\n\t        } = childBBox.center();\n\t        const {\n\t          angle,\n\t          cx = ox,\n\t          cy = oy\n\t        } = originalChild.rotate();\n\t        if (angle) replacement.rotate(angle, cx, cy);\n\t        // Note: it's not important to keep the same sibling index since all subnodes are filled\n\t        childEl.parent().append(replacement);\n\t      }\n\t      childEl.remove();\n\t      return false;\n\t    }\n\t    // Keep the element, but clean it from certain attributes\n\t    MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n\t      if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n\t      childEl.removeAttr(attrName);\n\t    });\n\t    return true;\n\t  },\n\t  transformMaskRoot(_cellView, rootEl) {\n\t    const {\n\t      MASK_ROOT_ATTRIBUTE_BLACKLIST\n\t    } = this;\n\t    MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n\t      rootEl.removeAttr(attrName);\n\t    });\n\t  },\n\t  getMaskShape(cellView, vel) {\n\t    const {\n\t      options,\n\t      MASK_REPLACE_TAGS\n\t    } = this;\n\t    const {\n\t      deep\n\t    } = options;\n\t    const tagName = vel.tagName();\n\t    let maskRoot;\n\t    if (tagName === 'G') {\n\t      if (!deep) return null;\n\t      maskRoot = vel.clone();\n\t      forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n\t    } else {\n\t      if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n\t      maskRoot = vel.clone();\n\t    }\n\t    this.transformMaskRoot(cellView, maskRoot);\n\t    return maskRoot;\n\t  },\n\t  getMaskId() {\n\t    return `highlight-mask-${this.cid}`;\n\t  },\n\t  getMask(cellView, vNode) {\n\t    const {\n\t      VISIBLE,\n\t      INVISIBLE,\n\t      options\n\t    } = this;\n\t    const {\n\t      padding,\n\t      attrs\n\t    } = options;\n\t    // support both `strokeWidth` and `stroke-width` attribute names\n\t    const strokeWidth = parseFloat(V('g').attr(attrs).attr('stroke-width'));\n\t    const hasNodeFill = vNode.attr('fill') !== 'none';\n\t    let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n\t    if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n\t    // stroke of the invisible shape\n\t    const minStrokeWidth = magnetStrokeWidth + padding * 2;\n\t    // stroke of the visible shape\n\t    const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n\t    let maskEl = this.getMaskShape(cellView, vNode);\n\t    if (!maskEl) {\n\t      const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n\t      // Make sure the rect is visible\n\t      nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n\t      maskEl = V('rect', nodeBBox.toJSON());\n\t    }\n\t    maskEl.attr(attrs);\n\t    return V('mask', {\n\t      'id': this.getMaskId()\n\t    }).append([maskEl.clone().attr({\n\t      'fill': hasNodeFill ? VISIBLE : 'none',\n\t      'stroke': VISIBLE,\n\t      'stroke-width': maxStrokeWidth\n\t    }), maskEl.clone().attr({\n\t      'fill': hasNodeFill ? INVISIBLE : 'none',\n\t      'stroke': INVISIBLE,\n\t      'stroke-width': minStrokeWidth\n\t    })]);\n\t  },\n\t  removeMask(paper) {\n\t    const maskNode = paper.svg.getElementById(this.getMaskId());\n\t    if (maskNode) {\n\t      paper.defs.removeChild(maskNode);\n\t    }\n\t  },\n\t  addMask(paper, maskEl) {\n\t    paper.defs.appendChild(maskEl.node);\n\t  },\n\t  highlight(cellView, node) {\n\t    const {\n\t      options,\n\t      vel\n\t    } = this;\n\t    const {\n\t      padding,\n\t      attrs,\n\t      maskClip = MASK_CLIP,\n\t      layer\n\t    } = options;\n\t    const color = 'stroke' in attrs ? attrs['stroke'] : '#000000';\n\t    if (!layer && node === cellView.el) {\n\t      // If the highlighter is appended to the cellView\n\t      // and we measure the size of the cellView wrapping group\n\t      // it's necessary to remove the highlighter first\n\t      vel.remove();\n\t    }\n\t    const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n\t    const highlightMatrix = this.getNodeMatrix(cellView, node);\n\t    const maskEl = this.getMask(cellView, V(node));\n\t    this.addMask(cellView.paper, maskEl);\n\t    vel.attr(highlighterBBox.toJSON());\n\t    vel.attr({\n\t      'transform': V.matrixToTransformString(highlightMatrix),\n\t      'mask': `url(#${maskEl.id})`,\n\t      'fill': color\n\t    });\n\t  },\n\t  unhighlight(cellView) {\n\t    this.removeMask(cellView.paper);\n\t  }\n\t});\n\n\tconst opacity = HighlighterView.extend({\n\t  UPDATABLE: false,\n\t  MOUNTABLE: false,\n\t  highlight: function (_cellView, node) {\n\t    const {\n\t      alphaValue = 0.3\n\t    } = this.options;\n\t    node.style.opacity = alphaValue;\n\t  },\n\t  unhighlight: function (_cellView, node) {\n\t    node.style.opacity = '';\n\t  }\n\t});\n\n\tconst className = addClassNamePrefix('highlighted');\n\tconst addClass = HighlighterView.extend({\n\t  UPDATABLE: false,\n\t  MOUNTABLE: false,\n\t  options: {\n\t    className\n\t  },\n\t  highlight: function (_cellView, node) {\n\t    V(node).addClass(this.options.className);\n\t  },\n\t  unhighlight: function (_cellView, node) {\n\t    V(node).removeClass(this.options.className);\n\t  }\n\t}, {\n\t  // Backwards Compatibility\n\t  className\n\t});\n\n\tconst Directions$1 = {\n\t  ROW: 'row',\n\t  COLUMN: 'column'\n\t};\n\tconst list = HighlighterView.extend({\n\t  tagName: 'g',\n\t  MOUNTABLE: true,\n\t  UPDATE_ATTRIBUTES: function () {\n\t    return [this.options.attribute];\n\t  },\n\t  _prevItems: null,\n\t  highlight(elementView, node) {\n\t    const element = elementView.model;\n\t    const {\n\t      attribute,\n\t      size = 20,\n\t      gap = 5,\n\t      direction = Directions$1.ROW\n\t    } = this.options;\n\t    if (!attribute) throw new Error('List: attribute is required');\n\t    const normalizedSize = typeof size === 'number' ? {\n\t      width: size,\n\t      height: size\n\t    } : size;\n\t    const isRowDirection = direction === Directions$1.ROW;\n\t    const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n\t    let items = element.get(attribute);\n\t    if (!Array.isArray(items)) items = [];\n\t    const prevItems = this._prevItems || [];\n\t    const comparison = items.map((item, index) => isEqual(prevItems[index], items[index]));\n\t    if (prevItems.length !== items.length || comparison.some(unchanged => !unchanged)) {\n\t      const prevEls = this.vel.children();\n\t      const itemsEls = items.map((item, index) => {\n\t        const prevEl = index in prevEls ? prevEls[index].node : null;\n\t        if (comparison[index]) return prevEl;\n\t        const itemEl = this.createListItem(item, normalizedSize, prevEl);\n\t        if (!itemEl) return null;\n\t        if (!(itemEl instanceof SVGElement)) throw new Error('List: item must be an SVGElement');\n\t        itemEl.dataset.index = index;\n\t        itemEl.dataset.attribute = attribute;\n\t        const offset = index * (itemWidth + gap);\n\t        itemEl.setAttribute('transform', isRowDirection ? `translate(${offset}, 0)` : `translate(0, ${offset})`);\n\t        return itemEl;\n\t      });\n\t      this.vel.empty().append(itemsEls);\n\t      this._prevItems = items;\n\t    }\n\t    const itemsCount = items.length;\n\t    const length = itemsCount === 0 ? 0 : itemsCount * itemWidth + (itemsCount - 1) * gap;\n\t    const listSize = isRowDirection ? {\n\t      width: length,\n\t      height: normalizedSize.height\n\t    } : {\n\t      width: normalizedSize.width,\n\t      height: length\n\t    };\n\t    this.position(element, listSize);\n\t  },\n\t  position(element, listSize) {\n\t    const {\n\t      vel,\n\t      options\n\t    } = this;\n\t    const {\n\t      margin = 5,\n\t      position = 'top-left'\n\t    } = options;\n\t    const {\n\t      width,\n\t      height\n\t    } = element.size();\n\t    const {\n\t      left,\n\t      right,\n\t      top,\n\t      bottom\n\t    } = normalizeSides(margin);\n\t    const bbox = new Rect(left, top, width - (left + right), height - (top + bottom));\n\t    let {\n\t      x,\n\t      y\n\t    } = getRectPoint(bbox, position);\n\t    // x\n\t    switch (position) {\n\t      case Positions.CENTER:\n\t      case Positions.TOP:\n\t      case Positions.BOTTOM:\n\t        {\n\t          x -= listSize.width / 2;\n\t          break;\n\t        }\n\t      case Positions.RIGHT:\n\t      case Positions.BOTTOM_RIGHT:\n\t      case Positions.TOP_RIGHT:\n\t        {\n\t          x -= listSize.width;\n\t          break;\n\t        }\n\t    }\n\t    // y\n\t    switch (position) {\n\t      case Positions.CENTER:\n\t      case Positions.RIGHT:\n\t      case Positions.LEFT:\n\t        {\n\t          y -= listSize.height / 2;\n\t          break;\n\t        }\n\t      case Positions.BOTTOM:\n\t      case Positions.BOTTOM_RIGHT:\n\t      case Positions.BOTTOM_LEFT:\n\t        {\n\t          y -= listSize.height;\n\t          break;\n\t        }\n\t    }\n\t    vel.attr('transform', `translate(${x}, ${y})`);\n\t  }\n\t}, {\n\t  Directions: Directions$1,\n\t  Positions\n\t});\n\n\tvar highlighters = {\n\t\t__proto__: null,\n\t\taddClass: addClass,\n\t\tlist: list,\n\t\tmask: mask,\n\t\topacity: opacity,\n\t\tstroke: stroke$1\n\t};\n\n\tfunction offsetPoint(p1, p2, offset) {\n\t  if (isPlainObject(offset)) {\n\t    const {\n\t      x,\n\t      y\n\t    } = offset;\n\t    if (isFinite(y)) {\n\t      const line = new Line(p2, p1);\n\t      const {\n\t        start,\n\t        end\n\t      } = line.parallel(y);\n\t      p2 = start;\n\t      p1 = end;\n\t    }\n\t    offset = x;\n\t  }\n\t  if (!isFinite(offset)) return p1;\n\t  var length = p1.distance(p2);\n\t  if (offset === 0 && length > 0) return p1;\n\t  return p1.move(p2, -Math.min(offset, length - 1));\n\t}\n\tfunction stroke(magnet) {\n\t  var stroke = magnet.getAttribute('stroke-width');\n\t  if (stroke === null) return 0;\n\t  return parseFloat(stroke) || 0;\n\t}\n\tfunction alignLine(line, type, offset = 0) {\n\t  let coordinate, a, b, direction;\n\t  const {\n\t    start,\n\t    end\n\t  } = line;\n\t  switch (type) {\n\t    case 'left':\n\t      coordinate = 'x';\n\t      a = end;\n\t      b = start;\n\t      direction = -1;\n\t      break;\n\t    case 'right':\n\t      coordinate = 'x';\n\t      a = start;\n\t      b = end;\n\t      direction = 1;\n\t      break;\n\t    case 'top':\n\t      coordinate = 'y';\n\t      a = end;\n\t      b = start;\n\t      direction = -1;\n\t      break;\n\t    case 'bottom':\n\t      coordinate = 'y';\n\t      a = start;\n\t      b = end;\n\t      direction = 1;\n\t      break;\n\t    default:\n\t      return;\n\t  }\n\t  if (start[coordinate] < end[coordinate]) {\n\t    a[coordinate] = b[coordinate];\n\t  } else {\n\t    b[coordinate] = a[coordinate];\n\t  }\n\t  if (isFinite(offset)) {\n\t    a[coordinate] += direction * offset;\n\t    b[coordinate] += direction * offset;\n\t  }\n\t}\n\n\t// Connection Points\n\n\tfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n\t  const {\n\t    offset,\n\t    alignOffset,\n\t    align\n\t  } = opt;\n\t  if (align) alignLine(line, align, alignOffset);\n\t  return offsetPoint(line.end, line.start, offset);\n\t}\n\tfunction bboxIntersection(line, view, magnet, opt) {\n\t  const bbox = opt.useModelGeometry ? getNodeModelBBox(view, magnet, true) : view.getNodeBBox(magnet);\n\t  if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n\t  const intersections = line.intersect(bbox);\n\t  const cp = intersections ? line.start.chooseClosest(intersections) : line.end;\n\t  return offsetPoint(cp, line.start, opt.offset);\n\t}\n\tfunction rectangleIntersection(line, view, magnet, opt) {\n\t  const angle = view.model.angle();\n\t  if (angle === 0) {\n\t    return bboxIntersection(line, view, magnet, opt);\n\t  }\n\t  const bboxWORotation = opt.useModelGeometry ? getNodeModelBBox(view, magnet, false) : view.getNodeUnrotatedBBox(magnet);\n\t  if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n\t  const center = bboxWORotation.center();\n\t  const lineWORotation = line.clone().rotate(center, angle);\n\t  const intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n\t  const cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;\n\t  return offsetPoint(cp, line.start, opt.offset);\n\t}\n\tfunction getNodeModelBBox(elementView, magnet, rotate) {\n\t  const element = elementView.model;\n\t  const portId = elementView.findAttribute('port', magnet);\n\t  if (element.hasPort(portId)) {\n\t    return element.getPortBBox(portId, {\n\t      rotate\n\t    });\n\t  }\n\t  return element.getBBox({\n\t    rotate\n\t  });\n\t}\n\tfunction findShapeNode(magnet) {\n\t  if (!magnet) return null;\n\t  var node = magnet;\n\t  do {\n\t    var tagName = node.tagName;\n\t    if (typeof tagName !== 'string') return null;\n\t    tagName = tagName.toUpperCase();\n\t    if (tagName === 'G') {\n\t      node = node.firstElementChild;\n\t    } else if (tagName === 'TITLE') {\n\t      node = node.nextElementSibling;\n\t    } else break;\n\t  } while (node);\n\t  return node;\n\t}\n\tvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\n\tvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\tfunction boundaryIntersection(line, view, magnet, opt) {\n\t  var node, intersection;\n\t  var selector = opt.selector;\n\t  var anchor = line.end;\n\t  if (typeof selector === 'string') {\n\t    node = view.findNode(selector);\n\t  } else if (selector === false) {\n\t    node = magnet;\n\t  } else if (Array.isArray(selector)) {\n\t    node = getByPath(magnet, selector);\n\t  } else {\n\t    node = findShapeNode(magnet);\n\t  }\n\t  if (!V.isSVGGraphicsElement(node)) {\n\t    if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n\t    node = magnet;\n\t  }\n\t  var localShape = view.getNodeShape(node);\n\t  var magnetMatrix = view.getNodeMatrix(node);\n\t  var translateMatrix = view.getRootTranslateMatrix();\n\t  var rotateMatrix = view.getRootRotateMatrix();\n\t  var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n\t  var localMatrix = targetMatrix.inverse();\n\t  var localLine = V.transformLine(line, localMatrix);\n\t  var localRef = localLine.start.clone();\n\t  var data = view.getNodeData(node);\n\t  if (opt.insideout === false) {\n\t    if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n\t    var localBBox = data[BNDR_SHAPE_BBOX];\n\t    if (localBBox.containsPoint(localRef)) return anchor;\n\t  }\n\n\t  // Caching segment subdivisions for paths\n\t  var pathOpt;\n\t  if (localShape instanceof Path$1) {\n\t    var precision = opt.precision || 2;\n\t    if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({\n\t      precision: precision\n\t    });\n\t    pathOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n\t    };\n\t  }\n\t  if (opt.extrapolate === true) localLine.setLength(1e6);\n\t  intersection = localLine.intersect(localShape, pathOpt);\n\t  if (intersection) {\n\t    // More than one intersection\n\t    if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n\t  } else if (opt.sticky === true) {\n\t    // No intersection, find the closest point instead\n\t    if (localShape instanceof Rect) {\n\t      intersection = localShape.pointNearestToPoint(localRef);\n\t    } else if (localShape instanceof Ellipse$1) {\n\t      intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n\t    } else {\n\t      intersection = localShape.closestPoint(localRef, pathOpt);\n\t    }\n\t  }\n\t  var cp = intersection ? V.transformPoint(intersection, targetMatrix) : anchor;\n\t  var cpOffset = opt.offset || 0;\n\t  if (opt.stroke) cpOffset += stroke(node) / 2;\n\t  return offsetPoint(cp, line.start, cpOffset);\n\t}\n\tconst anchor = anchorConnectionPoint;\n\tconst bbox = bboxIntersection;\n\tconst rectangle = rectangleIntersection;\n\tconst boundary = boundaryIntersection;\n\n\tvar connectionPoints = {\n\t\t__proto__: null,\n\t\tanchor: anchor,\n\t\tbbox: bbox,\n\t\tboundary: boundary,\n\t\trectangle: rectangle\n\t};\n\n\tfunction abs2rel(absolute, max) {\n\t  if (max === 0) return '0%';\n\t  // round to 3 decimal places\n\t  const dp = 1000;\n\t  const relative = Math.round(absolute / max * 100 * dp) / dp;\n\t  return `${relative}%`;\n\t}\n\tfunction pin(relative) {\n\t  return function (end, view, magnet, coords) {\n\t    var fn = view.isNodeConnection(magnet) ? pinnedLinkEnd : pinnedElementEnd;\n\t    return fn(relative, end, view, magnet, coords);\n\t  };\n\t}\n\tfunction pinnedElementEnd(relative, end, view, magnet, coords) {\n\t  var angle = view.model.angle();\n\t  var bbox = view.getNodeUnrotatedBBox(magnet);\n\t  var origin = view.model.getCenter();\n\t  coords.rotate(origin, angle);\n\t  var dx = coords.x - bbox.x;\n\t  var dy = coords.y - bbox.y;\n\t  if (relative) {\n\t    dx = abs2rel(dx, bbox.width);\n\t    dy = abs2rel(dy, bbox.height);\n\t  }\n\t  end.anchor = {\n\t    name: 'topLeft',\n\t    args: {\n\t      dx: dx,\n\t      dy: dy,\n\t      rotate: true\n\t    }\n\t  };\n\t  return end;\n\t}\n\tfunction pinnedLinkEnd(relative, end, view, _magnet, coords) {\n\t  var connection = view.getConnection();\n\t  if (!connection) return end;\n\t  var length = connection.closestPointLength(coords);\n\t  if (relative) {\n\t    var totalLength = connection.length();\n\t    end.anchor = {\n\t      name: 'connectionRatio',\n\t      args: {\n\t        ratio: length / totalLength\n\t      }\n\t    };\n\t  } else {\n\t    end.anchor = {\n\t      name: 'connectionLength',\n\t      args: {\n\t        length: length\n\t      }\n\t    };\n\t  }\n\t  return end;\n\t}\n\tconst useDefaults = noop;\n\tconst pinAbsolute = pin(false);\n\tconst pinRelative = pin(true);\n\n\tvar index$3 = {\n\t\t__proto__: null,\n\t\tpinAbsolute: pinAbsolute,\n\t\tpinRelative: pinRelative,\n\t\tuseDefaults: useDefaults\n\t};\n\n\t// Does not make any changes to vertices.\n\t// Returns the arguments that are passed to it, unchanged.\n\tconst normal = function (vertices, opt, linkView) {\n\t  return vertices;\n\t};\n\n\t// Routes the link always to/from a certain side\n\t//\n\t// Arguments:\n\t//   padding ... gap between the element and the first vertex. :: Default 40.\n\t//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n\t//\n\tconst oneSide = function (vertices, opt, linkView) {\n\t  var side = opt.side || 'bottom';\n\t  var padding = normalizeSides(opt.padding || 40);\n\n\t  // LinkView contains cached source an target bboxes.\n\t  // Note that those are Geometry rectangle objects.\n\t  var sourceBBox = linkView.sourceBBox;\n\t  var targetBBox = linkView.targetBBox;\n\t  var sourcePoint = sourceBBox.center();\n\t  var targetPoint = targetBBox.center();\n\t  var coordinate, dimension, direction;\n\t  switch (side) {\n\t    case 'bottom':\n\t      direction = 1;\n\t      coordinate = 'y';\n\t      dimension = 'height';\n\t      break;\n\t    case 'top':\n\t      direction = -1;\n\t      coordinate = 'y';\n\t      dimension = 'height';\n\t      break;\n\t    case 'left':\n\t      direction = -1;\n\t      coordinate = 'x';\n\t      dimension = 'width';\n\t      break;\n\t    case 'right':\n\t      direction = 1;\n\t      coordinate = 'x';\n\t      dimension = 'width';\n\t      break;\n\t    default:\n\t      throw new Error('Router: invalid side');\n\t  }\n\n\t  // move the points from the center of the element to outside of it.\n\t  sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n\t  targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n\t  // make link orthogonal (at least the first and last vertex).\n\t  if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {\n\t    targetPoint[coordinate] = sourcePoint[coordinate];\n\t  } else {\n\t    sourcePoint[coordinate] = targetPoint[coordinate];\n\t  }\n\t  return [sourcePoint].concat(vertices, targetPoint);\n\t};\n\n\t// bearing -> opposite bearing\n\tvar opposites = {\n\t  N: 'S',\n\t  S: 'N',\n\t  E: 'W',\n\t  W: 'E'\n\t};\n\n\t// bearing -> radians\n\tvar radians = {\n\t  N: -Math.PI / 2 * 3,\n\t  S: -Math.PI / 2,\n\t  E: 0,\n\t  W: Math.PI\n\t};\n\n\t// HELPERS //\n\n\t// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n\t// in the given box\n\tfunction freeJoin(p1, p2, bbox) {\n\t  var p = new Point(p1.x, p2.y);\n\t  if (bbox.containsPoint(p)) p = new Point(p2.x, p1.y);\n\t  // kept for reference\n\t  // if (bbox.containsPoint(p)) p = null;\n\n\t  return p;\n\t}\n\n\t// returns either width or height of a bbox based on the given bearing\n\tfunction getBBoxSize(bbox, bearing) {\n\t  return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n\t}\n\n\t// simple bearing method (calculates only orthogonal cardinals)\n\tfunction getBearing(from, to) {\n\t  if (from.x === to.x) return from.y > to.y ? 'N' : 'S';\n\t  if (from.y === to.y) return from.x > to.x ? 'W' : 'E';\n\t  return null;\n\t}\n\n\t// transform point to a rect\n\tfunction getPointBox(p) {\n\t  return new Rect(p.x, p.y, 0, 0);\n\t}\n\tfunction getPaddingBox(opt) {\n\t  // if both provided, opt.padding wins over opt.elementPadding\n\t  var sides = normalizeSides(opt.padding || opt.elementPadding || 20);\n\t  return {\n\t    x: -sides.left,\n\t    y: -sides.top,\n\t    width: sides.left + sides.right,\n\t    height: sides.top + sides.bottom\n\t  };\n\t}\n\n\t// return source bbox\n\tfunction getSourceBBox$1(linkView, opt) {\n\t  return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n\t}\n\n\t// return target bbox\n\tfunction getTargetBBox$1(linkView, opt) {\n\t  return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n\t}\n\n\t// return source anchor\n\tfunction getSourceAnchor$1(linkView, opt) {\n\t  if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n\t  // fallback: center of bbox\n\t  var sourceBBox = getSourceBBox$1(linkView, opt);\n\t  return sourceBBox.center();\n\t}\n\n\t// return target anchor\n\tfunction getTargetAnchor$1(linkView, opt) {\n\t  if (linkView.targetAnchor) return linkView.targetAnchor;\n\n\t  // fallback: center of bbox\n\t  var targetBBox = getTargetBBox$1(linkView, opt);\n\t  return targetBBox.center(); // default\n\t}\n\n\t// PARTIAL ROUTERS //\n\n\tfunction vertexVertex(from, to, bearing) {\n\t  var p1 = new Point(from.x, to.y);\n\t  var p2 = new Point(to.x, from.y);\n\t  var d1 = getBearing(from, p1);\n\t  var d2 = getBearing(from, p2);\n\t  var opposite = opposites[bearing];\n\t  var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n\t  return {\n\t    points: [p],\n\t    direction: getBearing(p, to)\n\t  };\n\t}\n\tfunction elementVertex(from, to, fromBBox) {\n\t  var p = freeJoin(from, to, fromBBox);\n\t  return {\n\t    points: [p],\n\t    direction: getBearing(p, to)\n\t  };\n\t}\n\tfunction vertexElement(from, to, toBBox, bearing) {\n\t  var route = {};\n\t  var points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n\t  var freePoints = points.filter(function (pt) {\n\t    return !toBBox.containsPoint(pt);\n\t  });\n\t  var freeBearingPoints = freePoints.filter(function (pt) {\n\t    return getBearing(pt, from) !== bearing;\n\t  });\n\t  var p;\n\t  if (freeBearingPoints.length > 0) {\n\t    // Try to pick a point which bears the same direction as the previous segment.\n\n\t    p = freeBearingPoints.filter(function (pt) {\n\t      return getBearing(from, pt) === bearing;\n\t    }).pop();\n\t    p = p || freeBearingPoints[0];\n\t    route.points = [p];\n\t    route.direction = getBearing(p, to);\n\t  } else {\n\t    // Here we found only points which are either contained in the element or they would create\n\t    // a link segment going in opposite direction from the previous one.\n\t    // We take the point inside element and move it outside the element in the direction the\n\t    // route is going. Now we can join this point with the current end (using freeJoin).\n\n\t    p = difference(points, freePoints)[0];\n\t    var p2 = new Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n\t    var p1 = freeJoin(p2, from, toBBox);\n\t    route.points = [p1, p2];\n\t    route.direction = getBearing(p2, to);\n\t  }\n\t  return route;\n\t}\n\tfunction elementElement(from, to, fromBBox, toBBox) {\n\t  var route = elementVertex(to, from, toBBox);\n\t  var p1 = route.points[0];\n\t  if (fromBBox.containsPoint(p1)) {\n\t    route = elementVertex(from, to, fromBBox);\n\t    var p2 = route.points[0];\n\t    if (toBBox.containsPoint(p2)) {\n\t      var fromBorder = new Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n\t      var toBorder = new Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n\t      var mid = new Line(fromBorder, toBorder).midpoint();\n\t      var startRoute = elementVertex(from, mid, fromBBox);\n\t      var endRoute = vertexVertex(mid, to, startRoute.direction);\n\t      route.points = [startRoute.points[0], endRoute.points[0]];\n\t      route.direction = endRoute.direction;\n\t    }\n\t  }\n\t  return route;\n\t}\n\n\t// Finds route for situations where one element is inside the other.\n\t// Typically the route is directed outside the outer element first and\n\t// then back towards the inner element.\n\tfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\t  var route = {};\n\t  var boundary = fromBBox.union(toBBox).inflate(1);\n\n\t  // start from the point which is closer to the boundary\n\t  var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n\t  var start = reversed ? to : from;\n\t  var end = reversed ? from : to;\n\t  var p1, p2, p3;\n\t  if (bearing) {\n\t    // Points on circle with radius equals 'W + H` are always outside the rectangle\n\t    // with width W and height H if the center of that circle is the center of that rectangle.\n\t    p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n\t    p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\t  } else {\n\t    p1 = boundary.pointNearestToPoint(start).move(start, 1);\n\t  }\n\t  p2 = freeJoin(p1, end, boundary);\n\t  if (p1.round().equals(p2.round())) {\n\t    p2 = Point.fromPolar(boundary.width + boundary.height, toRad(p1.theta(start)) + Math.PI / 2, end);\n\t    p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n\t    p3 = freeJoin(p1, p2, boundary);\n\t    route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\t  } else {\n\t    route.points = reversed ? [p2, p1] : [p1, p2];\n\t  }\n\t  route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\t  return route;\n\t}\n\n\t// MAIN ROUTER //\n\n\t// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n\t// routing from source to target going through `vertices`.\n\tfunction orthogonal(vertices, opt, linkView) {\n\t  var sourceBBox = getSourceBBox$1(linkView, opt);\n\t  var targetBBox = getTargetBBox$1(linkView, opt);\n\t  var sourceAnchor = getSourceAnchor$1(linkView, opt);\n\t  var targetAnchor = getTargetAnchor$1(linkView, opt);\n\n\t  // if anchor lies outside of bbox, the bbox expands to include it\n\t  sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n\t  targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\t  vertices = toArray$1(vertices).map(Point);\n\t  vertices.unshift(sourceAnchor);\n\t  vertices.push(targetAnchor);\n\t  var bearing; // bearing of previous route segment\n\n\t  var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n\t  for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\t    var route = null;\n\t    var from = vertices[i];\n\t    var to = vertices[i + 1];\n\t    var isOrthogonal = !!getBearing(from, to);\n\t    if (i === 0) {\n\t      // source\n\n\t      if (i + 1 === max) {\n\t        // route source -> target\n\n\t        // Expand one of the elements by 1px to detect situations when the two\n\t        // elements are positioned next to each other with no gap in between.\n\t        if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n\t          route = insideElement(from, to, sourceBBox, targetBBox);\n\t        } else if (!isOrthogonal) {\n\t          route = elementElement(from, to, sourceBBox, targetBBox);\n\t        }\n\t      } else {\n\t        // route source -> vertex\n\n\t        if (sourceBBox.containsPoint(to)) {\n\t          route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\t        } else if (!isOrthogonal) {\n\t          route = elementVertex(from, to, sourceBBox);\n\t        }\n\t      }\n\t    } else if (i + 1 === max) {\n\t      // route vertex -> target\n\n\t      // prevent overlaps with previous line segment\n\t      var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\t      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n\t        route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\t      } else if (!isOrthogonal) {\n\t        route = vertexElement(from, to, targetBBox, bearing);\n\t      }\n\t    } else if (!isOrthogonal) {\n\t      // route vertex -> vertex\n\t      route = vertexVertex(from, to, bearing);\n\t    }\n\n\t    // applicable to all routes:\n\n\t    // set bearing for next iteration\n\t    if (route) {\n\t      Array.prototype.push.apply(orthogonalVertices, route.points);\n\t      bearing = route.direction;\n\t    } else {\n\t      // orthogonal route and not looped\n\t      bearing = getBearing(from, to);\n\t    }\n\n\t    // push `to` point to identified orthogonal vertices array\n\t    if (i + 1 < max) {\n\t      orthogonalVertices.push(to);\n\t    }\n\t  }\n\t  return orthogonalVertices;\n\t}\n\n\tvar config$1 = {\n\t  // size of the step to find a route (the grid of the manhattan pathfinder)\n\t  step: 10,\n\t  // the number of route finding loops that cause the router to abort\n\t  // returns fallback route instead\n\t  maximumLoops: 2000,\n\t  // the number of decimal places to round floating point coordinates\n\t  precision: 1,\n\t  // maximum change of direction\n\t  maxAllowedDirectionChange: 90,\n\t  // should the router use perpendicular linkView option?\n\t  // does not connect anchor of element but rather a point close-by that is orthogonal\n\t  // this looks much better\n\t  perpendicular: true,\n\t  // should the source and/or target not be considered as obstacles?\n\t  excludeEnds: [],\n\t  // 'source', 'target'\n\n\t  // should certain types of elements not be considered as obstacles?\n\t  excludeTypes: [],\n\t  // possible starting directions from an element\n\t  startDirections: ['top', 'right', 'bottom', 'left'],\n\t  // possible ending directions to an element\n\t  endDirections: ['top', 'right', 'bottom', 'left'],\n\t  // specify the directions used above and what they mean\n\t  directionMap: {\n\t    top: {\n\t      x: 0,\n\t      y: -1\n\t    },\n\t    right: {\n\t      x: 1,\n\t      y: 0\n\t    },\n\t    bottom: {\n\t      x: 0,\n\t      y: 1\n\t    },\n\t    left: {\n\t      x: -1,\n\t      y: 0\n\t    }\n\t  },\n\t  // cost of an orthogonal step\n\t  cost: function () {\n\t    return this.step;\n\t  },\n\t  // an array of directions to find next points on the route\n\t  // different from start/end directions\n\t  directions: function () {\n\t    var step = this.step;\n\t    var cost = this.cost();\n\t    return [{\n\t      offsetX: step,\n\t      offsetY: 0,\n\t      cost: cost\n\t    }, {\n\t      offsetX: -step,\n\t      offsetY: 0,\n\t      cost: cost\n\t    }, {\n\t      offsetX: 0,\n\t      offsetY: step,\n\t      cost: cost\n\t    }, {\n\t      offsetX: 0,\n\t      offsetY: -step,\n\t      cost: cost\n\t    }];\n\t  },\n\t  // a penalty received for direction change\n\t  penalties: function () {\n\t    return {\n\t      0: 0,\n\t      45: this.step / 2,\n\t      90: this.step / 2\n\t    };\n\t  },\n\t  // padding applied on the element bounding boxes\n\t  paddingBox: function () {\n\t    var step = this.step;\n\t    return {\n\t      x: -step,\n\t      y: -step,\n\t      width: 2 * step,\n\t      height: 2 * step\n\t    };\n\t  },\n\t  // A function that determines whether a given point is an obstacle or not.\n\t  // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n\t  // (point: dia.Point) => boolean;\n\t  isPointObstacle: null,\n\t  // a router to use when the manhattan router fails\n\t  // (one of the partial routes returns null)\n\t  fallbackRouter: function (vertices, opt, linkView) {\n\t    if (!isFunction(orthogonal)) {\n\t      throw new Error('Manhattan requires the orthogonal router as default fallback.');\n\t    }\n\t    return orthogonal(vertices, assign({}, config$1, opt), linkView);\n\t  },\n\t  /* Deprecated */\n\t  // a simple route used in situations when main routing method fails\n\t  // (exceed max number of loop iterations, inaccessible)\n\t  fallbackRoute: function (from, to, opt) {\n\t    return null; // null result will trigger the fallbackRouter\n\n\t    // left for reference:\n\t    /*// Find an orthogonal route ignoring obstacles.\n\t     var point = ((opt.previousDirAngle || 0) % 180 === 0)\n\t            ? new g.Point(from.x, to.y)\n\t            : new g.Point(to.x, from.y);\n\t     return [point];*/\n\t  },\n\t  // if a function is provided, it's used to route the link while dragging an end\n\t  // i.e. function(from, to, opt) { return []; }\n\t  draggingRoute: null\n\t};\n\n\t// HELPER CLASSES //\n\n\t// Map of obstacles\n\t// Helper structure to identify whether a point lies inside an obstacle.\n\tfunction ObstacleMap(opt) {\n\t  this.map = {};\n\t  this.options = opt;\n\t  // tells how to divide the paper when creating the elements map\n\t  this.mapGridSize = 100;\n\t}\n\tObstacleMap.prototype.build = function (graph, link) {\n\t  var opt = this.options;\n\n\t  // source or target element could be excluded from set of obstacles\n\t  var excludedEnds = toArray$1(opt.excludeEnds).reduce(function (res, item) {\n\t    var end = link.get(item);\n\t    if (end) {\n\t      var cell = graph.getCell(end.id);\n\t      if (cell) {\n\t        res.push(cell);\n\t      }\n\t    }\n\t    return res;\n\t  }, []);\n\n\t  // Exclude any embedded elements from the source and the target element.\n\t  var excludedAncestors = [];\n\t  var source = graph.getCell(link.get('source').id);\n\t  if (source) {\n\t    excludedAncestors = union(excludedAncestors, source.getAncestors().map(function (cell) {\n\t      return cell.id;\n\t    }));\n\t  }\n\t  var target = graph.getCell(link.get('target').id);\n\t  if (target) {\n\t    excludedAncestors = union(excludedAncestors, target.getAncestors().map(function (cell) {\n\t      return cell.id;\n\t    }));\n\t  }\n\n\t  // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n\t  // in any obstacle?) (a simplified grid search).\n\t  // The paper is divided into smaller cells, where each holds information about which\n\t  // elements belong to it. When we query whether a point lies inside an obstacle we\n\t  // don't need to go through all obstacles, we check only those in a particular cell.\n\t  var mapGridSize = this.mapGridSize;\n\t  graph.getElements().reduce(function (map, element) {\n\t    var isExcludedType = toArray$1(opt.excludeTypes).includes(element.get('type'));\n\t    var isExcludedEnd = excludedEnds.find(function (excluded) {\n\t      return excluded.id === element.id;\n\t    });\n\t    var isExcludedAncestor = excludedAncestors.includes(element.id);\n\t    var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n\t    if (!isExcluded) {\n\t      var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\t      var origin = bbox.origin().snapToGrid(mapGridSize);\n\t      var corner = bbox.corner().snapToGrid(mapGridSize);\n\t      for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n\t        for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n\t          var gridKey = x + '@' + y;\n\t          map[gridKey] = map[gridKey] || [];\n\t          map[gridKey].push(bbox);\n\t        }\n\t      }\n\t    }\n\t    return map;\n\t  }, this.map);\n\t  return this;\n\t};\n\tObstacleMap.prototype.isPointAccessible = function (point) {\n\t  var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\t  return toArray$1(this.map[mapKey]).every(function (obstacle) {\n\t    return !obstacle.containsPoint(point);\n\t  });\n\t};\n\n\t// Sorted Set\n\t// Set of items sorted by given value.\n\tfunction SortedSet() {\n\t  this.items = [];\n\t  this.hash = {};\n\t  this.values = {};\n\t  this.OPEN = 1;\n\t  this.CLOSE = 2;\n\t}\n\tSortedSet.prototype.add = function (item, value) {\n\t  if (this.hash[item]) {\n\t    // item removal\n\t    this.items.splice(this.items.indexOf(item), 1);\n\t  } else {\n\t    this.hash[item] = this.OPEN;\n\t  }\n\t  this.values[item] = value;\n\t  var index = sortedIndex(this.items, item, function (i) {\n\t    return this.values[i];\n\t  }.bind(this));\n\t  this.items.splice(index, 0, item);\n\t};\n\tSortedSet.prototype.remove = function (item) {\n\t  this.hash[item] = this.CLOSE;\n\t};\n\tSortedSet.prototype.isOpen = function (item) {\n\t  return this.hash[item] === this.OPEN;\n\t};\n\tSortedSet.prototype.isClose = function (item) {\n\t  return this.hash[item] === this.CLOSE;\n\t};\n\tSortedSet.prototype.isEmpty = function () {\n\t  return this.items.length === 0;\n\t};\n\tSortedSet.prototype.pop = function () {\n\t  var item = this.items.shift();\n\t  this.remove(item);\n\t  return item;\n\t};\n\n\t// HELPERS //\n\n\t// return source bbox\n\tfunction getSourceBBox(linkView, opt) {\n\t  // expand by padding box\n\t  if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\t  return linkView.sourceBBox.clone();\n\t}\n\n\t// return target bbox\n\tfunction getTargetBBox(linkView, opt) {\n\t  // expand by padding box\n\t  if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\t  return linkView.targetBBox.clone();\n\t}\n\n\t// return source anchor\n\tfunction getSourceAnchor(linkView, opt) {\n\t  if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n\t  // fallback: center of bbox\n\t  var sourceBBox = getSourceBBox(linkView, opt);\n\t  return sourceBBox.center();\n\t}\n\n\t// return target anchor\n\tfunction getTargetAnchor(linkView, opt) {\n\t  if (linkView.targetAnchor) return linkView.targetAnchor;\n\n\t  // fallback: center of bbox\n\t  var targetBBox = getTargetBBox(linkView, opt);\n\t  return targetBBox.center(); // default\n\t}\n\n\t// returns a direction index from start point to end point\n\t// corrects for grid deformation between start and end\n\tfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\t  var quadrant = 360 / numDirections;\n\t  var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n\t  var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);\n\t  return quadrant * Math.floor(normalizedAngle / quadrant);\n\t}\n\n\t// helper function for getDirectionAngle()\n\t// corrects for grid deformation\n\t// (if a point is one grid steps away from another in both dimensions,\n\t// it is considered to be 45 degrees away, even if the real angle is different)\n\t// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\n\tfunction fixAngleEnd(start, end, grid, opt) {\n\t  var step = opt.step;\n\t  var diffX = end.x - start.x;\n\t  var diffY = end.y - start.y;\n\t  var gridStepsX = diffX / grid.x;\n\t  var gridStepsY = diffY / grid.y;\n\t  var distanceX = gridStepsX * step;\n\t  var distanceY = gridStepsY * step;\n\t  return new Point(start.x + distanceX, start.y + distanceY);\n\t}\n\n\t// return the change in direction between two direction angles\n\tfunction getDirectionChange(angle1, angle2) {\n\t  var directionChange = Math.abs(angle1 - angle2);\n\t  return directionChange > 180 ? 360 - directionChange : directionChange;\n\t}\n\n\t// fix direction offsets according to current grid\n\tfunction getGridOffsets(directions, grid, opt) {\n\t  var step = opt.step;\n\t  toArray$1(opt.directions).forEach(function (direction) {\n\t    direction.gridOffsetX = direction.offsetX / step * grid.x;\n\t    direction.gridOffsetY = direction.offsetY / step * grid.y;\n\t  });\n\t}\n\n\t// get grid size in x and y dimensions, adapted to source and target positions\n\tfunction getGrid(step, source, target) {\n\t  return {\n\t    source: source.clone(),\n\t    x: getGridDimension(target.x - source.x, step),\n\t    y: getGridDimension(target.y - source.y, step)\n\t  };\n\t}\n\n\t// helper function for getGrid()\n\tfunction getGridDimension(diff, step) {\n\t  // return step if diff = 0\n\t  if (!diff) return step;\n\t  var absDiff = Math.abs(diff);\n\t  var numSteps = Math.round(absDiff / step);\n\n\t  // return absDiff if less than one step apart\n\t  if (!numSteps) return absDiff;\n\n\t  // otherwise, return corrected step\n\t  var roundedDiff = numSteps * step;\n\t  var remainder = absDiff - roundedDiff;\n\t  var stepCorrection = remainder / numSteps;\n\t  return step + stepCorrection;\n\t}\n\n\t// return a clone of point snapped to grid\n\tfunction snapToGrid(point, grid) {\n\t  var source = grid.source;\n\t  var snappedX = snapToGrid$1(point.x - source.x, grid.x) + source.x;\n\t  var snappedY = snapToGrid$1(point.y - source.y, grid.y) + source.y;\n\t  return new Point(snappedX, snappedY);\n\t}\n\n\t// round the point to opt.precision\n\tfunction round(point, precision) {\n\t  return point.round(precision);\n\t}\n\n\t// snap to grid and then round the point\n\tfunction align(point, grid, precision) {\n\t  return round(snapToGrid(point.clone(), grid), precision);\n\t}\n\n\t// return a string representing the point\n\t// string is rounded in both dimensions\n\tfunction getKey(point) {\n\t  return point.clone().toString();\n\t}\n\n\t// return a normalized vector from given point\n\t// used to determine the direction of a difference of two points\n\tfunction normalizePoint(point) {\n\t  return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n\t}\n\n\t// PATHFINDING //\n\n\t// reconstructs a route by concatenating points with their parents\n\tfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\t  var route = [];\n\t  var prevDiff = normalizePoint(to.difference(tailPoint));\n\n\t  // tailPoint is assumed to be aligned already\n\t  var currentKey = getKey(tailPoint);\n\t  var parent = parents[currentKey];\n\t  var point;\n\t  while (parent) {\n\t    // point is assumed to be aligned already\n\t    point = points[currentKey];\n\t    var diff = normalizePoint(point.difference(parent));\n\t    if (!diff.equals(prevDiff)) {\n\t      route.unshift(point);\n\t      prevDiff = diff;\n\t    }\n\n\t    // parent is assumed to be aligned already\n\t    currentKey = getKey(parent);\n\t    parent = parents[currentKey];\n\t  }\n\n\t  // leadPoint is assumed to be aligned already\n\t  var leadPoint = points[currentKey];\n\t  var fromDiff = normalizePoint(leadPoint.difference(from));\n\t  if (!fromDiff.equals(prevDiff)) {\n\t    route.unshift(leadPoint);\n\t  }\n\t  return route;\n\t}\n\n\t// heuristic method to determine the distance between two points\n\tfunction estimateCost(from, endPoints) {\n\t  var min = Infinity;\n\t  for (var i = 0, len = endPoints.length; i < len; i++) {\n\t    var cost = from.manhattanDistance(endPoints[i]);\n\t    if (cost < min) min = cost;\n\t  }\n\t  return min;\n\t}\n\n\t// find points around the bbox taking given directions into account\n\t// lines are drawn from anchor in given directions, intersections recorded\n\t// if anchor is outside bbox, only those directions that intersect get a rect point\n\t// the anchor itself is returned as rect point (representing some directions)\n\t// (since those directions are unobstructed by the bbox)\n\tfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\t  var precision = opt.precision;\n\t  var directionMap = opt.directionMap;\n\t  var anchorCenterVector = anchor.difference(bbox.center());\n\t  var keys = isObject(directionMap) ? Object.keys(directionMap) : [];\n\t  var dirList = toArray$1(directionList);\n\t  var rectPoints = keys.reduce(function (res, key) {\n\t    if (dirList.includes(key)) {\n\t      var direction = directionMap[key];\n\n\t      // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n\t      // even if anchor lies outside of bbox\n\t      var endpoint = new Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));\n\t      var intersectionLine = new Line(anchor, endpoint);\n\n\t      // get the farther intersection, in case there are two\n\t      // (that happens if anchor lies next to bbox)\n\t      var intersections = intersectionLine.intersect(bbox) || [];\n\t      var numIntersections = intersections.length;\n\t      var farthestIntersectionDistance;\n\t      var farthestIntersection = null;\n\t      for (var i = 0; i < numIntersections; i++) {\n\t        var currentIntersection = intersections[i];\n\t        var distance = anchor.squaredDistance(currentIntersection);\n\t        if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {\n\t          farthestIntersectionDistance = distance;\n\t          farthestIntersection = currentIntersection;\n\t        }\n\t      }\n\n\t      // if an intersection was found in this direction, it is our rectPoint\n\t      if (farthestIntersection) {\n\t        var point = align(farthestIntersection, grid, precision);\n\n\t        // if the rectPoint lies inside the bbox, offset it by one more step\n\t        if (bbox.containsPoint(point)) {\n\t          point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n\t        }\n\n\t        // then add the point to the result array\n\t        // aligned\n\t        res.push(point);\n\t      }\n\t    }\n\t    return res;\n\t  }, []);\n\n\t  // if anchor lies outside of bbox, add it to the array of points\n\t  if (!bbox.containsPoint(anchor)) {\n\t    // aligned\n\t    rectPoints.push(align(anchor, grid, precision));\n\t  }\n\t  return rectPoints;\n\t}\n\n\t// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n\t// rectangles get rect points assigned by getRectPoints()\n\tfunction findRoute(from, to, isPointObstacle, opt) {\n\t  var precision = opt.precision;\n\n\t  // Get grid for this route.\n\n\t  var sourceAnchor, targetAnchor;\n\t  if (from instanceof Rect) {\n\t    // `from` is sourceBBox\n\t    sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n\t  } else {\n\t    sourceAnchor = round(from.clone(), precision);\n\t  }\n\t  if (to instanceof Rect) {\n\t    // `to` is targetBBox\n\t    targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n\t  } else {\n\t    targetAnchor = round(to.clone(), precision);\n\t  }\n\t  var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n\t  // Get pathfinding points.\n\n\t  var start, end; // aligned with grid by definition\n\t  var startPoints, endPoints; // assumed to be aligned with grid already\n\n\t  // set of points we start pathfinding from\n\t  if (from instanceof Rect) {\n\t    // `from` is sourceBBox\n\t    start = sourceAnchor;\n\t    startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\t  } else {\n\t    start = sourceAnchor;\n\t    startPoints = [start];\n\t  }\n\n\t  // set of points we want the pathfinding to finish at\n\t  if (to instanceof Rect) {\n\t    // `to` is targetBBox\n\t    end = targetAnchor;\n\t    endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\t  } else {\n\t    end = targetAnchor;\n\t    endPoints = [end];\n\t  }\n\n\t  // take into account only accessible rect points (those not under obstacles)\n\t  startPoints = startPoints.filter(p => !isPointObstacle(p));\n\t  endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n\t  // Check that there is an accessible route point on both sides.\n\t  // Otherwise, use fallbackRoute().\n\t  if (startPoints.length > 0 && endPoints.length > 0) {\n\t    // The set of tentative points to be evaluated, initially containing the start points.\n\t    // Rounded to nearest integer for simplicity.\n\t    var openSet = new SortedSet();\n\t    // Keeps reference to actual points for given elements of the open set.\n\t    var points = {};\n\t    // Keeps reference to a point that is immediate predecessor of given element.\n\t    var parents = {};\n\t    // Cost from start to a point along best known path.\n\t    var costs = {};\n\t    for (var i = 0, n = startPoints.length; i < n; i++) {\n\t      // startPoint is assumed to be aligned already\n\t      var startPoint = startPoints[i];\n\t      var key = getKey(startPoint);\n\t      openSet.add(key, estimateCost(startPoint, endPoints));\n\t      points[key] = startPoint;\n\t      costs[key] = 0;\n\t    }\n\t    var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n\t    var isPathBeginning = previousRouteDirectionAngle === undefined;\n\n\t    // directions\n\t    var direction, directionChange;\n\t    var directions = opt.directions;\n\t    getGridOffsets(directions, grid, opt);\n\t    var numDirections = directions.length;\n\t    var endPointsKeys = toArray$1(endPoints).reduce(function (res, endPoint) {\n\t      // endPoint is assumed to be aligned already\n\n\t      var key = getKey(endPoint);\n\t      res.push(key);\n\t      return res;\n\t    }, []);\n\n\t    // main route finding loop\n\t    var loopsRemaining = opt.maximumLoops;\n\t    while (!openSet.isEmpty() && loopsRemaining > 0) {\n\t      // remove current from the open list\n\t      var currentKey = openSet.pop();\n\t      var currentPoint = points[currentKey];\n\t      var currentParent = parents[currentKey];\n\t      var currentCost = costs[currentKey];\n\t      var isRouteBeginning = currentParent === undefined; // undefined for route starts\n\t      var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n\t      var previousDirectionAngle;\n\t      if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n\t      else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n\t      else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n\t      else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n\t      // check if we reached any endpoint\n\t      var samePoints = startPoints.length === endPoints.length;\n\t      if (samePoints) {\n\t        for (var j = 0; j < startPoints.length; j++) {\n\t          if (!startPoints[j].equals(endPoints[j])) {\n\t            samePoints = false;\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      var skipEndCheck = isRouteBeginning && samePoints;\n\t      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n\t        opt.previousDirectionAngle = previousDirectionAngle;\n\t        return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n\t      }\n\n\t      // go over all possible directions and find neighbors\n\t      for (i = 0; i < numDirections; i++) {\n\t        direction = directions[i];\n\t        var directionAngle = direction.angle;\n\t        directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n\t        // if the direction changed rapidly, don't use this point\n\t        // any direction is allowed for starting points\n\t        if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\t        var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n\t        var neighborKey = getKey(neighborPoint);\n\n\t        // Closed points from the openSet were already evaluated.\n\t        if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n\t        // We can only enter end points at an acceptable angle.\n\t        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n\t          // neighbor is an end point\n\n\t          var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n\t          if (!isNeighborEnd) {\n\t            var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n\t            var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\t            if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n\t          }\n\t        }\n\n\t        // The current direction is ok.\n\n\t        var neighborCost = direction.cost;\n\t        var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n\t        var costFromStart = currentCost + neighborCost + neighborPenalty;\n\t        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n\t          // neighbor point has not been processed yet\n\t          // or the cost of the path from start is lower than previously calculated\n\n\t          points[neighborKey] = neighborPoint;\n\t          parents[neighborKey] = currentPoint;\n\t          costs[neighborKey] = costFromStart;\n\t          openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n\t        }\n\t      }\n\t      loopsRemaining--;\n\t    }\n\t  }\n\n\t  // no route found (`to` point either wasn't accessible or finding route took\n\t  // way too much calculation)\n\t  return opt.fallbackRoute.call(this, start, end, opt);\n\t}\n\n\t// resolve some of the options\n\tfunction resolveOptions(opt) {\n\t  opt.directions = result(opt, 'directions');\n\t  opt.penalties = result(opt, 'penalties');\n\t  opt.paddingBox = result(opt, 'paddingBox');\n\t  opt.padding = result(opt, 'padding');\n\t  if (opt.padding) {\n\t    // if both provided, opt.padding wins over opt.paddingBox\n\t    var sides = normalizeSides(opt.padding);\n\t    opt.paddingBox = {\n\t      x: -sides.left,\n\t      y: -sides.top,\n\t      width: sides.left + sides.right,\n\t      height: sides.top + sides.bottom\n\t    };\n\t  }\n\t  toArray$1(opt.directions).forEach(function (direction) {\n\t    var point1 = new Point(0, 0);\n\t    var point2 = new Point(direction.offsetX, direction.offsetY);\n\t    direction.angle = normalizeAngle(point1.theta(point2));\n\t  });\n\t}\n\n\t// initialization of the route finding\n\tfunction router(vertices, opt, linkView) {\n\t  resolveOptions(opt);\n\n\t  // enable/disable linkView perpendicular option\n\t  linkView.options.perpendicular = !!opt.perpendicular;\n\t  var sourceBBox = getSourceBBox(linkView, opt);\n\t  var targetBBox = getTargetBBox(linkView, opt);\n\t  var sourceAnchor = getSourceAnchor(linkView, opt);\n\t  //var targetAnchor = getTargetAnchor(linkView, opt);\n\n\t  // pathfinding\n\t  let isPointObstacle;\n\t  if (typeof opt.isPointObstacle === 'function') {\n\t    isPointObstacle = opt.isPointObstacle;\n\t  } else {\n\t    const map = new ObstacleMap(opt);\n\t    map.build(linkView.paper.model, linkView.model);\n\t    isPointObstacle = point => !map.isPointAccessible(point);\n\t  }\n\t  var oldVertices = toArray$1(vertices).map(Point);\n\t  var newVertices = [];\n\t  var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n\t  // find a route by concatenating all partial routes (routes need to pass through vertices)\n\t  // source -> vertex[1] -> ... -> vertex[n] -> target\n\t  var to, from;\n\t  for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\t    var partialRoute = null;\n\t    from = to || sourceBBox;\n\t    to = oldVertices[i];\n\t    if (!to) {\n\t      // this is the last iteration\n\t      // we ran through all vertices in oldVertices\n\t      // 'to' is not a vertex.\n\n\t      to = targetBBox;\n\n\t      // If the target is a point (i.e. it's not an element), we\n\t      // should use dragging route instead of main routing method if it has been provided.\n\t      var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\t      if (isEndingAtPoint && isFunction(opt.draggingRoute)) {\n\t        // Make sure we are passing points only (not rects).\n\t        var dragFrom = from === sourceBBox ? sourceAnchor : from;\n\t        var dragTo = to.origin();\n\t        partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n\t      }\n\t    }\n\n\t    // if partial route has not been calculated yet use the main routing method to find one\n\t    partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\t    if (partialRoute === null) {\n\t      // the partial route cannot be found\n\t      return opt.fallbackRouter(vertices, opt, linkView);\n\t    }\n\t    var leadPoint = partialRoute[0];\n\n\t    // remove the first point if the previous partial route had the same point as last\n\t    if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n\t    // save tailPoint for next iteration\n\t    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\t    Array.prototype.push.apply(newVertices, partialRoute);\n\t  }\n\t  return newVertices;\n\t}\n\n\t// public function\n\tconst manhattan = function (vertices, opt, linkView) {\n\t  return router(vertices, assign({}, config$1, opt), linkView);\n\t};\n\n\tvar config = {\n\t  maxAllowedDirectionChange: 45,\n\t  // cost of a diagonal step\n\t  diagonalCost: function () {\n\t    var step = this.step;\n\t    return Math.ceil(Math.sqrt(step * step << 1));\n\t  },\n\t  // an array of directions to find next points on the route\n\t  // different from start/end directions\n\t  directions: function () {\n\t    var step = this.step;\n\t    var cost = this.cost();\n\t    var diagonalCost = this.diagonalCost();\n\t    return [{\n\t      offsetX: step,\n\t      offsetY: 0,\n\t      cost: cost\n\t    }, {\n\t      offsetX: step,\n\t      offsetY: step,\n\t      cost: diagonalCost\n\t    }, {\n\t      offsetX: 0,\n\t      offsetY: step,\n\t      cost: cost\n\t    }, {\n\t      offsetX: -step,\n\t      offsetY: step,\n\t      cost: diagonalCost\n\t    }, {\n\t      offsetX: -step,\n\t      offsetY: 0,\n\t      cost: cost\n\t    }, {\n\t      offsetX: -step,\n\t      offsetY: -step,\n\t      cost: diagonalCost\n\t    }, {\n\t      offsetX: 0,\n\t      offsetY: -step,\n\t      cost: cost\n\t    }, {\n\t      offsetX: step,\n\t      offsetY: -step,\n\t      cost: diagonalCost\n\t    }];\n\t  },\n\t  // a simple route used in situations when main routing method fails\n\t  // (exceed max number of loop iterations, inaccessible)\n\t  fallbackRoute: function (from, to, opt) {\n\t    // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n\t    var theta = from.theta(to);\n\t    var route = [];\n\t    var a = {\n\t      x: to.x,\n\t      y: from.y\n\t    };\n\t    var b = {\n\t      x: from.x,\n\t      y: to.y\n\t    };\n\t    if (theta % 180 > 90) {\n\t      var t = a;\n\t      a = b;\n\t      b = t;\n\t    }\n\t    var p1 = theta % 90 < 45 ? a : b;\n\t    var l1 = new Line(from, p1);\n\t    var alpha = 90 * Math.ceil(theta / 90);\n\t    var p2 = Point.fromPolar(l1.squaredLength(), toRad(alpha + 135), p1);\n\t    var l2 = new Line(to, p2);\n\t    var intersectionPoint = l1.intersection(l2);\n\t    var point = intersectionPoint ? intersectionPoint : to;\n\t    var directionFrom = intersectionPoint ? point : from;\n\t    var quadrant = 360 / opt.directions.length;\n\t    var angleTheta = directionFrom.theta(to);\n\t    var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);\n\t    var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\t    opt.previousDirectionAngle = directionAngle;\n\t    if (point) route.push(point.round());\n\t    route.push(to);\n\t    return route;\n\t  }\n\t};\n\n\t// public function\n\tconst metro = function (vertices, opt, linkView) {\n\t  if (!isFunction(manhattan)) {\n\t    throw new Error('Metro requires the manhattan router.');\n\t  }\n\t  return manhattan(vertices, assign({}, config, opt), linkView);\n\t};\n\n\tconst Directions = {\n\t  AUTO: 'auto',\n\t  LEFT: 'left',\n\t  RIGHT: 'right',\n\t  TOP: 'top',\n\t  BOTTOM: 'bottom',\n\t  ANCHOR_SIDE: 'anchor-side',\n\t  MAGNET_SIDE: 'magnet-side'\n\t};\n\tconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\tconst OPPOSITE_DIRECTIONS = {\n\t  [Directions.LEFT]: Directions.RIGHT,\n\t  [Directions.RIGHT]: Directions.LEFT,\n\t  [Directions.TOP]: Directions.BOTTOM,\n\t  [Directions.BOTTOM]: Directions.TOP\n\t};\n\tconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\n\tconst ANGLE_DIRECTION_MAP = {\n\t  0: Directions.RIGHT,\n\t  180: Directions.LEFT,\n\t  270: Directions.TOP,\n\t  90: Directions.BOTTOM\n\t};\n\tfunction getSegmentAngle(line) {\n\t  // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n\t  return line.angle();\n\t}\n\tfunction simplifyPoints(points) {\n\t  // TODO: use own more efficient implementation (filter points that do not change direction).\n\t  // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n\t  return new Polyline$1(points).simplify({\n\t    threshold: 1\n\t  }).points;\n\t}\n\tfunction resolveSides(source, target) {\n\t  const {\n\t    point: sourcePoint,\n\t    x0: sx0,\n\t    y0: sy0,\n\t    view: sourceView,\n\t    bbox: sourceBBox,\n\t    direction: sourceDirection\n\t  } = source;\n\t  const {\n\t    point: targetPoint,\n\t    x0: tx0,\n\t    y0: ty0,\n\t    view: targetView,\n\t    bbox: targetBBox,\n\t    direction: targetDirection\n\t  } = target;\n\t  let sourceSide;\n\t  if (!sourceView) {\n\t    const sourceLinkAnchorBBox = new Rect(sx0, sy0, 0, 0);\n\t    sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n\t  } else if (sourceView.model.isLink()) {\n\t    sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n\t  } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n\t    sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n\t  } else if (sourceDirection === Directions.MAGNET_SIDE) {\n\t    sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n\t  } else {\n\t    sourceSide = sourceDirection;\n\t  }\n\t  let targetSide;\n\t  if (!targetView) {\n\t    const targetLinkAnchorBBox = new Rect(tx0, ty0, 0, 0);\n\t    targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n\t  } else if (targetView.model.isLink()) {\n\t    targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n\t  } else if (targetDirection === Directions.ANCHOR_SIDE) {\n\t    targetSide = targetBBox.sideNearestToPoint(targetPoint);\n\t  } else if (targetDirection === Directions.MAGNET_SIDE) {\n\t    targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n\t  } else {\n\t    targetSide = targetDirection;\n\t  }\n\t  return [sourceSide, targetSide];\n\t}\n\tfunction resolveForTopSourceSide(source, target, nextInLine) {\n\t  const {\n\t    x0: sx0,\n\t    y0: sy0,\n\t    width,\n\t    height,\n\t    point: anchor,\n\t    margin\n\t  } = source;\n\t  const sx1 = sx0 + width;\n\t  const sy1 = sy0 + height;\n\t  const smx0 = sx0 - margin;\n\t  const smx1 = sx1 + margin;\n\t  const smy0 = sy0 - margin;\n\t  const {\n\t    x: ax\n\t  } = anchor;\n\t  const {\n\t    x0: tx,\n\t    y0: ty\n\t  } = target;\n\t  if (tx === ax && ty < sy0) return Directions.BOTTOM;\n\t  if (tx < ax && ty < smy0) {\n\t    if (nextInLine.point.x === ax) return Directions.BOTTOM;\n\t    return Directions.RIGHT;\n\t  }\n\t  if (tx > ax && ty < smy0) {\n\t    if (nextInLine.point.x === ax) return Directions.BOTTOM;\n\t    return Directions.LEFT;\n\t  }\n\t  if (tx < smx0 && ty > smy0) return Directions.TOP;\n\t  if (tx > smx1 && ty > smy0) return Directions.TOP;\n\t  if (tx >= smx0 && tx <= ax && ty > sy1) {\n\t    if (nextInLine.point.x < tx) {\n\t      return Directions.RIGHT;\n\t    }\n\t    return Directions.LEFT;\n\t  }\n\t  if (tx <= smx1 && tx >= ax && ty > sy1) {\n\t    if (nextInLine.point.x < tx) {\n\t      return Directions.RIGHT;\n\t    }\n\t    return Directions.LEFT;\n\t  }\n\t  return Directions.BOTTOM;\n\t}\n\tfunction resolveForBottomSourceSide(source, target, nextInLine) {\n\t  const {\n\t    x0: sx0,\n\t    y0: sy0,\n\t    width,\n\t    height,\n\t    point: anchor,\n\t    margin\n\t  } = source;\n\t  const sx1 = sx0 + width;\n\t  const sy1 = sy0 + height;\n\t  const smx0 = sx0 - margin;\n\t  const smx1 = sx1 + margin;\n\t  const smy1 = sy1 + margin;\n\t  const {\n\t    x: ax\n\t  } = anchor;\n\t  const {\n\t    x0: tx,\n\t    y0: ty\n\t  } = target;\n\t  if (tx === ax && ty > sy1) return Directions.TOP;\n\t  if (tx < ax && ty > smy1) {\n\t    if (nextInLine.point.x === ax) return Directions.TOP;\n\t    return Directions.RIGHT;\n\t  }\n\t  if (tx > ax && ty > smy1) {\n\t    if (nextInLine.point.x === ax) return Directions.TOP;\n\t    return Directions.LEFT;\n\t  }\n\t  if (tx < smx0 && ty < smy1) return Directions.BOTTOM;\n\t  if (tx > smx1 && ty < smy1) return Directions.BOTTOM;\n\t  if (tx >= smx0 && tx <= ax && ty < sy0) {\n\t    if (nextInLine.point.x < tx) {\n\t      return Directions.RIGHT;\n\t    }\n\t    return Directions.LEFT;\n\t  }\n\t  if (tx <= smx1 && tx >= ax && ty < sy0) {\n\t    if (nextInLine.point.x < tx) {\n\t      return Directions.RIGHT;\n\t    }\n\t    return Directions.LEFT;\n\t  }\n\t  return Directions.TOP;\n\t}\n\tfunction resolveForLeftSourceSide(source, target, nextInLine) {\n\t  const {\n\t    y0: sy0,\n\t    x0: sx0,\n\t    width,\n\t    height,\n\t    point: anchor,\n\t    margin\n\t  } = source;\n\t  const sx1 = sx0 + width;\n\t  const sy1 = sy0 + height;\n\t  const smx0 = sx0 - margin;\n\t  const smy0 = sy0 - margin;\n\t  const smy1 = sy1 + margin;\n\t  const {\n\t    x: ax,\n\t    y: ay\n\t  } = anchor;\n\t  const {\n\t    x0: tx,\n\t    y0: ty\n\t  } = target;\n\t  if (tx < ax && ty === ay) return Directions.RIGHT;\n\t  if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n\t  if (tx <= smx0 && ty > ay) return Directions.TOP;\n\t  if (tx >= smx0 && ty < smy0) return Directions.LEFT;\n\t  if (tx >= smx0 && ty > smy1) return Directions.LEFT;\n\t  if (tx > sx1 && ty >= smy0 && ty <= ay) {\n\t    if (nextInLine.point.y < ty) {\n\t      return Directions.BOTTOM;\n\t    }\n\t    return Directions.TOP;\n\t  }\n\t  if (tx > sx1 && ty <= smy1 && ty >= ay) {\n\t    if (nextInLine.point.y < ty) {\n\t      return Directions.BOTTOM;\n\t    }\n\t    return Directions.TOP;\n\t  }\n\t  return Directions.RIGHT;\n\t}\n\tfunction resolveForRightSourceSide(source, target, nextInLine) {\n\t  const {\n\t    y0: sy0,\n\t    x0: sx0,\n\t    width,\n\t    height,\n\t    point: anchor,\n\t    margin\n\t  } = source;\n\t  const sx1 = sx0 + width;\n\t  const sy1 = sy0 + height;\n\t  const smx1 = sx1 + margin;\n\t  const smy0 = sy0 - margin;\n\t  const smy1 = sy1 + margin;\n\t  const {\n\t    x: ax,\n\t    y: ay\n\t  } = anchor;\n\t  const {\n\t    x0: tx,\n\t    y0: ty\n\t  } = target;\n\t  if (tx > ax && ty === ay) return Directions.LEFT;\n\t  if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n\t  if (tx >= smx1 && ty > ay) return Directions.TOP;\n\t  if (tx <= smx1 && ty < smy0) return Directions.RIGHT;\n\t  if (tx <= smx1 && ty > smy1) return Directions.RIGHT;\n\t  if (tx < sx0 && ty >= smy0 && ty <= ay) {\n\t    if (nextInLine.point.y < ty) {\n\t      return Directions.BOTTOM;\n\t    }\n\t    return Directions.TOP;\n\t  }\n\t  if (tx < sx0 && ty <= smy1 && ty >= ay) {\n\t    if (nextInLine.point.y < ty) {\n\t      return Directions.BOTTOM;\n\t    }\n\t    return Directions.TOP;\n\t  }\n\t  return Directions.LEFT;\n\t}\n\tfunction resolveInitialDirection(source, target, nextInLine) {\n\t  const [sourceSide] = resolveSides(source, target);\n\t  switch (sourceSide) {\n\t    case Directions.TOP:\n\t      return resolveForTopSourceSide(source, target, nextInLine);\n\t    case Directions.RIGHT:\n\t      return resolveForRightSourceSide(source, target, nextInLine);\n\t    case Directions.BOTTOM:\n\t      return resolveForBottomSourceSide(source, target, nextInLine);\n\t    case Directions.LEFT:\n\t      return resolveForLeftSourceSide(source, target, nextInLine);\n\t  }\n\t}\n\tfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n\t  const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n\t  const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n\t  if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n\t    return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n\t  } else if (linkOrigin.x === connectionPoint.x) {\n\t    return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n\t  }\n\t  switch (roundedAngle) {\n\t    case 0:\n\t    case 180:\n\t    case 360:\n\t      return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n\t    case 90:\n\t    case 270:\n\t      return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n\t  }\n\t}\n\tfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n\t  if (direction === Directions.AUTO) {\n\t    direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n\t  }\n\t  const isElement = view && view.model.isElement();\n\t  const {\n\t    x: x0,\n\t    y: y0,\n\t    width = 0,\n\t    height = 0\n\t  } = isElement ? Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n\t  return {\n\t    point,\n\t    x0,\n\t    y0,\n\t    view,\n\t    bbox,\n\t    width,\n\t    height,\n\t    direction,\n\t    margin: isElement ? margin : 0\n\t  };\n\t}\n\tfunction pointDataFromVertex({\n\t  x,\n\t  y\n\t}) {\n\t  const point = new Point(x, y);\n\t  return {\n\t    point,\n\t    x0: point.x,\n\t    y0: point.y,\n\t    view: null,\n\t    bbox: new Rect(x, y, 0, 0),\n\t    width: 0,\n\t    height: 0,\n\t    direction: null,\n\t    margin: 0\n\t  };\n\t}\n\tfunction getOutsidePoint(side, pointData, margin) {\n\t  const outsidePoint = pointData.point.clone();\n\t  const {\n\t    x0,\n\t    y0,\n\t    width,\n\t    height\n\t  } = pointData;\n\t  switch (side) {\n\t    case 'left':\n\t      outsidePoint.x = x0 - margin;\n\t      break;\n\t    case 'right':\n\t      outsidePoint.x = x0 + width + margin;\n\t      break;\n\t    case 'top':\n\t      outsidePoint.y = y0 - margin;\n\t      break;\n\t    case 'bottom':\n\t      outsidePoint.y = y0 + height + margin;\n\t      break;\n\t  }\n\t  return outsidePoint;\n\t}\n\tfunction createLoop(from, to, {\n\t  dx = 0,\n\t  dy = 0\n\t}) {\n\t  const p1 = {\n\t    x: from.point.x + dx,\n\t    y: from.point.y + dy\n\t  };\n\t  const p2 = {\n\t    x: to.point.x + dx,\n\t    y: to.point.y + dy\n\t  };\n\t  return [from.point, p1, p2, to.point];\n\t}\n\tfunction loopSegment(from, to, connectionSegmentAngle, margin) {\n\t  // Find out the loop coordinates.\n\t  const angle = normalizeAngle(connectionSegmentAngle - 90);\n\t  let dx = 0;\n\t  let dy = 0;\n\t  if (angle === 90) {\n\t    dy = -margin;\n\t  } else if (angle === 180) {\n\t    dx = -margin;\n\t  } else if (angle === 270) {\n\t    dy = margin;\n\t  } else if (angle === 0) {\n\t    dx = margin;\n\t  }\n\t  const loopRoute = createLoop(from, to, {\n\t    dx,\n\t    dy\n\t  });\n\t  const secondCreatedPoint = loopRoute[2];\n\t  const loopEndSegment = new Line(to.point, secondCreatedPoint);\n\t  // The direction in which the loop should continue.\n\t  const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n\t  return {\n\t    loopRoute,\n\t    continueDirection\n\t  };\n\t}\n\n\t// Calculates the distances along the horizontal axis for the left and right route.\n\tfunction getHorizontalDistance(source, target) {\n\t  const {\n\t    x0: sx0,\n\t    x1: sx1,\n\t    outsidePoint: sourcePoint\n\t  } = source;\n\t  const {\n\t    x0: tx0,\n\t    x1: tx1,\n\t    outsidePoint: targetPoint\n\t  } = target;\n\n\t  // Furthest left boundary\n\t  let leftBoundary = Math.min(sx0, tx0);\n\t  // Furthest right boundary\n\t  let rightBoundary = Math.max(sx1, tx1);\n\n\t  // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n\t  if (source.direction === target.direction) {\n\t    const aboveShape = source.y0 < target.y0 ? source : target;\n\t    const belowShape = aboveShape === source ? target : source;\n\n\t    // The source and target anchors are on the top => then the `aboveShape` defines the boundary.\n\t    // The source and target anchors are on the bottom => then the `belowShape` defines the boundary.\n\t    const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;\n\t    leftBoundary = boundaryDefiningShape.x0;\n\t    rightBoundary = boundaryDefiningShape.x1;\n\t  }\n\t  const {\n\t    x: sox\n\t  } = sourcePoint;\n\t  const {\n\t    x: tox\n\t  } = targetPoint;\n\n\t  // Calculate the distances for the left route\n\t  const leftDistance1 = Math.abs(sox - leftBoundary);\n\t  const leftDistance2 = Math.abs(tox - leftBoundary);\n\t  const leftD = leftDistance1 + leftDistance2;\n\n\t  // Calculate the distances for the right route\n\t  const rightDistance1 = Math.abs(sox - rightBoundary);\n\t  const rightDistance2 = Math.abs(tox - rightBoundary);\n\t  const rightD = rightDistance1 + rightDistance2;\n\t  return [leftD, rightD];\n\t}\n\n\t// Calculates the distances along the vertical axis for the top and bottom route.\n\tfunction getVerticalDistance(source, target) {\n\t  const {\n\t    y0: sy0,\n\t    y1: sy1,\n\t    outsidePoint: sourcePoint\n\t  } = source;\n\t  const {\n\t    y0: ty0,\n\t    y1: ty1,\n\t    outsidePoint: targetPoint\n\t  } = target;\n\n\t  // Furthest top boundary\n\t  let topBoundary = Math.min(sy0, ty0);\n\t  // Furthest bottom boundary\n\t  let bottomBoundary = Math.max(sy1, ty1);\n\n\t  // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n\t  if (source.direction === target.direction) {\n\t    const leftShape = source.x0 < target.x0 ? source : target;\n\t    const rightShape = leftShape === source ? target : source;\n\n\t    // The source and target anchors are on the left => then the `leftShape` defines the boundary.\n\t    // The source and target anchors are on the right => then the `rightShape` defines the boundary.\n\t    const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;\n\t    topBoundary = boundaryDefiningShape.y0;\n\t    bottomBoundary = boundaryDefiningShape.y1;\n\t  }\n\t  const {\n\t    y: soy\n\t  } = sourcePoint;\n\t  const {\n\t    y: toy\n\t  } = targetPoint;\n\n\t  // Calculate the distances for the top route\n\t  const topDistance1 = Math.abs(soy - topBoundary);\n\t  const topDistance2 = Math.abs(toy - topBoundary);\n\t  const topD = topDistance1 + topDistance2;\n\n\t  // Calculate the distances for the bottom route\n\t  const bottomDistance1 = Math.abs(soy - bottomBoundary);\n\t  const bottomDistance2 = Math.abs(toy - bottomBoundary);\n\t  const bottomD = bottomDistance1 + bottomDistance2;\n\t  return [topD, bottomD];\n\t}\n\n\t// Inflate bbox in 3 directions depending on the direction of the anchor\n\t// don't inflate in the opposite direction of the anchor\n\tfunction moveAndExpandBBox(bbox, direction, margin) {\n\t  switch (direction) {\n\t    case Directions.LEFT:\n\t      bbox.inflate(0, margin).moveAndExpand({\n\t        x: -margin,\n\t        width: margin\n\t      });\n\t      break;\n\t    case Directions.RIGHT:\n\t      bbox.inflate(0, margin).moveAndExpand({\n\t        width: margin\n\t      });\n\t      break;\n\t    case Directions.TOP:\n\t      bbox.inflate(margin, 0).moveAndExpand({\n\t        y: -margin,\n\t        height: margin\n\t      });\n\t      break;\n\t    case Directions.BOTTOM:\n\t      bbox.inflate(margin, 0).moveAndExpand({\n\t        height: margin\n\t      });\n\t      break;\n\t  }\n\t  return bbox;\n\t}\n\tfunction routeBetweenPoints(source, target, opt = {}) {\n\t  const {\n\t    point: sourcePoint,\n\t    x0: sx0,\n\t    y0: sy0,\n\t    width: sourceWidth,\n\t    height: sourceHeight,\n\t    margin: sourceMargin\n\t  } = source;\n\t  const {\n\t    point: targetPoint,\n\t    x0: tx0,\n\t    y0: ty0,\n\t    width: targetWidth,\n\t    height: targetHeight,\n\t    margin: targetMargin\n\t  } = target;\n\t  const {\n\t    targetInSourceBBox = false\n\t  } = opt;\n\t  const tx1 = tx0 + targetWidth;\n\t  const ty1 = ty0 + targetHeight;\n\t  const sx1 = sx0 + sourceWidth;\n\t  const sy1 = sy0 + sourceHeight;\n\n\t  // Key coordinates including the margin\n\t  const smx0 = sx0 - sourceMargin;\n\t  const smx1 = sx1 + sourceMargin;\n\t  const smy0 = sy0 - sourceMargin;\n\t  const smy1 = sy1 + sourceMargin;\n\t  const tmx0 = tx0 - targetMargin;\n\t  const tmx1 = tx1 + targetMargin;\n\t  const tmy0 = ty0 - targetMargin;\n\t  const tmy1 = ty1 + targetMargin;\n\t  const [sourceSide, targetSide] = resolveSides(source, target);\n\t  const sourceOutsidePoint = getOutsidePoint(sourceSide, {\n\t    point: sourcePoint,\n\t    x0: sx0,\n\t    y0: sy0,\n\t    width: sourceWidth,\n\t    height: sourceHeight\n\t  }, sourceMargin);\n\t  const targetOutsidePoint = getOutsidePoint(targetSide, {\n\t    point: targetPoint,\n\t    x0: tx0,\n\t    y0: ty0,\n\t    width: targetWidth,\n\t    height: targetHeight\n\t  }, targetMargin);\n\t  const {\n\t    x: sox,\n\t    y: soy\n\t  } = sourceOutsidePoint;\n\t  const {\n\t    x: tox,\n\t    y: toy\n\t  } = targetOutsidePoint;\n\t  const tcx = (tx0 + tx1) / 2;\n\t  const tcy = (ty0 + ty1) / 2;\n\t  const scx = (sx0 + sx1) / 2;\n\t  const scy = (sy0 + sy1) / 2;\n\t  const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;\n\t  const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;\n\t  const sourceBBox = new Rect(sx0, sy0, sourceWidth, sourceHeight);\n\t  const targetBBox = new Rect(tx0, ty0, targetWidth, targetHeight);\n\t  const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);\n\t  const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);\n\t  const sourceForDistance = Object.assign({}, source, {\n\t    x1: sx1,\n\t    y1: sy1,\n\t    outsidePoint: sourceOutsidePoint,\n\t    direction: sourceSide\n\t  });\n\t  const targetForDistance = Object.assign({}, target, {\n\t    x1: tx1,\n\t    y1: ty1,\n\t    outsidePoint: targetOutsidePoint,\n\t    direction: targetSide\n\t  });\n\n\t  // Distances used to determine the shortest route along the connections on horizontal sides for\n\t  // bottom => bottom\n\t  // top => bottom\n\t  // bottom => top\n\t  // top => top\n\t  const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);\n\n\t  // Distances used to determine the shortest route along the connection on vertical sides for\n\t  // left => left\n\t  // left => right\n\t  // right => right\n\t  // right => left\n\t  const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);\n\n\t  // All possible combinations of source and target sides\n\t  if (sourceSide === 'left' && targetSide === 'right') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n\t    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n\t    // Use S-shaped connection\n\t    if (isPointInsideSource || isPointInsideTarget) {\n\t      const middleOfAnchors = (soy + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: middleOfAnchors\n\t      }, {\n\t        x: tox,\n\t        y: middleOfAnchors\n\t      }, {\n\t        x: tox,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smx0 < tox) {\n\t      let y = middleOfHorizontalSides;\n\t      let x1 = sox;\n\t      let x2 = tox;\n\t      const isUpwardsShorter = topD < bottomD;\n\n\t      // If the source and target elements overlap, we need to make sure the connection\n\t      // goes around the target element.\n\t      if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {\n\t        if (smy1 >= tmy0 && isUpwardsShorter) {\n\t          y = Math.min(tmy0, smy0);\n\t        } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n\t          y = Math.max(tmy1, smy1);\n\t        }\n\n\t        // This handles the case when the source and target elements overlap as well as\n\t        // the case when the source is to the left of the target element.\n\t        x1 = Math.min(sox, tmx0);\n\t        x2 = Math.max(tox, smx1);\n\n\t        // This is an edge case when the source and target intersect and\n\t        if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {\n\t          // the path should no longer rely on minimal x boundary in `x1`\n\t          x1 = sox;\n\t        } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {\n\t          // the path should no longer rely on maximal x boundary in `x2`\n\t          x2 = tox;\n\t        }\n\t      }\n\t      return [{\n\t        x: x1,\n\t        y: soy\n\t      }, {\n\t        x: x1,\n\t        y\n\t      }, {\n\t        x: x2,\n\t        y\n\t      }, {\n\t        x: x2,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = (sox + tox) / 2;\n\t    return [{\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'right' && targetSide === 'left') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n\t    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n\t    // Use S-shaped connection\n\t    if (isPointInsideSource || isPointInsideTarget) {\n\t      const middleOfAnchors = (soy + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: middleOfAnchors\n\t      }, {\n\t        x: tox,\n\t        y: middleOfAnchors\n\t      }, {\n\t        x: tox,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smx1 > tox) {\n\t      let y = middleOfHorizontalSides;\n\t      let x1 = sox;\n\t      let x2 = tox;\n\t      const isUpwardsShorter = topD < bottomD;\n\n\t      // If the source and target elements overlap, we need to make sure the connection\n\t      // goes around the target element.\n\t      if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {\n\t        if (smy1 >= tmy0 && isUpwardsShorter) {\n\t          y = Math.min(tmy0, smy0);\n\t        } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n\t          y = Math.max(tmy1, smy1);\n\t        }\n\n\t        // This handles the case when the source and target elements overlap as well as\n\t        // the case when the source is to the left of the target element.\n\t        x1 = Math.max(sox, tmx1);\n\t        x2 = Math.min(tox, smx0);\n\n\t        // This is an edge case when the source and target intersect and\n\t        if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {\n\t          // the path should no longer rely on maximal x boundary in `x1`\n\t          x1 = sox;\n\t        } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {\n\t          // the path should no longer rely on minimal x boundary in `x2`\n\t          x2 = tox;\n\t        }\n\t      }\n\t      return [{\n\t        x: x1,\n\t        y: soy\n\t      }, {\n\t        x: x1,\n\t        y\n\t      }, {\n\t        x: x2,\n\t        y\n\t      }, {\n\t        x: x2,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = (sox + tox) / 2;\n\t    return [{\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'top' && targetSide === 'bottom') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n\t    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n\t    // Use S-shaped connection\n\t    if (isPointInsideSource || isPointInsideTarget) {\n\t      const middleOfAnchors = (sox + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: middleOfAnchors,\n\t        y: soy\n\t      }, {\n\t        x: middleOfAnchors,\n\t        y: toy\n\t      }, {\n\t        x: tox,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy0 < toy) {\n\t      let x = middleOfVerticalSides;\n\t      let y1 = soy;\n\t      let y2 = toy;\n\t      const isLeftShorter = leftD < rightD;\n\n\t      // If the source and target elements overlap, we need to make sure the connection\n\t      // goes around the target element.\n\t      if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {\n\t        if (smx1 >= tmx0 && isLeftShorter) {\n\t          x = Math.min(tmx0, smx0);\n\t        } else if (smx0 <= tmx1 && !isLeftShorter) {\n\t          x = Math.max(tmx1, smx1);\n\t        }\n\n\t        // This handles the case when the source and target elements overlap as well as\n\t        // the case when the source is to the left of the target element.\n\t        y1 = Math.min(soy, tmy0);\n\t        y2 = Math.max(toy, smy1);\n\n\t        // This is an edge case when the source and target intersect and\n\t        if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {\n\t          // the path should no longer rely on minimal y boundary in `y1`\n\t          y1 = soy;\n\t        } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {\n\t          // the path should no longer rely on maximal y boundary in `y2`\n\t          y2 = toy;\n\t        }\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: y1\n\t      }, {\n\t        x,\n\t        y: y1\n\t      }, {\n\t        x,\n\t        y: y2\n\t      }, {\n\t        x: tox,\n\t        y: y2\n\t      }];\n\t    }\n\t    const y = (soy + toy) / 2;\n\t    return [{\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'bottom' && targetSide === 'top') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n\t    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n\t    // Use S-shaped connection\n\t    if (isPointInsideSource || isPointInsideTarget) {\n\t      const middleOfAnchors = (sox + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: middleOfAnchors,\n\t        y: soy\n\t      }, {\n\t        x: middleOfAnchors,\n\t        y: toy\n\t      }, {\n\t        x: tox,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy1 > toy) {\n\t      let x = middleOfVerticalSides;\n\t      let y1 = soy;\n\t      let y2 = toy;\n\t      const isLeftShorter = leftD < rightD;\n\n\t      // If the source and target elements overlap, we need to make sure the connection\n\t      // goes around the target element.\n\t      if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {\n\t        if (smx1 >= tmx0 && isLeftShorter) {\n\t          x = Math.min(tmx0, smx0);\n\t        } else if (smx0 <= tmx1 && !isLeftShorter) {\n\t          x = Math.max(tmx1, smx1);\n\t        }\n\n\t        // This handles the case when the source and target elements overlap as well as\n\t        // the case when the source is to the left of the target element.\n\t        y1 = Math.max(soy, tmy1);\n\t        y2 = Math.min(toy, smy0);\n\n\t        // This is an edge case when the source and target intersect and\n\t        if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {\n\t          // the path should no longer rely on maximal y boundary in `y1`\n\t          y1 = soy;\n\t        } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {\n\t          // the path should no longer rely on minimal y boundary in `y2`\n\t          y2 = toy;\n\t        }\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: y1\n\t      }, {\n\t        x,\n\t        y: y1\n\t      }, {\n\t        x,\n\t        y: y2\n\t      }, {\n\t        x: tox,\n\t        y: y2\n\t      }];\n\t    }\n\t    const y = (soy + toy) / 2;\n\t    return [{\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'top' && targetSide === 'top') {\n\t    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox) || soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox);\n\n\t    // U-shape connection is a straight line if `sox` and `tox` are the same\n\t    if (useUShapeConnection && sox !== tox) {\n\t      return [{\n\t        x: sox,\n\t        y: Math.min(soy, toy)\n\t      }, {\n\t        x: tox,\n\t        y: Math.min(soy, toy)\n\t      }];\n\t    }\n\t    let x;\n\t    const y1 = Math.min((sy1 + ty0) / 2, toy);\n\t    const y2 = Math.min((sy0 + ty1) / 2, soy);\n\t    if (toy < soy) {\n\t      // Use the shortest path along the connections on horizontal sides\n\t      if (rightD > leftD) {\n\t        x = Math.min(sox, tmx0);\n\t      } else {\n\t        x = Math.max(sox, tmx1);\n\t      }\n\t    } else {\n\t      if (rightD > leftD) {\n\t        x = Math.min(tox, smx0);\n\t      } else {\n\t        x = Math.max(tox, smx1);\n\t      }\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: y2\n\t    }, {\n\t      x,\n\t      y: y2\n\t    }, {\n\t      x,\n\t      y: y1\n\t    }, {\n\t      x: tox,\n\t      y: y1\n\t    }];\n\t  } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n\t    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox) || soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox);\n\n\t    // U-shape connection is a straight line if `sox` and `tox` are the same\n\t    if (useUShapeConnection && sox !== tox) {\n\t      return [{\n\t        x: sox,\n\t        y: Math.max(soy, toy)\n\t      }, {\n\t        x: tox,\n\t        y: Math.max(soy, toy)\n\t      }];\n\t    }\n\t    let x;\n\t    const y1 = Math.max((sy0 + ty1) / 2, toy);\n\t    const y2 = Math.max((sy1 + ty0) / 2, soy);\n\t    if (toy > soy) {\n\t      // Use the shortest path along the connections on horizontal sides\n\t      if (rightD > leftD) {\n\t        x = Math.min(sox, tmx0);\n\t      } else {\n\t        x = Math.max(sox, tmx1);\n\t      }\n\t    } else {\n\t      if (rightD > leftD) {\n\t        x = Math.min(tox, smx0);\n\t      } else {\n\t        x = Math.max(tox, smx1);\n\t      }\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: y2\n\t    }, {\n\t      x,\n\t      y: y2\n\t    }, {\n\t      x,\n\t      y: y1\n\t    }, {\n\t      x: tox,\n\t      y: y1\n\t    }];\n\t  } else if (sourceSide === 'left' && targetSide === 'left') {\n\t    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy) || sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy);\n\n\t    // U-shape connection is a straight line if `soy` and `toy` are the same\n\t    if (useUShapeConnection && soy !== toy) {\n\t      return [{\n\t        x: Math.min(sox, tox),\n\t        y: soy\n\t      }, {\n\t        x: Math.min(sox, tox),\n\t        y: toy\n\t      }];\n\t    }\n\t    let y;\n\t    const x1 = Math.min((sx1 + tx0) / 2, tox);\n\t    const x2 = Math.min((sx0 + tx1) / 2, sox);\n\t    if (tox > sox) {\n\t      if (topD <= bottomD) {\n\t        y = Math.min(smy0, toy);\n\t      } else {\n\t        y = Math.max(smy1, toy);\n\t      }\n\t    } else {\n\t      if (topD <= bottomD) {\n\t        y = Math.min(tmy0, soy);\n\t      } else {\n\t        y = Math.max(tmy1, soy);\n\t      }\n\t    }\n\t    return [{\n\t      x: x2,\n\t      y: soy\n\t    }, {\n\t      x: x2,\n\t      y\n\t    }, {\n\t      x: x1,\n\t      y\n\t    }, {\n\t      x: x1,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'right' && targetSide === 'right') {\n\t    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy) || sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy);\n\n\t    // U-shape connection is a straight line if `soy` and `toy` are the same\n\t    if (useUShapeConnection && soy !== toy) {\n\t      return [{\n\t        x: Math.max(sox, tox),\n\t        y: soy\n\t      }, {\n\t        x: Math.max(sox, tox),\n\t        y: toy\n\t      }];\n\t    }\n\t    let y;\n\t    const x1 = Math.max((sx0 + tx1) / 2, tox);\n\t    const x2 = Math.max((sx1 + tx0) / 2, sox);\n\t    if (tox <= sox) {\n\t      if (topD <= bottomD) {\n\t        y = Math.min(smy0, toy);\n\t      } else {\n\t        y = Math.max(smy1, toy);\n\t      }\n\t    } else {\n\t      if (topD <= bottomD) {\n\t        y = Math.min(tmy0, soy);\n\t      } else {\n\t        y = Math.max(tmy1, soy);\n\t      }\n\t    }\n\t    return [{\n\t      x: x2,\n\t      y: soy\n\t    }, {\n\t      x: x2,\n\t      y\n\t    }, {\n\t      x: x1,\n\t      y\n\t    }, {\n\t      x: x1,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'top' && targetSide === 'right') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (sox <= tmx1) {\n\t        const x = Math.max(sox + sourceMargin, tox);\n\t        const y = Math.min(smy0, tmy0);\n\n\t        // Target anchor is on the right side of the source anchor\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: x,\n\t          y\n\t        }, {\n\t          x: x,\n\t          y: toy\n\t        }];\n\t      }\n\n\t      // Target anchor is on the left side of the source anchor\n\t      // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n\t      const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy0 > toy) {\n\t      if (sox < tox) {\n\t        let y = tmy0;\n\t        if (tmy1 <= smy0 && tmx1 >= sox) {\n\t          y = middleOfHorizontalSides;\n\t        }\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = Math.max(middleOfVerticalSides, tmx1);\n\t    if (sox > tox && sy1 >= toy) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (x > smx0 && soy < ty1) {\n\t      const y = Math.min(smy0, tmy0);\n\t      const x = Math.max(smx1, tmx1);\n\t      return [{\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'top' && targetSide === 'left') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (sox >= tmx0) {\n\t        const x = Math.min(sox - sourceMargin, tox);\n\t        const y = Math.min(smy0, tmy0);\n\n\t        // Target anchor is on the left side of the source anchor\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: x,\n\t          y\n\t        }, {\n\t          x: x,\n\t          y: toy\n\t        }];\n\t      }\n\n\t      // Target anchor is on the right side of the source anchor\n\t      // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n\t      const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy0 > toy) {\n\t      if (sox > tox) {\n\t        let y = tmy0;\n\t        if (tmy1 <= smy0 && tmx0 <= sox) {\n\t          y = middleOfHorizontalSides;\n\t        }\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = Math.min(tmx0, middleOfVerticalSides);\n\t    if (sox < tox && sy1 >= toy) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (x < smx1 && soy < ty1) {\n\t      const y = Math.min(smy0, tmy0);\n\t      const x = Math.min(smx0, tmx0);\n\t      return [{\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'bottom' && targetSide === 'right') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (sox <= tmx1) {\n\t        const x = Math.max(sox + sourceMargin, tox);\n\t        const y = Math.max(smy1, tmy1);\n\n\t        // Target anchor is on the right side of the source anchor\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }];\n\t      }\n\n\t      // Target anchor is on the left side of the source anchor\n\t      // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n\t      const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy1 < toy) {\n\t      if (sox < tox) {\n\t        let y = tmy1;\n\t        if (tmy0 >= smy1 && tmx1 >= sox) {\n\t          y = middleOfHorizontalSides;\n\t        }\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = Math.max(middleOfVerticalSides, tmx1);\n\t    if (sox > tox && sy0 <= toy) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (x > smx0 && soy > ty0) {\n\t      const y = Math.max(smy1, tmy1);\n\t      const x = Math.max(smx1, tmx1);\n\t      return [{\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'bottom' && targetSide === 'left') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (sox >= tmx0) {\n\t        const x = Math.min(sox - sourceMargin, tox);\n\t        const y = Math.max(smy1, tmy1);\n\n\t        // Target anchor is on the left side of the source anchor\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }];\n\t      }\n\n\t      // Target anchor is on the right side of the source anchor\n\t      // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n\t      const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy1 < toy) {\n\t      if (sox > tox) {\n\t        let y = tmy1;\n\t        if (tmy0 >= smy1 && tmx0 <= sox) {\n\t          y = middleOfHorizontalSides;\n\t        }\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = Math.min(tmx0, middleOfVerticalSides);\n\t    if (sox < tox && sy0 <= toy) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (x < smx1 && soy > ty0) {\n\t      const y = Math.max(smy1, tmy1);\n\t      const x = Math.min(smx0, tmx0);\n\t      return [{\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'left' && targetSide === 'bottom') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (soy <= tmy1) {\n\t        const x = Math.min(smx0, tmx0);\n\t        const y = Math.max(soy + sourceMargin, toy);\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }];\n\t      }\n\n\t      // Target anchor is above the source anchor\n\t      const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: anchorMiddleY\n\t      }, {\n\t        x: tox,\n\t        y: anchorMiddleY\n\t      }];\n\t    }\n\t    if (smx0 > tox) {\n\t      if (soy < toy) {\n\t        let x = tmx0;\n\t        if (tmx1 <= smx0 && tmy1 >= soy) {\n\t          x = middleOfVerticalSides;\n\t        }\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: tox,\n\t        y: soy\n\t      }];\n\t    }\n\t    const y = Math.max(tmy1, middleOfHorizontalSides);\n\t    if (soy > toy && sx1 >= tox) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    if (y > smy0 && sox < tx1) {\n\t      const x = Math.min(smx0, tmx0);\n\t      const y = Math.max(smy1, tmy1);\n\t      return [{\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'left' && targetSide === 'top') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (soy >= tmy0) {\n\t        const y = Math.min(soy - sourceMargin, toy);\n\t        const x = Math.min(smx0, tmx0);\n\n\t        // Target anchor is on the top side of the source anchor\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }];\n\t      }\n\n\t      // Target anchor is below the source anchor\n\t      // Add the `sourceMargin` since the source anchor is above the target anchor\n\t      const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: anchorMiddleY\n\t      }, {\n\t        x: tox,\n\t        y: anchorMiddleY\n\t      }];\n\t    }\n\t    if (smx0 > tox) {\n\t      if (soy > toy) {\n\t        let x = tmx0;\n\t        if (tmx1 <= smx0 && tmy0 <= soy) {\n\t          x = middleOfVerticalSides;\n\t        }\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: tox,\n\t        y: soy\n\t      }];\n\t    }\n\t    const y = Math.min(tmy0, middleOfHorizontalSides);\n\t    if (soy < toy && sx1 >= tox) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    if (y < smy1 && sox < tx1) {\n\t      const x = Math.min(smx0, tmx0);\n\t      const y = Math.min(smy0, tmy0);\n\t      return [{\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'right' && targetSide === 'top') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (soy >= tmy0) {\n\t        const x = Math.max(smx1, tmx1);\n\t        const y = Math.min(soy - sourceMargin, toy);\n\n\t        // Target anchor is on the top side of the source anchor\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y\n\t        },\n\t        // Path adjustment for right side start\n\t        {\n\t          x: tox,\n\t          y\n\t        }];\n\t      }\n\n\t      // Target anchor is below the source anchor\n\t      // Adjust sourceMargin calculation since the source anchor is now on the right\n\t      const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: anchorMiddleY\n\t      }, {\n\t        x: tox,\n\t        y: anchorMiddleY\n\t      }];\n\t    }\n\t    if (smx1 < tox) {\n\t      if (soy > toy) {\n\t        let x = tmx1;\n\t        if (tmx0 >= smx1 && tmy0 <= soy) {\n\t          x = middleOfVerticalSides;\n\t        }\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: tox,\n\t        y: soy\n\t      }];\n\t    }\n\t    const y = Math.min(tmy0, middleOfHorizontalSides);\n\t    if (soy < toy && sx0 <= tox) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    if (y < smy1 && sox > tx0) {\n\t      const x = Math.max(smx1, tmx1);\n\t      const y = Math.min(smy0, tmy0);\n\t      return [{\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'right' && targetSide === 'bottom') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (soy <= tmy1) {\n\t        const x = Math.max(smx1, tmx1);\n\t        const y = Math.max(soy + sourceMargin, toy);\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }];\n\t      }\n\n\t      // Target anchor is above the source anchor\n\t      const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: anchorMiddleY\n\t      }, {\n\t        x: tox,\n\t        y: anchorMiddleY\n\t      }];\n\t    }\n\t    if (smx1 < tox) {\n\t      if (soy < toy) {\n\t        let x = tmx1;\n\t        if (tmx0 >= smx1 && tmy1 >= soy) {\n\t          x = middleOfVerticalSides;\n\t        }\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: tox,\n\t        y: soy\n\t      }];\n\t    }\n\t    const y = Math.max(tmy1, middleOfHorizontalSides);\n\t    if (soy > toy && sx0 <= tox) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    if (y > smy0 && sox > tx0) {\n\t      const x = Math.max(smx1, tmx1);\n\t      const y = Math.max(smy1, tmy1);\n\t      return [{\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  }\n\t}\n\tfunction getLoopCoordinates(direction, angle, margin) {\n\t  const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;\n\t  let dx = 0;\n\t  let dy = 0;\n\t  switch (normalizeAngle(Math.round(angle))) {\n\t    case 0:\n\t    case 90:\n\t      dx = isHorizontal ? 0 : margin;\n\t      dy = isHorizontal ? margin : 0;\n\t      break;\n\t    case 180:\n\t    case 270:\n\t      dx = isHorizontal ? 0 : -margin;\n\t      dy = isHorizontal ? -margin : 0;\n\t      break;\n\t  }\n\t  return {\n\t    dx,\n\t    dy\n\t  };\n\t}\n\tfunction rightAngleRouter(vertices, opt, linkView) {\n\t  const {\n\t    sourceDirection = Directions.AUTO,\n\t    targetDirection = Directions.AUTO\n\t  } = opt;\n\t  const margin = opt.margin || 20;\n\t  const useVertices = opt.useVertices || false;\n\t  const isSourcePort = !!linkView.model.source().port;\n\t  const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n\t  const isTargetPort = !!linkView.model.target().port;\n\t  const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n\t  const resultVertices = [];\n\t  if (!useVertices || vertices.length === 0) {\n\t    return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n\t  }\n\t  const verticesData = vertices.map(v => pointDataFromVertex(v));\n\t  const [firstVertex] = verticesData;\n\t  const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);\n\t  const isElement = sourcePoint.view && sourcePoint.view.model.isElement();\n\t  const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;\n\t  const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;\n\t  if (isVertexInside) {\n\t    const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);\n\t    const firstPointOverlap = outsidePoint.equals(firstVertex.point);\n\t    const alignsVertically = sourcePoint.point.x === firstVertex.point.x;\n\t    const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;\n\t    const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);\n\t    const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);\n\t    const firstSegment = new Line(sourcePoint.point, outsidePoint);\n\t    const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);\n\t    const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);\n\t    if (firstPointOverlap) {\n\t      resultVertices.push(sourcePoint.point, firstVertex.point);\n\t      // Set the access direction as the opposite of the source direction that will be used to connect the route with the next vertex\n\t      firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];\n\t    } else if (isVertexOnSegment || isVertexAlignedAndInside) {\n\t      // Case where there is a need to create a loop\n\t      const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new Line(sourcePoint.point, firstVertex.point));\n\t      const {\n\t        dx,\n\t        dy\n\t      } = getLoopCoordinates(resolvedSourceDirection, angle, margin);\n\t      const loop = createLoop({\n\t        point: outsidePoint\n\t      }, firstVertex, {\n\t        dx,\n\t        dy\n\t      });\n\t      const secondCreatedPoint = loop[2];\n\t      const loopEndSegment = new Line(firstVertex.point, secondCreatedPoint);\n\t      const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n\t      firstVertex.direction = accessDirection;\n\t      resultVertices.push(...loop);\n\t    } else {\n\t      // No need to create a route, use the `routeBetweenPoints` to construct a route\n\t      firstVertex.direction = resolvedSourceDirection;\n\t      firstVertex.margin = margin;\n\t      resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, {\n\t        targetInSourceBBox: true\n\t      }), firstVertex.point);\n\t    }\n\t  } else {\n\t    // The first point responsible for the initial direction of the route\n\t    const next = verticesData[1] || targetPoint;\n\t    const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n\t    firstVertex.direction = direction;\n\t    resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n\t  }\n\t  for (let i = 0; i < verticesData.length - 1; i++) {\n\t    const from = verticesData[i];\n\t    const to = verticesData[i + 1];\n\t    const connectionSegment = new Line(from.point, to.point);\n\t    const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n\t    if (connectionSegmentAngle % 90 === 0) {\n\t      // Segment is horizontal or vertical\n\t      const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\t      const simplifiedRoute = simplifyPoints([...resultVertices, from.point]);\n\t      // const simplifiedRoute2 = simplifyPoints([from.point, ...resultVertices]);\n\t      // Find out the direction that is used to connect the current route with the next vertex\n\t      const accessSegment = new Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);\n\t      // const accessSegment2 = new g.Line(simplifiedRoute2[simplifiedRoute2.length - 2], simplifiedRoute2[simplifiedRoute2.length - 1]);\n\t      const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n\t      // const accessDirection2 = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment2))];\n\t      // console.log(accessDirection);\n\t      // console.log(accessDirection2);\n\t      // if (accessDirection !== accessDirection2) {\n\t      //     console.log('error');\n\t      // }\n\t      // console.log('------------------');\n\n\t      if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n\t        // The directions are not opposite, so we can connect the vertices directly\n\t        resultVertices.push(from.point, to.point);\n\t        const [, toDirection] = resolveSides(from, to);\n\t        to.direction = toDirection;\n\t      } else {\n\t        // The directions are overlapping, so we need to create a loop\n\t        const {\n\t          loopRoute,\n\t          continueDirection\n\t        } = loopSegment(from, to, connectionSegmentAngle, margin);\n\t        to.direction = continueDirection;\n\t        // Constructing a loop\n\t        resultVertices.push(...loopRoute);\n\t      }\n\t      continue;\n\t    }\n\n\t    // Vertices are not aligned vertically nor horizontally\n\t    // so we need to route between them\n\n\t    const [fromDirection, toDirection] = resolveDirection(from, to);\n\t    from.direction = fromDirection;\n\t    to.direction = toDirection;\n\t    resultVertices.push(...routeBetweenPoints(from, to), to.point);\n\t  }\n\t  const lastVertex = verticesData[verticesData.length - 1];\n\t  if (targetPoint.view && targetPoint.view.model.isElement()) {\n\t    const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);\n\t    const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);\n\n\t    // the last point of `simplified` array is the last defined vertex\n\t    // this will ensure that the last segment continues in a straight line\n\t    const simplified = simplifyPoints([...resultVertices, lastVertex.point]);\n\t    const simplifiedSegment = new Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);\n\t    const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));\n\t    const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];\n\t    const lastPointOverlap = outsidePoint.equals(lastVertex.point);\n\t    if (!lastPointOverlap || lastPointOverlap && definedDirection === resolvedTargetDirection) {\n\t      lastVertex.direction = definedDirection;\n\t      let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n\t      const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n\t      const lastSegment = new Line(p1, p2);\n\t      const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n\t      const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n\t      const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);\n\t      const alignsVertically = lastVertex.point.x === targetPoint.point.x;\n\t      const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;\n\t      const isVertexInside = targetBBox.containsPoint(lastVertex.point);\n\t      const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);\n\t      const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);\n\t      if (!lastPointOverlap && isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns)) {\n\t        // Handle special cases when the last vertex is inside the target element\n\t        // and in is aligned with the connection point => construct a loop\n\t        const {\n\t          dx,\n\t          dy\n\t        } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);\n\t        lastSegmentRoute = createLoop(lastVertex, {\n\t          point: outsidePoint\n\t        }, {\n\t          dx,\n\t          dy\n\t        });\n\t      } else if (isVertexInside && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {\n\t        lastVertex.margin = margin;\n\t        lastVertex.direction = resolvedTargetDirection;\n\t        lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n\t      } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n\t        lastVertex.margin = margin;\n\t        lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n\t      }\n\t      resultVertices.push(...lastSegmentRoute);\n\t    }\n\t  } else {\n\t    // since the target is only a point we can apply the same logic as if we connected two verticesData\n\t    const from = lastVertex;\n\t    const to = targetPoint;\n\t    const connectionSegment = new Line(from.point, to.point);\n\t    const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n\t    if (connectionSegmentAngle % 90 === 0) {\n\t      // Segment is horizontal or vertical\n\t      const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\t      const simplifiedRoute = simplifyPoints(resultVertices);\n\t      // Find out the direction that is used to connect the current route with the next vertex\n\t      const accessSegment = new Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);\n\t      const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n\t      if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n\t        // The directions are not opposite, so we can connect the vertices directly by adding the first point\n\t        // the target point is handled separately\n\t        resultVertices.push(from.point);\n\t      } else {\n\t        // The directions are overlapping, so we need to create a loop\n\t        const {\n\t          loopRoute\n\t        } = loopSegment(from, to, connectionSegmentAngle, margin);\n\t        // Remove the last point since it is the target that is handled separately\n\t        loopRoute.pop();\n\t        // Constructing a loop\n\t        resultVertices.push(...loopRoute);\n\t      }\n\t    } else {\n\t      // The last vertex and the target are not aligned vertically nor horizontally\n\t      // so we need to route between them\n\t      const [fromDirection, toDirection] = resolveDirection(from, to);\n\t      from.direction = fromDirection;\n\t      to.direction = toDirection;\n\t      resultVertices.push(...routeBetweenPoints(from, to));\n\t    }\n\t  }\n\t  return simplifyPoints(resultVertices);\n\t}\n\tfunction resolveDirection(from, to) {\n\t  const accessDirection = from.direction;\n\t  const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n\t  let sourceDirection = from.direction;\n\t  let targetDirection = to.direction;\n\t  if (isDirectionVertical) {\n\t    const isToAbove = from.point.y > to.point.y;\n\t    const dx = to.point.x - from.point.x;\n\t    if (accessDirection === Directions.BOTTOM) {\n\t      // If isToAbove === false and we need figure out if to go left or right\n\t      sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n\t      if (dx > 0) {\n\t        targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n\t      } else if (dx < 0) {\n\t        targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n\t      }\n\t    } else {\n\t      // If isToAbove === true and we need figure out if to go left or right\n\t      sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n\t      if (dx > 0) {\n\t        targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n\t      } else if (dx < 0) {\n\t        targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n\t      }\n\t    }\n\t  } else {\n\t    const isToLeft = from.point.x > to.point.x;\n\t    const dy = to.point.y - from.point.y;\n\t    if (accessDirection === Directions.RIGHT) {\n\t      sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n\t      if (dy > 0) {\n\t        targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n\t      } else if (dy < 0) {\n\t        targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n\t      }\n\t    } else {\n\t      sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n\t      if (dy > 0) {\n\t        targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n\t      } else if (dy < 0) {\n\t        targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n\t      }\n\t    }\n\t  }\n\t  return [sourceDirection, targetDirection];\n\t}\n\trightAngleRouter.Directions = Directions;\n\tconst rightAngle = rightAngleRouter;\n\n\tvar routers = {\n\t\t__proto__: null,\n\t\tmanhattan: manhattan,\n\t\tmetro: metro,\n\t\tnormal: normal,\n\t\toneSide: oneSide,\n\t\torthogonal: orthogonal,\n\t\trightAngle: rightAngle\n\t};\n\n\tfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\t  var ratio = 'ratio' in opt ? opt.ratio : 0.5;\n\t  return view.getPointAtRatio(ratio);\n\t}\n\tfunction connectionLength(view, _magnet, _refPoint, opt) {\n\t  var length = 'length' in opt ? opt.length : 20;\n\t  return view.getPointAtLength(length);\n\t}\n\tfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\t  var OFFSET = 1e6;\n\t  var path = view.getConnection();\n\t  var segmentSubdivisions = view.getConnectionSubdivisions();\n\t  var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n\t  var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n\t  var verticalIntersections = verticalLine.intersect(path, {\n\t    segmentSubdivisions: segmentSubdivisions\n\t  });\n\t  var horizontalIntersections = horizontalLine.intersect(path, {\n\t    segmentSubdivisions: segmentSubdivisions\n\t  });\n\t  var intersections = [];\n\t  if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n\t  if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n\t  if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n\t  if ('fallbackAt' in opt) {\n\t    return getPointAtLink(view, opt.fallbackAt);\n\t  }\n\t  return connectionClosest(view, _magnet, refPoint, opt);\n\t}\n\tfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\t  var closestPoint = view.getClosestPoint(refPoint);\n\t  if (!closestPoint) return new Point();\n\t  return closestPoint;\n\t}\n\tfunction resolveRef(fn) {\n\t  return function (view, magnet, ref, opt, endType, linkView) {\n\t    if (ref instanceof Element) {\n\t      var refView = this.paper.findView(ref);\n\t      var refPoint;\n\t      if (refView) {\n\t        if (refView.isNodeConnection(ref)) {\n\t          var distance = 'fixedAt' in opt ? opt.fixedAt : '50%';\n\t          refPoint = getPointAtLink(refView, distance);\n\t        } else {\n\t          refPoint = refView.getNodeBBox(ref).center();\n\t        }\n\t      } else {\n\t        // Something went wrong\n\t        refPoint = new Point();\n\t      }\n\t      return fn.call(this, view, magnet, refPoint, opt, endType, linkView);\n\t    }\n\t    return fn.apply(this, arguments);\n\t  };\n\t}\n\tfunction getPointAtLink(view, value) {\n\t  var parsedValue = parseFloat(value);\n\t  if (isPercentage(value)) {\n\t    return view.getPointAtRatio(parsedValue / 100);\n\t  } else {\n\t    return view.getPointAtLength(parsedValue);\n\t  }\n\t}\n\tconst connectionPerpendicular = resolveRef(_connectionPerpendicular);\n\tconst connectionClosest = resolveRef(_connectionClosest);\n\n\tvar linkAnchors = {\n\t\t__proto__: null,\n\t\tconnectionClosest: connectionClosest,\n\t\tconnectionLength: connectionLength,\n\t\tconnectionPerpendicular: connectionPerpendicular,\n\t\tconnectionRatio: connectionRatio,\n\t\tresolveRef: resolveRef\n\t};\n\n\tconst Side = {\n\t  LEFT: 'left',\n\t  RIGHT: 'right',\n\t  TOP: 'top',\n\t  BOTTOM: 'bottom'\n\t};\n\tconst SideMode = {\n\t  PREFER_HORIZONTAL: 'prefer-horizontal',\n\t  PREFER_VERTICAL: 'prefer-vertical',\n\t  HORIZONTAL: 'horizontal',\n\t  VERTICAL: 'vertical',\n\t  AUTO: 'auto'\n\t};\n\tfunction getModelBBoxFromConnectedLink(element, link, endType, rotate) {\n\t  const portId = link.get(endType).port;\n\t  if (element.hasPort(portId)) {\n\t    return element.getPortBBox(portId, {\n\t      rotate\n\t    });\n\t  }\n\t  return element.getBBox({\n\t    rotate\n\t  });\n\t}\n\tfunction getMiddleSide(rect, point, opt) {\n\t  const {\n\t    preferenceThreshold = 0,\n\t    mode\n\t  } = opt;\n\t  const {\n\t    x,\n\t    y\n\t  } = point;\n\t  const {\n\t    x: left,\n\t    y: top,\n\t    width,\n\t    height\n\t  } = rect;\n\t  switch (mode) {\n\t    case SideMode.PREFER_VERTICAL:\n\t      {\n\t        const {\n\t          top: topThreshold,\n\t          bottom: bottomThreshold\n\t        } = normalizeSides(preferenceThreshold);\n\t        const bottom = top + height;\n\t        if (y > top - topThreshold && y < bottom + bottomThreshold) {\n\t          const cx = left + width / 2;\n\t          return x < cx ? Side.LEFT : Side.RIGHT;\n\t        }\n\t      }\n\t    // eslint-disable-next-line no-fallthrough\n\t    case SideMode.VERTICAL:\n\t      {\n\t        const cy = top + height / 2;\n\t        return y < cy ? Side.TOP : Side.BOTTOM;\n\t      }\n\t    case SideMode.PREFER_HORIZONTAL:\n\t      {\n\t        const {\n\t          left: leftThreshold,\n\t          right: rightThreshold\n\t        } = normalizeSides(preferenceThreshold);\n\t        const right = left + width;\n\t        if (x > left - leftThreshold && x < right + rightThreshold) {\n\t          const cy = top + height / 2;\n\t          return y < cy ? Side.TOP : Side.BOTTOM;\n\t        }\n\t      }\n\t    // eslint-disable-next-line no-fallthrough\n\t    case SideMode.HORIZONTAL:\n\t      {\n\t        const cx = left + width / 2;\n\t        return x < cx ? Side.LEFT : Side.RIGHT;\n\t      }\n\t    case SideMode.AUTO:\n\t    default:\n\t      {\n\t        return rect.sideNearestToPoint(point);\n\t      }\n\t  }\n\t}\n\tfunction bboxWrapper(method) {\n\t  return function (elementView, magnet, ref, opt, endType, linkView) {\n\t    const rotate = !!opt.rotate;\n\t    const element = elementView.model;\n\t    const link = linkView.model;\n\t    const angle = element.angle();\n\t    let bbox, center;\n\t    if (opt.useModelGeometry) {\n\t      bbox = getModelBBoxFromConnectedLink(element, link, endType, !rotate);\n\t      center = bbox.center();\n\t    } else {\n\t      center = element.getCenter();\n\t      bbox = rotate ? elementView.getNodeUnrotatedBBox(magnet) : elementView.getNodeBBox(magnet);\n\t    }\n\t    const anchor = bbox[method]();\n\t    let dx = opt.dx;\n\t    if (dx) {\n\t      const isDxPercentage = isPercentage(dx);\n\t      if (!isDxPercentage && isCalcExpression(dx)) {\n\t        // calc expression\n\t        dx = Number(evalCalcExpression(dx, bbox));\n\t      } else {\n\t        // percentage or a number\n\t        dx = parseFloat(dx);\n\t      }\n\t      if (isFinite(dx)) {\n\t        if (isDxPercentage) {\n\t          dx /= 100;\n\t          dx *= bbox.width;\n\t        }\n\t        anchor.x += dx;\n\t      }\n\t    }\n\t    let dy = opt.dy;\n\t    if (dy) {\n\t      const isDyPercentage = isPercentage(dy);\n\t      if (!isDyPercentage && isCalcExpression(dy)) {\n\t        // calc expression\n\t        dy = Number(evalCalcExpression(dy, bbox));\n\t      } else {\n\t        // percentage or a number\n\t        dy = parseFloat(dy);\n\t      }\n\t      if (isFinite(dy)) {\n\t        if (isDyPercentage) {\n\t          dy /= 100;\n\t          dy *= bbox.height;\n\t        }\n\t        anchor.y += dy;\n\t      }\n\t    }\n\t    return rotate ? anchor.rotate(center, -angle) : anchor;\n\t  };\n\t}\n\tfunction _perpendicular(elementView, magnet, refPoint, opt, endType, linkView) {\n\t  const element = elementView.model;\n\t  const angle = element.angle();\n\t  let bbox;\n\t  if (opt.useModelGeometry) {\n\t    bbox = getModelBBoxFromConnectedLink(element, linkView.model, endType, true);\n\t  } else {\n\t    bbox = elementView.getNodeBBox(magnet);\n\t  }\n\t  const anchor = bbox.center();\n\t  const topLeft = bbox.origin();\n\t  const bottomRight = bbox.corner();\n\t  let padding = opt.padding;\n\t  if (!isFinite(padding)) padding = 0;\n\t  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n\t    var dy = refPoint.y - anchor.y;\n\t    anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(toRad(angle));\n\t    anchor.y += dy;\n\t  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n\t    var dx = refPoint.x - anchor.x;\n\t    anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(toRad(angle));\n\t    anchor.x += dx;\n\t  }\n\t  return anchor;\n\t}\n\tfunction _midSide(view, magnet, refPoint, opt, endType, linkView) {\n\t  var rotate = !!opt.rotate;\n\t  var angle = view.model.angle();\n\t  var center = view.model.getCenter();\n\t  var bbox;\n\t  if (opt.useModelGeometry) {\n\t    bbox = getModelBBoxFromConnectedLink(view.model, linkView.model, endType, !rotate);\n\t    center = bbox.center();\n\t  } else {\n\t    bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n\t  }\n\t  var padding = opt.padding;\n\t  if (isFinite(padding)) bbox.inflate(padding);\n\t  if (rotate) refPoint.rotate(center, angle);\n\t  var side = getMiddleSide(bbox, refPoint, opt);\n\t  var anchor;\n\t  switch (side) {\n\t    case Side.LEFT:\n\t      anchor = bbox.leftMiddle();\n\t      break;\n\t    case Side.RIGHT:\n\t      anchor = bbox.rightMiddle();\n\t      break;\n\t    case Side.TOP:\n\t      anchor = bbox.topMiddle();\n\t      break;\n\t    case Side.BOTTOM:\n\t      anchor = bbox.bottomMiddle();\n\t      break;\n\t  }\n\t  return rotate ? anchor.rotate(center, -angle) : anchor;\n\t}\n\n\t// Can find anchor from model, when there is no selector or the link end\n\t// is connected to a port\n\tfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n\t  return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n\t}\n\n\t//joint.anchors\n\tconst center = bboxWrapper('center');\n\tconst top = bboxWrapper('topMiddle');\n\tconst bottom = bboxWrapper('bottomMiddle');\n\tconst left = bboxWrapper('leftMiddle');\n\tconst right = bboxWrapper('rightMiddle');\n\tconst topLeft = bboxWrapper('origin');\n\tconst topRight = bboxWrapper('topRight');\n\tconst bottomLeft = bboxWrapper('bottomLeft');\n\tconst bottomRight = bboxWrapper('corner');\n\tconst perpendicular = resolveRef(_perpendicular);\n\tconst midSide = resolveRef(_midSide);\n\tconst modelCenter = _modelCenter;\n\n\tvar anchors = {\n\t\t__proto__: null,\n\t\tbottom: bottom,\n\t\tbottomLeft: bottomLeft,\n\t\tbottomRight: bottomRight,\n\t\tcenter: center,\n\t\tleft: left,\n\t\tmidSide: midSide,\n\t\tmodelCenter: modelCenter,\n\t\tperpendicular: perpendicular,\n\t\tright: right,\n\t\ttop: top,\n\t\ttopLeft: topLeft,\n\t\ttopRight: topRight\n\t};\n\n\t/**\n\t * @class GraphLayersController\n\t * @description Coordinates interactions between the graph and its layers.\n\t * Automatically moves cells between layers when the layer attribute changes.\n\t */\n\tclass GraphLayersController extends Listener {\n\t  constructor(options) {\n\t    super(options);\n\n\t    // Make sure there are no arguments passed to the callbacks.\n\t    // See the `mvc.Listener` documentation for more details.\n\t    this.callbackArguments = [];\n\t    const graph = options.graph;\n\t    if (!graph) {\n\t      throw new Error('GraphLayersController: \"graph\" option is required.');\n\t    }\n\t    this.graph = graph;\n\t    this.layerCollection = graph.layerCollection;\n\t    this.startListening();\n\t  }\n\t  startListening() {\n\t    // Handle all events from the layer collection and its inner cell collections.\n\t    this.listenTo(this.layerCollection, 'all', this.onLayerCollectionEvent);\n\t  }\n\n\t  /**\n\t   * @description When a cell changes its layer attribute,\n\t   * move the cell to the target layer.\n\t   */\n\t  onCellChange(cell, options) {\n\t    if (!cell.hasChanged(config$3.layerAttribute)) return;\n\t    // Move the cell to the appropriate layer\n\t    const targetLayerId = this.graph.getCellLayerId(cell);\n\t    this.layerCollection.moveCellBetweenLayers(cell, targetLayerId, options);\n\t  }\n\n\t  /**\n\t   * @description When a cell is removed from a layer,\n\t   * also remove its embeds and connected links from the graph.\n\t   * Note: an embedded cell might come from a different layer,\n\t   * so we can not use the layer's cell collection to remove it.\n\t   */\n\t  onCellRemove(cell, options) {\n\t    // If the cell is being moved from one layer to another,\n\t    // no further action is needed.\n\t    if (options.fromLayer) return;\n\n\t    // When replacing a cell, we do not want to remove its embeds or\n\t    // unembed it from its parent.\n\t    if (options.replace) return;\n\n\t    // First, unembed this cell from its parent cell if there is one.\n\t    const parentCell = cell.getParentCell();\n\t    if (parentCell) {\n\t      parentCell.unembed(cell, options);\n\t    }\n\n\t    // Remove also all the cells, which were embedded into this cell\n\t    const embeddedCells = cell.getEmbeddedCells();\n\t    for (let i = 0, n = embeddedCells.length; i < n; i++) {\n\t      const embed = embeddedCells[i];\n\t      if (embed) {\n\t        this.layerCollection.removeCell(embed, options);\n\t      }\n\t    }\n\n\t    // When not clearing the whole graph or replacing the cell,\n\t    // we don't want to remove the connected links.\n\t    if (!options.clear) {\n\t      // Applications might provide a `disconnectLinks` option set to `true` in order to\n\t      // disconnect links when a cell is removed rather then removing them. The default\n\t      // is to remove all the associated links.\n\t      if (options.disconnectLinks) {\n\t        this.graph.disconnectLinks(cell, options);\n\t      } else {\n\t        this.graph.removeLinks(cell, options);\n\t      }\n\t    }\n\t  }\n\t  onLayerCollectionEvent(eventName, model) {\n\t    if (!model) return;\n\t    if (model[CELL_MARKER]) {\n\t      // First handle cell-specific cases that require custom processing,\n\t      // then forward the event to the graph.\n\t      // For example, when a cell is removed from a layer, its embeds and\n\t      // connected links must be removed as well. Listeners on the graph\n\t      // should receive removal notifications in the following order:\n\t      // embeds â links â cell.\n\t      switch (eventName) {\n\t        case 'change':\n\t          /* ('change', cell, options) */\n\t          this.onCellChange.call(this, model, arguments[2]);\n\t          break;\n\t        case 'remove':\n\t          /* ('remove', cell, collection, options) */\n\t          // When a cell is removed from a layer,\n\t          // ensure it is also removed from the graph.\n\t          this.onCellRemove.call(this, model, arguments[3]);\n\t          break;\n\t      }\n\t      // Notify the graph about cell events.\n\t      this.forwardCellEvent.apply(this, arguments);\n\t      return;\n\t    }\n\t    if (model[CELL_COLLECTION_MARKER]) {\n\t      this.forwardCellCollectionEvent.apply(this, arguments);\n\t      return;\n\t    }\n\t    if (model[GRAPH_LAYER_MARKER]) {\n\t      this.forwardLayerEvent.apply(this, arguments);\n\t      return;\n\t    }\n\t    if (model[GRAPH_LAYER_COLLECTION_MARKER]) {\n\t      this.forwardLayerCollectionEvent.apply(this, arguments);\n\t      return;\n\t    }\n\t  }\n\t  forwardLayerEvent() {\n\t    // Note: the layer event prefix is `layer:`\n\t    this.graph.trigger.apply(this.graph, arguments);\n\t  }\n\t  forwardCellEvent(eventName, cell) {\n\t    var _arguments$;\n\t    // Moving a cell from one layer to another is an internal operation\n\t    // that should not be exposed at the graph level.\n\t    // The single `move` event is triggered instead.\n\t    if ((eventName === 'remove' || eventName === 'add') && (_arguments$ = arguments[3]) !== null && _arguments$ !== void 0 && _arguments$.fromLayer) return;\n\t    this.graph.trigger.apply(this.graph, arguments);\n\t  }\n\t  forwardCellCollectionEvent(eventName) {\n\t    // Do not forward `layer:remove` or `layer:sort` events to the graph\n\t    if (eventName !== 'sort') return;\n\t    // Backwards compatibility:\n\t    // Trigger 'sort' event for cell collection 'sort' events\n\t    this.graph.trigger.apply(this.graph, arguments);\n\t  }\n\t  forwardLayerCollectionEvent(eventName) {\n\t    if (eventName === 'reset') {\n\t      // Currently, there is no need to forward `layers:reset` event.\n\t      // The graph `fromJSON()` triggers a single `reset` event after\n\t      // resetting cells, layers and attributes.\n\t      return;\n\t    }\n\t    // Forward layer collection events with `layers:` prefix.\n\t    // For example `layers:reset` event when the layer collection is reset\n\t    arguments[0] = 'layers:' + arguments[0];\n\t    this.graph.trigger.apply(this.graph, arguments);\n\t  }\n\t}\n\n\t/**\n\t * @class CellCollection\n\t * @description A CellCollection is a collection of cells which supports z-index management.\n\t * Additionally, it facilitates creating cell models from JSON using cellNamespace\n\t * and stores a reference to the graph when the cell model has been added.\n\t */\n\tclass CellCollection extends Collection {\n\t  [CELL_COLLECTION_MARKER] = true;\n\t  initialize(_models, opt) {\n\t    this.layer = opt.layer;\n\t  }\n\n\t  // Method for checking whether an object should be considered a model for\n\t  // the purposes of adding to the collection.\n\t  _isModel(model) {\n\t    return Boolean(model[CELL_MARKER]);\n\t  }\n\n\t  // Overriding the default `model` method to create cell models\n\t  // based on their `type` attribute and the `cellNamespace` option.\n\t  model(attrs, opt) {\n\t    const namespace = this.cellNamespace;\n\t    if (!namespace) {\n\t      throw new Error('dia.CellCollection: cellNamespace is required to instantiate a Cell from JSON.');\n\t    }\n\t    const {\n\t      type\n\t    } = attrs;\n\n\t    // Find the model class based on the `type` attribute in the cell namespace\n\t    const ModelClass = getByPath(namespace, type, '.');\n\t    if (!ModelClass) {\n\t      throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);\n\t    }\n\t    return new ModelClass(attrs, opt);\n\t  }\n\n\t  // Override to set graph reference\n\t  _addReference(model, options) {\n\t    super._addReference(model, options);\n\n\t    // If not in `dry` mode and the model does not have a graph reference yet,\n\t    // set the reference.\n\t    if (!options.dry && !model.graph) {\n\t      model.graph = this.layer.graph;\n\t    }\n\t  }\n\n\t  // Override to remove graph reference\n\t  _removeReference(model, options) {\n\t    super._removeReference(model, options);\n\n\t    // If not in `dry` mode and the model has a reference to this exact graph,\n\t    // remove the reference.\n\t    // Note: graph reference is removed from the layer after the `remove` event is fired.\n\t    // Due to this, event handlers can still access the graph during the `remove` event.\n\t    if (!options.dry && model.graph === this.layer.graph) {\n\t      model.graph = null;\n\t    }\n\t  }\n\n\t  // remove graph reference additionally\n\t  _removeReferenceFast(model, options) {\n\t    model.off('all', this._onModelEvent, this);\n\t    if (!options.dry) {\n\t      // If not in `dry` mode and the model has a reference\n\t      // to this exact graph/collection, remove the reference.\n\t      if (this === model.collection) {\n\t        delete model.collection;\n\t      }\n\t      if (model.graph === this.layer.graph) {\n\t        model.graph = null;\n\t      }\n\t    }\n\t  }\n\n\t  // `comparator` makes it easy to sort cells based on their `z` index.\n\t  comparator(model) {\n\t    return model.get('z') || 0;\n\t  }\n\n\t  // This method overrides base mvc.Collection implementation\n\t  // in a way that improves performance of resetting large collections.\n\t  // For layers specifically, there is an option where we put references\n\t  // from the main collection in order to improve performance when\n\t  // there is only one layer\n\t  reset(models, options) {\n\t    options = assign({}, {\n\t      add: true,\n\t      remove: false,\n\t      merge: false\n\t    }, options);\n\t    for (let i = 0; i < this.models.length; i++) {\n\t      this._removeReferenceFast(this.models[i], options);\n\t    }\n\t    options.previousModels = this.models;\n\t    this._reset();\n\t    for (let i = 0; i < models.length; i++) {\n\t      const model = this._prepareModel(models[i], options);\n\t      if (model) {\n\t        this.models.push(model);\n\t        this._addReference(model, options);\n\t      }\n\t    }\n\t    this.length = this.models.length;\n\t    const sort = this.comparator && options.sort !== false;\n\t    if (sort) {\n\t      this.sort({\n\t        silent: true\n\t      });\n\t    }\n\t    if (!options.silent) {\n\t      this.trigger('reset', this, options);\n\t    }\n\t    return this.models;\n\t  }\n\t  minZIndex() {\n\t    var _this$first;\n\t    return ((_this$first = this.first()) === null || _this$first === void 0 ? void 0 : _this$first.get('z')) || 0;\n\t  }\n\t  maxZIndex() {\n\t    var _this$last;\n\t    return ((_this$last = this.last()) === null || _this$last === void 0 ? void 0 : _this$last.get('z')) || 0;\n\t  }\n\t}\n\n\tconst DEFAULT_GRAPH_LAYER_TYPE = 'GraphLayer';\n\n\t/**\n\t * @class GraphLayer\n\t * @description A GraphLayer is a model representing a single layer in a dia.Graph.\n\t */\n\tclass GraphLayer extends Model {\n\t  [GRAPH_LAYER_MARKER] = true;\n\t  preinitialize() {\n\t    // This allows for propagating events from the inner `cellCollection` collection\n\t    // without any prefix and therefore distinguish them from the events\n\t    // fired by the GraphLayer model itself.\n\t    this.eventPrefix = 'layer:';\n\t  }\n\t  defaults() {\n\t    return {\n\t      type: DEFAULT_GRAPH_LAYER_TYPE\n\t    };\n\t  }\n\t  initialize(attrs, options = {}) {\n\t    super.initialize(attrs, options);\n\t    this.cellCollection = new CellCollection([], {\n\t      layer: this\n\t    });\n\n\t    // Forward all events from the inner `cellCollection` collection\n\t    this.cellCollection.on('all', this.trigger, this);\n\t    // Listen to cell changes to manage z-index sorting\n\t    this.cellCollection.on('change', this.onCellChange, this);\n\t  }\n\t  onCellChange(cell, opt) {\n\t    if (opt.sort === false || !cell.hasChanged('z')) return;\n\t    this.cellCollection.sort();\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Returns all cells in this layer.\n\t   */\n\t  getCells() {\n\t    return this.cellCollection.toArray();\n\t  }\n\t}\n\n\t/**\n\t * @class GraphLayerCollection\n\t * @description A collection of layers used in dia.Graph. It facilitates creating layers from JSON using layerNamespace.\n\t */\n\tconst GraphLayerCollection = Collection.extend({\n\t  defaultLayerNamespace: {\n\t    GraphLayer\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Initializes the collection and sets up the layer and cell namespaces.\n\t   */\n\t  initialize: function (_models, options = {}) {\n\t    const {\n\t      layerNamespace,\n\t      cellNamespace,\n\t      graph\n\t    } = options;\n\n\t    // Initialize the namespace that holds all available layer classes.\n\t    // Custom namespaces are merged with the default ones.\n\t    this.layerNamespace = assign({}, this.defaultLayerNamespace, layerNamespace);\n\n\t    // Initialize the namespace for all cell model classes, if provided.\n\t    if (cellNamespace) {\n\t      this.cellNamespace = cellNamespace;\n\t    } else {\n\t      // eslint-disable-next-line no-undef\n\t      this.cellNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n\t    }\n\t    this.graph = graph;\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Overrides the default `model` method\n\t   * to create layer models based on their `type` attribute.\n\t   */\n\t  model: function (attrs, opt) {\n\t    const collection = opt.collection;\n\t    const namespace = collection.layerNamespace;\n\t    const {\n\t      type\n\t    } = attrs;\n\n\t    // Find the model class based on the `type` attribute in the cell namespace\n\t    const GraphLayerClass = getByPath(namespace, type, '.');\n\t    if (!GraphLayerClass) {\n\t      throw new Error(`dia.Graph: Could not find layer constructor for type: '${type}'. Make sure to add the constructor to 'layerNamespace'.`);\n\t    }\n\t    return new GraphLayerClass(attrs, opt);\n\t  },\n\t  // Override to set graph reference\n\t  _addReference(layer, options) {\n\t    Collection.prototype._addReference.call(this, layer, options);\n\n\t    // assign graph and cellNamespace references\n\t    // to the added layer\n\t    layer.graph = this.graph;\n\t    layer.cellCollection.cellNamespace = this.cellNamespace;\n\t  },\n\t  // Override to remove graph reference\n\t  _removeReference(layer, options) {\n\t    Collection.prototype._removeReference.call(this, layer, options);\n\n\t    // remove graph and cellNamespace references\n\t    // from the removed layer\n\t    layer.graph = null;\n\t    layer.cellCollection.cellNamespace = null;\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Overrides the default `_prepareModel` method\n\t   * to set default layer type if missing.\n\t   */\n\t  _prepareModel: function (attrs, options) {\n\t    if (!attrs[GRAPH_LAYER_MARKER]) {\n\t      // Add a mandatory `type` attribute if missing\n\t      if (!attrs.type) {\n\t        const preparedAttributes = clone$1(attrs);\n\t        preparedAttributes.type = DEFAULT_GRAPH_LAYER_TYPE;\n\t        arguments[0] = preparedAttributes;\n\t      }\n\t    }\n\t    return Collection.prototype._prepareModel.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Add an assertion to prevent direct resetting of the collection.\n\t   */\n\t  reset(models, options) {\n\t    this._assertInternalCall(options);\n\t    return Collection.prototype.reset.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Add an assertion to prevent direct addition of layers.\n\t   */\n\t  add(models, options) {\n\t    this._assertInternalCall(options);\n\t    return Collection.prototype.add.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Add an assertion to prevent direct removal of layers.\n\t   */\n\t  remove(models, options) {\n\t    this._assertInternalCall(options);\n\t    return Collection.prototype.remove.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Overrides the default `_onModelEvent` method\n\t   * to distinguish between events coming from different model types.\n\t   */\n\t  _onModelEvent(_, model) {\n\t    if (model && model[CELL_MARKER]) {\n\t      // Do not filter cell `add` and `remove` events\n\t      // See `mvc.Collection` for more details\n\t      this.trigger.apply(this, arguments);\n\t      return;\n\t    }\n\n\t    // For other events, use the default behavior\n\t    Collection.prototype._onModelEvent.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Asserts that the collection manipulation\n\t   * is done via internal graph methods. Otherwise, it throws an error.\n\t   * This is a temporary measure until layers API is stabilized.\n\t   */\n\t  _assertInternalCall(options) {\n\t    if (options && !options.graph && !options.silent) {\n\t      throw new Error('dia.GraphLayerCollection: direct manipulation of the collection is not supported, use graph methods instead.');\n\t    }\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Inserts a layer before another layer or at the end if `beforeLayerId` is null.\n\t   */\n\t  insert(layerInit, beforeLayerId = null, options = {}) {\n\t    const id = layerInit.id;\n\t    if (id === beforeLayerId) {\n\t      // Inserting before itself is a no-op\n\t      return;\n\t    }\n\t    if (beforeLayerId && !this.has(beforeLayerId)) {\n\t      throw new Error(`dia.GraphLayerCollection: Layer \"${beforeLayerId}\" does not exist`);\n\t    }\n\n\t    // See if the layer is already in the collection\n\t    let currentIndex = -1;\n\t    if (this.has(id)) {\n\t      currentIndex = this.findIndex(l => l.id === id);\n\t      if (currentIndex === this.length - 1 && !beforeLayerId) {\n\t        // The layer is already at the end\n\t        return;\n\t      }\n\t      // Remove the layer from its current position\n\t      this.remove(id, {\n\t        silent: true\n\t      });\n\t    }\n\n\t    // At what index to insert the layer?\n\t    let insertAt;\n\t    if (!beforeLayerId) {\n\t      insertAt = this.length;\n\t    } else {\n\t      insertAt = this.findIndex(l => l.id === beforeLayerId);\n\t    }\n\t    if (currentIndex !== -1) {\n\t      // Re-insert the layer at the new position.\n\t      this.add(layerInit, {\n\t        at: insertAt,\n\t        silent: true\n\t      });\n\t      // Trigger `sort` event manually\n\t      // since we are not using collection sorting workflow\n\t      this.trigger('sort', this, options);\n\t    } else {\n\t      // Add to the collection and trigger an event\n\t      // when new layer has been added\n\t      this.add(layerInit, {\n\t        ...options,\n\t        at: insertAt\n\t      });\n\t    }\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Finds and returns a cell by its id from all layers.\n\t   */\n\t  getCell(cellRef) {\n\t    // TODO: should we create a map of cells for faster lookup?\n\t    for (const layer of this.models) {\n\t      const cell = layer.cellCollection.get(cellRef);\n\t      if (cell) {\n\t        return cell;\n\t      }\n\t    }\n\t    // Backward compatibility: return undefined if cell is not found\n\t    return undefined;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Returns all cells in all layers in the correct order.\n\t   */\n\t  getCells() {\n\t    const layers = this.models;\n\t    if (layers.length === 1) {\n\t      // Single layer:\n\t      // Fast path, just return the copy of the only layer's cells\n\t      return layers[0].getCells();\n\t    }\n\t    // Multiple layers:\n\t    // Each layer has its models sorted already, so we can just concatenate\n\t    // them in the order of layers.\n\t    const cells = [];\n\t    for (const layer of layers) {\n\t      Array.prototype.push.apply(cells, layer.cellCollection.models);\n\t    }\n\t    return cells;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Removes a cell from its current layer.\n\t   */\n\t  removeCell(cell, options = {}) {\n\t    var _cell$collection;\n\t    const cellCollection = (_cell$collection = cell.collection) === null || _cell$collection === void 0 || (_cell$collection = _cell$collection.layer) === null || _cell$collection === void 0 ? void 0 : _cell$collection.cellCollection;\n\t    if (!cellCollection) return;\n\t    cellCollection.remove(cell, options);\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Move a cell from its current layer to a target layer.\n\t   */\n\t  moveCellBetweenLayers(cell, targetLayerId, options = {}) {\n\t    var _cell$collection2;\n\t    const sourceLayer = (_cell$collection2 = cell.collection) === null || _cell$collection2 === void 0 ? void 0 : _cell$collection2.layer;\n\t    if (!sourceLayer) {\n\t      throw new Error('dia.GraphLayerCollection: cannot move a cell that is not part of any layer.');\n\t    }\n\t    const targetLayer = this.get(targetLayerId);\n\t    if (!targetLayer) {\n\t      throw new Error(`dia.GraphLayerCollection: cannot move cell to layer '${targetLayerId}' because such layer does not exist.`);\n\t    }\n\t    if (sourceLayer === targetLayer) {\n\t      // 1. The provided cell is already in the target layer\n\t      // 2. Implicit default layer vs. explicit default (or vice versa)\n\t      // No follow-up action needed\n\t      return;\n\t    }\n\t    const moveOptions = {\n\t      ...options,\n\t      fromLayer: sourceLayer.id,\n\t      toLayer: targetLayer.id\n\t    };\n\t    // Move the cell between the two layer collections\n\t    sourceLayer.cellCollection.remove(cell, moveOptions);\n\t    targetLayer.cellCollection.add(cell, moveOptions);\n\t    // Trigger a single `move` event to ease distinguishing layer moves\n\t    // from add/remove operations\n\t    cell.trigger('move', cell, moveOptions);\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Adds a cell to the specified layer.\n\t   */\n\t  addCellToLayer(cell, layerId, options = {}) {\n\t    const targetLayer = this.get(layerId);\n\t    if (!targetLayer) {\n\t      throw new Error(`dia.GraphLayerCollection: layer \"${layerId}\" does not exist.`);\n\t    }\n\t    const addOptions = {\n\t      ...options,\n\t      toLayer: targetLayer.id\n\t    };\n\t    // Add the cell to the target layer collection\n\t    targetLayer.cellCollection.add(cell, addOptions);\n\t  }\n\t});\n\tObject.defineProperty(GraphLayerCollection.prototype, GRAPH_LAYER_COLLECTION_MARKER, {\n\t  value: true\n\t});\n\n\t/**\n\t * @class GraphTopologyIndex\n\t * @description Maintains an index of the graph topology (adjacency list)\n\t * for fast graph queries.\n\t */\n\tclass GraphTopologyIndex extends Listener {\n\t  constructor(options) {\n\t    super(options);\n\n\t    // Make sure there are no arguments passed to the callbacks.\n\t    // See the `mvc.Listener` documentation for more details.\n\t    this.callbackArguments = [];\n\t    this.layerCollection = options.layerCollection;\n\t    if (!this.layerCollection) {\n\t      throw new Error('GraphTopologyIndex: \"layerCollection\" option is required.');\n\t    }\n\t    this.initializeIndex();\n\t    this.startListening();\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Start listening to graph and layer collection events\n\t   * to maintain the topology index.\n\t   */\n\t  startListening() {\n\t    this.listenTo(this.layerCollection.graph, {\n\t      'add': this._restructureOnAdd,\n\t      'remove': this._restructureOnRemove,\n\t      'reset': this._restructureOnReset\n\t    });\n\t    // Listening to the collection instead of the graph\n\t    // to avoid reacting to graph attribute change events\n\t    // e.g. graph.set('source', ...);\n\t    this.listenTo(this.layerCollection, {\n\t      'change:source': this._restructureOnChangeSource,\n\t      'change:target': this._restructureOnChangeTarget\n\t    });\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Initialize the internal data structures.\n\t   */\n\t  initializeIndex() {\n\t    // Outgoing edges per node. Note that we use a hash-table for the list\n\t    // of outgoing edges for a faster lookup.\n\t    // [nodeId] -> Object [edgeId] -> true\n\t    this._out = {};\n\t    // Ingoing edges per node.\n\t    // [nodeId] -> Object [edgeId] -> true\n\t    this._in = {};\n\t    // `_nodes` is useful for quick lookup of all the elements in the graph, without\n\t    // having to go through the whole cells array.\n\t    // [node ID] -> true\n\t    this._nodes = {};\n\t    // `_edges` is useful for quick lookup of all the links in the graph, without\n\t    // having to go through the whole cells array.\n\t    // [edgeId] -> true\n\t    this._edges = {};\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on graph reset.\n\t   * E.g. when fromJSON or resetCells is called.\n\t   */\n\t  _restructureOnReset() {\n\t    this.initializeIndex();\n\t    this.layerCollection.getCells().forEach(this._restructureOnAdd, this);\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on cell addition.\n\t   * @param {dia.Cell} cell - The cell being added.\n\t   */\n\t  _restructureOnAdd(cell) {\n\t    if (cell.isLink()) {\n\t      this._edges[cell.id] = true;\n\t      const {\n\t        source,\n\t        target\n\t      } = cell.attributes;\n\t      if (source.id) {\n\t        (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n\t      }\n\t      if (target.id) {\n\t        (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n\t      }\n\t    } else {\n\t      this._nodes[cell.id] = true;\n\t    }\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on cell removal.\n\t   * @param {dia.Cell} cell - The cell being removed.\n\t   */\n\t  _restructureOnRemove(cell) {\n\t    if (cell.isLink()) {\n\t      delete this._edges[cell.id];\n\t      const {\n\t        source,\n\t        target\n\t      } = cell.attributes;\n\t      if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n\t        delete this._out[source.id][cell.id];\n\t      }\n\t      if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n\t        delete this._in[target.id][cell.id];\n\t      }\n\t    } else {\n\t      delete this._nodes[cell.id];\n\t    }\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on link source change.\n\t   * @param {dia.Link} link - The link being changed.\n\t   */\n\t  _restructureOnChangeSource(link) {\n\t    const prevSource = link.previous('source');\n\t    if (prevSource.id && this._out[prevSource.id]) {\n\t      delete this._out[prevSource.id][link.id];\n\t    }\n\t    const source = link.attributes.source;\n\t    if (source.id) {\n\t      (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n\t    }\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on link target change.\n\t   * @param {dia.Link} link - The link being changed.\n\t   */\n\t  _restructureOnChangeTarget(link) {\n\t    const prevTarget = link.previous('target');\n\t    if (prevTarget.id && this._in[prevTarget.id]) {\n\t      delete this._in[prevTarget.id][link.id];\n\t    }\n\t    const target = link.get('target');\n\t    if (target.id) {\n\t      (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n\t    }\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Get all outbound edges for the node. Time complexity: O(1).\n\t   * @param {string} nodeId - The id of the node.\n\t   * @returns {Object} - An object of the form: [edgeId] -> true.\n\t   */\n\t  getOutboundEdges(nodeId) {\n\t    return this._out[nodeId] || {};\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Get all inbound edges for the node. Time complexity: O(1).\n\t   * @param {string} nodeId - The id of the node.\n\t   * @returns {Object} - An object of the form: [edgeId] -> true.\n\t   */\n\t  getInboundEdges(nodeId) {\n\t    return this._in[nodeId] || {};\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Get all sink nodes (leafs) in the graph. Time complexity: O(|V|).\n\t   * @returns {string[]} - Array of node ids.\n\t   */\n\t  getSinkNodes() {\n\t    const sinks = [];\n\t    for (const nodeId in this._nodes) {\n\t      if (!this._out[nodeId] || isEmpty(this._out[nodeId])) {\n\t        sinks.push(nodeId);\n\t      }\n\t    }\n\t    return sinks;\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Get all source nodes (roots) in the graph. Time complexity: O(|V|).\n\t   * @returns {string[]} - Array of node ids.\n\t   */\n\t  getSourceNodes() {\n\t    const sources = [];\n\t    for (const nodeId in this._nodes) {\n\t      if (!this._in[nodeId] || isEmpty(this._in[nodeId])) {\n\t        sources.push(nodeId);\n\t      }\n\t    }\n\t    return sources;\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Return `true` if `nodeId` is a source node (root). Time complexity: O(1).\n\t   * @param {string} nodeId - The id of the node to check.\n\t   * @returns {boolean}\n\t   */\n\t  isSourceNode(nodeId) {\n\t    return !this._in[nodeId] || isEmpty(this._in[nodeId]);\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Return `true` if `nodeId` is a sink node (leaf). Time complexity: O(1).\n\t   * @param {string} nodeId - The id of the node to check.\n\t   * @returns {boolean}\n\t   */\n\t  isSinkNode(nodeId) {\n\t    return !this._out[nodeId] || isEmpty(this._out[nodeId]);\n\t  }\n\t}\n\n\t// The ID of the default graph layer.\n\tconst DEFAULT_LAYER_ID = 'cells';\n\tconst Graph = Model.extend({\n\t  /**\n\t   * @todo Remove in v5.0.0\n\t   * @description In legacy mode, the information about layers is not\n\t   * exported into JSON.\n\t   */\n\t  legacyMode: true,\n\t  /**\n\t   * @protected\n\t   * @description The ID of the default layer.\n\t   */\n\t  defaultLayerId: DEFAULT_LAYER_ID,\n\t  /**\n\t   * @protected\n\t   * @description If `true`, layer functionality is disabled\n\t   * and all cells are assigned to the default layer.\n\t   */\n\t  ignoreLayers: false,\n\t  initialize: function (attrs, options = {}) {\n\t    const layerCollection = this.layerCollection = new GraphLayerCollection([], {\n\t      layerNamespace: options.layerNamespace,\n\t      cellNamespace: options.cellNamespace,\n\t      graph: this,\n\t      /** @deprecated use cellNamespace instead */\n\t      model: options.cellModel\n\t    });\n\n\t    // The default setup includes a single default layer.\n\t    layerCollection.add({\n\t      id: DEFAULT_LAYER_ID\n\t    }, {\n\t      graph: this.cid\n\t    });\n\n\t    /**\n\t     * @todo Remove in v5.0.0\n\t     * @description Retain legacy 'cells' collection in attributes for backward compatibility.\n\t     * Applicable only when the default layer setup is used.\n\t     */\n\t    this.attributes.cells = this.getLayer(DEFAULT_LAYER_ID).cellCollection;\n\n\t    // Controller that manages communication between the graph and its layers.\n\t    this.layersController = new GraphLayersController({\n\t      graph: this\n\t    });\n\n\t    // Option to ignore layers altogether.\n\t    if (options.ignoreLayers) {\n\t      this.ignoreLayers = true;\n\t    }\n\n\t    // `Graph` keeps an internal data structure (an adjacency list)\n\t    // for fast graph queries. All changes that affect the structure of the graph\n\t    // must be reflected in the `al` object. This object provides fast answers to\n\t    // questions such as \"what are the neighbors of this node\" or \"what\n\t    // are the sibling links of this link\".\n\t    this.topologyIndex = new GraphTopologyIndex({\n\t      layerCollection\n\t    });\n\t    this._batches = {};\n\t  },\n\t  toJSON: function (opt = {}) {\n\t    const {\n\t      layerCollection\n\t    } = this;\n\t    // Get the graph model attributes as a base JSON.\n\t    const json = Model.prototype.toJSON.apply(this, arguments);\n\n\t    // Add `cells` array holding all the cells in the graph.\n\t    json.cells = this.getCells().map(cell => cell.toJSON(opt.cellAttributes));\n\t    if (this.legacyMode) {\n\t      // Backwards compatibility for legacy setup\n\t      // with single default layer 'cells'.\n\t      // In this case, we do not need to export layers.\n\t      return json;\n\t    }\n\n\t    // Add `layers` array holding all the layers in the graph.\n\t    json.layers = layerCollection.toJSON();\n\n\t    // Add `defaultLayer` property indicating the default layer ID.\n\t    json.defaultLayer = this.defaultLayerId;\n\t    return json;\n\t  },\n\t  fromJSON: function (json, opt) {\n\t    const {\n\t      cells,\n\t      layers,\n\t      defaultLayer,\n\t      ...attributes\n\t    } = json;\n\t    if (!cells) {\n\t      throw new Error('Graph JSON must contain cells array.');\n\t    }\n\n\t    // The `fromJSON` should trigger a single 'reset' event at the end.\n\t    // Set all attributes silently for now.\n\t    this.set(attributes, {\n\t      silent: true\n\t    });\n\t    if (layers) {\n\t      // Reset the layers collection\n\t      // (`layers:reset` is not forwarded to the graph).\n\t      this._resetLayers(layers, defaultLayer, opt);\n\t    }\n\t    if (cells) {\n\t      // Reset the cells collection and trigger the 'reset' event.\n\t      this.resetCells(cells, opt);\n\t    }\n\t    return this;\n\t  },\n\t  /** @deprecated  */\n\t  clear: function (opt) {\n\t    opt = assign({}, opt, {\n\t      clear: true\n\t    });\n\t    const cells = this.getCells();\n\t    if (cells.length === 0) return this;\n\t    this.startBatch('clear', opt);\n\t    const sortedCells = sortBy(cells, cell => {\n\t      return cell.isLink() ? 1 : 2;\n\t    });\n\t    do {\n\t      // Remove all the cells one by one.\n\t      // Note that all the links are removed first, so it's\n\t      // safe to remove the elements without removing the connected\n\t      // links first.\n\t      this.layerCollection.removeCell(sortedCells.shift(), opt);\n\t    } while (sortedCells.length > 0);\n\t    this.stopBatch('clear', opt);\n\t    return this;\n\t  },\n\t  _prepareCell: function (cellInit, opt) {\n\t    let cellAttributes;\n\t    if (cellInit[CELL_MARKER]) {\n\t      cellAttributes = cellInit.attributes;\n\t    } else {\n\t      cellAttributes = cellInit;\n\t    }\n\t    if (!isString(cellAttributes.type)) {\n\t      throw new TypeError('dia.Graph: cell type must be a string.');\n\t    }\n\n\t    // Backward compatibility: prior v4.2, z-index was not set during reset.\n\t    if (opt && opt.ensureZIndex) {\n\t      if (cellAttributes.z === undefined) {\n\t        const layerId = this.getCellLayerId(cellInit);\n\t        const zIndex = this.maxZIndex(layerId) + 1;\n\t        if (cellInit[CELL_MARKER]) {\n\t          // Set with event in case there is a listener\n\t          // directly on the cell instance\n\t          // (the cell is not part of graph yet)\n\t          cellInit.set('z', zIndex, opt);\n\t        } else {\n\t          cellAttributes.z = zIndex;\n\t        }\n\t      }\n\t    }\n\t    return cellInit;\n\t  },\n\t  minZIndex: function (layerId = this.defaultLayerId) {\n\t    const layer = this.getLayer(layerId);\n\t    return layer.cellCollection.minZIndex();\n\t  },\n\t  maxZIndex: function (layerId = this.defaultLayerId) {\n\t    const layer = this.getLayer(layerId);\n\t    return layer.cellCollection.maxZIndex();\n\t  },\n\t  addCell: function (cellInit, options) {\n\t    if (Array.isArray(cellInit)) {\n\t      return this.addCells(cellInit, options);\n\t    }\n\t    this._prepareCell(cellInit, {\n\t      ...options,\n\t      ensureZIndex: true\n\t    });\n\t    this.layerCollection.addCellToLayer(cellInit, this.getCellLayerId(cellInit), options);\n\t    return this;\n\t  },\n\t  addCells: function (cells, opt) {\n\t    if (cells.length === 0) return this;\n\t    cells = flattenDeep(cells);\n\t    opt.maxPosition = opt.position = cells.length - 1;\n\t    this.startBatch('add', opt);\n\t    cells.forEach(cell => {\n\t      this.addCell(cell, opt);\n\t      opt.position--;\n\t    });\n\t    this.stopBatch('add', opt);\n\t    return this;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Reset the cells in the graph.\n\t   * Useful for bulk operations and optimizations.\n\t   */\n\t  resetCells: function (cellInits, options) {\n\t    const {\n\t      layerCollection\n\t    } = this;\n\t    // Note: `cellInits` is always an array and `options` is always an object.\n\t    // See `wrappers.cells` at the end of this file.\n\n\t    // When resetting cells, do not set z-index if not provided.\n\t    const prepareOptions = {\n\t      ...options,\n\t      ensureZIndex: false\n\t    };\n\n\t    // Initialize a map of layer IDs to arrays of cells\n\t    const layerCellsMap = layerCollection.reduce((map, layer) => {\n\t      map[layer.id] = [];\n\t      return map;\n\t    }, {});\n\n\t    // Distribute cells into their respective layers\n\t    for (let i = 0; i < cellInits.length; i++) {\n\t      const cellInit = cellInits[i];\n\t      const layerId = this.getCellLayerId(cellInit);\n\t      if (layerId in layerCellsMap) {\n\t        this._prepareCell(cellInit, prepareOptions);\n\t        layerCellsMap[layerId].push(cellInit);\n\t      } else {\n\t        throw new Error(`dia.Graph: Layer \"${layerId}\" does not exist.`);\n\t      }\n\t    }\n\n\t    // Reset each layer's cell collection with the corresponding cells.\n\t    layerCollection.each(layer => {\n\t      layer.cellCollection.reset(layerCellsMap[layer.id], options);\n\t    });\n\n\t    // Trigger a single `reset` event on the graph\n\t    // (while multiple `reset` events are triggered on layers).\n\t    // Backwards compatibility: use default layer collection\n\t    // The `collection` parameter is retained for backwards compatibility,\n\t    // and it is subject to removal in future releases.\n\t    this.trigger('reset', this.getDefaultLayer().cellCollection, options);\n\t    return this;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Get the layer ID in which the cell resides.\n\t   * Cells without an explicit layer are assigned to the default layer.\n\t   * @param {dia.Cell | Object} cellInit - Cell model or attributes.\n\t   * @returns {string} - The layer ID.\n\t   */\n\t  getCellLayerId: function (cellInit) {\n\t    if (!cellInit) {\n\t      throw new Error('dia.Graph: No cell provided.');\n\t    }\n\t    if (this.ignoreLayers) {\n\t      // When layers are ignored, all cells belong to the default layer.\n\t      return this.defaultLayerId;\n\t    }\n\t    const cellAttributes = cellInit[CELL_MARKER] ? cellInit.attributes : cellInit;\n\t    return cellAttributes[config$3.layerAttribute] || this.defaultLayerId;\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Reset the layers in the graph.\n\t   * It assumes the existing cells have been removed beforehand\n\t   * or can be discarded.\n\t   */\n\t  _resetLayers: function (layers, defaultLayerId, options = {}) {\n\t    if (!Array.isArray(layers) || layers.length === 0) {\n\t      throw new Error('dia.Graph: At least one layer must be defined.');\n\t    }\n\n\t    // Resetting layers disables legacy mode\n\t    this.legacyMode = false;\n\t    this.layerCollection.reset(layers, {\n\t      ...options,\n\t      graph: this.cid\n\t    });\n\n\t    // If no default layer is specified, use the first layer as default\n\t    if (defaultLayerId) {\n\t      // The default layer must be one of the defined layers\n\t      if (!this.hasLayer(defaultLayerId)) {\n\t        throw new Error(`dia.Graph: default layer \"${defaultLayerId}\" does not exist.`);\n\t      }\n\t      this.defaultLayerId = defaultLayerId;\n\t    } else {\n\t      this.defaultLayerId = this.layerCollection.at(0).id;\n\t    }\n\t    return this;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Remove multiple cells from the graph.\n\t   * @param {Array<dia.Cell | dia.Cell.ID>} cellRefs - Array of cell references (models or IDs) to remove.\n\t   * @param {Object} [options] - Removal options. See {@link dia.Graph#removeCell}.\n\t   */\n\t  removeCells: function (cellRefs, options) {\n\t    if (!cellRefs.length) return this;\n\t    // Remove multiple cells in a single batch\n\t    this.startBatch('remove', options);\n\t    for (const cellRef of cellRefs) {\n\t      if (!cellRef) continue;\n\t      let cell;\n\t      if (cellRef[CELL_MARKER]) {\n\t        cell = cellRef;\n\t      } else {\n\t        cell = this.getCell(cellRef);\n\t        if (!cell) {\n\t          // The cell might have been already removed (embedded cell, connected link, etc.)\n\t          continue;\n\t        }\n\t      }\n\t      this.layerCollection.removeCell(cell, options);\n\t    }\n\t    this.stopBatch('remove', options);\n\t    return this;\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Replace an existing cell with a new cell.\n\t   */\n\t  _replaceCell: function (currentCell, newCellInit, opt = {}) {\n\t    const batchName = 'replace-cell';\n\t    const replaceOptions = {\n\t      ...opt,\n\t      replace: true\n\t    };\n\t    this.startBatch(batchName, opt);\n\t    // 1. Remove the cell without removing connected links or embedded cells.\n\t    this.layerCollection.removeCell(currentCell, replaceOptions);\n\t    const newCellInitAttributes = newCellInit[CELL_MARKER] ? newCellInit.attributes : newCellInit;\n\t    // 2. Combine the current cell attributes with the new cell attributes\n\t    const replacementCellAttributes = Object.assign({}, currentCell.attributes, newCellInitAttributes);\n\t    let replacement;\n\t    if (newCellInit[CELL_MARKER]) {\n\t      // If the new cell is a model, set the merged attributes on the model\n\t      newCellInit.set(replacementCellAttributes, replaceOptions);\n\t      replacement = newCellInit;\n\t    } else {\n\t      replacement = replacementCellAttributes;\n\t    }\n\n\t    // 3. Add the replacement cell\n\t    this.addCell(replacement, replaceOptions);\n\t    this.stopBatch(batchName, opt);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Synchronize a single graph cell with the provided cell (model or attributes).\n\t   * If the cell with the same `id` exists, it is updated. If the cell does not exist, it is added.\n\t   * If the existing cell type is different from the incoming cell type, the existing cell is replaced.\n\t   */\n\t  _syncCell: function (cellInit, opt = {}) {\n\t    const cellAttributes = cellInit[CELL_MARKER] ? cellInit.attributes : cellInit;\n\t    const currentCell = this.getCell(cellInit.id);\n\t    if (currentCell) {\n\t      // `cellInit` is either a model or attributes object\n\t      if ('type' in cellAttributes && currentCell.get('type') !== cellAttributes.type) {\n\t        // Replace the cell if the type has changed\n\t        this._replaceCell(currentCell, cellInit, opt);\n\t      } else {\n\t        // Update existing cell\n\t        // Note: the existing cell attributes are not removed,\n\t        // if they're missing in `cellAttributes`.\n\t        currentCell.set(cellAttributes, opt);\n\t      }\n\t    } else {\n\t      // The cell does not exist yet, add it\n\t      this.addCell(cellInit, opt);\n\t    }\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Synchronize the graph cells with the provided array of cells (models or attributes).\n\t   */\n\t  syncCells: function (cellInits, opt = {}) {\n\t    const batchName = 'sync-cells';\n\t    const {\n\t      remove = false,\n\t      ...setOpt\n\t    } = opt;\n\t    let currentCells, newCellsMap;\n\t    if (remove) {\n\t      // We need to track existing cells to remove the missing ones later\n\t      currentCells = this.getCells();\n\t      newCellsMap = new Map();\n\t    }\n\n\t    // Observe changes to the graph cells\n\t    let changeObserver, changedLayers;\n\t    const shouldSort = opt.sort !== false;\n\t    if (shouldSort) {\n\t      changeObserver = new Listener();\n\t      changedLayers = new Set();\n\t      changeObserver.listenTo(this, {\n\t        'add': cell => {\n\t          changedLayers.add(this.getCellLayerId(cell));\n\t        },\n\t        'change': cell => {\n\t          if (cell.hasChanged(config$3.layerAttribute) || cell.hasChanged('z')) {\n\t            changedLayers.add(this.getCellLayerId(cell));\n\t          }\n\t        }\n\t      });\n\t    }\n\t    this.startBatch(batchName, opt);\n\n\t    // Prevent multiple sorts during sync\n\t    setOpt.sort = false;\n\n\t    // Add or update incoming cells\n\t    for (const cellInit of cellInits) {\n\t      if (remove) {\n\t        // only track existence\n\t        newCellsMap.set(cellInit.id, true);\n\t      }\n\t      this._syncCell(cellInit, setOpt);\n\t    }\n\t    if (remove) {\n\t      // Remove cells not present in the incoming array\n\t      for (const cell of currentCells) {\n\t        if (!newCellsMap.has(cell.id)) {\n\t          this.layerCollection.removeCell(cell, setOpt);\n\t        }\n\t      }\n\t    }\n\t    if (shouldSort) {\n\t      // Sort layers that had changes affecting z-index or layer\n\t      changeObserver.stopListening();\n\t      for (const layerId of changedLayers) {\n\t        this.getLayer(layerId).cellCollection.sort(opt);\n\t      }\n\t    }\n\t    this.stopBatch(batchName, opt);\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Remove a cell from the graph.\n\t   * @param {dia.Cell} cell\n\t   * @param {Object} [options]\n\t   * @param {boolean} [options.disconnectLinks=false] - If `true`, the connected links are\n\t   * disconnected instead of removed.\n\t   * @param {boolean} [options.clear=false] - If `true`, the connected links\n\t   * are kept. @internal\n\t   * @param {boolean} [options.replace=false] - If `true`, the connected links and\n\t   * embedded cells are kept. @internal\n\t   * @throws Will throw an error if no cell is provided\n\t   * @throws Will throw an error if the ID of the cell to remove\n\t   * does not exist in the graph\n\t   **/\n\t  removeCell: function (cellRef, options) {\n\t    if (!cellRef) {\n\t      throw new Error('dia.Graph: no cell provided.');\n\t    }\n\t    const cell = cellRef[CELL_MARKER] ? cellRef : this.getCell(cellRef);\n\t    if (!cell) {\n\t      throw new Error('dia.Graph: cell to remove does not exist in the graph.');\n\t    }\n\t    if (cell.graph !== this) return;\n\t    this.startBatch('remove', options);\n\t    cell.collection.remove(cell, options);\n\t    this.stopBatch('remove', options);\n\t  },\n\t  transferCellEmbeds: function (sourceCell, targetCell, opt = {}) {\n\t    const batchName = 'transfer-embeds';\n\t    this.startBatch(batchName, opt);\n\n\t    // Embed children of the source cell in the target cell.\n\t    const children = sourceCell.getEmbeddedCells();\n\t    targetCell.embed(children, {\n\t      ...opt,\n\t      reparent: true\n\t    });\n\t    this.stopBatch(batchName, opt);\n\t  },\n\t  transferCellConnectedLinks: function (sourceCell, targetCell, opt = {}) {\n\t    const batchName = 'transfer-connected-links';\n\t    this.startBatch(batchName, opt);\n\n\t    // Reconnect all the links connected to the old cell to the new cell.\n\t    const connectedLinks = this.getConnectedLinks(sourceCell, opt);\n\t    connectedLinks.forEach(link => {\n\t      if (link.getSourceCell() === sourceCell) {\n\t        link.prop(['source', 'id'], targetCell.id, opt);\n\t      }\n\t      if (link.getTargetCell() === sourceCell) {\n\t        link.prop(['target', 'id'], targetCell.id, opt);\n\t      }\n\t    });\n\t    this.stopBatch(batchName, opt);\n\t  },\n\t  /**\n\t   * @private\n\t   * Helper method for addLayer and moveLayer methods\n\t   */\n\t  _getBeforeLayerIdFromOptions(options, layer = null) {\n\t    let {\n\t      index\n\t    } = options;\n\t    const {\n\t      before = null\n\t    } = options;\n\t    if (before && index !== undefined) {\n\t      throw new Error('dia.Graph: Options \"before\" and \"index\" are mutually exclusive.');\n\t    }\n\t    let computedBefore;\n\t    if (index !== undefined) {\n\t      const layersArray = this.getLayers();\n\t      if (index >= layersArray.length) {\n\t        // If index is greater than the number of layers,\n\t        // return before as null (move to the end).\n\t        computedBefore = null;\n\t      } else if (index < 0) {\n\t        // If index is negative, move to the beginning.\n\t        computedBefore = layersArray[0].id;\n\t      } else {\n\t        var _layersArray$index;\n\t        const originalIndex = layersArray.indexOf(layer);\n\t        if (originalIndex !== -1 && index > originalIndex) {\n\t          // If moving a layer upwards in the stack, we need to adjust the index\n\t          // to account for the layer being removed from its original position.\n\t          index += 1;\n\t        }\n\t        // Otherwise, get the layer ID at the specified index.\n\t        computedBefore = ((_layersArray$index = layersArray[index]) === null || _layersArray$index === void 0 ? void 0 : _layersArray$index.id) || null;\n\t      }\n\t    } else {\n\t      computedBefore = before;\n\t    }\n\t    return computedBefore;\n\t  },\n\t  /**\n\t   * @public\n\t   * Adds a new layer to the graph.\n\t   * @param {GraphLayer | GraphLayerJSON} layerInit\n\t   * @param {*} options\n\t   * @param {string | null} [options.before] - ID of the layer\n\t   * before which to insert the new layer. If `null`, the layer is added at the end.\n\t   * @param {number} [options.index] - Zero-based index to which to add the layer.\n\t   * @throws Will throw an error if the layer to add is invalid\n\t   * @throws Will throw an error if a layer with the same ID already exists\n\t   * @throws Will throw if `before` reference is invalid\n\t   */\n\t  addLayer(layerInit, options = {}) {\n\t    if (!layerInit || !layerInit.id) {\n\t      throw new Error('dia.Graph: Layer to add is invalid.');\n\t    }\n\t    if (this.hasLayer(layerInit.id)) {\n\t      throw new Error(`dia.Graph: Layer \"${layerInit.id}\" already exists.`);\n\t    }\n\t    const {\n\t      before = null,\n\t      index,\n\t      ...insertOptions\n\t    } = options;\n\t    insertOptions.graph = this.cid;\n\n\t    // Adding a new layer disables legacy mode\n\t    this.legacyMode = false;\n\t    const beforeId = this._getBeforeLayerIdFromOptions({\n\t      before,\n\t      index\n\t    });\n\t    this.layerCollection.insert(layerInit, beforeId, insertOptions);\n\t  },\n\t  /**\n\t   * @public\n\t   * Moves an existing layer to a new position in the layer stack.\n\t   * @param {string | GraphLayer} layerRef - ID or reference of the layer to move.\n\t   * @param {*} options\n\t   * @param {string | null} [options.before] - ID of the layer\n\t   * before which to insert the moved layer. If `null`, the layer is moved to the end.\n\t   * @param {number} [options.index] - Zero-based index to which to move the layer.\n\t   * @throws Will throw an error if the layer to move does not exist\n\t   * @throws Will throw an error if `before` reference is invalid\n\t   * @throws Will throw an error if both `before` and `index` options are provided\n\t   */\n\t  moveLayer(layerRef, options = {}) {\n\t    if (!layerRef || !this.hasLayer(layerRef)) {\n\t      throw new Error('dia.Graph: Layer to move does not exist.');\n\t    }\n\t    const layer = this.getLayer(layerRef);\n\t    const {\n\t      before = null,\n\t      index,\n\t      ...insertOptions\n\t    } = options;\n\t    insertOptions.graph = this.cid;\n\n\t    // Moving a layer disables legacy mode\n\t    this.legacyMode = false;\n\t    const beforeId = this._getBeforeLayerIdFromOptions({\n\t      before,\n\t      index\n\t    }, layer);\n\t    this.layerCollection.insert(layer, beforeId, insertOptions);\n\t  },\n\t  /**\n\t   * @public\n\t   * Removes an existing layer from the graph.\n\t   * @param {string | GraphLayer} layerRef - ID or reference of the layer to remove.\n\t   * @param {*} options\n\t   * @throws Will throw an error if no layer is provided\n\t   * @throws Will throw an error if the layer to remove does not exist\n\t   */\n\t  removeLayer(layerRef, options = {}) {\n\t    if (!layerRef) {\n\t      throw new Error('dia.Graph: No layer provided.');\n\t    }\n\n\t    // The layer must exist\n\t    const layerId = layerRef.id ? layerRef.id : layerRef;\n\t    const layer = this.getLayer(layerId);\n\n\t    // Prevent removing the default layer\n\t    // Note: if there is only one layer, it is also the default layer.\n\t    const {\n\t      id: defaultLayerId\n\t    } = this.getDefaultLayer();\n\t    if (layerId === defaultLayerId) {\n\t      throw new Error('dia.Graph: default layer cannot be removed.');\n\t    }\n\n\t    // A layer with cells cannot be removed\n\t    if (layer.cellCollection.length > 0) {\n\t      throw new Error(`dia.Graph: Layer \"${layerId}\" cannot be removed because it is not empty.`);\n\t    }\n\t    this.layerCollection.remove(layerId, {\n\t      ...options,\n\t      graph: this.cid\n\t    });\n\t  },\n\t  getDefaultLayer() {\n\t    return this.layerCollection.get(this.defaultLayerId);\n\t  },\n\t  setDefaultLayer(layerRef, options = {}) {\n\t    if (!layerRef) {\n\t      throw new Error('dia.Graph: No default layer ID provided.');\n\t    }\n\n\t    // Make sure the layer exists\n\t    const defaultLayerId = layerRef.id ? layerRef.id : layerRef;\n\t    const defaultLayer = this.getLayer(defaultLayerId);\n\n\t    // If the default layer is not changing, do nothing\n\t    const currentDefaultLayerId = this.defaultLayerId;\n\t    if (defaultLayerId === currentDefaultLayerId) {\n\t      // The default layer stays the same\n\t      return;\n\t    }\n\n\t    // Get all cells that belong to the current default layer implicitly\n\t    const implicitLayerCells = this.getImplicitLayerCells();\n\n\t    // Set the new default layer ID\n\t    this.defaultLayerId = defaultLayerId;\n\t    const batchName = 'default-layer-change';\n\t    this.startBatch(batchName, options);\n\t    if (implicitLayerCells.length > 0) {\n\t      // Reassign any cells lacking an explicit layer to the new default layer.\n\t      // Do not sort yet, wait until all cells are moved.\n\t      const moveOptions = {\n\t        ...options,\n\t        sort: false\n\t      };\n\t      for (const cell of implicitLayerCells) {\n\t        this.layerCollection.moveCellBetweenLayers(cell, defaultLayerId, moveOptions);\n\t      }\n\t      // Now sort the new default layer\n\t      if (options.sort !== false) {\n\t        defaultLayer.cellCollection.sort(options);\n\t      }\n\t    }\n\n\t    // Pretend to trigger the event on the layer itself.\n\t    // It will bubble up as `layer:default` event on the graph.\n\t    defaultLayer.trigger(defaultLayer.eventPrefix + 'default', defaultLayer, {\n\t      ...options,\n\t      previousDefaultLayerId: currentDefaultLayerId\n\t    });\n\t    this.stopBatch(batchName, options);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Get all cells that do not have an explicit layer assigned.\n\t   * These cells belong to the default layer implicitly.\n\t   * @return {Array<dia.Cell>} Array of cells without an explicit layer.\n\t   */\n\t  getImplicitLayerCells() {\n\t    return this.getDefaultLayer().cellCollection.filter(cell => {\n\t      return cell.get(config$3.layerAttribute) == null;\n\t    });\n\t  },\n\t  getLayer(layerId) {\n\t    if (!this.hasLayer(layerId)) {\n\t      throw new Error(`dia.Graph: Layer \"${layerId}\" does not exist.`);\n\t    }\n\t    return this.layerCollection.get(layerId);\n\t  },\n\t  hasLayer(layerRef) {\n\t    return this.layerCollection.has(layerRef);\n\t  },\n\t  getLayers() {\n\t    return this.layerCollection.toArray();\n\t  },\n\t  getCell: function (cellRef) {\n\t    return this.layerCollection.getCell(cellRef);\n\t  },\n\t  getCells: function () {\n\t    return this.layerCollection.getCells();\n\t  },\n\t  getElements: function () {\n\t    return this.getCells().filter(cell => cell.isElement());\n\t  },\n\t  getLinks: function () {\n\t    return this.getCells().filter(cell => cell.isLink());\n\t  },\n\t  getFirstCell: function (layerId) {\n\t    let layer;\n\t    if (!layerId) {\n\t      // Get the first cell from the bottom-most layer\n\t      layer = this.getLayers().at(0);\n\t    } else {\n\t      layer = this.getLayer(layerId);\n\t    }\n\t    return layer.cellCollection.models.at(0);\n\t  },\n\t  getLastCell: function (layerId) {\n\t    let layer;\n\t    if (!layerId) {\n\t      // Get the last cell from the top-most layer\n\t      layer = this.getLayers().at(-1);\n\t    } else {\n\t      layer = this.getLayer(layerId);\n\t    }\n\t    return layer.cellCollection.models.at(-1);\n\t  },\n\t  // Get all inbound and outbound links connected to the cell `model`.\n\t  getConnectedLinks: function (model, opt) {\n\t    opt = opt || {};\n\t    var indirect = opt.indirect;\n\t    var inbound = opt.inbound;\n\t    var outbound = opt.outbound;\n\t    if (inbound === undefined && outbound === undefined) {\n\t      inbound = outbound = true;\n\t    }\n\n\t    // the final array of connected link models\n\t    var links = [];\n\t    // a hash table of connected edges of the form: [edgeId] -> true\n\t    // used for quick lookups to check if we already added a link\n\t    var edges = {};\n\t    if (outbound) {\n\t      addOutbounds(this, model);\n\t    }\n\t    if (inbound) {\n\t      addInbounds(this, model);\n\t    }\n\t    function addOutbounds(graph, model) {\n\t      forIn(graph.topologyIndex.getOutboundEdges(model.id), function (_, edge) {\n\t        // skip links that were already added\n\t        // (those must be self-loop links)\n\t        // (because they are inbound and outbound edges of the same two elements)\n\t        if (edges[edge]) return;\n\t        var link = graph.getCell(edge);\n\t        if (!link) return;\n\t        links.push(link);\n\t        edges[edge] = true;\n\t        if (indirect) {\n\t          if (inbound) addInbounds(graph, link);\n\t          if (outbound) addOutbounds(graph, link);\n\t        }\n\t      }.bind(graph));\n\t      if (indirect && model.isLink()) {\n\t        var outCell = model.getTargetCell();\n\t        if (outCell && outCell.isLink()) {\n\t          if (!edges[outCell.id]) {\n\t            links.push(outCell);\n\t            addOutbounds(graph, outCell);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    function addInbounds(graph, model) {\n\t      forIn(graph.topologyIndex.getInboundEdges(model.id), function (_, edge) {\n\t        // skip links that were already added\n\t        // (those must be self-loop links)\n\t        // (because they are inbound and outbound edges of the same two elements)\n\t        if (edges[edge]) return;\n\t        var link = graph.getCell(edge);\n\t        if (!link) return;\n\t        links.push(link);\n\t        edges[edge] = true;\n\t        if (indirect) {\n\t          if (inbound) addInbounds(graph, link);\n\t          if (outbound) addOutbounds(graph, link);\n\t        }\n\t      }.bind(graph));\n\t      if (indirect && model.isLink()) {\n\t        var inCell = model.getSourceCell();\n\t        if (inCell && inCell.isLink()) {\n\t          if (!edges[inCell.id]) {\n\t            links.push(inCell);\n\t            addInbounds(graph, inCell);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n\t    if (opt.deep) {\n\t      var embeddedCells = model.getEmbeddedCells({\n\t        deep: true\n\t      });\n\n\t      // in the first round, we collect all the embedded elements\n\t      var embeddedElements = {};\n\t      embeddedCells.forEach(function (cell) {\n\t        if (cell.isElement()) {\n\t          embeddedElements[cell.id] = true;\n\t        }\n\t      });\n\t      embeddedCells.forEach(function (cell) {\n\t        if (cell.isLink()) return;\n\t        if (outbound) {\n\t          forIn(this.topologyIndex.getOutboundEdges(cell.id), function (exists, edge) {\n\t            if (!edges[edge]) {\n\t              var edgeCell = this.getCell(edge);\n\t              var {\n\t                source,\n\t                target\n\t              } = edgeCell.attributes;\n\t              var sourceId = source.id;\n\t              var targetId = target.id;\n\n\t              // if `includeEnclosed` option is falsy, skip enclosed links\n\t              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n\t                return;\n\t              }\n\t              links.push(this.getCell(edge));\n\t              edges[edge] = true;\n\t            }\n\t          }.bind(this));\n\t        }\n\t        if (inbound) {\n\t          forIn(this.topologyIndex.getInboundEdges(cell.id), function (exists, edge) {\n\t            if (!edges[edge]) {\n\t              var edgeCell = this.getCell(edge);\n\t              var {\n\t                source,\n\t                target\n\t              } = edgeCell.attributes;\n\t              var sourceId = source.id;\n\t              var targetId = target.id;\n\n\t              // if `includeEnclosed` option is falsy, skip enclosed links\n\t              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n\t                return;\n\t              }\n\t              links.push(this.getCell(edge));\n\t              edges[edge] = true;\n\t            }\n\t          }.bind(this));\n\t        }\n\t      }, this);\n\t    }\n\t    return links;\n\t  },\n\t  getNeighbors: function (model, opt) {\n\t    opt || (opt = {});\n\t    var inbound = opt.inbound;\n\t    var outbound = opt.outbound;\n\t    if (inbound === undefined && outbound === undefined) {\n\t      inbound = outbound = true;\n\t    }\n\t    var neighbors = this.getConnectedLinks(model, opt).reduce(function (res, link) {\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\t      var loop = link.hasLoop(opt);\n\n\t      // Discard if it is a point, or if the neighbor was already added.\n\t      if (inbound && has(source, 'id') && !res[source.id]) {\n\t        var sourceElement = this.getCell(source.id);\n\t        if (sourceElement.isElement()) {\n\t          if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {\n\t            res[source.id] = sourceElement;\n\t          }\n\t        }\n\t      }\n\n\t      // Discard if it is a point, or if the neighbor was already added.\n\t      if (outbound && has(target, 'id') && !res[target.id]) {\n\t        var targetElement = this.getCell(target.id);\n\t        if (targetElement.isElement()) {\n\t          if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {\n\t            res[target.id] = targetElement;\n\t          }\n\t        }\n\t      }\n\t      return res;\n\t    }.bind(this), {});\n\t    if (model.isLink()) {\n\t      if (inbound) {\n\t        var sourceCell = model.getSourceCell();\n\t        if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n\t          neighbors[sourceCell.id] = sourceCell;\n\t        }\n\t      }\n\t      if (outbound) {\n\t        var targetCell = model.getTargetCell();\n\t        if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n\t          neighbors[targetCell.id] = targetCell;\n\t        }\n\t      }\n\t    }\n\t    return toArray$1(neighbors);\n\t  },\n\t  getCommonAncestor: function /* cells */\n\t  () {\n\t    var cellsAncestors = Array.from(arguments).map(function (cell) {\n\t      var ancestors = [];\n\t      var parentId = cell.get('parent');\n\t      while (parentId) {\n\t        ancestors.push(parentId);\n\t        parentId = this.getCell(parentId).get('parent');\n\t      }\n\t      return ancestors;\n\t    }, this);\n\t    cellsAncestors = cellsAncestors.sort(function (a, b) {\n\t      return a.length - b.length;\n\t    });\n\t    var commonAncestor = toArray$1(cellsAncestors.shift()).find(function (ancestor) {\n\t      return cellsAncestors.every(function (cellAncestors) {\n\t        return cellAncestors.includes(ancestor);\n\t      });\n\t    });\n\t    return this.getCell(commonAncestor);\n\t  },\n\t  // Find the whole branch starting at `element`.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n\t  getSuccessors: function (element, opt) {\n\t    opt = opt || {};\n\t    var res = [];\n\t    // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n\t    this.search(element, function (el) {\n\t      if (el !== element) {\n\t        res.push(el);\n\t      }\n\t    }, assign({}, opt, {\n\t      outbound: true\n\t    }));\n\t    return res;\n\t  },\n\t  cloneCells: cloneCells,\n\t  // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n\t  // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n\t  // Return a map of the form: [original cell ID] -> [clone].\n\t  cloneSubgraph: function (cells, opt) {\n\t    var subgraph = this.getSubgraph(cells, opt);\n\t    return this.cloneCells(subgraph);\n\t  },\n\t  // Return `cells` and all the connected links that connect cells in the `cells` array.\n\t  // If `opt.deep` is `true`, return all the cells including all their embedded cells\n\t  // and all the links that connect any of the returned cells.\n\t  // For example, for a single shallow element, the result is that very same element.\n\t  // For two elements connected with a link: `A --- L ---> B`, the result for\n\t  // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n\t  getSubgraph: function (cells, opt) {\n\t    opt = opt || {};\n\t    var subgraph = [];\n\t    // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n\t    var cellMap = {};\n\t    var elements = [];\n\t    var links = [];\n\t    toArray$1(cells).forEach(function (cell) {\n\t      if (!cellMap[cell.id]) {\n\t        subgraph.push(cell);\n\t        cellMap[cell.id] = cell;\n\t        if (cell.isLink()) {\n\t          links.push(cell);\n\t        } else {\n\t          elements.push(cell);\n\t        }\n\t      }\n\t      if (opt.deep) {\n\t        var embeds = cell.getEmbeddedCells({\n\t          deep: true\n\t        });\n\t        embeds.forEach(function (embed) {\n\t          if (!cellMap[embed.id]) {\n\t            subgraph.push(embed);\n\t            cellMap[embed.id] = embed;\n\t            if (embed.isLink()) {\n\t              links.push(embed);\n\t            } else {\n\t              elements.push(embed);\n\t            }\n\t          }\n\t        });\n\t      }\n\t    });\n\t    links.forEach(function (link) {\n\t      // For links, return their source & target (if they are elements - not points).\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\t      if (source.id && !cellMap[source.id]) {\n\t        var sourceElement = this.getCell(source.id);\n\t        subgraph.push(sourceElement);\n\t        cellMap[sourceElement.id] = sourceElement;\n\t        elements.push(sourceElement);\n\t      }\n\t      if (target.id && !cellMap[target.id]) {\n\t        var targetElement = this.getCell(target.id);\n\t        subgraph.push(this.getCell(target.id));\n\t        cellMap[targetElement.id] = targetElement;\n\t        elements.push(targetElement);\n\t      }\n\t    }, this);\n\t    elements.forEach(function (element) {\n\t      // For elements, include their connected links if their source/target is in the subgraph;\n\t      var links = this.getConnectedLinks(element, opt);\n\t      links.forEach(function (link) {\n\t        var {\n\t          source,\n\t          target\n\t        } = link.attributes;\n\t        if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n\t          subgraph.push(link);\n\t          cellMap[link.id] = link;\n\t        }\n\t      });\n\t    }, this);\n\t    return subgraph;\n\t  },\n\t  // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n\t  getPredecessors: function (element, opt) {\n\t    opt = opt || {};\n\t    var res = [];\n\t    // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n\t    this.search(element, function (el) {\n\t      if (el !== element) {\n\t        res.push(el);\n\t      }\n\t    }, assign({}, opt, {\n\t      inbound: true\n\t    }));\n\t    return res;\n\t  },\n\t  // Perform search on the graph.\n\t  // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n\t  // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // `iteratee` is a function of the form `function(element) {}`.\n\t  // If `iteratee` explicitly returns `false`, the searching stops.\n\t  search: function (element, iteratee, opt) {\n\t    opt = opt || {};\n\t    if (opt.breadthFirst) {\n\t      this.bfs(element, iteratee, opt);\n\t    } else {\n\t      this.dfs(element, iteratee, opt);\n\t    }\n\t  },\n\t  // Breadth-first search.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n\t  // `iteratee` is a function of the form `function(element, distance) {}`.\n\t  // where `element` is the currently visited element and `distance` is the distance of that element\n\t  // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n\t  // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n\t  // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n\t  // If `iteratee` explicitly returns `false`, the searching stops.\n\t  bfs: function (element, iteratee, opt = {}) {\n\t    const visited = {};\n\t    const distance = {};\n\t    const queue = [];\n\t    queue.push(element);\n\t    distance[element.id] = 0;\n\t    while (queue.length > 0) {\n\t      var next = queue.shift();\n\t      if (visited[next.id]) continue;\n\t      visited[next.id] = true;\n\t      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n\t      const neighbors = this.getNeighbors(next, opt);\n\t      for (let i = 0, n = neighbors.length; i < n; i++) {\n\t        const neighbor = neighbors[i];\n\t        distance[neighbor.id] = distance[next.id] + 1;\n\t        queue.push(neighbor);\n\t      }\n\t    }\n\t  },\n\t  // Depth-first search.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n\t  // `iteratee` is a function of the form `function(element, distance) {}`.\n\t  // If `iteratee` explicitly returns `false`, the search stops.\n\t  dfs: function (element, iteratee, opt = {}) {\n\t    const visited = {};\n\t    const distance = {};\n\t    const queue = [];\n\t    queue.push(element);\n\t    distance[element.id] = 0;\n\t    while (queue.length > 0) {\n\t      const next = queue.pop();\n\t      if (visited[next.id]) continue;\n\t      visited[next.id] = true;\n\t      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n\t      const neighbors = this.getNeighbors(next, opt);\n\t      const lastIndex = queue.length;\n\t      for (let i = 0, n = neighbors.length; i < n; i++) {\n\t        const neighbor = neighbors[i];\n\t        distance[neighbor.id] = distance[next.id] + 1;\n\t        queue.splice(lastIndex, 0, neighbor);\n\t      }\n\t    }\n\t  },\n\t  // Get all the roots of the graph. Time complexity: O(|V|).\n\t  getSources: function () {\n\t    return this.topologyIndex.getSourceNodes().map(nodeId => this.getCell(nodeId));\n\t  },\n\t  // Get all the leafs of the graph. Time complexity: O(|V|).\n\t  getSinks: function () {\n\t    return this.topologyIndex.getSinkNodes().map(nodeId => this.getCell(nodeId));\n\t  },\n\t  // Return `true` if `element` is a root. Time complexity: O(1).\n\t  isSource: function (element) {\n\t    return this.topologyIndex.isSourceNode(element.id);\n\t  },\n\t  // Return `true` if `element` is a leaf. Time complexity: O(1).\n\t  isSink: function (element) {\n\t    return this.topologyIndex.isSinkNode(element.id);\n\t  },\n\t  // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n\t  isSuccessor: function (elementA, elementB) {\n\t    var isSuccessor = false;\n\t    this.search(elementA, function (element) {\n\t      if (element === elementB && element !== elementA) {\n\t        isSuccessor = true;\n\t        return false;\n\t      }\n\t    }, {\n\t      outbound: true\n\t    });\n\t    return isSuccessor;\n\t  },\n\t  // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n\t  isPredecessor: function (elementA, elementB) {\n\t    var isPredecessor = false;\n\t    this.search(elementA, function (element) {\n\t      if (element === elementB && element !== elementA) {\n\t        isPredecessor = true;\n\t        return false;\n\t      }\n\t    }, {\n\t      inbound: true\n\t    });\n\t    return isPredecessor;\n\t  },\n\t  // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n\t  // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n\t  // for more details.\n\t  // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n\t  // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n\t  isNeighbor: function (elementA, elementB, opt) {\n\t    opt = opt || {};\n\t    var inbound = opt.inbound;\n\t    var outbound = opt.outbound;\n\t    if (inbound === undefined && outbound === undefined) {\n\t      inbound = outbound = true;\n\t    }\n\t    var isNeighbor = false;\n\t    this.getConnectedLinks(elementA, opt).forEach(function (link) {\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\n\t      // Discard if it is a point.\n\t      if (inbound && has(source, 'id') && source.id === elementB.id) {\n\t        isNeighbor = true;\n\t        return false;\n\t      }\n\n\t      // Discard if it is a point, or if the neighbor was already added.\n\t      if (outbound && has(target, 'id') && target.id === elementB.id) {\n\t        isNeighbor = true;\n\t        return false;\n\t      }\n\t    });\n\t    return isNeighbor;\n\t  },\n\t  // Disconnect links connected to the cell `model`.\n\t  disconnectLinks: function (model, opt) {\n\t    this.getConnectedLinks(model).forEach(function (link) {\n\t      link.set(link.attributes.source.id === model.id ? 'source' : 'target', {\n\t        x: 0,\n\t        y: 0\n\t      }, opt);\n\t    });\n\t  },\n\t  // Remove links connected to the cell `model` completely.\n\t  removeLinks: function (cell, opt) {\n\t    this.getConnectedLinks(cell).forEach(link => {\n\t      this.layerCollection.removeCell(link, opt);\n\t    });\n\t  },\n\t  // Find all cells at given point\n\n\t  findElementsAtPoint: function (point, opt) {\n\t    return this._filterAtPoint(this.getElements(), point, opt);\n\t  },\n\t  findLinksAtPoint: function (point, opt) {\n\t    return this._filterAtPoint(this.getLinks(), point, opt);\n\t  },\n\t  findCellsAtPoint: function (point, opt) {\n\t    return this._filterAtPoint(this.getCells(), point, opt);\n\t  },\n\t  _filterAtPoint: function (cells, point, opt = {}) {\n\t    return cells.filter(el => el.getBBox({\n\t      rotate: true\n\t    }).containsPoint(point, opt));\n\t  },\n\t  // Find all cells in given area\n\n\t  findElementsInArea: function (area, opt = {}) {\n\t    return this._filterInArea(this.getElements(), area, opt);\n\t  },\n\t  findLinksInArea: function (area, opt = {}) {\n\t    return this._filterInArea(this.getLinks(), area, opt);\n\t  },\n\t  findCellsInArea: function (area, opt = {}) {\n\t    return this._filterInArea(this.getCells(), area, opt);\n\t  },\n\t  _filterInArea: function (cells, area, opt = {}) {\n\t    const r = new Rect(area);\n\t    const {\n\t      strict = false\n\t    } = opt;\n\t    const method = strict ? 'containsRect' : 'intersect';\n\t    return cells.filter(el => r[method](el.getBBox({\n\t      rotate: true\n\t    })));\n\t  },\n\t  // Find all cells under the given element.\n\n\t  findElementsUnderElement: function (element, opt) {\n\t    return this._filterCellsUnderElement(this.getElements(), element, opt);\n\t  },\n\t  findLinksUnderElement: function (element, opt) {\n\t    return this._filterCellsUnderElement(this.getLinks(), element, opt);\n\t  },\n\t  findCellsUnderElement: function (element, opt) {\n\t    return this._filterCellsUnderElement(this.getCells(), element, opt);\n\t  },\n\t  _isValidElementUnderElement: function (el1, el2) {\n\t    return el1.id !== el2.id && !el1.isEmbeddedIn(el2);\n\t  },\n\t  _isValidLinkUnderElement: function (link, el) {\n\t    return link.source().id !== el.id && link.target().id !== el.id && !link.isEmbeddedIn(el);\n\t  },\n\t  _validateCellsUnderElement: function (cells, element) {\n\t    return cells.filter(cell => {\n\t      return cell.isLink() ? this._isValidLinkUnderElement(cell, element) : this._isValidElementUnderElement(cell, element);\n\t    });\n\t  },\n\t  _getFindUnderElementGeometry: function (element, searchBy = 'bbox') {\n\t    const bbox = element.getBBox({\n\t      rotate: true\n\t    });\n\t    return searchBy !== 'bbox' ? getRectPoint(bbox, searchBy) : bbox;\n\t  },\n\t  _filterCellsUnderElement: function (cells, element, opt = {}) {\n\t    const geometry = this._getFindUnderElementGeometry(element, opt.searchBy);\n\t    const filteredCells = geometry.type === types.Point ? this._filterAtPoint(cells, geometry) : this._filterInArea(cells, geometry, opt);\n\t    return this._validateCellsUnderElement(filteredCells, element);\n\t  },\n\t  // @deprecated use `findElementsInArea` instead\n\t  findModelsInArea: function (area, opt) {\n\t    return this.findElementsInArea(area, opt);\n\t  },\n\t  // @deprecated use `findElementsAtPoint` instead\n\t  findModelsFromPoint: function (point) {\n\t    return this.findElementsAtPoint(point);\n\t  },\n\t  // @deprecated use `findModelsUnderElement` instead\n\t  findModelsUnderElement: function (element, opt) {\n\t    return this.findElementsUnderElement(element, opt);\n\t  },\n\t  // Return bounding box of all elements.\n\t  getBBox: function () {\n\t    return this.getCellsBBox(this.getCells());\n\t  },\n\t  // Return the bounding box of all cells in array provided.\n\t  getCellsBBox: function (cells, opt = {}) {\n\t    const {\n\t      rotate = true\n\t    } = opt;\n\t    return toArray$1(cells).reduce(function (memo, cell) {\n\t      const rect = cell.getBBox({\n\t        rotate\n\t      });\n\t      if (!rect) return memo;\n\t      if (memo) {\n\t        return memo.union(rect);\n\t      }\n\t      return rect;\n\t    }, null);\n\t  },\n\t  translate: function (dx, dy, opt) {\n\t    // Don't translate cells that are embedded in any other cell.\n\t    var cells = this.getCells().filter(function (cell) {\n\t      return !cell.isEmbedded();\n\t    });\n\t    invoke(cells, 'translate', dx, dy, opt);\n\t    return this;\n\t  },\n\t  resize: function (width, height, opt) {\n\t    return this.resizeCells(width, height, this.getCells(), opt);\n\t  },\n\t  resizeCells: function (width, height, cells, opt) {\n\t    // `getBBox` method returns `null` if no elements provided.\n\t    // i.e. cells can be an array of links\n\t    var bbox = this.getCellsBBox(cells);\n\t    if (bbox) {\n\t      var sx = Math.max(width / bbox.width, 0);\n\t      var sy = Math.max(height / bbox.height, 0);\n\t      invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n\t    }\n\t    return this;\n\t  },\n\t  startBatch: function (name, data) {\n\t    data = data || {};\n\t    this._batches[name] = (this._batches[name] || 0) + 1;\n\t    return this.trigger('batch:start', assign({}, data, {\n\t      batchName: name\n\t    }));\n\t  },\n\t  stopBatch: function (name, data) {\n\t    data = data || {};\n\t    this._batches[name] = (this._batches[name] || 0) - 1;\n\t    return this.trigger('batch:stop', assign({}, data, {\n\t      batchName: name\n\t    }));\n\t  },\n\t  hasActiveBatch: function (name) {\n\t    const batches = this._batches;\n\t    let names;\n\t    if (arguments.length === 0) {\n\t      names = Object.keys(batches);\n\t    } else if (Array.isArray(name)) {\n\t      names = name;\n\t    } else {\n\t      names = [name];\n\t    }\n\t    return names.some(batch => batches[batch] > 0);\n\t  }\n\t}, {\n\t  validations: {\n\t    multiLinks: function (graph, link) {\n\t      // Do not allow multiple links to have the same source and target.\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\t      if (source.id && target.id) {\n\t        var sourceModel = link.getSourceCell();\n\t        if (sourceModel) {\n\t          var connectedLinks = graph.getConnectedLinks(sourceModel, {\n\t            outbound: true\n\t          });\n\t          var sameLinks = connectedLinks.filter(function (_link) {\n\t            var {\n\t              source: _source,\n\t              target: _target\n\t            } = _link.attributes;\n\t            return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);\n\t          });\n\t          if (sameLinks.length > 1) {\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t      return true;\n\t    },\n\t    linkPinning: function (_graph, link) {\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\t      return source.id && target.id;\n\t    }\n\t  }\n\t});\n\twrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n\n\tconst calcAttributesList = ['transform', 'x', 'y', 'cx', 'cy', 'dx', 'dy', 'x1', 'y1', 'x2', 'y2', 'points', 'd', 'r', 'rx', 'ry', 'width', 'height', 'stroke-width', 'font-size'];\n\tconst positiveValueList = ['r', 'rx', 'ry', 'width', 'height', 'stroke-width', 'font-size'];\n\tconst calcAttributes = calcAttributesList.reduce((acc, attrName) => {\n\t  acc[attrName] = true;\n\t  return acc;\n\t}, {});\n\tconst positiveValueAttributes = positiveValueList.reduce((acc, attrName) => {\n\t  acc[attrName] = true;\n\t  return acc;\n\t}, {});\n\tfunction evalAttributes(attrs, refBBox) {\n\t  const evalAttrs = {};\n\t  for (const attrName in attrs) {\n\t    if (!attrs.hasOwnProperty(attrName)) continue;\n\t    evalAttrs[attrName] = evalAttribute(attrName, attrs[attrName], refBBox);\n\t  }\n\t  return evalAttrs;\n\t}\n\tfunction evalAttribute(attrName, attrValue, refBBox) {\n\t  if (attrName in calcAttributes && isCalcExpression(attrValue)) {\n\t    let evalAttrValue = evalCalcExpression(attrValue, refBBox);\n\t    if (attrName in positiveValueAttributes) {\n\t      evalAttrValue = Math.max(0, evalAttrValue);\n\t    }\n\t    return evalAttrValue;\n\t  }\n\t  return attrValue;\n\t}\n\n\tconst HighlightingTypes$1 = {\n\t  DEFAULT: 'default',\n\t  EMBEDDING: 'embedding',\n\t  CONNECTING: 'connecting',\n\t  MAGNET_AVAILABILITY: 'magnetAvailability',\n\t  ELEMENT_AVAILABILITY: 'elementAvailability'\n\t};\n\tconst Flags$2 = {\n\t  TOOLS: 'TOOLS'\n\t};\n\n\t// CellView base view and controller.\n\t// --------------------------------------------\n\n\t// This is the base view and controller for `ElementView` and `LinkView`.\n\tconst CellView = View.extend({\n\t  tagName: 'g',\n\t  svgElement: true,\n\t  selector: 'root',\n\t  metrics: null,\n\t  className: function () {\n\t    var classNames = ['cell'];\n\t    var type = this.model.get('type');\n\t    if (type) {\n\t      type.toLowerCase().split('.').forEach(function (value, index, list) {\n\t        classNames.push('type-' + list.slice(0, index + 1).join('-'));\n\t      });\n\t    }\n\t    return classNames.join(' ');\n\t  },\n\t  _presentationAttributes: null,\n\t  _flags: null,\n\t  setFlags: function () {\n\t    var flags = {};\n\t    var attributes = {};\n\t    var shift = 0;\n\t    var i, n, label;\n\t    var presentationAttributes = result(this, 'presentationAttributes');\n\t    for (var attribute in presentationAttributes) {\n\t      if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n\t      var labels = presentationAttributes[attribute];\n\t      if (!Array.isArray(labels)) labels = [labels];\n\t      for (i = 0, n = labels.length; i < n; i++) {\n\t        label = labels[i];\n\t        var flag = flags[label];\n\t        if (!flag) {\n\t          flag = flags[label] = 1 << shift++;\n\t        }\n\t        attributes[attribute] |= flag;\n\t      }\n\t    }\n\t    var initFlag = result(this, 'initFlag');\n\t    if (!Array.isArray(initFlag)) initFlag = [initFlag];\n\t    for (i = 0, n = initFlag.length; i < n; i++) {\n\t      label = initFlag[i];\n\t      if (!flags[label]) flags[label] = 1 << shift++;\n\t    }\n\n\t    // 26 - 30 are reserved for paper flags\n\t    // 31+ overflows maximal number\n\t    if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\t    this._flags = flags;\n\t    this._presentationAttributes = attributes;\n\t  },\n\t  hasFlag: function (flag, label) {\n\t    return flag & this.getFlag(label);\n\t  },\n\t  removeFlag: function (flag, label) {\n\t    return flag ^ flag & this.getFlag(label);\n\t  },\n\t  getFlag: function (label) {\n\t    var flags = this._flags;\n\t    if (!flags) return 0;\n\t    var flag = 0;\n\t    if (Array.isArray(label)) {\n\t      for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n\t    } else {\n\t      flag |= flags[label];\n\t    }\n\t    return flag;\n\t  },\n\t  attributes: function () {\n\t    var cell = this.model;\n\t    return {\n\t      'model-id': cell.id,\n\t      'data-type': cell.attributes.type\n\t    };\n\t  },\n\t  constructor: function (options) {\n\t    // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n\t    // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n\t    // still be associated to the same object among all those clients. This is necessary for real-time\n\t    // collaboration mechanism.\n\t    options.id = options.id || guid(this);\n\t    View.call(this, options);\n\t  },\n\t  initialize: function () {\n\t    this.setFlags();\n\t    View.prototype.initialize.apply(this, arguments);\n\t    this.cleanNodesCache();\n\t    this.startListening();\n\t  },\n\t  startListening: function () {\n\t    this.listenTo(this.model, 'change', this.onAttributesChange);\n\t  },\n\t  onAttributesChange: function (model, opt) {\n\t    var flag = model.getChangeFlag(this._presentationAttributes);\n\t    if (opt.updateHandled || !flag) return;\n\t    if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n\t    // TODO: tool changes does not need to be sync\n\t    // Fix Segments tools\n\t    if (opt.tool) opt.async = false;\n\t    this.requestUpdate(flag, opt);\n\t  },\n\t  requestUpdate: function (flags, opt) {\n\t    const {\n\t      paper\n\t    } = this;\n\t    if (paper && flags > 0) {\n\t      paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n\t    }\n\t  },\n\t  parseDOMJSON: function (markup, root) {\n\t    var doc = parseDOMJSON(markup);\n\t    var selectors = doc.selectors;\n\t    var groups = doc.groupSelectors;\n\t    for (var group in groups) {\n\t      if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n\t      selectors[group] = groups[group];\n\t    }\n\t    if (root) {\n\t      var rootSelector = this.selector;\n\t      if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n\t      selectors[rootSelector] = root;\n\t    }\n\t    return {\n\t      fragment: doc.fragment,\n\t      selectors: selectors\n\t    };\n\t  },\n\t  // Return `true` if cell link is allowed to perform a certain UI `feature`.\n\t  // Example: `can('labelMove')`.\n\t  can: function (feature) {\n\t    var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n\t    return isObject(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;\n\t  },\n\t  findBySelector: function (selector, root, selectors) {\n\t    // These are either descendants of `this.$el` of `this.$el` itself.\n\t    // `.` is a special selector used to select the wrapping `<g>` element.\n\t    if (!selector || selector === '.') return [root];\n\t    if (selectors) {\n\t      var nodes = selectors[selector];\n\t      if (nodes) {\n\t        if (Array.isArray(nodes)) return nodes;\n\t        return [nodes];\n\t      }\n\t    }\n\n\t    // Maintaining backwards compatibility\n\t    // e.g. `circle:first` would fail with querySelector() call\n\t    if (this.useCSSSelectors) return $(root).find(selector).toArray();\n\t    return [];\n\t  },\n\t  findNodes: function (selector) {\n\t    return this.findBySelector(selector, this.el, this.selectors);\n\t  },\n\t  findNode: function (selector) {\n\t    const [node = null] = this.findNodes(selector);\n\t    return node;\n\t  },\n\t  notify: function (eventName) {\n\t    if (this.paper) {\n\t      var args = Array.prototype.slice.call(arguments, 1);\n\n\t      // Trigger the event on both the element itself and also on the paper.\n\t      this.trigger.apply(this, [eventName].concat(args));\n\n\t      // Paper event handlers receive the view object as the first argument.\n\t      this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n\t    }\n\t  },\n\t  getBBox: function (opt) {\n\t    var bbox;\n\t    if (opt && opt.useModelGeometry) {\n\t      var model = this.model;\n\t      bbox = model.getBBox().bbox(model.angle());\n\t    } else {\n\t      bbox = this.getNodeBBox(this.el);\n\t    }\n\t    return this.paper.localToPaperRect(bbox);\n\t  },\n\t  getNodeBBox: function (magnet) {\n\t    const rect = this.getNodeBoundingRect(magnet);\n\t    const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n\t    const magnetMatrix = this.getNodeMatrix(magnet);\n\t    return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n\t  },\n\t  getNodeRotateMatrix(node) {\n\t    if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n\t      // Rotate transformation is applied to all nodes when no rotatableGroup\n\t      // is present or to nodes inside the rotatableGroup only.\n\t      return this.getRootRotateMatrix();\n\t    }\n\t    // Nodes outside the rotatable group\n\t    return V.createSVGMatrix();\n\t  },\n\t  getNodeUnrotatedBBox: function (magnet) {\n\t    var rect = this.getNodeBoundingRect(magnet);\n\t    var magnetMatrix = this.getNodeMatrix(magnet);\n\t    var translateMatrix = this.getRootTranslateMatrix();\n\t    return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n\t  },\n\t  getRootTranslateMatrix: function () {\n\t    var model = this.model;\n\t    var position = model.position();\n\t    var mt = V.createSVGMatrix().translate(position.x, position.y);\n\t    return mt;\n\t  },\n\t  getRootRotateMatrix: function () {\n\t    var mr = V.createSVGMatrix();\n\t    var model = this.model;\n\t    var angle = model.angle();\n\t    if (angle) {\n\t      var bbox = model.getBBox();\n\t      var cx = bbox.width / 2;\n\t      var cy = bbox.height / 2;\n\t      mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n\t    }\n\t    return mr;\n\t  },\n\t  _notifyHighlight: function (eventName, el, opt = {}) {\n\t    const {\n\t      el: rootNode\n\t    } = this;\n\t    let node;\n\t    if (typeof el === 'string') {\n\t      node = this.findNode(el) || rootNode;\n\t    } else {\n\t      [node = rootNode] = this.$(el);\n\t    }\n\t    // set partial flag if the highlighted element is not the entire view.\n\t    opt.partial = node !== rootNode;\n\t    // translate type flag into a type string\n\t    if (opt.type === undefined) {\n\t      let type;\n\t      switch (true) {\n\t        case opt.embedding:\n\t          type = HighlightingTypes$1.EMBEDDING;\n\t          break;\n\t        case opt.connecting:\n\t          type = HighlightingTypes$1.CONNECTING;\n\t          break;\n\t        case opt.magnetAvailability:\n\t          type = HighlightingTypes$1.MAGNET_AVAILABILITY;\n\t          break;\n\t        case opt.elementAvailability:\n\t          type = HighlightingTypes$1.ELEMENT_AVAILABILITY;\n\t          break;\n\t        default:\n\t          type = HighlightingTypes$1.DEFAULT;\n\t          break;\n\t      }\n\t      opt.type = type;\n\t    }\n\t    this.notify(eventName, node, opt);\n\t    return this;\n\t  },\n\t  highlight: function (el, opt) {\n\t    return this._notifyHighlight('cell:highlight', el, opt);\n\t  },\n\t  unhighlight: function (el, opt = {}) {\n\t    return this._notifyHighlight('cell:unhighlight', el, opt);\n\t  },\n\t  // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n\t  // an element found, return the root element of the cell view.\n\t  findMagnet: function (el) {\n\t    const root = this.el;\n\t    let magnet = this.$(el)[0];\n\t    if (!magnet) {\n\t      magnet = root;\n\t    }\n\t    do {\n\t      const magnetAttribute = magnet.getAttribute('magnet');\n\t      const isMagnetRoot = magnet === root;\n\t      if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n\t        return magnet;\n\t      }\n\t      if (isMagnetRoot) {\n\t        // If the overall cell has set `magnet === false`, then return `undefined` to\n\t        // announce there is no magnet found for this cell.\n\t        // This is especially useful to set on cells that have 'ports'. In this case,\n\t        // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n\t        return undefined;\n\t      }\n\t      magnet = magnet.parentNode;\n\t    } while (magnet);\n\t    return undefined;\n\t  },\n\t  findProxyNode: function (el, type) {\n\t    el || (el = this.el);\n\t    const nodeSelector = el.getAttribute(`${type}-selector`);\n\t    if (nodeSelector) {\n\t      const proxyNode = this.findNode(nodeSelector);\n\t      if (proxyNode) return proxyNode;\n\t    }\n\t    return el;\n\t  },\n\t  // Construct a unique selector for the `el` element within this view.\n\t  // `prevSelector` is being collected through the recursive call.\n\t  // No value for `prevSelector` is expected when using this method.\n\t  getSelector: function (el, prevSelector) {\n\t    var selector;\n\t    if (el === this.el) {\n\t      if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;\n\t      return selector;\n\t    }\n\t    if (el) {\n\t      var nthChild = V(el).index() + 1;\n\t      selector = el.tagName + ':nth-child(' + nthChild + ')';\n\t      if (prevSelector) {\n\t        selector += ' > ' + prevSelector;\n\t      }\n\t      selector = this.getSelector(el.parentNode, selector);\n\t    }\n\t    return selector;\n\t  },\n\t  addLinkFromMagnet: function (magnet, x, y) {\n\t    var paper = this.paper;\n\t    var graph = paper.model;\n\t    var link = paper.getDefaultLink(this, magnet);\n\t    link.set({\n\t      source: this.getLinkEnd(magnet, x, y, link, 'source'),\n\t      target: {\n\t        x: x,\n\t        y: y\n\t      }\n\t    }).addTo(graph, {\n\t      async: false,\n\t      ui: true\n\t    });\n\t    return link.findView(paper);\n\t  },\n\t  getLinkEnd: function (magnet, ...args) {\n\t    const model = this.model;\n\t    const id = model.id;\n\t    // Find a node with the `port` attribute set on it.\n\t    const portNode = this.findAttributeNode('port', magnet);\n\t    // Find a unique `selector` of the element under pointer that is a magnet.\n\t    const selector = magnet.getAttribute('joint-selector');\n\t    const end = {\n\t      id: id\n\t    };\n\t    if (selector != null) end.magnet = selector;\n\t    if (portNode != null) {\n\t      let port = portNode.getAttribute('port');\n\t      if (portNode.getAttribute('port-id-type') === 'number') {\n\t        port = parseInt(port, 10);\n\t      }\n\t      end.port = port;\n\t      if (!model.hasPort(port) && !selector) {\n\t        // port created via the `port` attribute (not API)\n\t        end.selector = this.getSelector(magnet);\n\t      }\n\t    } else if (selector == null && this.el !== magnet) {\n\t      end.selector = this.getSelector(magnet);\n\t    }\n\t    return this.customizeLinkEnd(end, magnet, ...args);\n\t  },\n\t  customizeLinkEnd: function (end, magnet, x, y, link, endType) {\n\t    const {\n\t      paper\n\t    } = this;\n\t    const {\n\t      connectionStrategy\n\t    } = paper.options;\n\t    if (typeof connectionStrategy === 'function') {\n\t      var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n\t      if (strategy) return strategy;\n\t    }\n\t    return end;\n\t  },\n\t  getMagnetFromLinkEnd: function (end) {\n\t    var port = end.port;\n\t    var selector = end.magnet;\n\t    var model = this.model;\n\t    var magnet;\n\t    if (port != null && model.isElement() && model.hasPort(port)) {\n\t      magnet = this.findPortNode(port, selector) || this.el;\n\t    } else {\n\t      if (!selector) selector = end.selector;\n\t      if (!selector && port != null) {\n\t        // link end has only `id` and `port` property referencing\n\t        // a port created via the `port` attribute (not API).\n\t        selector = '[port=\"' + port + '\"]';\n\t      }\n\t      magnet = this.findNode(selector);\n\t    }\n\t    return this.findProxyNode(magnet, 'magnet');\n\t  },\n\t  dragLinkStart: function (evt, magnet, x, y) {\n\t    this.model.startBatch('add-link');\n\t    const linkView = this.addLinkFromMagnet(magnet, x, y);\n\t    // backwards compatibility events\n\t    linkView.notifyPointerdown(evt, x, y);\n\t    linkView.eventData(evt, linkView.startArrowheadMove('target', {\n\t      whenNotAllowed: 'remove'\n\t    }));\n\t    this.eventData(evt, {\n\t      linkView\n\t    });\n\t  },\n\t  dragLink: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    var linkView = data.linkView;\n\t    if (linkView) {\n\t      linkView.pointermove(evt, x, y);\n\t    } else {\n\t      var paper = this.paper;\n\t      var magnetThreshold = paper.options.magnetThreshold;\n\t      var currentTarget = this.getEventTarget(evt);\n\t      var targetMagnet = data.targetMagnet;\n\t      if (magnetThreshold === 'onleave') {\n\t        // magnetThreshold when the pointer leaves the magnet\n\t        if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n\t      } else {\n\t        // magnetThreshold defined as a number of movements\n\t        if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n\t      }\n\t      this.dragLinkStart(evt, targetMagnet, x, y);\n\t    }\n\t  },\n\t  dragLinkEnd: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    var linkView = data.linkView;\n\t    if (!linkView) return;\n\t    linkView.pointerup(evt, x, y);\n\t    this.model.stopBatch('add-link');\n\t  },\n\t  getAttributeDefinition: function (attrName) {\n\t    return this.model.constructor.getAttributeDefinition(attrName);\n\t  },\n\t  setNodeAttributes: function (node, attrs) {\n\t    if (!isEmpty(attrs)) {\n\t      if (node instanceof SVGElement) {\n\t        V(node).attr(attrs);\n\t      } else {\n\t        $(node).attr(attrs);\n\t      }\n\t    }\n\t  },\n\t  processNodeAttributes: function (node, attrs) {\n\t    var attrName, attrVal, def, i, n;\n\t    var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n\t    var relatives = [];\n\t    const rawAttrs = {};\n\t    for (attrName in attrs) {\n\t      if (!attrs.hasOwnProperty(attrName)) continue;\n\t      rawAttrs[V.attributeNames[attrName]] = attrs[attrName];\n\t    }\n\t    // divide the attributes between normal and special\n\t    for (attrName in rawAttrs) {\n\t      if (!rawAttrs.hasOwnProperty(attrName)) continue;\n\t      attrVal = rawAttrs[attrName];\n\t      def = this.getAttributeDefinition(attrName);\n\t      if (def) {\n\t        if (attrVal === null) {\n\t          // Assign the unset attribute name.\n\t          let unsetAttrName;\n\t          if (isFunction(def.unset)) {\n\t            unsetAttrName = def.unset.call(this, node, rawAttrs, this);\n\t          } else {\n\t            unsetAttrName = def.unset;\n\t          }\n\t          if (!unsetAttrName && isString(def.set)) {\n\t            // We unset an alias attribute.\n\t            unsetAttrName = def.set;\n\t          }\n\t          if (!unsetAttrName) {\n\t            // There is no alias for the attribute. We unset the attribute itself.\n\t            unsetAttrName = attrName;\n\t          }\n\t          // Unset the attribute.\n\t          if (isString(unsetAttrName) && unsetAttrName) {\n\t            // Unset a single attribute.\n\t            normalAttrs || (normalAttrs = {});\n\t            // values takes precedence over unset values\n\t            if (unsetAttrName in normalAttrs) continue;\n\t            normalAttrs[unsetAttrName] = attrVal;\n\t          } else if (Array.isArray(unsetAttrName) && unsetAttrName.length > 0) {\n\t            // Unset multiple attributes.\n\t            normalAttrs || (normalAttrs = {});\n\t            for (i = 0, n = unsetAttrName.length; i < n; i++) {\n\t              const attrName = unsetAttrName[i];\n\t              // values takes precedence over unset values\n\t              if (attrName in normalAttrs) continue;\n\t              normalAttrs[attrName] = attrVal;\n\t            }\n\t          }\n\t          // The unset value is neither a string nor an array.\n\t          // The attribute is not unset.\n\t        } else {\n\t          if (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this)) {\n\t            if (isString(def.set)) {\n\t              // An alias e.g 'xlink:href' -> 'href'\n\t              normalAttrs || (normalAttrs = {});\n\t              normalAttrs[def.set] = attrVal;\n\t            }\n\t            relatives.push(attrName, def);\n\t          } else {\n\t            normalAttrs || (normalAttrs = {});\n\t            normalAttrs[attrName] = attrVal;\n\t          }\n\t        }\n\t      } else {\n\t        normalAttrs || (normalAttrs = {});\n\t        normalAttrs[attrName] = attrVal;\n\t      }\n\t    }\n\n\t    // handle the rest of attributes via related method\n\t    // from the special attributes namespace.\n\t    for (i = 0, n = relatives.length; i < n; i += 2) {\n\t      attrName = relatives[i];\n\t      def = relatives[i + 1];\n\t      attrVal = attrs[attrName];\n\t      if (isFunction(def.set)) {\n\t        setAttrs || (setAttrs = {});\n\t        setAttrs[attrName] = attrVal;\n\t      }\n\t      if (isFunction(def.position)) {\n\t        positionAttrs || (positionAttrs = {});\n\t        positionAttrs[attrName] = attrVal;\n\t      }\n\t      if (isFunction(def.offset)) {\n\t        offsetAttrs || (offsetAttrs = {});\n\t        offsetAttrs[attrName] = attrVal;\n\t      }\n\t    }\n\t    return {\n\t      raw: rawAttrs,\n\t      normal: normalAttrs,\n\t      set: setAttrs,\n\t      position: positionAttrs,\n\t      offset: offsetAttrs\n\t    };\n\t  },\n\t  updateRelativeAttributes: function (node, attrs, refBBox, opt) {\n\t    opt || (opt = {});\n\t    var attrName, attrVal, def;\n\t    var evalAttrs = evalAttributes(attrs.raw || {}, refBBox);\n\t    var nodeAttrs = attrs.normal || {};\n\t    for (const nodeAttrName in nodeAttrs) {\n\t      nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];\n\t    }\n\t    var setAttrs = attrs.set;\n\t    var positionAttrs = attrs.position;\n\t    var offsetAttrs = attrs.offset;\n\t    for (attrName in setAttrs) {\n\t      attrVal = evalAttrs[attrName];\n\t      def = this.getAttributeDefinition(attrName);\n\t      // SET - set function should return attributes to be set on the node,\n\t      // which will affect the node dimensions based on the reference bounding\n\t      // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n\t      var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n\t      if (isObject(setResult)) {\n\t        assign(nodeAttrs, setResult);\n\t      } else if (setResult !== undefined) {\n\t        nodeAttrs[attrName] = setResult;\n\t      }\n\t    }\n\t    if (node instanceof HTMLElement) {\n\t      // TODO: setting the `transform` attribute on HTMLElements\n\t      // via `node.style.transform = 'matrix(...)';` would introduce\n\t      // a breaking change (e.g. basic.TextBlock).\n\t      this.setNodeAttributes(node, nodeAttrs);\n\t      return;\n\t    }\n\n\t    // The final translation of the subelement.\n\t    var nodeTransform = nodeAttrs.transform;\n\t    var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n\t    var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n\t    if (nodeTransform) {\n\t      nodeAttrs = omit(nodeAttrs, 'transform');\n\t      nodeMatrix.e = nodeMatrix.f = 0;\n\t    }\n\n\t    // Calculate node scale determined by the scalable group\n\t    // only if later needed.\n\t    var sx, sy, translation;\n\t    if (positionAttrs || offsetAttrs) {\n\t      var nodeScale = this.getNodeScale(node, opt.scalableNode);\n\t      sx = nodeScale.sx;\n\t      sy = nodeScale.sy;\n\t    }\n\t    var positioned = false;\n\t    for (attrName in positionAttrs) {\n\t      attrVal = evalAttrs[attrName];\n\t      def = this.getAttributeDefinition(attrName);\n\t      // POSITION - position function should return a point from the\n\t      // reference bounding box. The default position of the node is x:0, y:0 of\n\t      // the reference bounding box or could be further specify by some\n\t      // SVG attributes e.g. `x`, `y`\n\t      translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n\t      if (translation) {\n\t        nodePosition.offset(Point(translation).scale(sx, sy));\n\t        positioned || (positioned = true);\n\t      }\n\t    }\n\n\t    // The node bounding box could depend on the `size` set from the previous loop.\n\t    // Here we know, that all the size attributes have been already set.\n\t    this.setNodeAttributes(node, nodeAttrs);\n\t    var offseted = false;\n\t    if (offsetAttrs) {\n\t      // Check if the node is visible\n\t      var nodeBoundingRect = this.getNodeBoundingRect(node);\n\t      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n\t        var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n\t        for (attrName in offsetAttrs) {\n\t          attrVal = evalAttrs[attrName];\n\t          def = this.getAttributeDefinition(attrName);\n\t          // OFFSET - offset function should return a point from the element\n\t          // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n\t          // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n\t          translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);\n\t          if (translation) {\n\t            nodePosition.offset(Point(translation).scale(sx, sy));\n\t            offseted || (offseted = true);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    // Do not touch node's transform attribute if there is no transformation applied.\n\t    if (nodeTransform !== undefined || positioned || offseted) {\n\t      // Round the coordinates to 1 decimal point.\n\t      nodePosition.round(1);\n\t      nodeMatrix.e = nodePosition.x;\n\t      nodeMatrix.f = nodePosition.y;\n\t      node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n\t      // TODO: store nodeMatrix metrics?\n\t    }\n\t  },\n\t  getNodeScale: function (node, scalableNode) {\n\t    // Check if the node is a descendant of the scalable group.\n\t    var sx, sy;\n\t    if (scalableNode && scalableNode.contains(node)) {\n\t      var scale = scalableNode.scale();\n\t      sx = 1 / scale.sx;\n\t      sy = 1 / scale.sy;\n\t    } else {\n\t      sx = 1;\n\t      sy = 1;\n\t    }\n\t    return {\n\t      sx: sx,\n\t      sy: sy\n\t    };\n\t  },\n\t  cleanNodesCache: function () {\n\t    this.metrics = {};\n\t  },\n\t  cleanNodeCache: function (node) {\n\t    const id = node.id;\n\t    if (!id) return;\n\t    delete this.metrics[id];\n\t  },\n\t  nodeCache: function (magnet) {\n\t    var metrics = this.metrics;\n\t    // Don't use cache? It most likely a custom view with overridden update.\n\t    if (!metrics) return {};\n\t    var id = V.ensureId(magnet);\n\t    var value = metrics[id];\n\t    if (!value) value = metrics[id] = {};\n\t    return value;\n\t  },\n\t  getNodeData: function (magnet) {\n\t    var metrics = this.nodeCache(magnet);\n\t    if (!metrics.data) metrics.data = {};\n\t    return metrics.data;\n\t  },\n\t  getNodeBoundingRect: function (magnet) {\n\t    var metrics = this.nodeCache(magnet);\n\t    if (metrics.boundingRect === undefined) {\n\t      const {\n\t        measureNode\n\t      } = this.paper.options;\n\t      if (typeof measureNode === 'function') {\n\t        // Measure the node bounding box using the paper's measureNode method.\n\t        metrics.boundingRect = measureNode(magnet, this);\n\t      } else {\n\t        metrics.boundingRect = V(magnet).getBBox();\n\t      }\n\t    }\n\t    return new Rect(metrics.boundingRect);\n\t  },\n\t  getNodeMatrix: function (magnet) {\n\t    const metrics = this.nodeCache(magnet);\n\t    if (metrics.magnetMatrix === undefined) {\n\t      const {\n\t        rotatableNode,\n\t        el\n\t      } = this;\n\t      let target;\n\t      if (rotatableNode && rotatableNode.contains(magnet)) {\n\t        target = rotatableNode;\n\t      } else {\n\t        target = el;\n\t      }\n\t      metrics.magnetMatrix = V(magnet).getTransformToElement(target, {\n\t        // We use `safe` mode if the magnet is not visible (not in the DOM render tree).\n\t        // The browser would not be able to calculate the transformation matrix\n\t        // using `getScreenCTM()` method.\n\t        safe: !magnet.checkVisibility()\n\t      });\n\t    }\n\t    return V.createSVGMatrix(metrics.magnetMatrix);\n\t  },\n\t  getNodeShape: function (magnet) {\n\t    var metrics = this.nodeCache(magnet);\n\t    if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n\t    return metrics.geometryShape.clone();\n\t  },\n\t  isNodeConnection: function (node) {\n\t    return this.model.isLink() && (!node || node === this.el);\n\t  },\n\t  findNodesAttributes: function (attrs, root, selectorCache, selectors) {\n\t    var i, n, nodeAttrs, nodeId;\n\t    var nodesAttrs = {};\n\t    var mergeIds = [];\n\t    for (var selector in attrs) {\n\t      if (!attrs.hasOwnProperty(selector)) continue;\n\t      nodeAttrs = attrs[selector];\n\t      if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n\t      var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n\t      for (i = 0, n = selected.length; i < n; i++) {\n\t        var node = selected[i];\n\t        nodeId = V.ensureId(node);\n\t        // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n\t        // groupSelector referencing a single node is not \"unique\"\n\t        var unique = selectors && selectors[selector] === node;\n\t        var prevNodeAttrs = nodesAttrs[nodeId];\n\t        if (prevNodeAttrs) {\n\t          // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n\t          // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n\t          if (!prevNodeAttrs.array) {\n\t            mergeIds.push(nodeId);\n\t            prevNodeAttrs.array = true;\n\t            prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n\t            prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n\t          }\n\t          var attributes = prevNodeAttrs.attributes;\n\t          var selectedLength = prevNodeAttrs.selectedLength;\n\t          if (unique) {\n\t            // node referenced by `selector`\n\t            attributes.unshift(nodeAttrs);\n\t            selectedLength.unshift(-1);\n\t          } else {\n\t            // node referenced by `groupSelector`\n\t            var sortIndex = sortedIndex(selectedLength, n);\n\t            attributes.splice(sortIndex, 0, nodeAttrs);\n\t            selectedLength.splice(sortIndex, 0, n);\n\t          }\n\t        } else {\n\t          nodesAttrs[nodeId] = {\n\t            attributes: nodeAttrs,\n\t            selectedLength: unique ? -1 : n,\n\t            node: node,\n\t            array: false\n\t          };\n\t        }\n\t      }\n\t    }\n\t    for (i = 0, n = mergeIds.length; i < n; i++) {\n\t      nodeId = mergeIds[i];\n\t      nodeAttrs = nodesAttrs[nodeId];\n\t      nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n\t    }\n\t    return nodesAttrs;\n\t  },\n\t  getEventTarget: function (evt, opt = {}) {\n\t    const {\n\t      target,\n\t      type,\n\t      clientX = 0,\n\t      clientY = 0\n\t    } = evt;\n\t    if (\n\t    // Explicitly defined `fromPoint` option\n\t    opt.fromPoint ||\n\t    // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n\t    // It holds the element when a touchstart triggered.\n\t    type === 'touchmove' || type === 'touchend' ||\n\t    // Pointermove/Pointerup event with the pointer captured\n\t    'pointerId' in evt && target.hasPointerCapture(evt.pointerId)) {\n\t      return document.elementFromPoint(clientX, clientY);\n\t    }\n\t    return target;\n\t  },\n\t  // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n\t  // unless `attrs` parameter was passed.\n\t  updateDOMSubtreeAttributes: function (rootNode, attrs, opt) {\n\t    opt || (opt = {});\n\t    opt.rootBBox || (opt.rootBBox = Rect());\n\t    opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n\t    // Cache table for query results and bounding box calculation.\n\t    // Note that `selectorCache` needs to be invalidated for all\n\t    // `updateAttributes` calls, as the selectors might pointing\n\t    // to nodes designated by an attribute or elements dynamically\n\t    // created.\n\t    var selectorCache = {};\n\t    var bboxCache = {};\n\t    var relativeItems = [];\n\t    var relativeRefItems = [];\n\t    var item, node, nodeAttrs, nodeData, processedAttrs;\n\t    var roAttrs = opt.roAttributes;\n\t    var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n\t    // `nodesAttrs` are different from all attributes, when\n\t    // rendering only  attributes sent to this method.\n\t    var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;\n\t    for (var nodeId in nodesAttrs) {\n\t      nodeData = nodesAttrs[nodeId];\n\t      nodeAttrs = nodeData.attributes;\n\t      node = nodeData.node;\n\t      processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\t      if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {\n\t        // Set all the normal attributes right on the SVG/HTML element.\n\t        this.setNodeAttributes(node, evalAttributes(processedAttrs.normal, opt.rootBBox));\n\t      } else {\n\t        var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n\t        var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;\n\t        var refNode;\n\t        if (refSelector) {\n\t          refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n\t          if (!refNode) {\n\t            throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n\t          }\n\t        } else {\n\t          refNode = null;\n\t        }\n\t        item = {\n\t          node: node,\n\t          refNode: refNode,\n\t          processedAttributes: processedAttrs,\n\t          allAttributes: nodeAllAttrs\n\t        };\n\t        if (refNode) {\n\t          // If an element in the list is positioned relative to this one, then\n\t          // we want to insert this one before it in the list.\n\t          var itemIndex = relativeRefItems.findIndex(function (item) {\n\t            return item.refNode === node;\n\t          });\n\t          if (itemIndex > -1) {\n\t            relativeRefItems.splice(itemIndex, 0, item);\n\t          } else {\n\t            relativeRefItems.push(item);\n\t          }\n\t        } else {\n\t          // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n\t          // The order of no-ref-items is not specified/important.\n\t          relativeItems.push(item);\n\t        }\n\t      }\n\t    }\n\t    relativeItems.push(...relativeRefItems);\n\t    for (let i = 0, n = relativeItems.length; i < n; i++) {\n\t      item = relativeItems[i];\n\t      node = item.node;\n\t      refNode = item.refNode;\n\n\t      // Find the reference element bounding box. If no reference was provided, we\n\t      // use the optional bounding box.\n\t      const refNodeId = refNode ? V.ensureId(refNode) : '';\n\t      let refBBox = bboxCache[refNodeId];\n\t      if (!refBBox) {\n\t        if (refNode) {\n\t          // Get the bounding box of the reference element using to the common ancestor\n\t          // transformation space.\n\t          //\n\t          // @example 1\n\t          // <g transform=\"translate(11, 13)\">\n\t          //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n\t          //     <rect @selector=\"a\"/>\n\t          // </g>\n\t          //\n\t          // In this case, the reference bounding box can not be affected\n\t          // by the `transform` attribute of the `<g>` element,\n\t          // because the exact transformation will be applied to the `a` element\n\t          // as well as to the `b` element.\n\t          //\n\t          // @example 2\n\t          // <g transform=\"translate(11, 13)\">\n\t          //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n\t          // </g>\n\t          // <rect @selector=\"a\"/>\n\t          //\n\t          // In this case, the reference bounding box have to be affected by the\n\t          // `transform` attribute of the `<g>` element, because the `a` element\n\t          // is not descendant of the `<g>` element and will not be affected\n\t          // by the transformation.\n\t          const refRect = this.getNodeBoundingRect(refNode);\n\t          const refTMatrix = V(refNode).getTransformToElement(V.getCommonAncestor(node, refNode));\n\t          refBBox = V.transformRect(refRect, refTMatrix);\n\t        } else {\n\t          refBBox = opt.rootBBox;\n\t        }\n\t        bboxCache[refNodeId] = refBBox;\n\t      }\n\t      if (roAttrs) {\n\t        // if there was a special attribute affecting the position amongst passed-in attributes\n\t        // we have to merge it with the rest of the element's attributes as they are necessary\n\t        // to update the position relatively (i.e `ref-x` && 'ref-dx')\n\t        processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n\t        this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\t      } else {\n\t        processedAttrs = item.processedAttributes;\n\t      }\n\t      this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n\t    }\n\t  },\n\t  mergeProcessedAttributes: function (processedAttrs, roProcessedAttrs) {\n\t    processedAttrs.set || (processedAttrs.set = {});\n\t    processedAttrs.position || (processedAttrs.position = {});\n\t    processedAttrs.offset || (processedAttrs.offset = {});\n\t    assign(processedAttrs.set, roProcessedAttrs.set);\n\t    assign(processedAttrs.position, roProcessedAttrs.position);\n\t    assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n\t    // Handle also the special transform property.\n\t    var transform = processedAttrs.normal && processedAttrs.normal.transform;\n\t    if (transform !== undefined && roProcessedAttrs.normal) {\n\t      roProcessedAttrs.normal.transform = transform;\n\t    }\n\t    processedAttrs.normal = roProcessedAttrs.normal;\n\t  },\n\t  // Lifecycle methods\n\n\t  // Called when the view is attached to the DOM,\n\t  // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n\t  // or `paper.options.viewport` returning `true` (isInitialMount === false).\n\t  onMount(isInitialMount) {\n\t    if (isInitialMount) return;\n\t    this.mountTools();\n\t    HighlighterView.mount(this);\n\t  },\n\t  // Called when the view is detached from the DOM,\n\t  // as result of `paper.options.viewport` returning `false`.\n\t  onDetach() {\n\t    this.unmountTools();\n\t    HighlighterView.unmount(this);\n\t  },\n\t  // Called when the view is removed from the DOM\n\t  // as result of `cell.remove()`.\n\t  onRemove: function () {\n\t    this.removeTools();\n\t    this.removeHighlighters();\n\t  },\n\t  _toolsView: null,\n\t  hasTools: function (name) {\n\t    var toolsView = this._toolsView;\n\t    if (!toolsView) return false;\n\t    if (!name) return true;\n\t    return toolsView.getName() === name;\n\t  },\n\t  addTools: function (toolsView) {\n\t    this.removeTools();\n\t    if (toolsView) {\n\t      this._toolsView = toolsView;\n\t      toolsView.configure({\n\t        relatedView: this\n\t      });\n\t      toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n\t    }\n\t    return this;\n\t  },\n\t  unmountTools() {\n\t    const toolsView = this._toolsView;\n\t    if (toolsView) toolsView.unmount();\n\t    return this;\n\t  },\n\t  mountTools() {\n\t    const toolsView = this._toolsView;\n\t    // Prevent unnecessary re-appending of the tools.\n\t    if (toolsView && !toolsView.isMounted()) toolsView.mount();\n\t    return this;\n\t  },\n\t  updateTools: function (opt) {\n\t    var toolsView = this._toolsView;\n\t    if (toolsView) toolsView.update(opt);\n\t    return this;\n\t  },\n\t  removeTools: function () {\n\t    var toolsView = this._toolsView;\n\t    if (toolsView) {\n\t      toolsView.remove();\n\t      this._toolsView = null;\n\t    }\n\t    return this;\n\t  },\n\t  hideTools: function () {\n\t    var toolsView = this._toolsView;\n\t    if (toolsView) toolsView.hide();\n\t    return this;\n\t  },\n\t  showTools: function () {\n\t    var toolsView = this._toolsView;\n\t    if (toolsView) toolsView.show();\n\t    return this;\n\t  },\n\t  onToolEvent: function (event) {\n\t    switch (event) {\n\t      case 'remove':\n\t        this.removeTools();\n\t        break;\n\t      case 'hide':\n\t        this.hideTools();\n\t        break;\n\t      case 'show':\n\t        this.showTools();\n\t        break;\n\t    }\n\t  },\n\t  removeHighlighters: function () {\n\t    HighlighterView.remove(this);\n\t  },\n\t  updateHighlighters: function (dirty = false) {\n\t    HighlighterView.update(this, null, dirty);\n\t  },\n\t  transformHighlighters: function () {\n\t    HighlighterView.transform(this);\n\t  },\n\t  // Interaction. The controller part.\n\t  // ---------------------------------\n\n\t  preventDefaultInteraction(evt) {\n\t    this.eventData(evt, {\n\t      defaultInteractionPrevented: true\n\t    });\n\t  },\n\t  isDefaultInteractionPrevented(evt) {\n\t    const {\n\t      defaultInteractionPrevented = false\n\t    } = this.eventData(evt);\n\t    return defaultInteractionPrevented;\n\t  },\n\t  // Interaction is handled by the paper and delegated to the view in interest.\n\t  // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n\t  // If necessary, real coordinates can be obtained from the `evt` event object.\n\n\t  // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n\t  // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n\t  pointerdblclick: function (evt, x, y) {\n\t    this.notify('cell:pointerdblclick', evt, x, y);\n\t  },\n\t  pointerclick: function (evt, x, y) {\n\t    this.notify('cell:pointerclick', evt, x, y);\n\t  },\n\t  contextmenu: function (evt, x, y) {\n\t    this.notify('cell:contextmenu', evt, x, y);\n\t  },\n\t  pointerdown: function (evt, x, y) {\n\t    const {\n\t      model\n\t    } = this;\n\t    const {\n\t      graph\n\t    } = model;\n\t    if (graph) {\n\t      model.startBatch('pointer');\n\t      this.eventData(evt, {\n\t        graph\n\t      });\n\t    }\n\t    this.notify('cell:pointerdown', evt, x, y);\n\t  },\n\t  pointermove: function (evt, x, y) {\n\t    this.notify('cell:pointermove', evt, x, y);\n\t  },\n\t  pointerup: function (evt, x, y) {\n\t    const {\n\t      graph\n\t    } = this.eventData(evt);\n\t    this.notify('cell:pointerup', evt, x, y);\n\t    if (graph) {\n\t      // we don't want to trigger event on model as model doesn't\n\t      // need to be member of collection anymore (remove)\n\t      graph.stopBatch('pointer', {\n\t        cell: this.model\n\t      });\n\t    }\n\t  },\n\t  mouseover: function (evt) {\n\t    this.notify('cell:mouseover', evt);\n\t  },\n\t  mouseout: function (evt) {\n\t    this.notify('cell:mouseout', evt);\n\t  },\n\t  mouseenter: function (evt) {\n\t    this.notify('cell:mouseenter', evt);\n\t  },\n\t  mouseleave: function (evt) {\n\t    this.notify('cell:mouseleave', evt);\n\t  },\n\t  mousewheel: function (evt, x, y, delta) {\n\t    this.notify('cell:mousewheel', evt, x, y, delta);\n\t  },\n\t  onevent: function (evt, eventName, x, y) {\n\t    this.notify(eventName, evt, x, y);\n\t  },\n\t  onmagnet: function () {\n\n\t    // noop\n\t  },\n\t  magnetpointerdblclick: function () {\n\n\t    // noop\n\t  },\n\t  magnetcontextmenu: function () {\n\n\t    // noop\n\t  },\n\t  checkMouseleave(evt) {\n\t    const {\n\t      paper,\n\t      model\n\t    } = this;\n\t    if (paper.isAsync()) {\n\t      // Make sure the source/target views are updated before this view.\n\t      // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n\t      // The connected cells could be links as well. In that case, we would\n\t      // need to recursively go through all the connected links and update\n\t      // their source/target views as well.\n\t      if (model.isLink()) {\n\t        // The `this.sourceView` and `this.targetView` might not be updated yet.\n\t        // We need to find the view by the model.\n\t        const sourceElement = model.getSourceElement();\n\t        if (sourceElement) {\n\t          const sourceView = paper.findViewByModel(sourceElement);\n\t          if (sourceView) {\n\t            paper.dumpView(sourceView);\n\t            paper.checkViewVisibility(sourceView);\n\t          }\n\t        }\n\t        const targetElement = model.getTargetElement();\n\t        if (targetElement) {\n\t          const targetView = paper.findViewByModel(targetElement);\n\t          if (targetView) {\n\t            paper.dumpView(targetView);\n\t            paper.checkViewVisibility(targetView);\n\t          }\n\t        }\n\t      }\n\t      // Do the updates of the current view synchronously now\n\t      paper.dumpView(this);\n\t      paper.checkViewVisibility(this);\n\t    }\n\t    const target = this.getEventTarget(evt, {\n\t      fromPoint: true\n\t    });\n\t    const view = paper.findView(target);\n\t    if (view === this) return;\n\t    // Leaving the current view\n\t    this.mouseleave(evt);\n\t    if (!view) return;\n\t    // Entering another view\n\t    view.mouseenter(evt);\n\t  },\n\t  setInteractivity: function (value) {\n\t    this.options.interactive = value;\n\t  },\n\t  isIntersecting: function (geometryShape, geometryData) {\n\t    return intersection$1.exists(geometryShape, this.getNodeBBox(this.el), geometryData);\n\t  },\n\t  isEnclosedIn: function (geometryRect) {\n\t    return geometryRect.containsRect(this.getNodeBBox(this.el));\n\t  },\n\t  isInArea: function (geometryRect, options = {}) {\n\t    if (options.strict) {\n\t      return this.isEnclosedIn(geometryRect);\n\t    }\n\t    return this.isIntersecting(geometryRect);\n\t  },\n\t  isAtPoint: function (point, options) {\n\t    return this.getNodeBBox(this.el).containsPoint(point, options);\n\t  }\n\t}, {\n\t  Flags: Flags$2,\n\t  Highlighting: HighlightingTypes$1,\n\t  addPresentationAttributes: function (presentationAttributes) {\n\t    return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function (a, b) {\n\t      if (!a || !b) return;\n\t      if (typeof a === 'string') a = [a];\n\t      if (typeof b === 'string') b = [b];\n\t      if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n\t    });\n\t  },\n\t  evalAttribute\n\t});\n\tObject.defineProperty(CellView.prototype, 'useCSSSelectors', {\n\t  get() {\n\t    const localUse = this.model.useCSSSelectors;\n\t    if (localUse !== undefined) return localUse;\n\t    return config$3.useCSSSelectors;\n\t  }\n\t});\n\n\t// Internal tag to identify this object as a cell view instance.\n\t// Used instead of `instanceof` for performance and cross-frame safety.\n\n\tObject.defineProperty(CellView.prototype, CELL_VIEW_MARKER, {\n\t  value: true\n\t});\n\n\tconst Flags$1 = {\n\t  TOOLS: CellView.Flags.TOOLS,\n\t  UPDATE: 'UPDATE',\n\t  TRANSLATE: 'TRANSLATE',\n\t  RESIZE: 'RESIZE',\n\t  PORTS: 'PORTS',\n\t  ROTATE: 'ROTATE',\n\t  RENDER: 'RENDER'\n\t};\n\tconst DragActions = {\n\t  MOVE: 'move',\n\t  MAGNET: 'magnet'\n\t};\n\t// Element base view and controller.\n\t// -------------------------------------------\n\n\tconst ElementView = CellView.extend({\n\t  /**\n\t   * @abstract\n\t   */\n\t  _removePorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  /**\n\t   *\n\t   * @abstract\n\t   */\n\t  _renderPorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  className: function () {\n\t    var classNames = CellView.prototype.className.apply(this).split(' ');\n\t    classNames.push('element');\n\t    return classNames.join(' ');\n\t  },\n\t  initialize: function () {\n\t    CellView.prototype.initialize.apply(this, arguments);\n\t    this._initializePorts();\n\t  },\n\t  presentationAttributes: {\n\t    'attrs': [Flags$1.UPDATE],\n\t    'position': [Flags$1.TRANSLATE, Flags$1.TOOLS],\n\t    'size': [Flags$1.RESIZE, Flags$1.PORTS, Flags$1.TOOLS],\n\t    'angle': [Flags$1.ROTATE, Flags$1.TOOLS],\n\t    'markup': [Flags$1.RENDER],\n\t    'ports': [Flags$1.PORTS]\n\t  },\n\t  initFlag: [Flags$1.RENDER],\n\t  UPDATE_PRIORITY: 0,\n\t  confirmUpdate: function (flag, opt) {\n\t    const {\n\t      useCSSSelectors\n\t    } = this;\n\t    if (this.hasFlag(flag, Flags$1.PORTS)) {\n\t      this._removePorts();\n\t      this._cleanPortsCache();\n\t    }\n\t    let transformHighlighters = false;\n\t    if (this.hasFlag(flag, Flags$1.RENDER)) {\n\t      this.render();\n\t      this.updateTools(opt);\n\t      this.updateHighlighters(true);\n\t      transformHighlighters = true;\n\t      flag = this.removeFlag(flag, [Flags$1.RENDER, Flags$1.UPDATE, Flags$1.RESIZE, Flags$1.TRANSLATE, Flags$1.ROTATE, Flags$1.PORTS, Flags$1.TOOLS]);\n\t    } else {\n\t      let updateHighlighters = false;\n\n\t      // Skip this branch if render is required\n\t      if (this.hasFlag(flag, Flags$1.RESIZE)) {\n\t        this.resize(opt);\n\t        updateHighlighters = true;\n\t        // Resize method is calling `update()` internally\n\t        flag = this.removeFlag(flag, [Flags$1.RESIZE, Flags$1.UPDATE]);\n\t        if (useCSSSelectors) {\n\t          // `resize()` rendered the ports when useCSSSelectors are enabled\n\t          flag = this.removeFlag(flag, Flags$1.PORTS);\n\t        }\n\t      }\n\t      if (this.hasFlag(flag, Flags$1.UPDATE)) {\n\t        this.update(this.model, null, opt);\n\t        flag = this.removeFlag(flag, Flags$1.UPDATE);\n\t        updateHighlighters = true;\n\t        if (useCSSSelectors) {\n\t          // `update()` will render ports when useCSSSelectors are enabled\n\t          flag = this.removeFlag(flag, Flags$1.PORTS);\n\t        }\n\t      }\n\t      if (this.hasFlag(flag, Flags$1.TRANSLATE)) {\n\t        this.translate();\n\t        flag = this.removeFlag(flag, Flags$1.TRANSLATE);\n\t        transformHighlighters = true;\n\t      }\n\t      if (this.hasFlag(flag, Flags$1.ROTATE)) {\n\t        this.rotate();\n\t        flag = this.removeFlag(flag, Flags$1.ROTATE);\n\t        transformHighlighters = true;\n\t      }\n\t      if (this.hasFlag(flag, Flags$1.PORTS)) {\n\t        this._renderPorts();\n\t        updateHighlighters = true;\n\t        flag = this.removeFlag(flag, Flags$1.PORTS);\n\t      }\n\t      if (updateHighlighters) {\n\t        this.updateHighlighters(false);\n\t      }\n\t    }\n\t    if (transformHighlighters) {\n\t      this.transformHighlighters();\n\t    }\n\t    if (this.hasFlag(flag, Flags$1.TOOLS)) {\n\t      this.updateTools(opt);\n\t      flag = this.removeFlag(flag, Flags$1.TOOLS);\n\t    }\n\t    return flag;\n\t  },\n\t  /**\n\t   * @abstract\n\t   */\n\t  _initializePorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  update: function (_, renderingOnlyAttrs) {\n\t    this.cleanNodesCache();\n\n\t    // When CSS selector strings are used, make sure no rule matches port nodes.\n\t    const {\n\t      useCSSSelectors\n\t    } = this;\n\t    if (useCSSSelectors) this._removePorts();\n\t    var model = this.model;\n\t    var modelAttrs = model.attr();\n\t    this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n\t      rootBBox: new Rect(model.size()),\n\t      selectors: this.selectors,\n\t      scalableNode: this.scalableNode,\n\t      rotatableNode: this.rotatableNode,\n\t      // Use rendering only attributes if they differs from the model attributes\n\t      roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs\n\t    });\n\t    if (useCSSSelectors) {\n\t      this._renderPorts();\n\t    }\n\t  },\n\t  rotatableSelector: 'rotatable',\n\t  scalableSelector: 'scalable',\n\t  scalableNode: null,\n\t  rotatableNode: null,\n\t  // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n\t  // default markup is not desirable.\n\t  renderMarkup: function () {\n\t    var element = this.model;\n\t    var markup = element.get('markup') || element.markup;\n\t    if (!markup) throw new Error('dia.ElementView: markup required');\n\t    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n\t    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n\t    throw new Error('dia.ElementView: invalid markup');\n\t  },\n\t  renderJSONMarkup: function (markup) {\n\t    var doc = this.parseDOMJSON(markup, this.el);\n\t    var selectors = this.selectors = doc.selectors;\n\t    this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n\t    this.scalableNode = V(selectors[this.scalableSelector]) || null;\n\t    // Fragment\n\t    this.vel.append(doc.fragment);\n\t  },\n\t  renderStringMarkup: function (markup) {\n\t    var vel = this.vel;\n\t    vel.append(V(markup));\n\t    // Cache transformation groups\n\t    this.rotatableNode = vel.findOne('.rotatable');\n\t    this.scalableNode = vel.findOne('.scalable');\n\t    var selectors = this.selectors = {};\n\t    selectors[this.selector] = this.el;\n\t  },\n\t  render: function () {\n\t    this.vel.empty();\n\t    this.renderMarkup();\n\t    if (this.scalableNode) {\n\t      // Double update is necessary for elements with the scalable group only\n\t      // Note the resize() triggers the other `update`.\n\t      this.update();\n\t    }\n\t    this.resize();\n\t    if (this.rotatableNode) {\n\t      // Translate transformation is applied on `this.el` while the rotation transformation\n\t      // on `this.rotatableNode`\n\t      this.rotate();\n\t      this.translate();\n\t    } else {\n\t      this.updateTransformation();\n\t    }\n\t    if (!this.useCSSSelectors) this._renderPorts();\n\t    return this;\n\t  },\n\t  resize: function (opt) {\n\t    if (this.scalableNode) return this.sgResize(opt);\n\t    if (this.model.attributes.angle) this.rotate();\n\t    this.update();\n\t  },\n\t  translate: function () {\n\t    if (this.rotatableNode) return this.rgTranslate();\n\t    this.updateTransformation();\n\t  },\n\t  rotate: function () {\n\t    if (this.rotatableNode) {\n\t      this.rgRotate();\n\t      // It's necessary to call the update for the nodes outside\n\t      // the rotatable group referencing nodes inside the group\n\t      this.update();\n\t      return;\n\t    }\n\t    this.updateTransformation();\n\t  },\n\t  updateTransformation: function () {\n\t    var transformation = this.getTranslateString();\n\t    var rotateString = this.getRotateString();\n\t    if (rotateString) transformation += ' ' + rotateString;\n\t    this.vel.attr('transform', transformation);\n\t  },\n\t  getTranslateString: function () {\n\t    const {\n\t      x,\n\t      y\n\t    } = this.model.position();\n\t    return `translate(${x},${y})`;\n\t  },\n\t  getRotateString: function () {\n\t    const angle = this.model.angle();\n\t    if (!angle) return null;\n\t    const {\n\t      width,\n\t      height\n\t    } = this.model.size();\n\t    return `rotate(${angle},${width / 2},${height / 2})`;\n\t  },\n\t  // Rotatable & Scalable Group\n\t  // always slower, kept mainly for backwards compatibility\n\n\t  rgRotate: function () {\n\t    this.rotatableNode.attr('transform', this.getRotateString());\n\t  },\n\t  rgTranslate: function () {\n\t    this.vel.attr('transform', this.getTranslateString());\n\t  },\n\t  sgResize: function (opt) {\n\t    var model = this.model;\n\t    var angle = model.angle();\n\t    var size = model.size();\n\t    var scalable = this.scalableNode;\n\n\t    // Getting scalable group's bbox.\n\t    // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n\t    // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n\t    var recursive = false;\n\t    if (scalable.node.getElementsByTagName('path').length > 0) {\n\t      // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n\t      // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n\t      recursive = true;\n\t    }\n\t    var scalableBBox = scalable.getBBox({\n\t      recursive: recursive\n\t    });\n\n\t    // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n\t    // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n\t    var sx = size.width / (scalableBBox.width || 1);\n\t    var sy = size.height / (scalableBBox.height || 1);\n\t    scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n\t    // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n\t    // Order of transformations is significant but we want to reconstruct the object always in the order:\n\t    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n\t    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n\t    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n\t    // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n\t    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n\t    // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\t    var rotatable = this.rotatableNode;\n\t    var rotation = rotatable && rotatable.attr('transform');\n\t    if (rotation) {\n\t      rotatable.attr('transform', rotation + ' rotate(' + -angle + ',' + size.width / 2 + ',' + size.height / 2 + ')');\n\t      var rotatableBBox = scalable.getBBox({\n\t        target: this.paper.cells\n\t      });\n\n\t      // Store new x, y and perform rotate() again against the new rotation origin.\n\t      model.set('position', {\n\t        x: rotatableBBox.x,\n\t        y: rotatableBBox.y\n\t      }, assign({\n\t        updateHandled: true\n\t      }, opt));\n\t      this.translate();\n\t      this.rotate();\n\t    }\n\n\t    // Update must always be called on non-rotated element. Otherwise, relative positioning\n\t    // would work with wrong (rotated) bounding boxes.\n\t    this.update();\n\t  },\n\t  // Embedding mode methods.\n\t  // -----------------------\n\n\t  prepareEmbedding: function (data = {}) {\n\t    const element = data.model || this.model;\n\t    const paper = data.paper || this.paper;\n\t    const graph = paper.model;\n\t    const initialZIndices = data.initialZIndices = {};\n\t    const embeddedCells = element.getEmbeddedCells({\n\t      deep: true\n\t    });\n\t    const connectedLinks = graph.getConnectedLinks(element, {\n\t      deep: true,\n\t      includeEnclosed: true\n\t    });\n\n\t    // Note: an embedded cell can be a connect link, but it's fine\n\t    // to iterate over the cell twice.\n\t    [element, ...embeddedCells, ...connectedLinks].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n\t    element.startBatch('to-front');\n\n\t    // Bring the model to the front with all his embeds.\n\t    element.toFront({\n\t      deep: true,\n\t      ui: true\n\t    });\n\n\t    // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n\t    // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n\t    const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);\n\n\t    // Move to front also all the inbound and outbound links that are connected\n\t    // to any of the element descendant. If we bring to front only embedded elements,\n\t    // links connected to them would stay in the background.\n\t    connectedLinks.forEach(link => {\n\t      if (link.attributes.z <= maxZ) {\n\t        link.set('z', maxZ + 1, {\n\t          ui: true\n\t        });\n\t      }\n\t    });\n\t    element.stopBatch('to-front');\n\n\t    // Before we start looking for suitable parent we remove the current one.\n\t    const parentId = element.parent();\n\t    if (parentId) {\n\t      const parent = graph.getCell(parentId);\n\t      parent.unembed(element, {\n\t        ui: true\n\t      });\n\t      data.initialParentId = parentId;\n\t    } else {\n\t      // `data.initialParentId` can be explicitly set to a dummy value to enable validation of unembedding.\n\t      data.initialParentId = data.initialParentId || null;\n\t    }\n\t  },\n\t  processEmbedding: function (data = {}, evt, x, y) {\n\t    const model = data.model || this.model;\n\t    const paper = data.paper || this.paper;\n\t    const graph = paper.model;\n\t    const {\n\t      findParentBy,\n\t      frontParentOnly,\n\t      validateEmbedding\n\t    } = paper.options;\n\t    let candidates;\n\t    if (isFunction(findParentBy)) {\n\t      candidates = toArray$1(findParentBy.call(graph, this, evt, x, y));\n\t    } else if (findParentBy === 'pointer') {\n\t      candidates = graph.findElementsAtPoint({\n\t        x,\n\t        y\n\t      });\n\t    } else {\n\t      candidates = graph.findElementsUnderElement(model, {\n\t        searchBy: findParentBy\n\t      });\n\t    }\n\t    candidates = candidates.filter(el => {\n\t      return el instanceof Cell && model.id !== el.id && !el.isEmbeddedIn(model);\n\t    });\n\t    if (frontParentOnly) {\n\t      // pick the element with the highest `z` index\n\t      candidates = candidates.slice(-1);\n\t    }\n\t    let newCandidateView = null;\n\t    const prevCandidateView = data.candidateEmbedView;\n\n\t    // iterate over all candidates starting from the last one (has the highest z-index).\n\t    for (let i = candidates.length - 1; i >= 0; i--) {\n\t      const candidate = candidates[i];\n\t      if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n\t        // candidate remains the same\n\t        newCandidateView = prevCandidateView;\n\t        break;\n\t      } else {\n\t        const view = candidate.findView(paper);\n\t        if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n\t          // flip to the new candidate\n\t          newCandidateView = view;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    if (newCandidateView && newCandidateView != prevCandidateView) {\n\t      // A new candidate view found. Highlight the new one.\n\t      this.clearEmbedding(data);\n\t      data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, 'container'), {\n\t        embedding: true\n\t      });\n\t    }\n\t    if (!newCandidateView && prevCandidateView) {\n\t      // No candidate view found. Unhighlight the previous candidate.\n\t      this.clearEmbedding(data);\n\t    }\n\t  },\n\t  clearEmbedding: function (data) {\n\t    data || (data = {});\n\t    var candidateView = data.candidateEmbedView;\n\t    if (candidateView) {\n\t      // No candidate view found. Unhighlight the previous candidate.\n\t      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n\t        embedding: true\n\t      });\n\t      data.candidateEmbedView = null;\n\t    }\n\t  },\n\t  finalizeEmbedding: function (data = {}) {\n\t    const candidateView = data.candidateEmbedView;\n\t    const element = data.model || this.model;\n\t    const paper = data.paper || this.paper;\n\t    if (candidateView) {\n\t      // We finished embedding. Candidate view is chosen to become the parent of the model.\n\t      candidateView.model.embed(element, {\n\t        ui: true\n\t      });\n\t      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n\t        embedding: true\n\t      });\n\t      data.candidateEmbedView = null;\n\t    } else {\n\t      const {\n\t        validateUnembedding\n\t      } = paper.options;\n\t      const {\n\t        initialParentId\n\t      } = data;\n\t      // The element was originally embedded into another element.\n\t      // The interaction would unembed the element. Let's validate\n\t      // if the element can be unembedded.\n\t      if (initialParentId && typeof validateUnembedding === 'function' && !validateUnembedding.call(paper, this)) {\n\t        this._disallowUnembed(data);\n\t        return;\n\t      }\n\t    }\n\t    paper.model.getConnectedLinks(element, {\n\t      deep: true\n\t    }).forEach(link => {\n\t      link.reparent({\n\t        ui: true\n\t      });\n\t    });\n\t  },\n\t  _disallowUnembed: function (data) {\n\t    const {\n\t      model,\n\t      whenNotAllowed = 'revert'\n\t    } = data;\n\t    const element = model || this.model;\n\t    const paper = data.paper || this.paper;\n\t    const graph = paper.model;\n\t    switch (whenNotAllowed) {\n\t      case 'remove':\n\t        {\n\t          element.remove({\n\t            ui: true\n\t          });\n\t          break;\n\t        }\n\t      case 'revert':\n\t        {\n\t          const {\n\t            initialParentId,\n\t            initialPosition,\n\t            initialZIndices\n\t          } = data;\n\t          // Revert the element's position (and the position of its embedded cells if any)\n\t          if (initialPosition) {\n\t            const {\n\t              x,\n\t              y\n\t            } = initialPosition;\n\t            element.position(x, y, {\n\t              deep: true,\n\t              ui: true\n\t            });\n\t          }\n\t          // Revert all the z-indices changed during the embedding\n\t          if (initialZIndices) {\n\t            Object.keys(initialZIndices).forEach(id => {\n\t              const cell = graph.getCell(id);\n\t              if (cell) {\n\t                cell.set('z', initialZIndices[id], {\n\t                  ui: true\n\t                });\n\t              }\n\t            });\n\t          }\n\t          // Revert the original parent\n\t          const parent = graph.getCell(initialParentId);\n\t          if (parent) {\n\t            parent.embed(element, {\n\t              ui: true\n\t            });\n\t          }\n\t          break;\n\t        }\n\t    }\n\t  },\n\t  getTargetParentView: function (evt) {\n\t    const {\n\t      candidateEmbedView = null\n\t    } = this.eventData(evt);\n\t    return candidateEmbedView;\n\t  },\n\t  getDelegatedView: function () {\n\t    var view = this;\n\t    var model = view.model;\n\t    var paper = view.paper;\n\t    while (view) {\n\t      if (model.isLink()) break;\n\t      if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n\t      model = model.getParentCell();\n\t      view = paper.findViewByModel(model);\n\t    }\n\t    return null;\n\t  },\n\t  findProxyNode: function (el, type) {\n\t    el || (el = this.el);\n\t    const nodeSelector = el.getAttribute(`${type}-selector`);\n\t    if (nodeSelector) {\n\t      const port = this.findAttribute('port', el);\n\t      if (port) {\n\t        const proxyPortNode = this.findPortNode(port, nodeSelector);\n\t        if (proxyPortNode) return proxyPortNode;\n\t      } else {\n\t        const proxyNode = this.findNode(nodeSelector);\n\t        if (proxyNode) return proxyNode;\n\t      }\n\t    }\n\t    return el;\n\t  },\n\t  // Interaction. The controller part.\n\t  // ---------------------------------\n\n\t  notifyPointerdown(evt, x, y) {\n\t    CellView.prototype.pointerdown.call(this, evt, x, y);\n\t    this.notify('element:pointerdown', evt, x, y);\n\t  },\n\t  notifyPointermove(evt, x, y) {\n\t    CellView.prototype.pointermove.call(this, evt, x, y);\n\t    this.notify('element:pointermove', evt, x, y);\n\t  },\n\t  notifyPointerup(evt, x, y) {\n\t    this.notify('element:pointerup', evt, x, y);\n\t    CellView.prototype.pointerup.call(this, evt, x, y);\n\t  },\n\t  pointerdblclick: function (evt, x, y) {\n\t    CellView.prototype.pointerdblclick.apply(this, arguments);\n\t    this.notify('element:pointerdblclick', evt, x, y);\n\t  },\n\t  pointerclick: function (evt, x, y) {\n\t    CellView.prototype.pointerclick.apply(this, arguments);\n\t    this.notify('element:pointerclick', evt, x, y);\n\t  },\n\t  contextmenu: function (evt, x, y) {\n\t    CellView.prototype.contextmenu.apply(this, arguments);\n\t    this.notify('element:contextmenu', evt, x, y);\n\t  },\n\t  pointerdown: function (evt, x, y) {\n\t    this.notifyPointerdown(evt, x, y);\n\t    this.dragStart(evt, x, y);\n\t  },\n\t  pointermove: function (evt, x, y) {\n\t    const data = this.eventData(evt);\n\t    const {\n\t      targetMagnet,\n\t      action,\n\t      delegatedView\n\t    } = data;\n\t    if (targetMagnet) {\n\t      this.magnetpointermove(evt, targetMagnet, x, y);\n\t    }\n\t    switch (action) {\n\t      case DragActions.MAGNET:\n\t        this.dragMagnet(evt, x, y);\n\t        break;\n\t      case DragActions.MOVE:\n\t        (delegatedView || this).drag(evt, x, y);\n\t      // eslint: no-fallthrough=false\n\t      default:\n\t        if (data.preventPointerEvents) break;\n\t        this.notifyPointermove(evt, x, y);\n\t        break;\n\t    }\n\n\t    // Make sure the element view data is passed along.\n\t    // It could have been wiped out in the handlers above.\n\t    this.eventData(evt, data);\n\t  },\n\t  pointerup: function (evt, x, y) {\n\t    const data = this.eventData(evt);\n\t    const {\n\t      targetMagnet,\n\t      action,\n\t      delegatedView\n\t    } = data;\n\t    if (targetMagnet) {\n\t      this.magnetpointerup(evt, targetMagnet, x, y);\n\t    }\n\t    switch (action) {\n\t      case DragActions.MAGNET:\n\t        this.dragMagnetEnd(evt, x, y);\n\t        break;\n\t      case DragActions.MOVE:\n\t        (delegatedView || this).dragEnd(evt, x, y);\n\t      // eslint: no-fallthrough=false\n\t      default:\n\t        if (data.preventPointerEvents) break;\n\t        this.notifyPointerup(evt, x, y);\n\t    }\n\t    if (targetMagnet) {\n\t      this.magnetpointerclick(evt, targetMagnet, x, y);\n\t    }\n\t    this.checkMouseleave(evt);\n\t  },\n\t  mouseover: function (evt) {\n\t    CellView.prototype.mouseover.apply(this, arguments);\n\t    this.notify('element:mouseover', evt);\n\t  },\n\t  mouseout: function (evt) {\n\t    CellView.prototype.mouseout.apply(this, arguments);\n\t    this.notify('element:mouseout', evt);\n\t  },\n\t  mouseenter: function (evt) {\n\t    CellView.prototype.mouseenter.apply(this, arguments);\n\t    this.notify('element:mouseenter', evt);\n\t  },\n\t  mouseleave: function (evt) {\n\t    CellView.prototype.mouseleave.apply(this, arguments);\n\t    this.notify('element:mouseleave', evt);\n\t  },\n\t  mousewheel: function (evt, x, y, delta) {\n\t    CellView.prototype.mousewheel.apply(this, arguments);\n\t    this.notify('element:mousewheel', evt, x, y, delta);\n\t  },\n\t  onmagnet: function (evt, x, y) {\n\t    const {\n\t      currentTarget: targetMagnet\n\t    } = evt;\n\t    this.magnetpointerdown(evt, targetMagnet, x, y);\n\t    this.eventData(evt, {\n\t      targetMagnet\n\t    });\n\t    this.dragMagnetStart(evt, x, y);\n\t  },\n\t  magnetpointerdown: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:pointerdown', evt, magnet, x, y);\n\t  },\n\t  magnetpointermove: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:pointermove', evt, magnet, x, y);\n\t  },\n\t  magnetpointerup: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:pointerup', evt, magnet, x, y);\n\t  },\n\t  magnetpointerdblclick: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n\t  },\n\t  magnetcontextmenu: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n\t  },\n\t  // Drag Start Handlers\n\n\t  dragStart: function (evt, x, y) {\n\t    if (this.isDefaultInteractionPrevented(evt)) return;\n\t    var view = this.getDelegatedView();\n\t    if (!view || !view.can('elementMove')) return;\n\t    this.eventData(evt, {\n\t      action: DragActions.MOVE,\n\t      delegatedView: view\n\t    });\n\t    const position = view.model.position();\n\t    view.eventData(evt, {\n\t      initialPosition: position,\n\t      pointerOffset: position.difference(x, y),\n\t      restrictedArea: this.paper.getRestrictedArea(view, x, y)\n\t    });\n\t  },\n\t  dragMagnetStart: function (evt, x, y) {\n\t    const {\n\t      paper\n\t    } = this;\n\t    const isPropagationAlreadyStopped = evt.isPropagationStopped();\n\t    if (isPropagationAlreadyStopped) {\n\t      // Special case when the propagation was already stopped\n\t      // on the `element:magnet:pointerdown` event.\n\t      // Do not trigger any `element:pointer*` events\n\t      // but still start the magnet dragging.\n\t      this.eventData(evt, {\n\t        preventPointerEvents: true\n\t      });\n\t    }\n\t    if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {\n\t      // Stop the default action, which is to start dragging a link.\n\t      return;\n\t    }\n\t    const {\n\t      targetMagnet = evt.currentTarget\n\t    } = this.eventData(evt);\n\t    evt.stopPropagation();\n\n\t    // Invalid (Passive) magnet. Start dragging the element.\n\t    if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n\t      if (isPropagationAlreadyStopped) {\n\t        // Do not trigger `element:pointerdown` and start element dragging\n\t        // if the propagation was stopped.\n\t        this.dragStart(evt, x, y);\n\t        // The `element:pointerdown` event is not triggered because\n\t        // of `preventPointerEvents` flag.\n\t      } else {\n\t        // We need to reset the action\n\t        // to `MOVE` so that the element is dragged.\n\t        this.pointerdown(evt, x, y);\n\t      }\n\t      return;\n\t    }\n\n\t    // Valid magnet. Start dragging a link.\n\t    if (paper.options.magnetThreshold <= 0) {\n\t      this.dragLinkStart(evt, targetMagnet, x, y);\n\t    }\n\t    this.eventData(evt, {\n\t      action: DragActions.MAGNET\n\t    });\n\t  },\n\t  // Drag Handlers\n\n\t  snapToGrid: function (evt, x, y) {\n\t    const grid = this.paper.options.gridSize;\n\t    return {\n\t      x: snapToGrid$1(x, grid),\n\t      y: snapToGrid$1(y, grid)\n\t    };\n\t  },\n\t  drag: function (evt, x, y) {\n\t    var paper = this.paper;\n\t    var element = this.model;\n\t    var data = this.eventData(evt);\n\t    var {\n\t      pointerOffset,\n\t      restrictedArea,\n\t      embedding\n\t    } = data;\n\n\t    // Make sure the new element's position always snaps to the current grid\n\t    const {\n\t      x: elX,\n\t      y: elY\n\t    } = this.snapToGrid(evt, x + pointerOffset.x, y + pointerOffset.y);\n\t    element.position(elX, elY, {\n\t      restrictedArea,\n\t      deep: true,\n\t      ui: true\n\t    });\n\t    if (paper.options.embeddingMode) {\n\t      if (!embedding) {\n\t        // Prepare the element for embedding only if the pointer moves.\n\t        // We don't want to do unnecessary action with the element\n\t        // if an user only clicks/dblclicks on it.\n\t        this.prepareEmbedding(data);\n\t        embedding = true;\n\t      }\n\t      this.processEmbedding(data, evt, x, y);\n\t    }\n\t    this.eventData(evt, {\n\t      embedding\n\t    });\n\t  },\n\t  dragMagnet: function (evt, x, y) {\n\t    this.dragLink(evt, x, y);\n\t  },\n\t  // Drag End Handlers\n\n\t  dragEnd: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    if (data.embedding) this.finalizeEmbedding(data);\n\t  },\n\t  dragMagnetEnd: function (evt, x, y) {\n\t    this.dragLinkEnd(evt, x, y);\n\t  },\n\t  magnetpointerclick: function (evt, magnet, x, y) {\n\t    var paper = this.paper;\n\t    if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n\t    this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n\t  }\n\t}, {\n\t  Flags: Flags$1\n\t});\n\tassign(ElementView.prototype, elementViewPortPrototype);\n\n\tconst Flags = {\n\t  TOOLS: CellView.Flags.TOOLS,\n\t  RENDER: 'RENDER',\n\t  UPDATE: 'UPDATE',\n\t  LABELS: 'LABELS',\n\t  SOURCE: 'SOURCE',\n\t  TARGET: 'TARGET',\n\t  CONNECTOR: 'CONNECTOR'\n\t};\n\n\t// Link base view and controller.\n\t// ----------------------------------------\n\n\tconst LinkView = CellView.extend({\n\t  className: function () {\n\t    var classNames = CellView.prototype.className.apply(this).split(' ');\n\t    classNames.push('link');\n\t    return classNames.join(' ');\n\t  },\n\t  _labelCache: null,\n\t  _labelSelectors: null,\n\t  _V: null,\n\t  _sourceMagnet: null,\n\t  _targetMagnet: null,\n\t  _dragData: null,\n\t  // deprecated\n\n\t  metrics: null,\n\t  decimalsRounding: 2,\n\t  initialize: function () {\n\t    CellView.prototype.initialize.apply(this, arguments);\n\n\t    // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n\t    // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n\t    // nodes in `updateLabelPosition()` in order to update the label positions.\n\t    this._labelCache = {};\n\n\t    // a cache of label selectors\n\t    this._labelSelectors = {};\n\n\t    // cache of default markup nodes\n\t    this._V = {};\n\n\t    // connection path metrics\n\t    this.cleanNodesCache();\n\t  },\n\t  presentationAttributes: {\n\t    markup: [Flags.RENDER],\n\t    attrs: [Flags.UPDATE],\n\t    router: [Flags.UPDATE],\n\t    connector: [Flags.CONNECTOR],\n\t    labels: [Flags.LABELS, Flags.TOOLS],\n\t    labelMarkup: [Flags.LABELS],\n\t    vertices: [Flags.UPDATE],\n\t    source: [Flags.SOURCE, Flags.UPDATE],\n\t    target: [Flags.TARGET, Flags.UPDATE]\n\t  },\n\t  initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n\t  UPDATE_PRIORITY: 1,\n\t  EPSILON: 1e-6,\n\t  confirmUpdate: function (flags, opt = {}) {\n\t    const {\n\t      paper,\n\t      model\n\t    } = this;\n\t    const {\n\t      attributes\n\t    } = model;\n\t    const {\n\t      source: {\n\t        id: sourceId\n\t      },\n\t      target: {\n\t        id: targetId\n\t      }\n\t    } = attributes;\n\t    if (this.hasFlag(flags, Flags.SOURCE)) {\n\t      this._sourceMagnet = null; // reset cached source magnet\n\t      this.checkEndModel('source', sourceId);\n\t      flags = this.removeFlag(flags, Flags.SOURCE);\n\t    }\n\t    if (this.hasFlag(flags, Flags.TARGET)) {\n\t      this._targetMagnet = null; // reset cached target magnet\n\t      this.checkEndModel('target', targetId);\n\t      flags = this.removeFlag(flags, Flags.TARGET);\n\t    }\n\t    if (paper && (sourceId && !paper.isCellVisible(sourceId) || targetId && !paper.isCellVisible(targetId))) {\n\t      // Wait for the source and target views to be rendered\n\t      return flags;\n\t    }\n\t    if (this.hasFlag(flags, Flags.RENDER)) {\n\t      this.render();\n\t      this.updateHighlighters(true);\n\t      this.updateTools(opt);\n\t      flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);\n\t      if (env.test('isAppleWebKit')) {\n\t        this.__fixWebKitBug268376();\n\t      }\n\t      return flags;\n\t    }\n\t    let updateHighlighters = false;\n\t    let updateLabels = this.hasFlag(flags, Flags.LABELS);\n\t    if (updateLabels) {\n\t      this.onLabelsChange(model, attributes.labels, opt);\n\t      flags = this.removeFlag(flags, Flags.LABELS);\n\t      updateHighlighters = true;\n\t    }\n\t    const updateAll = this.hasFlag(flags, Flags.UPDATE);\n\t    const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n\t    if (updateAll || updateConnector) {\n\t      if (!updateAll) {\n\t        // Keep the current route and update the geometry\n\t        this.updatePath();\n\t        this.updateDOM();\n\t      } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n\t        // The link is being translated by an ancestor that will\n\t        // shift source point, target point and all vertices\n\t        // by an equal distance.\n\t        this.translate(opt.tx, opt.ty);\n\t      } else {\n\t        this.update();\n\t      }\n\t      this.updateTools(opt);\n\t      flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n\t      updateLabels = false;\n\t      updateHighlighters = true;\n\t    }\n\t    if (updateLabels) {\n\t      this.updateLabelPositions();\n\t    }\n\t    if (updateHighlighters) {\n\t      this.updateHighlighters();\n\t    }\n\t    if (this.hasFlag(flags, Flags.TOOLS)) {\n\t      this.updateTools(opt);\n\t      flags = this.removeFlag(flags, Flags.TOOLS);\n\t    }\n\t    return flags;\n\t  },\n\t  __fixWebKitBug268376: function () {\n\t    // WebKit has a bug where any change after the first render is not reflected in the DOM.\n\t    // https://bugs.webkit.org/show_bug.cgi?id=268376\n\t    const {\n\t      el\n\t    } = this;\n\t    const childNodes = Array.from(el.childNodes);\n\t    const fragment = document.createDocumentFragment();\n\t    for (let i = 0, n = childNodes.length; i < n; i++) {\n\t      el.removeChild(childNodes[i]);\n\t      fragment.appendChild(childNodes[i]);\n\t    }\n\t    el.appendChild(fragment);\n\t  },\n\t  requestConnectionUpdate: function (opt) {\n\t    this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n\t  },\n\t  isLabelsRenderRequired: function (opt = {}) {\n\t    const previousLabels = this.model.previous('labels');\n\t    if (!previousLabels) return true;\n\n\t    // Here is an optimization for cases when we know, that change does\n\t    // not require re-rendering of all labels.\n\t    if ('propertyPathArray' in opt && 'propertyValue' in opt) {\n\t      // The label is setting by `prop()` method\n\t      var pathArray = opt.propertyPathArray || [];\n\t      var pathLength = pathArray.length;\n\t      if (pathLength > 1) {\n\t        // We are changing a single label here e.g. 'labels/0/position'\n\t        var labelExists = !!previousLabels[pathArray[1]];\n\t        if (labelExists) {\n\t          if (pathLength === 2) {\n\t            // We are changing the entire label. Need to check if the\n\t            // markup is also being changed.\n\t            return 'markup' in Object(opt.propertyValue);\n\t          } else if (pathArray[2] !== 'markup') {\n\t            // We are changing a label property but not the markup\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  },\n\t  onLabelsChange: function (_link, _labels, opt) {\n\t    // Note: this optimization works in async=false mode only\n\t    if (this.isLabelsRenderRequired(opt)) {\n\t      this.renderLabels();\n\t    } else {\n\t      this.updateLabels();\n\t    }\n\t  },\n\t  // Rendering.\n\t  // ----------\n\n\t  render: function () {\n\t    this.vel.empty();\n\t    this.unmountLabels();\n\t    this._V = {};\n\t    this.renderMarkup();\n\t    // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n\t    // returns zero values)\n\t    this.renderLabels();\n\t    this.update();\n\t    return this;\n\t  },\n\t  renderMarkup: function () {\n\t    var link = this.model;\n\t    var markup = link.get('markup') || link.markup;\n\t    if (!markup) throw new Error('dia.LinkView: markup required');\n\t    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n\t    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n\t    throw new Error('dia.LinkView: invalid markup');\n\t  },\n\t  renderJSONMarkup: function (markup) {\n\t    var doc = this.parseDOMJSON(markup, this.el);\n\t    // Selectors\n\t    this.selectors = doc.selectors;\n\t    // Fragment\n\t    this.vel.append(doc.fragment);\n\t  },\n\t  renderStringMarkup: function (markup) {\n\t    // A special markup can be given in the `properties.markup` property. This might be handy\n\t    // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n\t    // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n\t    // of elements with special meaning though. Therefore, those classes should be preserved in any\n\t    // special markup passed in `properties.markup`.\n\t    var children = V(markup);\n\t    // custom markup may contain only one children\n\t    if (!Array.isArray(children)) children = [children];\n\t    this.vel.append(children);\n\t  },\n\t  _getLabelMarkup: function (labelMarkup) {\n\t    if (!labelMarkup) return undefined;\n\t    if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n\t    if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n\t    throw new Error('dia.linkView: invalid label markup');\n\t  },\n\t  _getLabelStringMarkup: function (labelMarkup) {\n\t    var children = V(labelMarkup);\n\t    var fragment = document.createDocumentFragment();\n\t    if (!Array.isArray(children)) {\n\t      fragment.appendChild(children.node);\n\t    } else {\n\t      for (var i = 0, n = children.length; i < n; i++) {\n\t        var currentChild = children[i].node;\n\t        fragment.appendChild(currentChild);\n\t      }\n\t    }\n\t    return {\n\t      fragment: fragment,\n\t      selectors: {}\n\t    }; // no selectors\n\t  },\n\t  // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n\t  // If it doesn't, add the <g /> container here.\n\t  _normalizeLabelMarkup: function (markup) {\n\t    if (!markup) return undefined;\n\t    var fragment = markup.fragment;\n\t    if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\t    var vNode;\n\t    var childNodes = fragment.childNodes;\n\t    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n\t      // default markup fragment is not wrapped in <g />\n\t      // add a <g /> container\n\t      vNode = V('g').append(fragment);\n\t    } else {\n\t      vNode = V(childNodes[0]);\n\t    }\n\t    vNode.addClass('label');\n\t    return {\n\t      node: vNode.node,\n\t      selectors: markup.selectors\n\t    };\n\t  },\n\t  renderLabels: function () {\n\t    var cache = this._V;\n\t    var vLabels = cache.labels;\n\t    var labelCache = this._labelCache = {};\n\t    var labelSelectors = this._labelSelectors = {};\n\t    var model = this.model;\n\t    var labels = model.attributes.labels || [];\n\t    var labelsCount = labels.length;\n\t    if (labelsCount === 0) {\n\t      if (vLabels) vLabels.remove();\n\t      return this;\n\t    }\n\t    if (vLabels) {\n\t      vLabels.empty();\n\t    } else {\n\t      // there is no label container in the markup but some labels are defined\n\t      // add a <g class=\"labels\" /> container\n\t      vLabels = cache.labels = V('g').addClass('labels');\n\t      if (this.options.labelsLayer) {\n\t        vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n\t        vLabels.attr('model-id', model.id);\n\t      }\n\t    }\n\t    for (var i = 0; i < labelsCount; i++) {\n\t      var label = labels[i];\n\t      var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n\t      var labelNode;\n\t      var selectors;\n\t      if (labelMarkup) {\n\t        labelNode = labelMarkup.node;\n\t        selectors = labelMarkup.selectors;\n\t      } else {\n\t        var builtinDefaultLabel = model._builtins.defaultLabel;\n\t        var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n\t        var defaultLabel = model._getDefaultLabel();\n\t        var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n\t        var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\t        labelNode = defaultMarkup.node;\n\t        selectors = defaultMarkup.selectors;\n\t      }\n\t      labelNode.setAttribute('label-idx', i); // assign label-idx\n\t      vLabels.append(labelNode);\n\t      labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n\t      var rootSelector = this.selector;\n\t      if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n\t      selectors[rootSelector] = labelNode;\n\t      labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n\t    }\n\t    if (!vLabels.parent()) {\n\t      this.mountLabels();\n\t    }\n\t    this.updateLabels();\n\t    return this;\n\t  },\n\t  mountLabels: function () {\n\t    const {\n\t      el,\n\t      paper,\n\t      model,\n\t      _V,\n\t      options\n\t    } = this;\n\t    const {\n\t      labels: vLabels\n\t    } = _V;\n\t    if (!vLabels || !model.hasLabels()) return;\n\t    const {\n\t      node\n\t    } = vLabels;\n\t    if (options.labelsLayer) {\n\t      paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n\t    } else {\n\t      if (node.parentNode !== el) {\n\t        el.appendChild(node);\n\t      }\n\t    }\n\t  },\n\t  unmountLabels: function () {\n\t    const {\n\t      options,\n\t      _V\n\t    } = this;\n\t    if (!_V) return;\n\t    const {\n\t      labels: vLabels\n\t    } = _V;\n\t    if (vLabels && options.labelsLayer) {\n\t      vLabels.remove();\n\t    }\n\t  },\n\t  findLabelNodes: function (labelIndex, selector) {\n\t    const labelRoot = this._labelCache[labelIndex];\n\t    if (!labelRoot) return [];\n\t    const labelSelectors = this._labelSelectors[labelIndex];\n\t    return this.findBySelector(selector, labelRoot, labelSelectors);\n\t  },\n\t  findLabelNode: function (labelIndex, selector) {\n\t    const [node = null] = this.findLabelNodes(labelIndex, selector);\n\t    return node;\n\t  },\n\t  // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n\t  // keep `undefined` or `null` because `{}` means something else\n\t  _mergeLabelAttrs: function (hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\t    if (labelAttrs === null) return null;\n\t    if (labelAttrs === undefined) {\n\t      if (defaultLabelAttrs === null) return null;\n\t      if (defaultLabelAttrs === undefined) {\n\t        if (hasCustomMarkup) return undefined;\n\t        return builtinDefaultLabelAttrs;\n\t      }\n\t      if (hasCustomMarkup) return defaultLabelAttrs;\n\t      return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n\t    }\n\t    if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n\t    return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n\t  },\n\t  // merge default label size into label size (no built-in default)\n\t  // keep `undefined` or `null` because `{}` means something else\n\t  _mergeLabelSize: function (labelSize, defaultLabelSize) {\n\t    if (labelSize === null) return null;\n\t    if (labelSize === undefined) {\n\t      if (defaultLabelSize === null) return null;\n\t      if (defaultLabelSize === undefined) return undefined;\n\t      return defaultLabelSize;\n\t    }\n\t    return merge({}, defaultLabelSize, labelSize);\n\t  },\n\t  updateLabels: function () {\n\t    if (!this._V.labels) return this;\n\t    if (!this.paper.options.labelLayer) {\n\t      // If there is no label layer, the cache needs to be cleared\n\t      // of the root node because the labels are attached\n\t      // to it and could affect the bounding box.\n\t      this.cleanNodeCache(this.el);\n\t    }\n\t    var model = this.model;\n\t    var labels = model.get('labels') || [];\n\t    var canLabelMove = this.can('labelMove');\n\t    var builtinDefaultLabel = model._builtins.defaultLabel;\n\t    var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\t    var defaultLabel = model._getDefaultLabel();\n\t    var defaultLabelMarkup = defaultLabel.markup;\n\t    var defaultLabelAttrs = defaultLabel.attrs;\n\t    var defaultLabelSize = defaultLabel.size;\n\t    for (var i = 0, n = labels.length; i < n; i++) {\n\t      var labelNode = this._labelCache[i];\n\t      labelNode.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n\t      var selectors = this._labelSelectors[i];\n\t      var label = labels[i];\n\t      var labelMarkup = label.markup;\n\t      var labelAttrs = label.attrs;\n\t      var labelSize = label.size;\n\t      var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);\n\t      var size = this._mergeLabelSize(labelSize, defaultLabelSize);\n\t      this.updateDOMSubtreeAttributes(labelNode, attrs, {\n\t        rootBBox: new Rect(size),\n\t        selectors: selectors\n\t      });\n\t    }\n\t    return this;\n\t  },\n\t  // remove vertices that lie on (or nearly on) straight lines within the link\n\t  // return the number of removed points\n\t  removeRedundantLinearVertices: function (opt) {\n\t    const SIMPLIFY_THRESHOLD = 0.001;\n\t    const link = this.model;\n\t    const vertices = link.vertices();\n\t    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n\t    const numRoutePoints = routePoints.length;\n\n\t    // put routePoints into a polyline and try to simplify\n\t    const polyline = new Polyline$1(routePoints);\n\t    polyline.simplify({\n\t      threshold: SIMPLIFY_THRESHOLD\n\t    });\n\t    const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification\n\t    const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n\t    // shortcut if simplification did not remove any redundant vertices:\n\t    if (numRoutePoints === numPolylinePoints) return 0;\n\n\t    // else: set simplified polyline points as link vertices\n\t    // remove first and last polyline points again (= source/target anchors)\n\t    link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n\t    return numRoutePoints - numPolylinePoints;\n\t  },\n\t  getEndView: function (type) {\n\t    switch (type) {\n\t      case 'source':\n\t        return this.sourceView || null;\n\t      case 'target':\n\t        return this.targetView || null;\n\t      default:\n\t        throw new Error('dia.LinkView: type parameter required.');\n\t    }\n\t  },\n\t  getEndAnchor: function (type) {\n\t    switch (type) {\n\t      case 'source':\n\t        return new Point(this.sourceAnchor);\n\t      case 'target':\n\t        return new Point(this.targetAnchor);\n\t      default:\n\t        throw new Error('dia.LinkView: type parameter required.');\n\t    }\n\t  },\n\t  getEndConnectionPoint: function (type) {\n\t    switch (type) {\n\t      case 'source':\n\t        return new Point(this.sourcePoint);\n\t      case 'target':\n\t        return new Point(this.targetPoint);\n\t      default:\n\t        throw new Error('dia.LinkView: type parameter required.');\n\t    }\n\t  },\n\t  getEndMagnet: function (type) {\n\t    switch (type) {\n\t      case 'source':\n\t        var sourceView = this.sourceView;\n\t        if (!sourceView) break;\n\t        return this.sourceMagnet || sourceView.el;\n\t      case 'target':\n\t        var targetView = this.targetView;\n\t        if (!targetView) break;\n\t        return this.targetMagnet || targetView.el;\n\t      default:\n\t        throw new Error('dia.LinkView: type parameter required.');\n\t    }\n\t    return null;\n\t  },\n\t  // Updating.\n\t  // ---------\n\n\t  update: function () {\n\t    this.updateRoute();\n\t    this.updatePath();\n\t    this.updateDOM();\n\t    return this;\n\t  },\n\t  translate: function (tx = 0, ty = 0) {\n\t    const {\n\t      route,\n\t      path\n\t    } = this;\n\t    if (!route || !path) return;\n\t    // translate the route\n\t    const polyline = new Polyline$1(route);\n\t    polyline.translate(tx, ty);\n\t    this.route = polyline.points;\n\t    // translate source and target connection and anchor points.\n\t    this.sourcePoint.offset(tx, ty);\n\t    this.targetPoint.offset(tx, ty);\n\t    this.sourceAnchor.offset(tx, ty);\n\t    this.targetAnchor.offset(tx, ty);\n\t    // translate the geometry path\n\t    path.translate(tx, ty);\n\t    this.updateDOM();\n\t  },\n\t  updateDOM() {\n\t    const {\n\t      el,\n\t      model,\n\t      selectors\n\t    } = this;\n\t    this.cleanNodesCache();\n\t    // update SVG attributes defined by 'attrs/'.\n\t    this.updateDOMSubtreeAttributes(el, model.attr(), {\n\t      selectors\n\t    });\n\t    // update the label position etc.\n\t    this.updateLabelPositions();\n\t    // *Deprecated*\n\t    // Local perpendicular flag (as opposed to one defined on paper).\n\t    // Could be enabled inside a connector/router. It's valid only\n\t    // during the update execution.\n\t    this.options.perpendicular = null;\n\t  },\n\t  updateRoute: function () {\n\t    const {\n\t      model\n\t    } = this;\n\t    const vertices = model.vertices();\n\t    // 1. Find Anchors\n\t    const anchors = this.findAnchors(vertices);\n\t    const sourceAnchor = this.sourceAnchor = anchors.source;\n\t    const targetAnchor = this.targetAnchor = anchors.target;\n\t    // 2. Find Route\n\t    const route = this.findRoute(vertices);\n\t    this.route = route;\n\t    // 3. Find Connection Points\n\t    var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n\t    this.sourcePoint = connectionPoints.source;\n\t    this.targetPoint = connectionPoints.target;\n\t  },\n\t  updatePath: function () {\n\t    const {\n\t      route,\n\t      sourcePoint,\n\t      targetPoint\n\t    } = this;\n\t    // 4. Find Connection\n\t    const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());\n\t    this.path = path;\n\t  },\n\t  findAnchorsOrdered: function (firstEndType, firstRef, secondEndType, secondRef) {\n\t    var firstAnchor, secondAnchor;\n\t    var firstAnchorRef, secondAnchorRef;\n\t    var model = this.model;\n\t    var firstDef = model.get(firstEndType);\n\t    var secondDef = model.get(secondEndType);\n\t    var firstView = this.getEndView(firstEndType);\n\t    var secondView = this.getEndView(secondEndType);\n\t    var firstMagnet = this.getEndMagnet(firstEndType);\n\t    var secondMagnet = this.getEndMagnet(secondEndType);\n\n\t    // Anchor first\n\t    if (firstView) {\n\t      if (firstRef) {\n\t        firstAnchorRef = new Point(firstRef);\n\t      } else if (secondView) {\n\t        firstAnchorRef = secondMagnet;\n\t      } else {\n\t        firstAnchorRef = new Point(secondDef);\n\t      }\n\t      firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n\t    } else {\n\t      firstAnchor = new Point(firstDef);\n\t    }\n\n\t    // Anchor second\n\t    if (secondView) {\n\t      secondAnchorRef = new Point(secondRef || firstAnchor);\n\t      secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n\t    } else {\n\t      secondAnchor = new Point(secondDef);\n\t    }\n\t    var res = {};\n\t    res[firstEndType] = firstAnchor;\n\t    res[secondEndType] = secondAnchor;\n\t    return res;\n\t  },\n\t  findAnchors: function (vertices) {\n\t    var model = this.model;\n\t    var firstVertex = vertices[0];\n\t    var lastVertex = vertices[vertices.length - 1];\n\t    if (model.target().priority && !model.source().priority) {\n\t      // Reversed order\n\t      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n\t    }\n\n\t    // Usual order\n\t    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n\t  },\n\t  findConnectionPoints: function (route, sourceAnchor, targetAnchor) {\n\t    var firstWaypoint = route[0];\n\t    var lastWaypoint = route[route.length - 1];\n\t    var model = this.model;\n\t    var sourceDef = model.get('source');\n\t    var targetDef = model.get('target');\n\t    var sourceView = this.sourceView;\n\t    var targetView = this.targetView;\n\t    var paperOptions = this.paper.options;\n\t    var sourceMagnet, targetMagnet;\n\n\t    // Connection Point Source\n\t    var sourcePoint;\n\t    if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n\t      sourceMagnet = this.sourceMagnet || sourceView.el;\n\t      var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n\t      var sourcePointRef = firstWaypoint || targetAnchor;\n\t      var sourceLine = new Line(sourcePointRef, sourceAnchor);\n\t      sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n\t    } else {\n\t      sourcePoint = sourceAnchor;\n\t    }\n\t    // Connection Point Target\n\t    var targetPoint;\n\t    if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n\t      targetMagnet = this.targetMagnet || targetView.el;\n\t      var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n\t      var targetPointRef = lastWaypoint || sourceAnchor;\n\t      var targetLine = new Line(targetPointRef, targetAnchor);\n\t      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n\t    } else {\n\t      targetPoint = targetAnchor;\n\t    }\n\t    return {\n\t      source: sourcePoint,\n\t      target: targetPoint\n\t    };\n\t  },\n\t  getAnchor: function (anchorDef, cellView, magnet, ref, endType) {\n\t    var isConnection = cellView.isNodeConnection(magnet);\n\t    var paperOptions = this.paper.options;\n\t    if (!anchorDef) {\n\t      if (isConnection) {\n\t        anchorDef = paperOptions.defaultLinkAnchor;\n\t      } else {\n\t        if (this.options.perpendicular) {\n\t          // Backwards compatibility\n\t          // See `manhattan` router for more details\n\t          anchorDef = {\n\t            name: 'perpendicular'\n\t          };\n\t        } else {\n\t          anchorDef = paperOptions.defaultAnchor;\n\t        }\n\t      }\n\t    }\n\t    if (!anchorDef) throw new Error('Anchor required.');\n\t    var anchorFn;\n\t    if (typeof anchorDef === 'function') {\n\t      anchorFn = anchorDef;\n\t    } else {\n\t      var anchorName = anchorDef.name;\n\t      var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n\t      anchorFn = paperOptions[anchorNamespace][anchorName];\n\t      if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n\t    }\n\t    var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);\n\t    if (!anchor) return new Point();\n\t    return anchor.round(this.decimalsRounding);\n\t  },\n\t  getConnectionPoint: function (connectionPointDef, view, magnet, line, endType) {\n\t    var connectionPoint;\n\t    var anchor = line.end;\n\t    var paperOptions = this.paper.options;\n\t    if (!connectionPointDef) return anchor;\n\t    var connectionPointFn;\n\t    if (typeof connectionPointDef === 'function') {\n\t      connectionPointFn = connectionPointDef;\n\t    } else {\n\t      var connectionPointName = connectionPointDef.name;\n\t      connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n\t      if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n\t    }\n\t    connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n\t    if (!connectionPoint) return anchor;\n\t    return connectionPoint.round(this.decimalsRounding);\n\t  },\n\t  isIntersecting: function (geometryShape, geometryData) {\n\t    const connection = this.getConnection();\n\t    if (!connection) return false;\n\t    return intersection$1.exists(geometryShape, connection, geometryData, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  isEnclosedIn: function (geometryRect) {\n\t    const connection = this.getConnection();\n\t    if (!connection) return false;\n\t    const bbox = connection.bbox();\n\t    if (!bbox) return false;\n\t    return geometryRect.containsRect(bbox);\n\t  },\n\t  isAtPoint: function (point /*, options */) {\n\t    // Note: `strict` option is not applicable for links.\n\t    // There is currently no method to determine if a path contains a point.\n\t    const area = new Rect(point);\n\t    // Intersection with a zero-size area is not possible.\n\t    area.inflate(this.EPSILON);\n\t    return this.isIntersecting(area);\n\t  },\n\t  // combine default label position with built-in default label position\n\t  _getDefaultLabelPositionProperty: function () {\n\t    var model = this.model;\n\t    var builtinDefaultLabel = model._builtins.defaultLabel;\n\t    var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\t    var defaultLabel = model._getDefaultLabel();\n\t    var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\t    return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n\t  },\n\t  // if label position is a number, normalize it to a position object\n\t  // this makes sure that label positions can be merged properly\n\t  _normalizeLabelPosition: function (labelPosition) {\n\t    if (typeof labelPosition === 'number') return {\n\t      distance: labelPosition,\n\t      offset: null,\n\t      angle: 0,\n\t      args: null\n\t    };\n\t    return labelPosition;\n\t  },\n\t  // expects normalized position properties\n\t  // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n\t  _mergeLabelPositionProperty: function (normalizedLabelPosition, normalizedDefaultLabelPosition) {\n\t    if (normalizedLabelPosition === null) return null;\n\t    if (normalizedLabelPosition === undefined) {\n\t      if (normalizedDefaultLabelPosition === null) return null;\n\t      return normalizedDefaultLabelPosition;\n\t    }\n\t    return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n\t  },\n\t  updateLabelPositions: function () {\n\t    if (!this._V.labels) return this;\n\t    var path = this.path;\n\t    if (!path) return this;\n\n\t    // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n\t    // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n\t    var model = this.model;\n\t    var labels = model.get('labels') || [];\n\t    if (!labels.length) return this;\n\t    var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\t    for (var idx = 0, n = labels.length; idx < n; idx++) {\n\t      var labelNode = this._labelCache[idx];\n\t      if (!labelNode) continue;\n\t      var label = labels[idx];\n\t      var labelPosition = this._normalizeLabelPosition(label.position);\n\t      var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n\t      var transformationMatrix = this._getLabelTransformationMatrix(position);\n\t      labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n\t      this._cleanLabelMatrices(idx);\n\t    }\n\t    return this;\n\t  },\n\t  _cleanLabelMatrices: function (index) {\n\t    // Clean magnetMatrix for all nodes of the label.\n\t    // Cached BoundingRect does not need to updated when the position changes\n\t    // TODO: this doesn't work for labels with XML String markups.\n\t    const {\n\t      metrics,\n\t      _labelSelectors\n\t    } = this;\n\t    const selectors = _labelSelectors[index];\n\t    if (!selectors) return;\n\t    for (const selector in selectors) {\n\t      const {\n\t        id\n\t      } = selectors[selector];\n\t      if (id && id in metrics) delete metrics[id].magnetMatrix;\n\t    }\n\t  },\n\t  checkEndModel: function (endType, endId) {\n\t    if (!endId) return;\n\t    const endModel = this.paper.getModelById(endId);\n\t    if (!endModel) {\n\t      throw new Error(`LinkView: invalid ${endType} cell.`);\n\t    }\n\t  },\n\t  _getLabelPositionProperty: function (idx) {\n\t    return this.model.label(idx).position || {};\n\t  },\n\t  _getLabelPositionAngle: function (idx) {\n\t    var labelPosition = this._getLabelPositionProperty(idx);\n\t    return labelPosition.angle || 0;\n\t  },\n\t  _getLabelPositionArgs: function (idx) {\n\t    var labelPosition = this._getLabelPositionProperty(idx);\n\t    return labelPosition.args;\n\t  },\n\t  _getDefaultLabelPositionArgs: function () {\n\t    var defaultLabel = this.model._getDefaultLabel();\n\t    var defaultLabelPosition = defaultLabel.position || {};\n\t    return defaultLabelPosition.args;\n\t  },\n\t  // merge default label position args into label position args\n\t  // keep `undefined` or `null` because `{}` means something else\n\t  _mergeLabelPositionArgs: function (labelPositionArgs, defaultLabelPositionArgs) {\n\t    if (labelPositionArgs === null) return null;\n\t    if (labelPositionArgs === undefined) {\n\t      if (defaultLabelPositionArgs === null) return null;\n\t      return defaultLabelPositionArgs;\n\t    }\n\t    return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n\t  },\n\t  // Add default label at given position at end of `labels` array.\n\t  // Four signatures:\n\t  // - obj, obj = point, opt\n\t  // - obj, num, obj = point, angle, opt\n\t  // - num, num, obj = x, y, opt\n\t  // - num, num, num, obj = x, y, angle, opt\n\t  // Assigns relative coordinates by default:\n\t  // `opt.absoluteDistance` forces absolute coordinates.\n\t  // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n\t  // `opt.absoluteOffset` forces absolute coordinates for offset.\n\t  // Additional args:\n\t  // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n\t  // `opt.ensureLegibility` rotates labels so they are never upside-down.\n\t  addLabel: function (p1, p2, p3, p4) {\n\t    // normalize data from the four possible signatures\n\t    var localX;\n\t    var localY;\n\t    var localAngle = 0;\n\t    var localOpt;\n\t    if (typeof p1 !== 'number') {\n\t      // {x, y} object provided as first parameter\n\t      localX = p1.x;\n\t      localY = p1.y;\n\t      if (typeof p2 === 'number') {\n\t        // angle and opt provided as second and third parameters\n\t        localAngle = p2;\n\t        localOpt = p3;\n\t      } else {\n\t        // opt provided as second parameter\n\t        localOpt = p2;\n\t      }\n\t    } else {\n\t      // x and y provided as first and second parameters\n\t      localX = p1;\n\t      localY = p2;\n\t      if (typeof p3 === 'number') {\n\t        // angle and opt provided as third and fourth parameters\n\t        localAngle = p3;\n\t        localOpt = p4;\n\t      } else {\n\t        // opt provided as third parameter\n\t        localOpt = p3;\n\t      }\n\t    }\n\n\t    // merge label position arguments\n\t    var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\t    var labelPositionArgs = localOpt;\n\t    var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n\t    // append label to labels array\n\t    var label = {\n\t      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n\t    };\n\t    var idx = -1;\n\t    this.model.insertLabel(idx, label, localOpt);\n\t    return idx;\n\t  },\n\t  // Add a new vertex at calculated index to the `vertices` array.\n\t  addVertex: function (x, y, opt) {\n\t    // accept input in form `{ x, y }, opt` or `x, y, opt`\n\t    var isPointProvided = typeof x !== 'number';\n\t    var localX = isPointProvided ? x.x : x;\n\t    var localY = isPointProvided ? x.y : y;\n\t    var localOpt = isPointProvided ? y : opt;\n\t    var vertex = {\n\t      x: localX,\n\t      y: localY\n\t    };\n\t    var idx = this.getVertexIndex(localX, localY);\n\t    this.model.insertVertex(idx, vertex, localOpt);\n\t    return idx;\n\t  },\n\t  // Send a token (an SVG element, usually a circle) along the connection path.\n\t  // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n\t  // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n\t  // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n\t  // `opt.connection` is an optional selector to the connection path.\n\t  // `callback` is optional and is a function to be called once the token reaches the target.\n\t  sendToken: function (token, opt, callback) {\n\t    function onAnimationEnd(vToken, callback) {\n\t      return function () {\n\t        vToken.remove();\n\t        if (typeof callback === 'function') {\n\t          callback();\n\t        }\n\t      };\n\t    }\n\t    var duration, isReversed, selector;\n\t    if (isObject(opt)) {\n\t      duration = opt.duration;\n\t      isReversed = opt.direction === 'reverse';\n\t      selector = opt.connection;\n\t    } else {\n\t      // Backwards compatibility\n\t      duration = opt;\n\t      isReversed = false;\n\t      selector = null;\n\t    }\n\t    duration = duration || 1000;\n\t    var animationAttributes = {\n\t      dur: duration + 'ms',\n\t      repeatCount: 1,\n\t      calcMode: 'linear',\n\t      fill: 'freeze'\n\t    };\n\t    if (isReversed) {\n\t      animationAttributes.keyPoints = '1;0';\n\t      animationAttributes.keyTimes = '0;1';\n\t    }\n\t    var vToken = V(token);\n\t    var connection;\n\t    if (typeof selector === 'string') {\n\t      // Use custom connection path.\n\t      connection = this.findNode(selector);\n\t    } else {\n\t      // Select connection path automatically.\n\t      var cache = this._V;\n\t      connection = cache.connection ? cache.connection.node : this.el.querySelector('path');\n\t    }\n\t    if (!(connection instanceof SVGPathElement)) {\n\t      throw new Error('dia.LinkView: token animation requires a valid connection path.');\n\t    }\n\t    vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);\n\t    setTimeout(onAnimationEnd(vToken, callback), duration);\n\t  },\n\t  findRoute: function (vertices) {\n\t    vertices || (vertices = []);\n\t    var namespace = this.paper.options.routerNamespace || routers;\n\t    var router = this.model.router();\n\t    var defaultRouter = this.paper.options.defaultRouter;\n\t    if (!router) {\n\t      if (defaultRouter) router = defaultRouter;else return vertices.map(Point); // no router specified\n\t    }\n\t    var routerFn = isFunction(router) ? router : namespace[router.name];\n\t    if (!isFunction(routerFn)) {\n\t      throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n\t    }\n\t    var args = router.args || {};\n\t    var route = routerFn.call(this,\n\t    // context\n\t    vertices,\n\t    // vertices\n\t    args,\n\t    // options\n\t    this // linkView\n\t    );\n\t    if (!route) return vertices.map(Point);\n\t    return route;\n\t  },\n\t  // Return the `d` attribute value of the `<path>` element representing the link\n\t  // between `source` and `target`.\n\t  findPath: function (route, sourcePoint, targetPoint) {\n\t    var namespace = this.paper.options.connectorNamespace || connectors;\n\t    var connector = this.model.connector();\n\t    var defaultConnector = this.paper.options.defaultConnector;\n\t    if (!connector) {\n\t      connector = defaultConnector || {};\n\t    }\n\t    var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n\t    if (!isFunction(connectorFn)) {\n\t      throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n\t    }\n\t    var args = clone$1(connector.args || {});\n\t    args.raw = true; // Request raw g.Path as the result.\n\n\t    var path = connectorFn.call(this,\n\t    // context\n\t    sourcePoint,\n\t    // start point\n\t    targetPoint,\n\t    // end point\n\t    route,\n\t    // vertices\n\t    args,\n\t    // options\n\t    this // linkView\n\t    );\n\t    if (typeof path === 'string') {\n\t      // Backwards compatibility for connectors not supporting `raw` option.\n\t      path = new Path$1(V.normalizePathData(path));\n\t    }\n\t    return path;\n\t  },\n\t  // Public API.\n\t  // -----------\n\n\t  getConnection: function () {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.clone();\n\t  },\n\t  getSerializedConnection: function () {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    var metrics = this.metrics;\n\t    if (metrics.hasOwnProperty('data')) return metrics.data;\n\t    var data = path.serialize();\n\t    metrics.data = data;\n\t    return data;\n\t  },\n\t  getConnectionSubdivisions: function () {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    var metrics = this.metrics;\n\t    if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n\t    var subdivisions = path.getSegmentSubdivisions();\n\t    metrics.segmentSubdivisions = subdivisions;\n\t    return subdivisions;\n\t  },\n\t  getConnectionLength: function () {\n\t    var path = this.path;\n\t    if (!path) return 0;\n\t    var metrics = this.metrics;\n\t    if (metrics.hasOwnProperty('length')) return metrics.length;\n\t    var length = path.length({\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t    metrics.length = length;\n\t    return length;\n\t  },\n\t  getPointAtLength: function (length) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.pointAtLength(length, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getPointAtRatio: function (ratio) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n\t    return path.pointAt(ratio, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getTangentAtLength: function (length) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.tangentAtLength(length, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getTangentAtRatio: function (ratio) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.tangentAt(ratio, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getClosestPoint: function (point) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.closestPoint(point, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getClosestPointLength: function (point) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.closestPointLength(point, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getClosestPointRatio: function (point) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.closestPointNormalizedLength(point, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  // Get label position object based on two provided coordinates, x and y.\n\t  // (Used behind the scenes when user moves labels around.)\n\t  // Two signatures:\n\t  // - num, num, obj = x, y, options\n\t  // - num, num, num, obj = x, y, angle, options\n\t  // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n\t  // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n\t  // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n\t  getLabelPosition: function (x, y, p3, p4) {\n\t    var position = {};\n\n\t    // normalize data from the two possible signatures\n\t    var localAngle = 0;\n\t    var localOpt;\n\t    if (typeof p3 === 'number') {\n\t      // angle and opt provided as third and fourth argument\n\t      localAngle = p3;\n\t      localOpt = p4;\n\t    } else {\n\t      // opt provided as third argument\n\t      localOpt = p3;\n\t    }\n\n\t    // save localOpt as `args` of the position object that is passed along\n\t    if (localOpt) position.args = localOpt;\n\n\t    // identify distance/offset settings\n\t    var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n\t    var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default\n\t    var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n\t    // find closest point t\n\t    var path = this.path;\n\t    var pathOpt = {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    };\n\t    var labelPoint = new Point(x, y);\n\t    var t = path.closestPointT(labelPoint, pathOpt);\n\n\t    // DISTANCE:\n\t    var labelDistance = path.lengthAtT(t, pathOpt);\n\t    if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length\n\t    if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)\n\t    position.distance = labelDistance;\n\n\t    // OFFSET:\n\t    // use absolute offset if:\n\t    // - opt.absoluteOffset is true,\n\t    // - opt.absoluteOffset is not true but there is no tangent\n\t    var tangent;\n\t    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n\t    var labelOffset;\n\t    if (tangent) {\n\t      labelOffset = tangent.pointOffset(labelPoint);\n\t    } else {\n\t      var closestPoint = path.pointAtT(t);\n\t      var labelOffsetDiff = labelPoint.difference(closestPoint);\n\t      labelOffset = {\n\t        x: labelOffsetDiff.x,\n\t        y: labelOffsetDiff.y\n\t      };\n\t    }\n\t    position.offset = labelOffset;\n\n\t    // ANGLE:\n\t    position.angle = localAngle;\n\t    return position;\n\t  },\n\t  _getLabelTransformationMatrix: function (labelPosition) {\n\t    var labelDistance;\n\t    var labelAngle = 0;\n\t    var args = {};\n\t    if (typeof labelPosition === 'number') {\n\t      labelDistance = labelPosition;\n\t    } else if (typeof labelPosition.distance === 'number') {\n\t      args = labelPosition.args || {};\n\t      labelDistance = labelPosition.distance;\n\t      labelAngle = labelPosition.angle || 0;\n\t    } else {\n\t      throw new Error('dia.LinkView: invalid label position distance.');\n\t    }\n\t    var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n\t    var labelOffset = 0;\n\t    var labelOffsetCoordinates = {\n\t      x: 0,\n\t      y: 0\n\t    };\n\t    if (labelPosition.offset) {\n\t      var positionOffset = labelPosition.offset;\n\t      if (typeof positionOffset === 'number') labelOffset = positionOffset;\n\t      if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n\t      if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n\t    }\n\t    var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;\n\t    var isKeepGradient = args.keepGradient;\n\t    var isEnsureLegibility = args.ensureLegibility;\n\t    var path = this.path;\n\t    var pathOpt = {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    };\n\t    var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n\t    var tangent = path.tangentAtLength(distance, pathOpt);\n\t    var translation;\n\t    var angle = labelAngle;\n\t    if (tangent) {\n\t      if (isOffsetAbsolute) {\n\t        translation = tangent.start.clone();\n\t        translation.offset(labelOffsetCoordinates);\n\t      } else {\n\t        var normal = tangent.clone();\n\t        normal.rotate(tangent.start, -90);\n\t        normal.setLength(labelOffset);\n\t        translation = normal.end;\n\t      }\n\t      if (isKeepGradient) {\n\t        angle = tangent.angle() + labelAngle;\n\t        if (isEnsureLegibility) {\n\t          angle = normalizeAngle((angle + 90) % 180 - 90);\n\t        }\n\t      }\n\t    } else {\n\t      // fallback - the connection has zero length\n\t      translation = path.start.clone();\n\t      if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n\t    }\n\t    return V.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n\t  },\n\t  getLabelCoordinates: function (labelPosition) {\n\t    var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n\t    return new Point(transformationMatrix.e, transformationMatrix.f);\n\t  },\n\t  getVertexIndex: function (x, y) {\n\t    var model = this.model;\n\t    var vertices = model.vertices();\n\t    var vertexLength = this.getClosestPointLength(new Point(x, y));\n\t    var idx = 0;\n\t    for (var n = vertices.length; idx < n; idx++) {\n\t      var currentVertex = vertices[idx];\n\t      var currentVertexLength = this.getClosestPointLength(currentVertex);\n\t      if (vertexLength < currentVertexLength) break;\n\t    }\n\t    return idx;\n\t  },\n\t  // Interaction. The controller part.\n\t  // ---------------------------------\n\n\t  notifyPointerdown(evt, x, y) {\n\t    CellView.prototype.pointerdown.call(this, evt, x, y);\n\t    this.notify('link:pointerdown', evt, x, y);\n\t  },\n\t  notifyPointermove(evt, x, y) {\n\t    CellView.prototype.pointermove.call(this, evt, x, y);\n\t    this.notify('link:pointermove', evt, x, y);\n\t  },\n\t  notifyPointerup(evt, x, y) {\n\t    this.notify('link:pointerup', evt, x, y);\n\t    CellView.prototype.pointerup.call(this, evt, x, y);\n\t  },\n\t  pointerdblclick: function (evt, x, y) {\n\t    CellView.prototype.pointerdblclick.apply(this, arguments);\n\t    this.notify('link:pointerdblclick', evt, x, y);\n\t  },\n\t  pointerclick: function (evt, x, y) {\n\t    CellView.prototype.pointerclick.apply(this, arguments);\n\t    this.notify('link:pointerclick', evt, x, y);\n\t  },\n\t  contextmenu: function (evt, x, y) {\n\t    CellView.prototype.contextmenu.apply(this, arguments);\n\t    this.notify('link:contextmenu', evt, x, y);\n\t  },\n\t  pointerdown: function (evt, x, y) {\n\t    this.notifyPointerdown(evt, x, y);\n\t    this.dragStart(evt, x, y);\n\t  },\n\t  pointermove: function (evt, x, y) {\n\t    // Backwards compatibility\n\t    var dragData = this._dragData;\n\t    if (dragData) this.eventData(evt, dragData);\n\t    var data = this.eventData(evt);\n\t    switch (data.action) {\n\t      case 'label-move':\n\t        this.dragLabel(evt, x, y);\n\t        break;\n\t      case 'arrowhead-move':\n\t        this.dragArrowhead(evt, x, y);\n\t        break;\n\t      case 'move':\n\t        this.drag(evt, x, y);\n\t        break;\n\t    }\n\n\t    // Backwards compatibility\n\t    if (dragData) assign(dragData, this.eventData(evt));\n\t    this.notifyPointermove(evt, x, y);\n\t  },\n\t  pointerup: function (evt, x, y) {\n\t    // Backwards compatibility\n\t    var dragData = this._dragData;\n\t    if (dragData) {\n\t      this.eventData(evt, dragData);\n\t      this._dragData = null;\n\t    }\n\t    var data = this.eventData(evt);\n\t    switch (data.action) {\n\t      case 'label-move':\n\t        this.dragLabelEnd(evt, x, y);\n\t        break;\n\t      case 'arrowhead-move':\n\t        this.dragArrowheadEnd(evt, x, y);\n\t        break;\n\t      case 'move':\n\t        this.dragEnd(evt, x, y);\n\t    }\n\t    this.notifyPointerup(evt, x, y);\n\t    this.checkMouseleave(evt);\n\t  },\n\t  mouseover: function (evt) {\n\t    CellView.prototype.mouseover.apply(this, arguments);\n\t    this.notify('link:mouseover', evt);\n\t  },\n\t  mouseout: function (evt) {\n\t    CellView.prototype.mouseout.apply(this, arguments);\n\t    this.notify('link:mouseout', evt);\n\t  },\n\t  mouseenter: function (evt) {\n\t    CellView.prototype.mouseenter.apply(this, arguments);\n\t    this.notify('link:mouseenter', evt);\n\t  },\n\t  mouseleave: function (evt) {\n\t    CellView.prototype.mouseleave.apply(this, arguments);\n\t    this.notify('link:mouseleave', evt);\n\t  },\n\t  mousewheel: function (evt, x, y, delta) {\n\t    CellView.prototype.mousewheel.apply(this, arguments);\n\t    this.notify('link:mousewheel', evt, x, y, delta);\n\t  },\n\t  onlabel: function (evt, x, y) {\n\t    this.notifyPointerdown(evt, x, y);\n\t    this.dragLabelStart(evt, x, y);\n\t    var stopPropagation = this.eventData(evt).stopPropagation;\n\t    if (stopPropagation) evt.stopPropagation();\n\t  },\n\t  // Drag Start Handlers\n\n\t  dragLabelStart: function (evt, x, y) {\n\t    if (this.can('labelMove')) {\n\t      if (this.isDefaultInteractionPrevented(evt)) return;\n\t      var labelNode = evt.currentTarget;\n\t      var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\t      var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\t      var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n\t      var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n\t      var coords = this.getLabelCoordinates(position);\n\t      var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n\t      var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n\t      var positionAngle = this._getLabelPositionAngle(labelIdx);\n\t      var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n\t      var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\t      var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\t      this.eventData(evt, {\n\t        action: 'label-move',\n\t        labelIdx: labelIdx,\n\t        dx: dx,\n\t        dy: dy,\n\t        positionAngle: positionAngle,\n\t        positionArgs: positionArgs,\n\t        stopPropagation: true\n\t      });\n\t    } else {\n\t      // Backwards compatibility:\n\t      // If labels can't be dragged no default action is triggered.\n\t      this.eventData(evt, {\n\t        stopPropagation: true\n\t      });\n\t    }\n\t    this.paper.delegateDragEvents(this, evt.data);\n\t  },\n\t  dragArrowheadStart: function (evt, x, y) {\n\t    if (!this.can('arrowheadMove')) return;\n\t    var arrowheadNode = evt.target;\n\t    var arrowheadType = arrowheadNode.getAttribute('end');\n\t    var data = this.startArrowheadMove(arrowheadType, {\n\t      ignoreBackwardsCompatibility: true\n\t    });\n\t    this.eventData(evt, data);\n\t  },\n\t  dragStart: function (evt, x, y) {\n\t    if (this.isDefaultInteractionPrevented(evt)) return;\n\t    if (!this.can('linkMove')) return;\n\t    this.eventData(evt, {\n\t      action: 'move',\n\t      dx: x,\n\t      dy: y\n\t    });\n\t  },\n\t  // Drag Handlers\n\t  dragLabel: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    var label = {\n\t      position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)\n\t    };\n\t    if (this.paper.options.snapLabels) delete label.position.offset;\n\t    // The `touchmove' events are not fired\n\t    // when the original event target is removed from the DOM.\n\t    // The labels are currently re-rendered completely when only\n\t    // the position changes. This is why we need to make sure that\n\t    // the label is updated synchronously.\n\t    // TODO: replace `touchmove` with `pointermove` (breaking change).\n\t    const setOptions = {\n\t      ui: true\n\t    };\n\t    if (this.paper.isAsync() && evt.type === 'touchmove') {\n\t      setOptions.async = false;\n\t    }\n\t    this.model.label(data.labelIdx, label, setOptions);\n\t  },\n\t  dragArrowhead: function (evt, x, y) {\n\t    if (this.paper.options.snapLinks) {\n\t      const isSnapped = this._snapArrowhead(evt, x, y);\n\t      if (!isSnapped && this.paper.options.snapLinksSelf) {\n\t        this._snapArrowheadSelf(evt, x, y);\n\t      }\n\t    } else {\n\t      if (this.paper.options.snapLinksSelf) {\n\t        this._snapArrowheadSelf(evt, x, y);\n\t      } else {\n\t        this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n\t      }\n\t    }\n\t  },\n\t  drag: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    this.model.translate(x - data.dx, y - data.dy, {\n\t      ui: true\n\t    });\n\t    this.eventData(evt, {\n\t      dx: x,\n\t      dy: y\n\t    });\n\t  },\n\t  // Drag End Handlers\n\n\t  dragLabelEnd: function () {\n\t    // noop\n\t  },\n\t  dragArrowheadEnd: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    var paper = this.paper;\n\t    if (paper.options.snapLinks) {\n\t      this._snapArrowheadEnd(data);\n\t    } else {\n\t      this._connectArrowheadEnd(data, x, y);\n\t    }\n\t    if (!paper.linkAllowed(this)) {\n\t      // If the changed link is not allowed, revert to its previous state.\n\t      this._disallow(data);\n\t    } else {\n\t      this._finishEmbedding(data);\n\t      this._notifyConnectEvent(data, evt);\n\t    }\n\t    this._afterArrowheadMove(data);\n\t  },\n\t  dragEnd: function () {\n\t    // noop\n\t  },\n\t  _disallow: function (data) {\n\t    switch (data.whenNotAllowed) {\n\t      case 'remove':\n\t        this.model.remove({\n\t          ui: true\n\t        });\n\t        break;\n\t      case 'revert':\n\t      default:\n\t        this.model.set(data.arrowhead, data.initialEnd, {\n\t          ui: true\n\t        });\n\t        break;\n\t    }\n\t  },\n\t  _finishEmbedding: function (data) {\n\t    // Reparent the link if embedding is enabled\n\t    if (this.paper.options.embeddingMode && this.model.reparent()) {\n\t      // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n\t      data.z = null;\n\t    }\n\t  },\n\t  _notifyConnectEvent: function (data, evt) {\n\t    var arrowhead = data.arrowhead;\n\t    var initialEnd = data.initialEnd;\n\t    var currentEnd = this.model.prop(arrowhead);\n\t    var endChanged = currentEnd && !Link$1.endsEqual(initialEnd, currentEnd);\n\t    if (endChanged) {\n\t      var paper = this.paper;\n\t      if (initialEnd.id) {\n\t        this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n\t      }\n\t      if (currentEnd.id) {\n\t        this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n\t      }\n\t    }\n\t  },\n\t  _snapToPoints: function (snapPoint, points, radius) {\n\t    let closestPointX = null;\n\t    let closestDistanceX = Infinity;\n\t    let closestPointY = null;\n\t    let closestDistanceY = Infinity;\n\t    let x = snapPoint.x;\n\t    let y = snapPoint.y;\n\t    for (let i = 0; i < points.length; i++) {\n\t      const distX = Math.abs(points[i].x - snapPoint.x);\n\t      if (distX < closestDistanceX) {\n\t        closestDistanceX = distX;\n\t        closestPointX = points[i];\n\t      }\n\t      const distY = Math.abs(points[i].y - snapPoint.y);\n\t      if (distY < closestDistanceY) {\n\t        closestDistanceY = distY;\n\t        closestPointY = points[i];\n\t      }\n\t    }\n\t    if (closestDistanceX < radius) {\n\t      x = closestPointX.x;\n\t    }\n\t    if (closestDistanceY < radius) {\n\t      y = closestPointY.y;\n\t    }\n\t    return {\n\t      x,\n\t      y\n\t    };\n\t  },\n\t  _snapArrowheadSelf: function (evt, x, y) {\n\t    const {\n\t      paper,\n\t      model\n\t    } = this;\n\t    const {\n\t      snapLinksSelf\n\t    } = paper.options;\n\t    const data = this.eventData(evt);\n\t    const radius = snapLinksSelf.radius || 20;\n\t    const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n\t    const vertices = model.vertices();\n\t    const points = [anchor, ...vertices];\n\t    const snapPoint = this._snapToPoints({\n\t      x: x,\n\t      y: y\n\t    }, points, radius);\n\t    const point = paper.localToClientPoint(snapPoint);\n\t    this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n\t  },\n\t  _snapArrowhead: function (evt, x, y) {\n\t    const {\n\t      paper\n\t    } = this;\n\t    const {\n\t      snapLinks,\n\t      connectionStrategy\n\t    } = paper.options;\n\t    const data = this.eventData(evt);\n\t    let isSnapped = false;\n\t    // checking view in close area of the pointer\n\n\t    const radius = snapLinks.radius || 50;\n\t    const findInAreaOptions = snapLinks.findInAreaOptions;\n\t    const prevClosestView = data.closestView || null;\n\t    const prevClosestMagnet = data.closestMagnet || null;\n\t    const prevMagnetProxy = data.magnetProxy || null;\n\t    data.closestView = data.closestMagnet = data.magnetProxy = null;\n\t    const isValidCandidate = (view, magnet) => {\n\t      // Do not snap to the current view\n\t      if (view === this) {\n\t        return false;\n\t      }\n\t      const isAlreadyValidated = prevClosestMagnet === magnet;\n\t      return isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet));\n\t    };\n\t    const closest = paper.findClosestMagnetToPoint({\n\t      x,\n\t      y\n\t    }, {\n\t      radius,\n\t      findInAreaOptions,\n\t      filter: isValidCandidate\n\t    });\n\t    data.closestView = closest ? closest.view : null;\n\t    data.closestMagnet = closest ? closest.magnet : null;\n\t    var end;\n\t    var magnetProxy = null;\n\t    var closestView = data.closestView;\n\t    var closestMagnet = data.closestMagnet;\n\t    if (closestMagnet) {\n\t      magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n\t    }\n\t    var endType = data.arrowhead;\n\t    var newClosestMagnet = prevClosestMagnet !== closestMagnet;\n\t    if (prevClosestView && newClosestMagnet) {\n\t      prevClosestView.unhighlight(prevMagnetProxy, {\n\t        connecting: true,\n\t        snapping: true\n\t      });\n\t    }\n\t    if (closestView) {\n\t      const {\n\t        prevEnd,\n\t        prevX,\n\t        prevY\n\t      } = data;\n\t      data.prevX = x;\n\t      data.prevY = y;\n\t      isSnapped = true;\n\t      if (!newClosestMagnet) {\n\t        if (typeof connectionStrategy !== 'function' || prevX === x && prevY === y) {\n\t          // the magnet has not changed and the link's end does not depend on the x and y\n\t          return isSnapped;\n\t        }\n\t      }\n\t      end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n\t      if (!newClosestMagnet && isEqual(prevEnd, end)) {\n\t        // the source/target json has not changed\n\t        return isSnapped;\n\t      }\n\t      data.prevEnd = end;\n\t      if (newClosestMagnet) {\n\t        closestView.highlight(magnetProxy, {\n\t          connecting: true,\n\t          snapping: true\n\t        });\n\t      }\n\t    } else {\n\t      end = {\n\t        x: x,\n\t        y: y\n\t      };\n\t    }\n\t    this.model.set(endType, end || {\n\t      x: x,\n\t      y: y\n\t    }, {\n\t      ui: true\n\t    });\n\t    if (prevClosestView) {\n\t      this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n\t    }\n\t    if (closestView) {\n\t      this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n\t    }\n\t    return isSnapped;\n\t  },\n\t  _snapArrowheadEnd: function (data) {\n\t    // Finish off link snapping.\n\t    // Everything except view unhighlighting was already done on pointermove.\n\t    var closestView = data.closestView;\n\t    var closestMagnet = data.closestMagnet;\n\t    if (closestView && closestMagnet) {\n\t      closestView.unhighlight(data.magnetProxy, {\n\t        connecting: true,\n\t        snapping: true\n\t      });\n\t      data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n\t    }\n\t    data.closestView = data.closestMagnet = null;\n\t  },\n\t  _connectArrowhead: function (target, x, y, data) {\n\t    // checking views right under the pointer\n\t    const {\n\t      paper,\n\t      model\n\t    } = this;\n\t    if (data.eventTarget !== target) {\n\t      // Unhighlight the previous view under pointer if there was one.\n\t      if (data.magnetProxy) {\n\t        data.viewUnderPointer.unhighlight(data.magnetProxy, {\n\t          connecting: true\n\t        });\n\t      }\n\t      const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n\t      if (viewUnderPointer) {\n\t        // If we found a view that is under the pointer, we need to find the closest\n\t        // magnet based on the real target element of the event.\n\t        const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n\t        const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\t        if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {\n\t          // If there was no magnet found, do not highlight anything and assume there\n\t          // is no view under pointer we're interested in reconnecting to.\n\t          // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n\t          if (magnetProxy) {\n\t            viewUnderPointer.highlight(magnetProxy, {\n\t              connecting: true\n\t            });\n\t          }\n\t        } else {\n\t          // This type of connection is not valid. Disregard this magnet.\n\t          data.magnetUnderPointer = null;\n\t          data.magnetProxy = null;\n\t        }\n\t      } else {\n\t        // Make sure we'll unset previous magnet.\n\t        data.magnetUnderPointer = null;\n\t        data.magnetProxy = null;\n\t      }\n\t    }\n\t    data.eventTarget = target;\n\t    model.set(data.arrowhead, {\n\t      x: x,\n\t      y: y\n\t    }, {\n\t      ui: true\n\t    });\n\t  },\n\t  _connectArrowheadEnd: function (data = {}, x, y) {\n\t    const {\n\t      model\n\t    } = this;\n\t    const {\n\t      viewUnderPointer,\n\t      magnetUnderPointer,\n\t      magnetProxy,\n\t      arrowhead\n\t    } = data;\n\t    if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\t    viewUnderPointer.unhighlight(magnetProxy, {\n\t      connecting: true\n\t    });\n\n\t    // The link end is taken from the magnet under the pointer, not the proxy.\n\t    const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n\t    model.set(arrowhead, end, {\n\t      ui: true\n\t    });\n\t  },\n\t  _beforeArrowheadMove: function (data) {\n\t    data.z = this.model.get('z');\n\t    this.model.toFront();\n\n\t    // Let the pointer propagate through the link view elements so that\n\t    // the `evt.target` is another element under the pointer, not the link itself.\n\t    var style = this.el.style;\n\t    data.pointerEvents = style.pointerEvents;\n\t    style.pointerEvents = 'none';\n\t    if (this.paper.options.markAvailable) {\n\t      this._markAvailableMagnets(data);\n\t    }\n\t  },\n\t  _afterArrowheadMove: function (data) {\n\t    if (data.z !== null) {\n\t      this.model.set('z', data.z, {\n\t        ui: true\n\t      });\n\t      data.z = null;\n\t    }\n\n\t    // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n\t    this.el.style.pointerEvents = data.pointerEvents;\n\t    if (this.paper.options.markAvailable) {\n\t      this._unmarkAvailableMagnets(data);\n\t    }\n\t  },\n\t  _createValidateConnectionArgs: function (arrowhead) {\n\t    // It makes sure the arguments for validateConnection have the following form:\n\t    // (source view, source magnet, target view, target magnet and link view)\n\t    var args = [];\n\t    args[4] = arrowhead;\n\t    args[5] = this;\n\t    var oppositeArrowhead;\n\t    var i = 0;\n\t    var j = 0;\n\t    if (arrowhead === 'source') {\n\t      i = 2;\n\t      oppositeArrowhead = 'target';\n\t    } else {\n\t      j = 2;\n\t      oppositeArrowhead = 'source';\n\t    }\n\t    var end = this.model.get(oppositeArrowhead);\n\t    if (end.id) {\n\t      var view = args[i] = this.paper.findViewByModel(end.id);\n\t      var magnet = view.getMagnetFromLinkEnd(end);\n\t      if (magnet === view.el) magnet = undefined;\n\t      args[i + 1] = magnet;\n\t    }\n\t    function validateConnectionArgs(cellView, magnet) {\n\t      args[j] = cellView;\n\t      args[j + 1] = cellView.el === magnet ? undefined : magnet;\n\t      return args;\n\t    }\n\t    return validateConnectionArgs;\n\t  },\n\t  _markAvailableMagnets: function (data) {\n\t    function isMagnetAvailable(view, magnet) {\n\t      var paper = view.paper;\n\t      var validate = paper.options.validateConnection;\n\t      return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n\t    }\n\t    var paper = this.paper;\n\t    var elements = paper.model.getCells();\n\t    data.marked = {};\n\t    for (var i = 0, n = elements.length; i < n; i++) {\n\t      var view = elements[i].findView(paper);\n\t      if (!view) {\n\t        continue;\n\t      }\n\t      var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n\t      if (view.el.getAttribute('magnet') !== 'false') {\n\t        // Element wrapping group is also a magnet\n\t        magnets.push(view.el);\n\t      }\n\t      var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\t      if (availableMagnets.length > 0) {\n\t        // highlight all available magnets\n\t        for (var j = 0, m = availableMagnets.length; j < m; j++) {\n\t          view.highlight(availableMagnets[j], {\n\t            magnetAvailability: true\n\t          });\n\t        }\n\t        // highlight the entire view\n\t        view.highlight(null, {\n\t          elementAvailability: true\n\t        });\n\t        data.marked[view.model.id] = availableMagnets;\n\t      }\n\t    }\n\t  },\n\t  _unmarkAvailableMagnets: function (data) {\n\t    var markedKeys = Object.keys(data.marked);\n\t    var id;\n\t    var markedMagnets;\n\t    for (var i = 0, n = markedKeys.length; i < n; i++) {\n\t      id = markedKeys[i];\n\t      markedMagnets = data.marked[id];\n\t      var view = this.paper.findViewByModel(id);\n\t      if (view) {\n\t        for (var j = 0, m = markedMagnets.length; j < m; j++) {\n\t          view.unhighlight(markedMagnets[j], {\n\t            magnetAvailability: true\n\t          });\n\t        }\n\t        view.unhighlight(null, {\n\t          elementAvailability: true\n\t        });\n\t      }\n\t    }\n\t    data.marked = null;\n\t  },\n\t  startArrowheadMove: function (end, opt) {\n\t    opt || (opt = {});\n\n\t    // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n\t    // move without need to click on the actual arrowhead dom element.\n\t    var data = {\n\t      action: 'arrowhead-move',\n\t      arrowhead: end,\n\t      whenNotAllowed: opt.whenNotAllowed || 'revert',\n\t      initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n\t      initialEnd: clone$1(this.model.get(end)),\n\t      validateConnectionArgs: this._createValidateConnectionArgs(end)\n\t    };\n\t    this._beforeArrowheadMove(data);\n\t    if (opt.ignoreBackwardsCompatibility !== true) {\n\t      this._dragData = data;\n\t    }\n\t    return data;\n\t  },\n\t  // Lifecycle methods\n\n\t  onMount: function () {\n\t    CellView.prototype.onMount.apply(this, arguments);\n\t    this.mountLabels();\n\t  },\n\t  onDetach: function () {\n\t    CellView.prototype.onDetach.apply(this, arguments);\n\t    this.unmountLabels();\n\t  },\n\t  onRemove: function () {\n\t    CellView.prototype.onRemove.apply(this, arguments);\n\t    this.unmountLabels();\n\t  }\n\t}, {\n\t  Flags: Flags\n\t});\n\tObject.defineProperty(LinkView.prototype, 'sourceView', {\n\t  enumerable: true,\n\t  get: function () {\n\t    const source = this.model.attributes.source;\n\t    if (source.id && this.paper) {\n\t      return this.paper.findViewByModel(source.id);\n\t    }\n\t    return null;\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'targetView', {\n\t  enumerable: true,\n\t  get: function () {\n\t    const target = this.model.attributes.target;\n\t    if (target.id && this.paper) {\n\t      return this.paper.findViewByModel(target.id);\n\t    }\n\t    return null;\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'sourceMagnet', {\n\t  enumerable: true,\n\t  get: function () {\n\t    const sourceView = this.sourceView;\n\t    if (!sourceView) return null;\n\t    let sourceMagnet = null;\n\t    // Check if the magnet is already found and cached.\n\t    // We need to check if the cached magnet is still part of the source view.\n\t    // The source view might have been disposed and recreated, or the magnet might have been changed.\n\t    const cachedSourceMagnet = this._sourceMagnet;\n\t    if (cachedSourceMagnet && sourceView.el.contains(cachedSourceMagnet)) {\n\t      sourceMagnet = cachedSourceMagnet;\n\t    } else {\n\t      // If the cached magnet is not valid, we need to find the magnet.\n\t      sourceMagnet = sourceView.getMagnetFromLinkEnd(this.model.attributes.source);\n\t    }\n\t    this._sourceMagnet = sourceMagnet;\n\t    if (sourceMagnet === sourceView.el) {\n\t      // If the source magnet is the element itself, we treat it as no magnet.\n\t      return null;\n\t    }\n\t    return sourceMagnet;\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'targetMagnet', {\n\t  enumerable: true,\n\t  get: function () {\n\t    const targetView = this.targetView;\n\t    if (!targetView) return null;\n\t    let targetMagnet = null;\n\t    // Check if the magnet is already found and cached (See `sourceMagnet` for explanation).\n\t    const cachedTargetMagnet = this._targetMagnet;\n\t    if (cachedTargetMagnet && targetView.el.contains(cachedTargetMagnet)) {\n\t      targetMagnet = cachedTargetMagnet;\n\t    } else {\n\t      // If the cached magnet is not valid, we need to find the magnet.\n\t      targetMagnet = targetView.getMagnetFromLinkEnd(this.model.attributes.target);\n\t    }\n\t    this._targetMagnet = targetMagnet;\n\t    if (targetMagnet === targetView.el) {\n\t      // If the target magnet is the element itself, we treat it as no magnet.\n\t      return null;\n\t    }\n\t    return targetMagnet;\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\t  enumerable: true,\n\t  get: function () {\n\t    var sourceView = this.sourceView;\n\t    if (!sourceView) {\n\t      var sourceDef = this.model.source();\n\t      return new Rect(sourceDef.x, sourceDef.y);\n\t    }\n\t    var sourceMagnet = this.sourceMagnet;\n\t    if (sourceView.isNodeConnection(sourceMagnet)) {\n\t      return new Rect(this.sourceAnchor);\n\t    }\n\t    return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\t  enumerable: true,\n\t  get: function () {\n\t    var targetView = this.targetView;\n\t    if (!targetView) {\n\t      var targetDef = this.model.target();\n\t      return new Rect(targetDef.x, targetDef.y);\n\t    }\n\t    var targetMagnet = this.targetMagnet;\n\t    if (targetView.isNodeConnection(targetMagnet)) {\n\t      return new Rect(this.targetAnchor);\n\t    }\n\t    return targetView.getNodeBBox(targetMagnet || targetView.el);\n\t  }\n\t});\n\n\tconst LayerView = View.extend({\n\t  tagName: 'g',\n\t  svgElement: true,\n\t  pivotNodes: null,\n\t  defaultTheme: null,\n\t  UPDATE_PRIORITY: 4,\n\t  options: {\n\t    id: ''\n\t  },\n\t  paper: null,\n\t  init: function () {\n\t    this.pivotNodes = {};\n\t    this.id = this.options.id || this.cid;\n\t  },\n\t  setPaperReference: function (paper) {\n\t    this.paper = paper;\n\t    this.afterPaperReferenceSet(paper);\n\t  },\n\t  unsetPaperReference: function () {\n\t    if (!this.paper) return;\n\t    this.beforePaperReferenceUnset(this.paper);\n\t    this.paper = null;\n\t  },\n\t  assertPaperReference() {\n\t    if (!this.paper) {\n\t      throw new Error('LayerView: paper reference is not set.');\n\t    }\n\t  },\n\t  afterPaperReferenceSet: function () {\n\t    // Can be overridden in subclasses.\n\t  },\n\t  beforePaperReferenceUnset: function () {\n\t    // Can be overridden in subclasses.\n\t  },\n\t  // prevents id to be set on the DOM element\n\t  _setAttributes: function (attrs) {\n\t    const newAttrs = clone$1(attrs);\n\t    delete newAttrs.id;\n\t    View.prototype._setAttributes.call(this, newAttrs);\n\t  },\n\t  className: function () {\n\t    const {\n\t      id\n\t    } = this.options;\n\t    return addClassNamePrefix(`${id}-layer`);\n\t  },\n\t  insertSortedNode: function (node, z) {\n\t    this.el.insertBefore(node, this.insertPivot(z));\n\t  },\n\t  insertNode: function (node) {\n\t    const {\n\t      el\n\t    } = this;\n\t    if (node.parentNode !== el) {\n\t      el.appendChild(node);\n\t    }\n\t  },\n\t  insertPivot: function (z) {\n\t    const {\n\t      el,\n\t      pivotNodes\n\t    } = this;\n\t    z = +z;\n\t    z || (z = 0);\n\t    let pivotNode = pivotNodes[z];\n\t    if (pivotNode) return pivotNode;\n\t    pivotNode = pivotNodes[z] = document.createComment('z-index:' + (z + 1));\n\t    let neighborZ = -Infinity;\n\t    for (let currentZ in pivotNodes) {\n\t      currentZ = +currentZ;\n\t      if (currentZ < z && currentZ > neighborZ) {\n\t        neighborZ = currentZ;\n\t        if (neighborZ === z - 1) continue;\n\t      }\n\t    }\n\t    if (neighborZ !== -Infinity) {\n\t      const neighborPivot = pivotNodes[neighborZ];\n\t      // Insert After\n\t      el.insertBefore(pivotNode, neighborPivot.nextSibling);\n\t    } else {\n\t      // First Child\n\t      el.insertBefore(pivotNode, el.firstChild);\n\t    }\n\t    return pivotNode;\n\t  },\n\t  removePivots: function () {\n\t    const {\n\t      el,\n\t      pivotNodes\n\t    } = this;\n\t    for (const z in pivotNodes) el.removeChild(pivotNodes[z]);\n\t    this.pivotNodes = {};\n\t  },\n\t  isEmpty: function () {\n\t    // Check if the layer has any child elements (pivot comments are not counted).\n\t    return this.el.children.length === 0;\n\t  },\n\t  reset: function () {\n\t    this.removePivots();\n\t  }\n\t});\n\tObject.defineProperty(LayerView.prototype, LAYER_VIEW_MARKER, {\n\t  value: true\n\t});\n\n\t/**\n\t * @class GraphLayerView\n\t * @description A GraphLayerView is responsible for managing the rendering of cell views inside a layer.\n\t * It listens to the corresponding GraphLayer model and updates the DOM accordingly.\n\t * It uses dia.Paper sorting options to sort cell views in the DOM based on their `z` attribute.\n\t */\n\tconst GraphLayerView = LayerView.extend({\n\t  SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n\t  style: {\n\t    webkitUserSelect: 'none',\n\t    userSelect: 'none'\n\t  },\n\t  graph: null,\n\t  init() {\n\t    LayerView.prototype.init.apply(this, arguments);\n\t    this.graph = this.model.graph;\n\t  },\n\t  className: function () {\n\t    const {\n\t      id\n\t    } = this.options;\n\t    return [addClassNamePrefix(`${id}-layer`), addClassNamePrefix('cells')].join(' ');\n\t  },\n\t  afterPaperReferenceSet(paper) {\n\t    this.listenTo(this.model, 'sort', this.onCellCollectionSort);\n\t    this.listenTo(this.model, 'change', this.onCellChange);\n\t    this.listenTo(this.model, 'move', this.onCellMove);\n\t    this.listenTo(this.graph, 'batch:stop', this.onGraphBatchStop);\n\t  },\n\t  beforePaperReferenceUnset() {\n\t    this.stopListening(this.model);\n\t    this.stopListening(this.graph);\n\t  },\n\t  onCellCollectionSort() {\n\t    if (this.graph.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n\t    this.sort();\n\t  },\n\t  onCellMove(cell, opt = {}) {\n\t    // When a cell is moved from one layer to another,\n\t    // request insertion of its view in the new layer.\n\t    this.paper.requestCellViewInsertion(cell, opt);\n\t  },\n\t  onCellChange(cell, opt) {\n\t    if (!cell.hasChanged('z')) return;\n\t    // Re-insert the cell view to maintain correct z-ordering\n\t    if (this.paper.options.sorting === sortingTypes.APPROX) {\n\t      this.paper.requestCellViewInsertion(cell, opt);\n\t    }\n\t  },\n\t  onGraphBatchStop(data) {\n\t    const name = data && data.batchName;\n\t    const sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n\t    // After certain batches, sorting may be required\n\t    if (sortDelayingBatches.includes(name) && !this.graph.hasActiveBatch(sortDelayingBatches)) {\n\t      this.sort();\n\t    }\n\t  },\n\t  sort() {\n\t    this.assertPaperReference();\n\t    const {\n\t      paper\n\t    } = this;\n\t    if (!paper.isExactSorting()) {\n\t      // noop\n\t      return;\n\t    }\n\t    if (paper.isFrozen()) {\n\t      // sort views once unfrozen\n\t      paper._updates.sort = true;\n\t      return;\n\t    }\n\t    this.sortExact();\n\t  },\n\t  sortExact() {\n\t    // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n\t    // associated model `z` attribute.\n\t    const cellNodes = Array.from(this.el.children).filter(node => node.getAttribute('model-id'));\n\t    const cellCollection = this.model.cellCollection;\n\t    sortElements(cellNodes, function (a, b) {\n\t      const cellA = cellCollection.get(a.getAttribute('model-id'));\n\t      const cellB = cellCollection.get(b.getAttribute('model-id'));\n\t      const zA = cellA.attributes.z || 0;\n\t      const zB = cellB.attributes.z || 0;\n\t      return zA === zB ? 0 : zA < zB ? -1 : 1;\n\t    });\n\t  },\n\t  insertCellView(cellView) {\n\t    this.assertPaperReference();\n\t    const {\n\t      paper\n\t    } = this;\n\t    const {\n\t      el,\n\t      model\n\t    } = cellView;\n\t    switch (paper.options.sorting) {\n\t      case sortingTypes.APPROX:\n\t        this.insertSortedNode(el, model.get('z'));\n\t        break;\n\t      case sortingTypes.EXACT:\n\t      default:\n\t        this.insertNode(el);\n\t        break;\n\t    }\n\t  }\n\t});\n\tObject.defineProperty(GraphLayerView.prototype, GRAPH_LAYER_VIEW_MARKER, {\n\t  value: true\n\t});\n\n\t/**\n\t * @class LegacyGraphLayerView\n\t * @description A legacy GraphLayerView with an additional class name for backward compatibility.\n\t */\n\tconst LegacyGraphLayerView = GraphLayerView.extend({\n\t  className: function () {\n\t    const className = GraphLayerView.prototype.className.apply(this, arguments);\n\t    return className + ' ' + addClassNamePrefix('viewport');\n\t  }\n\t});\n\n\t/**\n\t * Deque implementation for managing a double-ended queue.\n\t * This implementation uses a doubly linked list for efficient operations.\n\t * It supports operations like push, pop, move to head, and delete.\n\t * The deque maintains a map for O(1) access to nodes by key.\n\t */\n\tclass Deque {\n\t  constructor() {\n\t    this.head = null;\n\t    this.tail = null;\n\t    this.map = new Map(); // key -> node\n\t  }\n\n\t  // Return an array of keys in the deque\n\t  keys() {\n\t    let current = this.head;\n\t    const keys = [];\n\t    while (current) {\n\t      keys.push(current.key);\n\t      current = current.next;\n\t    }\n\t    return keys;\n\t  }\n\n\t  // Return the first node and remove it from the deque\n\t  popHead() {\n\t    if (!this.head) return null;\n\t    const node = this.head;\n\t    this.map.delete(node.key);\n\t    this.head = node.next;\n\t    if (this.head) {\n\t      this.head.prev = null;\n\t    } else {\n\t      this.tail = null;\n\t    }\n\t    return node;\n\t  }\n\n\t  // Add a new node to the back of the deque\n\t  pushTail(key, value) {\n\t    if (this.map.has(key)) {\n\t      throw new Error(`Key \"${key}\" already exists in the deque.`);\n\t    }\n\t    const node = {\n\t      key,\n\t      value,\n\t      prev: null,\n\t      next: null\n\t    };\n\t    this.map.set(key, node);\n\t    if (!this.tail) {\n\t      this.head = this.tail = node;\n\t    } else {\n\t      this.tail.next = node;\n\t      node.prev = this.tail;\n\t      this.tail = node;\n\t    }\n\t  }\n\n\t  // Move a node from the deque to the head\n\t  moveToHead(key) {\n\t    const node = this.map.get(key);\n\t    if (!node) return;\n\t    if (node === this.head) return; // already at head\n\t    // Remove node from its current position\n\t    if (node.prev) node.prev.next = node.next;\n\t    if (node.next) node.next.prev = node.prev;\n\t    if (node === this.tail) this.tail = node.prev; // if it's the tail\n\t    if (node === this.head) this.head = node.next; // if it's the head\n\t    // Move node to head\n\t    node.prev = null;\n\t    node.next = this.head;\n\t    if (this.head) {\n\t      this.head.prev = node; // link old head back to new head\n\t    }\n\t    this.head = node; // update head to be the moved node\n\t    if (!this.tail) {\n\t      this.tail = node; // if it was the only node, set tail as well\n\t    }\n\t  }\n\n\t  // Return the first node without removing it\n\t  peekHead() {\n\t    return this.head || null;\n\t  }\n\n\t  // Move the head node to the back of the deque\n\t  rotate() {\n\t    if (!this.head || !this.head.next) return;\n\t    this.tail.next = this.head; // link tail to head\n\t    this.head.prev = this.tail; // link head back to tail\n\t    this.tail = this.head; // update tail to be the old head\n\t    this.head = this.head.next; // move head to the next node\n\t    this.tail.next = null; // set new tail's next to null\n\t    this.head.prev = null; // set new head's prev to null\n\t  }\n\n\t  // Remove a node from the deque\n\t  delete(key) {\n\t    const node = this.map.get(key);\n\t    if (!node) return;\n\t    if (node.prev) node.prev.next = node.next;else this.head = node.next;\n\t    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;\n\t    this.map.delete(key);\n\t  }\n\n\t  // Does the deque contain a node with the given key?\n\t  has(key) {\n\t    return this.map.has(key);\n\t  }\n\n\t  // Get the node with the given key\n\t  get(key) {\n\t    return this.map.get(key) || null;\n\t  }\n\n\t  // Number of nodes in the deque\n\t  get length() {\n\t    return this.map.size;\n\t  }\n\t}\n\n\tconst GridLayerView = LayerView.extend({\n\t  style: {\n\t    'pointer-events': 'none'\n\t  },\n\t  _gridCache: null,\n\t  _gridSettings: null,\n\t  init() {\n\t    LayerView.prototype.init.apply(this, arguments);\n\t    this.paper = this.options.paper;\n\t    this._gridCache = null;\n\t    this._gridSettings = [];\n\t  },\n\t  afterPaperReferenceSet(paper) {\n\t    this.listenTo(paper, 'transform resize', this.updateGrid);\n\t  },\n\t  beforePaperReferenceUnset(paper) {\n\t    this.stopListening(paper);\n\t  },\n\t  setGrid(drawGrid) {\n\t    this._gridSettings = this.getGridSettings(drawGrid);\n\t    this.renderGrid();\n\t  },\n\t  getGridSettings(drawGrid) {\n\t    const gridSettings = [];\n\t    if (drawGrid) {\n\t      const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n\t      optionsList.forEach(item => {\n\t        gridSettings.push(...this._resolveDrawGridOption(item));\n\t      });\n\t    }\n\t    return gridSettings;\n\t  },\n\t  removeGrid() {\n\t    const {\n\t      _gridCache: grid\n\t    } = this;\n\t    if (!grid) return;\n\t    grid.root.remove();\n\t    this._gridCache = null;\n\t  },\n\t  renderGrid() {\n\t    const {\n\t      paper\n\t    } = this;\n\t    const {\n\t      _gridSettings: gridSettings\n\t    } = this;\n\t    this.removeGrid();\n\t    if (gridSettings.length === 0) return;\n\t    const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n\t    if (gridSize <= 1) {\n\t      return;\n\t    }\n\t    const refs = this._getGridRefs();\n\t    gridSettings.forEach((gridLayerSetting, index) => {\n\t      const id = this._getPatternId(index);\n\t      const options = merge({}, gridLayerSetting);\n\t      const {\n\t        scaleFactor = 1\n\t      } = options;\n\t      options.width = gridSize * scaleFactor || 1;\n\t      options.height = gridSize * scaleFactor || 1;\n\t      let vPattern;\n\t      if (!refs.exist(id)) {\n\t        vPattern = V('pattern', {\n\t          id: id,\n\t          patternUnits: 'userSpaceOnUse'\n\t        }, V(options.markup));\n\t        refs.add(id, vPattern);\n\t      } else {\n\t        vPattern = refs.get(id);\n\t      }\n\t      if (isFunction(options.render)) {\n\t        options.render(vPattern.node.firstChild, options, paper);\n\t      }\n\t      vPattern.attr({\n\t        width: options.width,\n\t        height: options.height\n\t      });\n\t    });\n\t    refs.root.appendTo(this.el);\n\t    this.updateGrid();\n\t  },\n\t  updateGrid() {\n\t    const {\n\t      _gridCache: grid,\n\t      _gridSettings: gridSettings,\n\t      paper\n\t    } = this;\n\t    if (!grid) return;\n\t    const {\n\t      root: vSvg,\n\t      patterns\n\t    } = grid;\n\t    const {\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    } = paper.getArea();\n\t    vSvg.attr({\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    });\n\t    for (const patternId in patterns) {\n\t      const vPattern = patterns[patternId];\n\t      vPattern.attr({\n\t        x: -x,\n\t        y: -y\n\t      });\n\t    }\n\t    gridSettings.forEach((options, index) => {\n\t      if (isFunction(options.update)) {\n\t        const vPattern = patterns[this._getPatternId(index)];\n\t        options.update(vPattern.node.firstChild, options, paper);\n\t      }\n\t    });\n\t  },\n\t  _getPatternId(index) {\n\t    return `pattern_${this.paper.cid}_${index}`;\n\t  },\n\t  _getGridRefs() {\n\t    let {\n\t      _gridCache: grid\n\t    } = this;\n\t    if (grid) return grid;\n\t    const defsVEl = V('defs');\n\t    const svgVEl = V('svg', {\n\t      width: '100%',\n\t      height: '100%'\n\t    }, [defsVEl]);\n\t    grid = this._gridCache = {\n\t      root: svgVEl,\n\t      patterns: {},\n\t      add: function (id, patternVEl) {\n\t        const rectVEl = V('rect', {\n\t          width: '100%',\n\t          height: '100%',\n\t          fill: `url(#${id})`\n\t        });\n\t        defsVEl.append(patternVEl);\n\t        svgVEl.append(rectVEl);\n\t        this.patterns[id] = patternVEl;\n\t      },\n\t      get: function (id) {\n\t        return this.patterns[id];\n\t      },\n\t      exist: function (id) {\n\t        return this.patterns[id] !== undefined;\n\t      }\n\t    };\n\t    return grid;\n\t  },\n\t  _resolveDrawGridOption(opt) {\n\t    const namespace = this.options.patterns;\n\t    if (isString(opt) && Array.isArray(namespace[opt])) {\n\t      return namespace[opt].map(function (item) {\n\t        return assign({}, item);\n\t      });\n\t    }\n\t    const options = opt || {\n\t      args: [{}]\n\t    };\n\t    const isArray = Array.isArray(options);\n\t    let name = options.name;\n\t    if (!isArray && !name && !options.markup) {\n\t      name = 'dot';\n\t    }\n\t    if (name && Array.isArray(namespace[name])) {\n\t      const pattern = namespace[name].map(function (item) {\n\t        return assign({}, item);\n\t      });\n\t      const args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\t      defaults(args[0], omit(opt, 'args'));\n\t      for (let i = 0; i < args.length; i++) {\n\t        if (pattern[i]) {\n\t          assign(pattern[i], args[i]);\n\t        }\n\t      }\n\t      return pattern;\n\t    }\n\t    return isArray ? options : [options];\n\t  },\n\t  isEmpty() {\n\t    const {\n\t      _gridCache: grid\n\t    } = this;\n\t    return this.el.children.length === (grid ? 1 : 0);\n\t  }\n\t});\n\n\tconst paperLayers = {\n\t  GRID: 'grid',\n\t  BACK: 'back',\n\t  /** @deprecated */\n\t  CELLS: 'cells',\n\t  FRONT: 'front',\n\t  TOOLS: 'tools',\n\t  LABELS: 'labels'\n\t};\n\tconst sortingTypes = {\n\t  NONE: 'sorting-none',\n\t  APPROX: 'sorting-approximate',\n\t  EXACT: 'sorting-exact'\n\t};\n\tconst WHEEL_CAP = 50;\n\tconst WHEEL_WAIT_MS = 20;\n\tconst MOUNT_BATCH_SIZE = 1000;\n\tconst UPDATE_BATCH_SIZE = Infinity;\n\tconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\n\tconst HighlightingTypes = CellView.Highlighting;\n\tconst defaultHighlighting = {\n\t  [HighlightingTypes.DEFAULT]: {\n\t    name: 'stroke',\n\t    options: {\n\t      padding: 3\n\t    }\n\t  },\n\t  [HighlightingTypes.MAGNET_AVAILABILITY]: {\n\t    name: 'addClass',\n\t    options: {\n\t      className: 'available-magnet'\n\t    }\n\t  },\n\t  [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n\t    name: 'addClass',\n\t    options: {\n\t      className: 'available-cell'\n\t    }\n\t  }\n\t};\n\tconst gridPatterns = {\n\t  dot: [{\n\t    color: '#AAAAAA',\n\t    thickness: 1,\n\t    markup: 'rect',\n\t    render: function (el, opt) {\n\t      V(el).attr({\n\t        width: opt.thickness,\n\t        height: opt.thickness,\n\t        fill: opt.color\n\t      });\n\t    }\n\t  }],\n\t  fixedDot: [{\n\t    color: '#AAAAAA',\n\t    thickness: 1,\n\t    markup: 'rect',\n\t    render: function (el, opt) {\n\t      V(el).attr({\n\t        fill: opt.color\n\t      });\n\t    },\n\t    update: function (el, opt, paper) {\n\t      const {\n\t        sx,\n\t        sy\n\t      } = paper.scale();\n\t      const width = sx <= 1 ? opt.thickness : opt.thickness / sx;\n\t      const height = sy <= 1 ? opt.thickness : opt.thickness / sy;\n\t      V(el).attr({\n\t        width,\n\t        height\n\t      });\n\t    }\n\t  }],\n\t  mesh: [{\n\t    color: '#AAAAAA',\n\t    thickness: 1,\n\t    markup: 'path',\n\t    render: function (el, opt) {\n\t      var d;\n\t      var width = opt.width;\n\t      var height = opt.height;\n\t      var thickness = opt.thickness;\n\t      if (width - thickness >= 0 && height - thickness >= 0) {\n\t        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t      } else {\n\t        d = 'M 0 0 0 0';\n\t      }\n\t      V(el).attr({\n\t        'd': d,\n\t        stroke: opt.color,\n\t        'stroke-width': opt.thickness\n\t      });\n\t    }\n\t  }],\n\t  doubleMesh: [{\n\t    color: '#AAAAAA',\n\t    thickness: 1,\n\t    markup: 'path',\n\t    render: function (el, opt) {\n\t      var d;\n\t      var width = opt.width;\n\t      var height = opt.height;\n\t      var thickness = opt.thickness;\n\t      if (width - thickness >= 0 && height - thickness >= 0) {\n\t        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t      } else {\n\t        d = 'M 0 0 0 0';\n\t      }\n\t      V(el).attr({\n\t        'd': d,\n\t        stroke: opt.color,\n\t        'stroke-width': opt.thickness\n\t      });\n\t    }\n\t  }, {\n\t    color: '#000000',\n\t    thickness: 3,\n\t    scaleFactor: 4,\n\t    markup: 'path',\n\t    render: function (el, opt) {\n\t      var d;\n\t      var width = opt.width;\n\t      var height = opt.height;\n\t      var thickness = opt.thickness;\n\t      if (width - thickness >= 0 && height - thickness >= 0) {\n\t        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t      } else {\n\t        d = 'M 0 0 0 0';\n\t      }\n\t      V(el).attr({\n\t        'd': d,\n\t        stroke: opt.color,\n\t        'stroke-width': opt.thickness\n\t      });\n\t    }\n\t  }]\n\t};\n\tconst backgroundPatterns = {\n\t  flipXy: function (img) {\n\t    // d b\n\t    // q p\n\n\t    var canvas = document.createElement('canvas');\n\t    var imgWidth = img.width;\n\t    var imgHeight = img.height;\n\t    canvas.width = 2 * imgWidth;\n\t    canvas.height = 2 * imgHeight;\n\t    var ctx = canvas.getContext('2d');\n\t    // top-left image\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // xy-flipped bottom-right image\n\t    ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // x-flipped top-right image\n\t    ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // y-flipped bottom-left image\n\t    ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    return canvas;\n\t  },\n\t  flipX: function (img) {\n\t    // d b\n\t    // d b\n\n\t    var canvas = document.createElement('canvas');\n\t    var imgWidth = img.width;\n\t    var imgHeight = img.height;\n\t    canvas.width = imgWidth * 2;\n\t    canvas.height = imgHeight;\n\t    var ctx = canvas.getContext('2d');\n\t    // left image\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // flipped right image\n\t    ctx.translate(2 * imgWidth, 0);\n\t    ctx.scale(-1, 1);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    return canvas;\n\t  },\n\t  flipY: function (img) {\n\t    // d d\n\t    // q q\n\n\t    var canvas = document.createElement('canvas');\n\t    var imgWidth = img.width;\n\t    var imgHeight = img.height;\n\t    canvas.width = imgWidth;\n\t    canvas.height = imgHeight * 2;\n\t    var ctx = canvas.getContext('2d');\n\t    // top image\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // flipped bottom image\n\t    ctx.translate(0, 2 * imgHeight);\n\t    ctx.scale(1, -1);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    return canvas;\n\t  },\n\t  watermark: function (img, opt) {\n\t    //   d\n\t    // d\n\n\t    opt = opt || {};\n\t    var imgWidth = img.width;\n\t    var imgHeight = img.height;\n\t    var canvas = document.createElement('canvas');\n\t    canvas.width = imgWidth * 3;\n\t    canvas.height = imgHeight * 3;\n\t    var ctx = canvas.getContext('2d');\n\t    var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n\t    var radians = toRad(angle);\n\t    var stepX = canvas.width / 4;\n\t    var stepY = canvas.height / 4;\n\t    for (var i = 0; i < 4; i++) {\n\t      for (var j = 0; j < 4; j++) {\n\t        if ((i + j) % 2 > 0) {\n\t          // reset the current transformations\n\t          ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n\t          ctx.rotate(radians);\n\t          ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n\t        }\n\t      }\n\t    }\n\t    return canvas;\n\t  }\n\t};\n\tconst implicitLayers = [{\n\t  id: paperLayers.GRID,\n\t  type: 'GridLayerView',\n\t  patterns: gridPatterns\n\t}, {\n\t  id: paperLayers.BACK\n\t}, {\n\t  id: paperLayers.LABELS\n\t}, {\n\t  id: paperLayers.FRONT\n\t}, {\n\t  id: paperLayers.TOOLS\n\t}];\n\tconst CELL_VIEW_PLACEHOLDER_MARKER = Symbol('joint.cellViewPlaceholderMarker');\n\tconst Paper = View.extend({\n\t  className: 'paper',\n\t  options: {\n\t    width: 800,\n\t    height: 600,\n\t    gridSize: 1,\n\t    // Whether or not to draw the grid lines on the paper's DOM element.\n\t    // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n\t    drawGrid: false,\n\t    // If not set, the size of the visual grid is the same as the `gridSize`.\n\t    drawGridSize: null,\n\t    // Whether or not to draw the background on the paper's DOM element.\n\t    // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n\t    background: false,\n\t    elementView: ElementView,\n\t    linkView: LinkView,\n\t    snapLabels: false,\n\t    // false, true\n\t    snapLinks: false,\n\t    // false, true, { radius: value }\n\t    snapLinksSelf: false,\n\t    // false, true, { radius: value }\n\n\t    // Should the link labels be rendered into its own layer?\n\t    // `false` - the labels are part of the links\n\t    // `true` - the labels are appended to LayersName.LABELS\n\t    // [LayersName] - the labels are appended to the layer specified\n\t    labelsLayer: false,\n\t    // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n\t    multiLinks: true,\n\t    // For adding custom guard logic.\n\t    guard: function (evt, view) {\n\t      // FALSE means the event isn't guarded.\n\t      return false;\n\t    },\n\t    highlighting: defaultHighlighting,\n\t    // Prevent the default context menu from being displayed.\n\t    preventContextMenu: true,\n\t    // Prevent the default action for blank:pointer<action>.\n\t    preventDefaultBlankAction: true,\n\t    // Prevent the default action for cell:pointer<action>.\n\t    preventDefaultViewAction: true,\n\t    // Restrict the translation of elements by given bounding box.\n\t    // Option accepts a boolean:\n\t    //  true - the translation is restricted to the paper area\n\t    //  false - no restrictions\n\t    // A method:\n\t    // restrictTranslate: function(elementView) {\n\t    //     var parentId = elementView.model.get('parent');\n\t    //     return parentId && this.model.getCell(parentId).getBBox();\n\t    // },\n\t    // Or a bounding box:\n\t    // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n\t    restrictTranslate: false,\n\t    // Marks all available magnets with 'available-magnet' class name and all available cells with\n\t    // 'available-cell' class name. Marks them when dragging a link is started and unmark\n\t    // when the dragging is stopped.\n\t    markAvailable: false,\n\t    // Defines what link model is added to the graph after an user clicks on an active magnet.\n\t    // Value could be the mvc.model or a function returning the mvc.model\n\t    // defaultLink: (elementView, magnet) => {\n\t    //   return condition ? new customLink1() : new customLink2()\n\t    // }\n\t    defaultLink: function () {\n\t      // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)\n\t      const {\n\t        cellNamespace\n\t      } = this.model.layerCollection;\n\t      const ctor = getByPath(cellNamespace, ['standard', 'Link']);\n\t      if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');\n\t      return new ctor();\n\t    },\n\t    // A connector that is used by links with no connector defined on the model.\n\t    // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n\t    defaultConnector: {\n\t      name: 'normal'\n\t    },\n\t    // A router that is used by links with no router defined on the model.\n\t    // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n\t    defaultRouter: {\n\t      name: 'normal'\n\t    },\n\t    defaultAnchor: {\n\t      name: 'center'\n\t    },\n\t    defaultLinkAnchor: {\n\t      name: 'connectionRatio'\n\t    },\n\t    defaultConnectionPoint: {\n\t      name: 'boundary'\n\t    },\n\t    /* CONNECTING */\n\n\t    connectionStrategy: null,\n\t    // Check whether to add a new link to the graph when user clicks on an a magnet.\n\t    validateMagnet: function (_cellView, magnet, _evt) {\n\t      return magnet.getAttribute('magnet') !== 'passive';\n\t    },\n\t    // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n\t    // being changed.\n\t    validateConnection: function (cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n\t      return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n\t    },\n\t    /* EMBEDDING */\n\n\t    // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n\t    // all links and elements are visible taken the level of embedding into account.\n\t    embeddingMode: false,\n\t    // Check whether to allow or disallow the element embedding while an element being translated.\n\t    validateEmbedding: function (childView, parentView) {\n\t      // by default all elements can be in relation child-parent\n\t      return true;\n\t    },\n\t    // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n\t    validateUnembedding: function (childView) {\n\t      // by default all elements can become roots\n\t      return true;\n\t    },\n\t    // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n\t    // The cell with the highest z-index (visually on the top) will be chosen.\n\t    findParentBy: 'bbox',\n\t    // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n\t    // If enabled only the element on the very front is taken into account for the embedding.\n\t    // If disabled the elements under the dragged view are tested one by one\n\t    // (from front to back) until a valid parent found.\n\t    frontParentOnly: true,\n\t    // Interactive flags. See online docs for the complete list of interactive flags.\n\t    interactive: {\n\t      labelMove: false\n\t    },\n\t    // When set to true the links can be pinned to the paper.\n\t    // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n\t    linkPinning: true,\n\t    // Custom validation after an interaction with a link ends.\n\t    // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n\t    // (linkView, paper) => boolean\n\t    allowLink: null,\n\t    // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n\t    clickThreshold: 0,\n\t    // Number of required mousemove events before the first pointermove event will be triggered.\n\t    moveThreshold: 0,\n\t    // Number of required mousemove events before a link is created out of the magnet.\n\t    // Or string `onleave` so the link is created when the pointer leaves the magnet\n\t    magnetThreshold: 0,\n\t    // Rendering Options\n\n\t    sorting: sortingTypes.APPROX,\n\t    frozen: false,\n\t    autoFreeze: false,\n\t    viewManagement: false,\n\t    // no docs yet\n\t    onViewUpdate: function (view, flag, priority, opt, paper) {\n\t      if (opt.mounting || opt.isolate) {\n\t        // Do not update connected links when:\n\t        // - the view was just mounted (added back to the paper by viewport function)\n\t        // - the change was marked as `isolate`.\n\t        return;\n\t      }\n\t      // Always update connected links when the view model was replaced with another model\n\t      // with the same id.\n\t      // Note: the removal is done in 2 steps: remove the old model, add the new model.\n\t      // We update connected links on the add step.\n\t      if (!(opt.replace && opt.add)) {\n\t        if (flag & (paper.FLAG_INSERT | paper.FLAG_REMOVE)) {\n\t          // Do not update connected links when:\n\t          // - the view was just inserted (added to the graph and rendered)\n\t          // - the view model was just removed from the graph\n\t          return;\n\t        }\n\t      }\n\t      paper.requestConnectedLinksUpdate(view, priority, opt);\n\t    },\n\t    // no docs yet\n\t    onViewPostponed: function (view, flag, paper) {\n\t      return paper.forcePostponedViewUpdate(view, flag);\n\t    },\n\t    beforeRender: null,\n\t    // function(opt, paper) { },\n\n\t    afterRender: null,\n\t    // function(stats, opt, paper) {\n\n\t    viewport: null,\n\t    // Default namespaces\n\n\t    cellViewNamespace: null,\n\t    layerViewNamespace: null,\n\t    routerNamespace: null,\n\t    connectorNamespace: null,\n\t    highlighterNamespace: highlighters,\n\t    anchorNamespace: anchors,\n\t    linkAnchorNamespace: linkAnchors,\n\t    connectionPointNamespace: connectionPoints,\n\t    overflow: false\n\t  },\n\t  events: {\n\t    'dblclick': 'pointerdblclick',\n\t    'dbltap': 'pointerdblclick',\n\t    'contextmenu': 'contextmenu',\n\t    'mousedown': 'pointerdown',\n\t    'touchstart': 'pointerdown',\n\t    'mouseover': 'mouseover',\n\t    'mouseout': 'mouseout',\n\t    'mouseenter': 'mouseenter',\n\t    'mouseleave': 'mouseleave',\n\t    'wheel': 'mousewheel',\n\t    'mouseenter .joint-cell': 'mouseenter',\n\t    'mouseleave .joint-cell': 'mouseleave',\n\t    'mouseenter .joint-tools': 'mouseenter',\n\t    'mouseleave .joint-tools': 'mouseleave',\n\t    'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n\t    'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n\t    'mousedown .joint-link .label': 'onlabel',\n\t    // interaction with link label\n\t    'touchstart .joint-link .label': 'onlabel',\n\t    'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n\t  },\n\t  documentEvents: {\n\t    'mousemove': 'pointermove',\n\t    'touchmove': 'pointermove',\n\t    'mouseup': 'pointerup',\n\t    'touchend': 'pointerup',\n\t    'touchcancel': 'pointerup'\n\t  },\n\t  /* CSS within the SVG document\n\t  * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for\n\t  *    elements that use the `scalable` group.\n\t  */\n\t  stylesheet: /*css*/`\n        .joint-element .scalable * {\n            vector-effect: non-scaling-stroke;\n        }\n    `,\n\t  svg: null,\n\t  defs: null,\n\t  tools: null,\n\t  layers: null,\n\t  // deprecated, use layers element instead\n\t  viewport: null,\n\t  // For storing the current transformation matrix (CTM) of the paper's viewport.\n\t  _viewportMatrix: null,\n\t  // For verifying whether the CTM is up-to-date. The viewport transform attribute\n\t  // could have been manipulated directly.\n\t  _viewportTransformString: null,\n\t  // Updates data (priorities, unmounted views etc.)\n\t  _updates: null,\n\t  // Paper Layers\n\t  _layers: null,\n\t  UPDATE_DELAYING_BATCHES: ['translate'],\n\t  // If you interact with these elements,\n\t  // the default interaction such as `element move` is prevented.\n\t  FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'],\n\t  // If you interact with these elements, the events are not propagated to the paper\n\t  // i.e. paper events such as `element:pointerdown` are not triggered.\n\t  GUARDED_TAG_NAMES: [\n\t  // Guard <select> for consistency. When you click on it:\n\t  // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n\t  // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n\t  //          on close. However, if you open and then close by clicking elsewhere on the page,\n\t  //           no other event is triggered.\n\t  // Safari: when you open it, it triggers `pointerdown`. That's it.\n\t  'SELECT'],\n\t  MIN_SCALE: 1e-6,\n\t  // Default find buffer for the findViewsInArea and findViewsAtPoint methods.\n\t  // The find buffer is used to extend the area of the search\n\t  // to mitigate the differences between the model and view geometry.\n\t  DEFAULT_FIND_BUFFER: 200,\n\t  FLAG_INSERT: 1 << 30,\n\t  FLAG_REMOVE: 1 << 29,\n\t  FLAG_INIT: 1 << 28,\n\t  // Layers that are always present on the paper (e.g. grid, back, front, tools)\n\t  implicitLayers,\n\t  // Reference layer for inserting new graph layers.\n\t  graphLayerRefId: paperLayers.LABELS,\n\t  init: function () {\n\t    const {\n\t      options\n\t    } = this;\n\t    if (!options.cellViewNamespace) {\n\t      // eslint-disable-next-line no-undef\n\t      options.cellViewNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n\t    }\n\t    const defaultLayerViewNamespace = {\n\t      LayerView,\n\t      GraphLayerView,\n\t      GridLayerView\n\t    };\n\t    this.layerViewNamespace = defaultsDeep({}, options.layerViewNamespace || {}, defaultLayerViewNamespace);\n\t    const model = this.model = options.model || new Graph();\n\n\t    // This property tells us if we need to keep the compatibility\n\t    // with the v4 API and behavior.\n\t    this.legacyMode = !options.viewManagement;\n\n\t    // Layers (SVGGroups)\n\t    this._layers = {\n\t      viewsMap: {},\n\t      order: []\n\t    };\n\n\t    // Hash of all cell views.\n\t    this._views = {};\n\t    this._viewPlaceholders = {};\n\t    this._idToCid = {};\n\t    this.cloneOptions();\n\t    this.render();\n\t    this._setDimensions();\n\t    this.startListening();\n\n\t    // Mouse wheel events buffer\n\t    this._mw_evt_buffer = {\n\t      event: null,\n\t      deltas: []\n\t    };\n\n\t    // Render existing cells in the graph\n\t    this.resetViews(model.getCells());\n\t  },\n\t  _resetUpdates: function () {\n\t    if (this._updates && this._updates.id) cancelFrame(this._updates.id);\n\t    return this._updates = {\n\t      id: null,\n\t      priorities: [{}, {}, {}],\n\t      unmountedList: new Deque(),\n\t      mountedList: new Deque(),\n\t      count: 0,\n\t      keyFrozen: false,\n\t      freezeKey: null,\n\t      sort: false,\n\t      disabled: false,\n\t      idle: false,\n\t      freshAfterReset: true\n\t    };\n\t  },\n\t  startListening: function () {\n\t    var model = this.model;\n\t    this.listenTo(model, 'add', this.onCellAdded).listenTo(model, 'remove', this.onCellRemoved).listenTo(model, 'reset', this.onGraphReset).listenTo(model, 'batch:stop', this.onGraphBatchStop);\n\t    this.listenTo(model, 'layer:add', this.onGraphLayerAdd).listenTo(model, 'layer:remove', this.onGraphLayerRemove).listenTo(model, 'layers:sort', this.onGraphLayerCollectionSort);\n\t    this.on('cell:highlight', this.onCellHighlight).on('cell:unhighlight', this.onCellUnhighlight).on('transform', this.update);\n\t  },\n\t  onCellAdded: function (cell, _, opt) {\n\t    var position = opt.position;\n\t    if (this.isAsync() || !isNumber(position)) {\n\t      this.renderView(cell, opt);\n\t      // Wake up the paper in case it was idle\n\t      // When using initializeUnmounted: true the paper won't wake up by itself\n\t      this.wakeUp();\n\t    } else {\n\t      if (opt.maxPosition === position) this.freeze({\n\t        key: 'addCells'\n\t      });\n\t      this.renderView(cell, opt);\n\t      if (position === 0) this.unfreeze({\n\t        key: 'addCells'\n\t      });\n\t    }\n\t  },\n\t  onCellRemoved: function (cell, _, opt) {\n\t    const viewLike = this._getCellViewLike(cell);\n\t    if (!viewLike) return;\n\t    if (viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t      // It's a cell placeholder, it must be in the unmounted list.\n\t      // Remove it from there and unregister.\n\t      this._updates.unmountedList.delete(viewLike.cid);\n\t      this._unregisterCellViewPlaceholder(viewLike);\n\t    } else {\n\t      this.requestViewUpdate(viewLike, this.FLAG_REMOVE, viewLike.UPDATE_PRIORITY, opt);\n\t    }\n\t  },\n\t  onGraphReset: function (_collection, opt) {\n\t    // Re-render all graph layer views\n\t    // but keep the implicit layer views.\n\t    this.renderGraphLayerViews();\n\t    this.resetLayerViews();\n\t    // Backward compatibility: reassign the `cells` property\n\t    // with the default layer view.\n\t    this.assertLayerViews();\n\t    this.resetViews(this.model.getCells(), opt);\n\t  },\n\t  onGraphBatchStop: function (data) {\n\t    if (this.isFrozen() || this.isIdle()) return;\n\t    var name = data && data.batchName;\n\t    var graph = this.model;\n\t    if (!this.isAsync()) {\n\t      var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n\t      if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n\t        this.updateViews(data);\n\t      }\n\t    }\n\t  },\n\t  /**\n\t  * @protected\n\t  * @description When a new layer is added to the graph, we create a new layer view\n\t  **/\n\t  onGraphLayerAdd: function (layer, _, opt) {\n\t    if (this.hasLayerView(layer.id)) return;\n\t    const layerView = this.createLayerView({\n\t      id: layer.id,\n\t      model: layer\n\t    });\n\t    const layers = this.model.getLayers();\n\t    let before;\n\t    // Note: There is always at least one graph layer.\n\t    if (layers[layers.length - 1] === layer) {\n\t      // This is the last layer, so insert before the labels layer\n\t      before = paperLayers.LABELS;\n\t    } else {\n\t      // There is a layer after the current one, so insert before that one\n\t      const index = layers.indexOf(layer);\n\t      before = layers[index + 1].id;\n\t    }\n\t    this.addLayerView(layerView, {\n\t      before\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description When a layer is removed from the graph, we remove the corresponding layer view\n\t   **/\n\t  onGraphLayerRemove: function (layer, _, opt) {\n\t    if (!this.hasLayerView(layer)) return;\n\n\t    // Request layer removal. Since the UPDATE_PRIORITY is lower\n\t    // than cells update priority, the cell views will be removed first.\n\t    this.requestLayerViewRemoval(layer);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description When the graph layer collection is sorted,\n\t   * we reorder all graph layer views.\n\t   **/\n\t  onGraphLayerCollectionSort: function (layerCollection) {\n\t    layerCollection.each(layer => {\n\t      if (!this.hasLayerView(layer)) return;\n\t      this.moveLayerView(layer, {\n\t        before: this.graphLayerRefId\n\t      });\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Resets all graph layer views.\n\t   */\n\t  renderGraphLayerViews: function () {\n\t    // Remove all existing graph layer views\n\t    // Note: we don't use `getGraphLayerViews()` here because\n\t    // rendered graph layer views could be different from the ones\n\t    // in the graph layer collection (`onResetGraphLayerCollectionReset`).\n\t    this.getLayerViews().forEach(layerView => {\n\t      if (!layerView[GRAPH_LAYER_VIEW_MARKER]) return;\n\t      this._removeLayerView(layerView);\n\t    });\n\t    // Create and insert new graph layer views\n\t    this.model.getLayers().forEach(layer => {\n\t      const layerView = this.createLayerView({\n\t        id: layer.id,\n\t        model: layer\n\t      });\n\t      // Insert the layer view into the paper layers, just before the labels layer.\n\t      // All cell layers are positioned between the \"back\" and \"labels\" layers,\n\t      // with the default \"cells\" layer originally occupying this position.\n\t      this.addLayerView(layerView, {\n\t        before: this.graphLayerRefId\n\t      });\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Renders all implicit layer views.\n\t   */\n\t  renderImplicitLayerViews: function () {\n\t    this.implicitLayers.forEach(layerInit => {\n\t      const layerView = this.createLayerView(layerInit);\n\t      this.addLayerView(layerView);\n\t    });\n\t  },\n\t  cloneOptions: function () {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      defaultConnector,\n\t      defaultRouter,\n\t      defaultConnectionPoint,\n\t      defaultAnchor,\n\t      defaultLinkAnchor,\n\t      highlighting,\n\t      cellViewNamespace,\n\t      interactive\n\t    } = options;\n\n\t    // Default cellView namespace for ES5\n\t    // eslint-disable-next-line no-undef\n\t    if (!cellViewNamespace && typeof joint !== 'undefined' && has(joint, 'shapes')) {\n\t      // eslint-disable-next-line no-undef\n\t      options.cellViewNamespace = joint.shapes;\n\t    }\n\n\t    // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n\t    // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n\t    if (!isFunction(defaultConnector)) {\n\t      options.defaultConnector = cloneDeep(defaultConnector);\n\t    }\n\t    if (!isFunction(defaultRouter)) {\n\t      options.defaultRouter = cloneDeep(defaultRouter);\n\t    }\n\t    if (!isFunction(defaultConnectionPoint)) {\n\t      options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n\t    }\n\t    if (!isFunction(defaultAnchor)) {\n\t      options.defaultAnchor = cloneDeep(defaultAnchor);\n\t    }\n\t    if (!isFunction(defaultLinkAnchor)) {\n\t      options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n\t    }\n\t    if (isPlainObject(interactive)) {\n\t      options.interactive = assign({}, interactive);\n\t    }\n\t    if (isPlainObject(highlighting)) {\n\t      // Return the default highlighting options into the user specified options.\n\t      options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n\t    }\n\t    // Copy and set defaults for the view management options.\n\t    options.viewManagement = defaults({}, options.viewManagement, {\n\t      // Whether to lazy initialize the cell views.\n\t      lazyInitialize: !!options.viewManagement,\n\t      // default `true` if options.viewManagement provided\n\t      // Whether to add initialized cell views into the unmounted queue.\n\t      initializeUnmounted: false,\n\t      // Whether to dispose the cell views that are not visible.\n\t      disposeHidden: false\n\t    });\n\t  },\n\t  children: function () {\n\t    var ns = V.namespace;\n\t    return [{\n\t      namespaceURI: ns.xhtml,\n\t      tagName: 'div',\n\t      className: addClassNamePrefix('paper-background'),\n\t      selector: 'background',\n\t      style: {\n\t        position: 'absolute',\n\t        inset: 0\n\t      }\n\t    }, {\n\t      namespaceURI: ns.svg,\n\t      tagName: 'svg',\n\t      attributes: {\n\t        'width': '100%',\n\t        'height': '100%',\n\t        'xmlns:xlink': ns.xlink\n\t      },\n\t      selector: 'svg',\n\t      style: {\n\t        position: 'absolute',\n\t        inset: 0\n\t      },\n\t      children: [{\n\t        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n\t        // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n\t        tagName: 'defs',\n\t        selector: 'defs'\n\t      }, {\n\t        tagName: 'g',\n\t        className: addClassNamePrefix('layers'),\n\t        selector: 'layers'\n\t      }]\n\t    }];\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Checks whether the layer view exists by the given layer id or layer model.\n\t   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.\n\t   * @return {boolean} True if the layer view exists, false otherwise.\n\t   */\n\t  hasLayerView(layerRef) {\n\t    let layerId;\n\t    if (isString(layerRef)) {\n\t      layerId = layerRef;\n\t    } else if (layerRef) {\n\t      layerId = layerRef.id;\n\t    } else {\n\t      return false;\n\t    }\n\t    return layerId in this._layers.viewsMap;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Returns the layer view by the given layer id or layer model.\n\t   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.\n\t   * @return {dia.LayerView} The layer view.\n\t   * @throws {Error} if the layer view is not found\n\t   */\n\t  getLayerView(layerRef) {\n\t    let layerId;\n\t    if (isString(layerRef)) {\n\t      layerId = layerRef;\n\t    } else if (layerRef) {\n\t      layerId = layerRef.id;\n\t    } else {\n\t      throw new Error('dia.Paper: No layer provided.');\n\t    }\n\t    const layerView = this._layers.viewsMap[layerId];\n\t    if (!layerView) {\n\t      throw new Error(`dia.Paper: Unknown layer view \"${layerId}\".`);\n\t    }\n\t    return layerView;\n\t  },\n\t  /**\n\t   * @deprecated use `getLayerView(layerId).el` instead\n\t   */\n\t  getLayerNode(layerId) {\n\t    return this.getLayerView(layerId).el;\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Removes the given layer view from the paper.\n\t   * It does not check whether the layer view is empty.\n\t   * @param {dia.LayerView} layerView - The layer view to remove.\n\t   */\n\t  _removeLayerView(layerView) {\n\t    this._unregisterLayerView(layerView);\n\t    layerView.remove();\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Removes all layer views from the paper.\n\t   * It does not check whether the layer views are empty.\n\t   */\n\t  _removeLayerViews: function () {\n\t    Object.values(this._layers.viewsMap).forEach(layerView => {\n\t      this._removeLayerView(layerView);\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Unregisters the given layer view from the paper.\n\t   * @param {dia.LayerView} layerView - The layer view to unregister.\n\t   */\n\t  _unregisterLayerView(layerView) {\n\t    const {\n\t      _layers: {\n\t        viewsMap,\n\t        order\n\t      }\n\t    } = this;\n\t    const layerId = layerView.id;\n\t    // Remove the layer id from the order list.\n\t    const layerIndex = order.indexOf(layerId);\n\t    if (layerIndex !== -1) {\n\t      order.splice(layerIndex, 1);\n\t    }\n\t    // Unlink the layer view from the paper.\n\t    layerView.unsetPaperReference();\n\t    // Remove the layer view from the paper's registry.\n\t    delete viewsMap[layerId];\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Registers the given layer view in the paper.\n\t   * @param {dia.LayerView} layerView - The layer view to register.\n\t   * @throws {Error} if the layer view is not an instance of dia.LayerView\n\t   * @throws {Error} if the layer view already exists in the paper\n\t   */\n\t  _registerLayerView(layerView) {\n\t    if (!layerView || !layerView[LAYER_VIEW_MARKER]) {\n\t      throw new Error('dia.Paper: The layer view must be an instance of dia.LayerView.');\n\t    }\n\t    if (this.hasLayerView(layerView.id)) {\n\t      throw new Error(`dia.Paper: The layer view \"${layerView.id}\" already exists.`);\n\t    }\n\t    // Link the layer view back to the paper.\n\t    layerView.setPaperReference(this);\n\t    // Store the layer view in the paper's registry.\n\t    this._layers.viewsMap[layerView.id] = layerView;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Removes the layer view by the given layer id or layer model.\n\t   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.\n\t   * @throws {Error} if the layer view is not empty\n\t   */\n\t  removeLayerView(layerRef) {\n\t    const layerView = this.getLayerView(layerRef);\n\t    if (!layerView.isEmpty()) {\n\t      throw new Error('dia.Paper: The layer view is not empty.');\n\t    }\n\t    this._removeLayerView(layerView);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Schedules the layer view removal by the given layer id or layer model.\n\t   * The actual removal will be performed during the paper update cycle.\n\t   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.\n\t   * @param {Object} [opt] - Update options.\n\t   */\n\t  requestLayerViewRemoval(layerRef, opt) {\n\t    const layerView = this.getLayerView(layerRef);\n\t    const {\n\t      FLAG_REMOVE\n\t    } = this;\n\t    const {\n\t      UPDATE_PRIORITY\n\t    } = layerView;\n\t    this.requestViewUpdate(layerView, FLAG_REMOVE, UPDATE_PRIORITY, opt);\n\t  },\n\t  /**\n\t   * @public\n\t   * @internal not documented\n\t   * @description Schedules the cell view insertion into the appropriate layer view.\n\t   * The actual insertion will be performed during the paper update cycle.\n\t   * @param {dia.Cell} cell - The cell model whose view should be inserted.\n\t   * @param {Object} [opt] - Update options.\n\t   */\n\t  requestCellViewInsertion(cell, opt) {\n\t    const viewLike = this._getCellViewLike(cell);\n\t    if (!viewLike) return;\n\t    this.requestViewUpdate(viewLike, this.FLAG_INSERT, viewLike.UPDATE_PRIORITY, opt);\n\t  },\n\t  /**\n\t   * @private\n\t   * Helper method for addLayerView and moveLayerView methods\n\t   */\n\t  _getBeforeLayerViewFromOptions(layerView, options) {\n\t    const {\n\t      before = null\n\t    } = options;\n\t    let {\n\t      index\n\t    } = options;\n\t    if (before && index !== undefined) {\n\t      throw new Error('dia.Paper: Options \"before\" and \"index\" are mutually exclusive.');\n\t    }\n\t    let computedBefore;\n\t    if (index !== undefined) {\n\t      const {\n\t        _layers: {\n\t          order\n\t        }\n\t      } = this;\n\t      if (index >= order.length) {\n\t        // If index is greater than the number of layers,\n\t        // return before as null (move to the end).\n\t        computedBefore = null;\n\t      } else if (index < 0) {\n\t        // If index is negative, move to the beginning.\n\t        computedBefore = order[0];\n\t      } else {\n\t        const originalIndex = order.indexOf(layerView.id);\n\t        if (originalIndex !== -1 && index > originalIndex) {\n\t          // If moving a layer upwards in the stack, we need to adjust the index\n\t          // to account for the layer being removed from its original position.\n\t          index += 1;\n\t        }\n\t        // Otherwise, get the layer ID at the specified index.\n\t        computedBefore = order[index] || null;\n\t      }\n\t    } else {\n\t      computedBefore = before;\n\t    }\n\t    return computedBefore ? this.getLayerView(computedBefore) : null;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Adds the layer view to the paper.\n\t   * @param {dia.LayerView} layerView - The layer view to add.\n\t   * @param {Object} [options] - Adding options.\n\t   * @param {string|dia.GraphLayer} [options.before] - Layer id or layer model before\n\t   */\n\t  addLayerView(layerView, options = {}) {\n\t    this._registerLayerView(layerView);\n\t    const beforeLayerView = this._getBeforeLayerViewFromOptions(layerView, options);\n\t    this.insertLayerView(layerView, beforeLayerView);\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Moves the layer view.\n\t   * @param {Paper.LayerRef} layerRef - The layer view reference to move.\n\t   * @param {Object} [options] - Moving options.\n\t   * @param {Paper.LayerRef} [options.before] - Layer id or layer model before\n\t   * @param {number} [options.index] - Zero-based index to which to move the layer view.\n\t   */\n\t  moveLayerView(layerRef, options = {}) {\n\t    const layerView = this.getLayerView(layerRef);\n\t    const beforeLayerView = this._getBeforeLayerViewFromOptions(layerView, options);\n\t    this.insertLayerView(layerView, beforeLayerView);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Inserts the layer view into the paper.\n\t   * If the layer view already exists in the paper, it is moved to the new position.\n\t   * @param {dia.LayerView} layerView - The layer view to insert.\n\t   * @param {dia.LayerView} [before] - Layer view before\n\t   * which the layer view should be inserted.\n\t   */\n\t  insertLayerView(layerView, beforeLayerView) {\n\t    const layerId = layerView.id;\n\t    const {\n\t      _layers: {\n\t        order\n\t      }\n\t    } = this;\n\t    const currentLayerIndex = order.indexOf(layerId);\n\n\t    // Should the layer view be inserted before another layer view?\n\t    if (beforeLayerView) {\n\t      const beforeLayerViewId = beforeLayerView.id;\n\t      if (layerId === beforeLayerViewId) {\n\t        // The layer view is already in the right place.\n\t        return;\n\t      }\n\t      let beforeLayerPosition = order.indexOf(beforeLayerViewId);\n\t      // Remove from the `order` list if the layer view is already in the order.\n\t      if (currentLayerIndex !== -1) {\n\t        if (currentLayerIndex < beforeLayerPosition) {\n\t          beforeLayerPosition -= 1;\n\t        }\n\t        order.splice(currentLayerIndex, 1);\n\t      }\n\t      order.splice(beforeLayerPosition, 0, layerId);\n\t      this.layers.insertBefore(layerView.el, beforeLayerView.el);\n\t      return;\n\t    }\n\n\t    // Remove from the `order` list if the layer view is already in the order.\n\t    // This is needed for the case when the layer view is inserted in the new position.\n\t    if (currentLayerIndex !== -1) {\n\t      order.splice(currentLayerIndex, 1);\n\t    }\n\t    order.push(layerId);\n\t    this.layers.appendChild(layerView.el);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Returns an array of layer view ids in the order they are rendered.\n\t   * @returns {string[]} An array of layer view ids.\n\t   */\n\t  getLayerViewOrder() {\n\t    return this._layers.order.slice();\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Returns an array of layer views in the order they are rendered.\n\t   * @returns {dia.LayerView[]} An array of layer views.\n\t   */\n\t  getLayerViews() {\n\t    return this.getLayerViewOrder().map(id => this.getLayerView(id));\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Returns an array of graph layer views in the order they are rendered.\n\t   * @returns {dia.GraphLayerView[]} An array of graph layer views.\n\t   */\n\t  getGraphLayerViews() {\n\t    const {\n\t      _layers: {\n\t        viewsMap\n\t      }\n\t    } = this;\n\t    return this.model.getLayers().map(layer => viewsMap[layer.id]);\n\t  },\n\t  render: function () {\n\t    this.renderChildren();\n\t    const {\n\t      el,\n\t      childNodes,\n\t      options,\n\t      stylesheet\n\t    } = this;\n\t    const {\n\t      svg,\n\t      defs,\n\t      layers\n\t    } = childNodes;\n\t    el.style.position = 'relative';\n\t    svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n\t    this.svg = svg;\n\t    this.defs = defs;\n\t    this.layers = layers;\n\t    this.renderLayerViews();\n\t    V.ensureId(svg);\n\t    this.addStylesheet(stylesheet);\n\t    if (options.background) {\n\t      this.drawBackground(options.background);\n\t    }\n\t    if (options.drawGrid) {\n\t      this.setGrid(options.drawGrid);\n\t    }\n\t    return this;\n\t  },\n\t  addStylesheet: function (css) {\n\t    if (!css) return;\n\t    V(this.svg).prepend(V.createSVGStyle(css));\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Creates a layer view instance based on the provided options.\n\t   * It finds the appropriate layer view constructor from the paper's\n\t   * `layerViewNamespace` and instantiates it.\n\t   * @param {*} options See `dia.LayerView` options.\n\t   * @returns {dia.LayerView}\n\t   */\n\t  createLayerView(options) {\n\t    if (options == null) {\n\t      throw new Error('dia.Paper: Layer view options are required.');\n\t    }\n\t    if (options.id == null) {\n\t      throw new Error('dia.Paper: Layer view id is required.');\n\t    }\n\t    const viewOptions = clone$1(options);\n\t    let viewConstructor;\n\t    if (viewOptions.model) {\n\t      const modelType = viewOptions.model.get('type') || viewOptions.model.constructor.name;\n\t      const type = modelType + 'View';\n\n\t      // For backward compatibility we use the LegacyGraphLayerView for the default `cells` layer.\n\t      if (this.model.legacyMode) {\n\t        viewConstructor = LegacyGraphLayerView;\n\t      } else {\n\t        viewConstructor = this.layerViewNamespace[type] || LayerView;\n\t      }\n\t    } else {\n\t      // Paper layers\n\t      const type = viewOptions.type;\n\t      viewConstructor = this.layerViewNamespace[type] || LayerView;\n\t    }\n\t    return new viewConstructor(viewOptions);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Renders all paper layer views and graph layer views.\n\t   */\n\t  renderLayerViews: function () {\n\t    this._removeLayerViews();\n\t    // Render the paper layers.\n\t    this.renderImplicitLayerViews();\n\t    // Render the layers.\n\t    this.renderGraphLayerViews();\n\t    // Ensure that essential layer views are present.\n\t    this.assertLayerViews();\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Ensures that essential layer views are present on the paper.\n\t   * @throws {Error} if any of the essential layer views is missing\n\t   */\n\t  assertLayerViews: function () {\n\t    // Throws an exception if essential layer views are missing.\n\t    const cellsLayerView = this.getLayerView(this.model.getDefaultLayer().id);\n\t    const toolsLayerView = this.getLayerView(paperLayers.TOOLS);\n\t    const labelsLayerView = this.getLayerView(paperLayers.LABELS);\n\n\t    // backwards compatibility\n\t    this.tools = toolsLayerView.el;\n\t    this.cells = this.viewport = cellsLayerView.el;\n\t    // Backwards compatibility: same as `LegacyGraphLayerView` we keep\n\t    // the `viewport` class on the labels layer.\n\t    labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n\t    labelsLayerView.el.style.webkitUserSelect = 'none';\n\t    labelsLayerView.el.style.userSelect = 'none';\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Resets all layer views.\n\t   */\n\t  resetLayerViews: function () {\n\t    this.getLayerViews().forEach(layerView => layerView.reset());\n\t  },\n\t  update: function () {\n\t    if (this._background) {\n\t      this.updateBackgroundImage(this._background);\n\t    }\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, data) {\n\t    const ctm = this.matrix();\n\t    // getter\n\t    if (sx === undefined) {\n\t      return V.matrixToScale(ctm);\n\t    }\n\t    // setter\n\t    if (sy === undefined) {\n\t      sy = sx;\n\t    }\n\t    sx = Math.max(sx || 0, this.MIN_SCALE);\n\t    sy = Math.max(sy || 0, this.MIN_SCALE);\n\t    ctm.a = sx;\n\t    ctm.d = sy;\n\t    this.matrix(ctm, data);\n\t    return this;\n\t  },\n\t  scaleUniformAtPoint: function (scale, point, data) {\n\t    const {\n\t      a: sx,\n\t      d: sy,\n\t      e: tx,\n\t      f: ty\n\t    } = this.matrix();\n\t    scale = Math.max(scale || 0, this.MIN_SCALE);\n\t    if (scale === sx && scale === sy) {\n\t      // The scale is the same as the current one.\n\t      return this;\n\t    }\n\t    const matrix = V.createSVGMatrix().translate(tx - point.x * (scale - sx), ty - point.y * (scale - sy)).scale(scale, scale);\n\t    this.matrix(matrix, data);\n\t    return this;\n\t  },\n\t  translate: function (tx, ty, data) {\n\t    const ctm = this.matrix();\n\t    // getter\n\t    if (tx === undefined) {\n\t      return V.matrixToTranslate(ctm);\n\t    }\n\t    // setter\n\t    tx || (tx = 0);\n\t    ty || (ty = 0);\n\t    if (ctm.e === tx && ctm.f === ty) return this;\n\t    ctm.e = tx;\n\t    ctm.f = ty;\n\t    this.matrix(ctm, data);\n\t    return this;\n\t  },\n\t  matrix: function (ctm, data = {}) {\n\t    var viewport = this.layers;\n\n\t    // Getter:\n\t    if (ctm === undefined) {\n\t      var transformString = viewport.getAttribute('transform');\n\t      if ((this._viewportTransformString || null) === transformString) {\n\t        // It's ok to return the cached matrix. The transform attribute has not changed since\n\t        // the matrix was stored.\n\t        ctm = this._viewportMatrix;\n\t      } else {\n\t        // The viewport transform attribute has changed. Measure the matrix and cache again.\n\t        ctm = viewport.getCTM();\n\t        this._viewportMatrix = ctm;\n\t        this._viewportTransformString = transformString;\n\t      }\n\n\t      // Clone the cached current transformation matrix.\n\t      // If no matrix previously stored the identity matrix is returned.\n\t      return V.createSVGMatrix(ctm);\n\t    }\n\n\t    // Setter:\n\t    const prev = this.matrix();\n\t    const current = V.createSVGMatrix(ctm);\n\t    const currentTransformString = this._viewportTransformString;\n\t    const ctmString = V.matrixToTransformString(current);\n\t    if (ctmString === currentTransformString) {\n\t      // The new transform string is the same as the current one.\n\t      // No need to update the transform attribute.\n\t      return this;\n\t    }\n\t    if (!currentTransformString && V.matrixToTransformString() === ctmString) {\n\t      // The current transform string is empty and the new one is an identity matrix.\n\t      // No need to update the transform attribute.\n\t      return this;\n\t    }\n\t    const {\n\t      a,\n\t      d,\n\t      e,\n\t      f\n\t    } = current;\n\t    viewport.setAttribute('transform', ctmString);\n\t    this._viewportMatrix = current;\n\t    this._viewportTransformString = viewport.getAttribute('transform');\n\n\t    // scale event\n\t    if (a !== prev.a || d !== prev.d) {\n\t      this.trigger('scale', a, d, data);\n\t    }\n\n\t    // translate event\n\t    if (e !== prev.e || f !== prev.f) {\n\t      this.trigger('translate', e, f, data);\n\t    }\n\t    this.trigger('transform', current, data);\n\t    return this;\n\t  },\n\t  clientMatrix: function () {\n\t    return V.createSVGMatrix(this.layers.getScreenCTM());\n\t  },\n\t  requestConnectedLinksUpdate: function (view, priority, opt) {\n\t    if (!view || !view[CELL_VIEW_MARKER]) return;\n\t    const model = view.model;\n\t    const links = this.model.getConnectedLinks(model);\n\t    for (let j = 0, n = links.length; j < n; j++) {\n\t      const link = links[j];\n\t      const linkView = this._getCellViewLike(link);\n\t      if (!linkView) continue;\n\t      // We do not have to update placeholder views.\n\t      // They will be updated on initial render.\n\t      if (linkView[CELL_VIEW_PLACEHOLDER_MARKER]) continue;\n\t      const flagLabels = [LinkView.Flags.UPDATE];\n\t      // We need to tell the link view which end requested this update.\n\t      if (link.getTargetCell() === model) flagLabels.push(LinkView.Flags.TARGET);\n\t      if (link.getSourceCell() === model) flagLabels.push(LinkView.Flags.SOURCE);\n\t      const nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n\t      this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n\t    }\n\t  },\n\t  forcePostponedViewUpdate: function (view, flag) {\n\t    if (!view || !view[CELL_VIEW_MARKER]) return false;\n\t    const model = view.model;\n\t    if (model.isElement()) return false;\n\t    const dumpOptions = {\n\t      silent: true\n\t    };\n\t    // LinkView is waiting for the target or the source cellView to be rendered\n\t    // This can happen when the cells are not in the viewport.\n\t    let sourceFlag = 0;\n\t    const sourceCell = model.getSourceCell();\n\t    if (sourceCell && !this.isCellVisible(sourceCell)) {\n\t      const sourceView = this.findViewByModel(sourceCell);\n\t      sourceFlag = this.dumpView(sourceView, dumpOptions);\n\t    }\n\t    let targetFlag = 0;\n\t    const targetCell = model.getTargetCell();\n\t    if (targetCell && !this.isCellVisible(targetCell)) {\n\t      const targetView = this.findViewByModel(targetCell);\n\t      targetFlag = this.dumpView(targetView, dumpOptions);\n\t    }\n\t    if (sourceFlag === 0 && targetFlag === 0) {\n\t      // If leftover flag is 0, all view updates were done.\n\t      return !this.dumpView(view, dumpOptions);\n\t    }\n\t    return false;\n\t  },\n\t  requestViewUpdate: function (view, flag, priority, opt) {\n\t    opt || (opt = {});\n\t    // Note: `scheduleViewUpdate` wakes up the paper if it is idle.\n\t    this.scheduleViewUpdate(view, flag, priority, opt);\n\t    var isAsync = this.isAsync();\n\t    if (this.isFrozen() || isAsync && opt.async !== false) return;\n\t    if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n\t    var stats = this.updateViews(opt);\n\t    if (isAsync) this.notifyAfterRender(stats, opt);\n\t  },\n\t  scheduleViewUpdate: function (view, type, priority, opt) {\n\t    const {\n\t      _updates: updates,\n\t      options\n\t    } = this;\n\t    if (updates.idle && options.autoFreeze) {\n\t      this.legacyMode ? this.unfreeze() // Restart rendering loop without original options\n\t      : this.wakeUp();\n\t    }\n\t    const {\n\t      FLAG_REMOVE,\n\t      FLAG_INSERT\n\t    } = this;\n\t    const {\n\t      UPDATE_PRIORITY,\n\t      cid\n\t    } = view;\n\t    let priorityUpdates = updates.priorities[priority];\n\t    if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n\t    // Move higher priority updates to this priority\n\t    if (priority > UPDATE_PRIORITY) {\n\t      // Not the default priority for this view. It's most likely a link view\n\t      // connected to another link view, which triggered the update.\n\t      // TODO: If there is an update scheduled with a lower priority already, we should\n\t      // change the requested priority to the lowest one. Does not seem to be critical\n\t      // right now, as it \"only\" results in multiple updates on the same view.\n\t      for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n\t        const prevPriorityUpdates = updates.priorities[i];\n\t        if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n\t        priorityUpdates[cid] |= prevPriorityUpdates[cid];\n\t        delete prevPriorityUpdates[cid];\n\t      }\n\t    }\n\t    const currentType = priorityUpdates[cid] || 0;\n\t    // Prevent cycling\n\t    if ((currentType & type) === type) return;\n\t    if (!currentType) updates.count++;\n\t    if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n\t      // When a view is removed we need to remove the insert flag as this is a reinsert\n\t      priorityUpdates[cid] ^= FLAG_INSERT;\n\t    } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n\t      // When a view is added we need to remove the remove flag as this is view was previously removed\n\t      priorityUpdates[cid] ^= FLAG_REMOVE;\n\t    }\n\t    priorityUpdates[cid] |= type;\n\t    const viewUpdateFn = options.onViewUpdate;\n\t    if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n\t  },\n\t  dumpViewUpdate: function (view) {\n\t    if (!view) return 0;\n\t    var updates = this._updates;\n\t    var cid = view.cid;\n\t    var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n\t    var flag = this.registerMountedView(view) | priorityUpdates[cid];\n\t    delete priorityUpdates[cid];\n\t    return flag;\n\t  },\n\t  dumpView: function (view, opt = {}) {\n\t    const flag = this.dumpViewUpdate(view);\n\t    if (!flag) return 0;\n\t    this.notifyBeforeRender(opt);\n\t    const leftover = this.updateView(view, flag, opt);\n\t    const stats = {\n\t      updated: 1,\n\t      priority: view.UPDATE_PRIORITY\n\t    };\n\t    this.notifyAfterRender(stats, opt);\n\t    return leftover;\n\t  },\n\t  updateView: function (view, flag, opt) {\n\t    if (!view) return 0;\n\t    const {\n\t      FLAG_REMOVE,\n\t      FLAG_INSERT,\n\t      FLAG_INIT\n\t    } = this;\n\t    const {\n\t      model\n\t    } = view;\n\t    if (view[GRAPH_LAYER_VIEW_MARKER]) {\n\t      if (flag & FLAG_REMOVE) {\n\t        this.removeLayerView(view);\n\t        return 0;\n\t      }\n\t    }\n\t    if (view[CELL_VIEW_MARKER]) {\n\t      if (flag & FLAG_REMOVE) {\n\t        this.removeView(model);\n\t        return 0;\n\t      }\n\t      if (flag & FLAG_INSERT) {\n\t        const isInitialInsert = !!(flag & FLAG_INIT);\n\t        if (isInitialInsert) {\n\t          flag ^= FLAG_INIT;\n\t        }\n\t        this.insertView(view, isInitialInsert);\n\t        flag ^= FLAG_INSERT;\n\t      }\n\t    }\n\t    if (!flag) return 0;\n\t    return view.confirmUpdate(flag, opt || {});\n\t  },\n\t  requireView: function (model, opt) {\n\t    var view = this.findViewByModel(model);\n\t    if (!view) return null;\n\t    this.dumpView(view, opt);\n\t    return view;\n\t  },\n\t  registerUnmountedView: function (view) {\n\t    var cid = view.cid;\n\t    var updates = this._updates;\n\t    if (updates.unmountedList.has(cid)) return 0;\n\t    const flag = this.FLAG_INSERT;\n\t    updates.unmountedList.pushTail(cid, flag);\n\t    updates.mountedList.delete(cid);\n\t    return flag;\n\t  },\n\t  registerMountedView: function (view) {\n\t    var cid = view.cid;\n\t    var updates = this._updates;\n\t    if (updates.mountedList.has(cid)) return 0;\n\t    const unmountedItem = updates.unmountedList.get(cid);\n\t    const flag = unmountedItem ? unmountedItem.value : 0;\n\t    updates.unmountedList.delete(cid);\n\t    updates.mountedList.pushTail(cid);\n\t    return flag;\n\t  },\n\t  isCellVisible: function (cellOrId) {\n\t    const cid = cellOrId && this._idToCid[cellOrId.id || cellOrId];\n\t    if (!cid) return false; // The view is not registered.\n\t    return this.isViewMounted(cid);\n\t  },\n\t  isViewMounted: function (viewOrCid) {\n\t    if (!viewOrCid) return false;\n\t    let cid;\n\t    if (viewOrCid[CELL_VIEW_MARKER] || viewOrCid[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t      cid = viewOrCid.cid;\n\t    } else {\n\t      cid = viewOrCid;\n\t    }\n\t    return this._updates.mountedList.has(cid);\n\t  },\n\t  /**\n\t   * @deprecated use `updateCellsVisibility` instead.\n\t   * `paper.updateCellsVisibility({ cellVisibility: () => true });`\n\t   */\n\t  dumpViews: function (opt) {\n\t    // Update cell visibility without `cellVisibility` callback i.e. make the cells visible\n\t    const passingOpt = defaults({}, opt, {\n\t      cellVisibility: null,\n\t      viewport: null\n\t    });\n\t    this.updateCellsVisibility(passingOpt);\n\t  },\n\t  /**\n\t   * Process all scheduled updates synchronously.\n\t   */\n\t  updateViews: function (opt = {}) {\n\t    this.notifyBeforeRender(opt);\n\t    const batchStats = this.updateViewsBatch({\n\t      ...opt,\n\t      batchSize: Infinity\n\t    });\n\t    const stats = {\n\t      updated: batchStats.updated,\n\t      priority: batchStats.priority,\n\t      // For backward compatibility. Will be removed in the future.\n\t      batches: Number.isFinite(opt.batchSize) ? Math.ceil(batchStats.updated / opt.batchSize) : 1\n\t    };\n\t    this.notifyAfterRender(stats, opt);\n\t    return stats;\n\t  },\n\t  hasScheduledUpdates: function () {\n\t    const updates = this._updates;\n\t    const priorities = updates.priorities;\n\t    const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n\t    let i = priorityIndexes.length;\n\t    while (i > 0 && i--) {\n\t      // a faster way how to check if an object is empty\n\t      for (const _key in priorities[priorityIndexes[i]]) return true;\n\t    }\n\t    return false;\n\t  },\n\t  updateViewsAsync: function (opt, data) {\n\t    opt || (opt = {});\n\t    data || (data = {\n\t      processed: 0,\n\t      priority: MIN_PRIORITY,\n\t      checkedUnmounted: 0,\n\t      checkedMounted: 0\n\t    });\n\t    const {\n\t      _updates: updates,\n\t      options\n\t    } = this;\n\t    const {\n\t      id,\n\t      mountedList,\n\t      unmountedList,\n\t      freshAfterReset\n\t    } = updates;\n\n\t    // Should we run the next batch update this frame?\n\t    let runBatchUpdate = true;\n\t    if (!id) {\n\t      // If there's no scheduled frame, no batch update is needed.\n\t      runBatchUpdate = false;\n\t    } else {\n\t      // Cancel any scheduled frame.\n\t      cancelFrame(id);\n\t      if (freshAfterReset) {\n\t        // First update after a reset.\n\t        updates.freshAfterReset = false;\n\t        // When `initializeUnmounted` is enabled, there are no scheduled updates.\n\t        // We check whether the `mountedList` and `unmountedList` are empty.\n\t        if (!this.legacyMode && mountedList.length === 0 && unmountedList.length === 0) {\n\t          // No updates to process; We trigger before/after render events via `updateViews`.\n\t          // Note: If `autoFreeze` is enabled, 'idle' event triggers next frame.\n\t          this.updateViews();\n\t          runBatchUpdate = false;\n\t        }\n\t      }\n\t    }\n\t    if (runBatchUpdate) {\n\t      if (data.processed === 0 && this.hasScheduledUpdates()) {\n\t        this.notifyBeforeRender(opt);\n\t      }\n\t      const stats = this.updateViewsBatch(opt);\n\t      const passingOpt = defaults({}, opt, {\n\t        mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n\t        unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n\t      });\n\t      const checkStats = this.scheduleCellsVisibilityUpdate(passingOpt);\n\t      const unmountCount = checkStats.unmounted;\n\t      const mountCount = checkStats.mounted;\n\t      let processed = data.processed;\n\t      const total = updates.count;\n\t      if (stats.updated > 0) {\n\t        // Some updates have been just processed\n\t        processed += stats.updated + stats.unmounted;\n\t        stats.processed = processed;\n\t        data.priority = Math.min(stats.priority, data.priority);\n\t        if (stats.empty && mountCount === 0) {\n\t          stats.unmounted += unmountCount;\n\t          stats.mounted += mountCount;\n\t          stats.priority = data.priority;\n\t          this.notifyAfterRender(stats, opt);\n\t          data.processed = 0;\n\t          data.priority = MIN_PRIORITY;\n\t          updates.count = 0;\n\t        } else {\n\t          data.processed = processed;\n\t        }\n\t        data.checkedUnmounted = 0;\n\t        data.checkedMounted = 0;\n\t      } else {\n\t        data.checkedUnmounted += Math.max(passingOpt.mountBatchSize, 0);\n\t        data.checkedMounted += Math.max(passingOpt.unmountBatchSize, 0);\n\t        // The `scheduleCellsVisibilityUpdate` could have scheduled some insertions\n\t        // (note that removals are currently done synchronously).\n\t        if (options.autoFreeze && !this.hasScheduledUpdates()) {\n\t          // If there are no updates scheduled and we checked all unmounted views,\n\t          if (data.checkedUnmounted >= unmountedList.length && data.checkedMounted >= mountedList.length) {\n\t            // We freeze the paper and notify the idle state.\n\t            this.freeze();\n\t            updates.idle = {\n\t              wakeUpOptions: opt\n\t            };\n\t            this.trigger('render:idle', opt);\n\t          }\n\t        }\n\t      }\n\t      // Progress callback\n\t      const progressFn = opt.progress;\n\t      if (total && typeof progressFn === 'function') {\n\t        progressFn.call(this, stats.empty, processed, total, stats, this);\n\t      }\n\t      // The current frame could have been canceled in a callback\n\t      if (updates.id !== id) return;\n\t    }\n\t    if (updates.disabled) {\n\t      throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n\t    }\n\t    updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n\t  },\n\t  notifyBeforeRender: function (opt = {}) {\n\t    if (opt.silent) return;\n\t    let beforeFn = opt.beforeRender;\n\t    if (typeof beforeFn !== 'function') {\n\t      beforeFn = this.options.beforeRender;\n\t      if (typeof beforeFn !== 'function') return;\n\t    }\n\t    beforeFn.call(this, opt, this);\n\t  },\n\t  notifyAfterRender: function (stats, opt = {}) {\n\t    if (opt.silent) return;\n\t    let afterFn = opt.afterRender;\n\t    if (typeof afterFn !== 'function') {\n\t      afterFn = this.options.afterRender;\n\t    }\n\t    if (typeof afterFn === 'function') {\n\t      afterFn.call(this, stats, opt, this);\n\t    }\n\t    this.trigger('render:done', stats, opt);\n\t  },\n\t  prioritizeCellViewMount: function (cellOrId) {\n\t    if (!cellOrId) return false;\n\t    const cid = this._idToCid[cellOrId.id || cellOrId];\n\t    if (!cid) return false;\n\t    const {\n\t      unmountedList\n\t    } = this._updates;\n\t    if (!unmountedList.has(cid)) return false;\n\t    // Move the view to the head of the mounted list\n\t    unmountedList.moveToHead(cid);\n\t    return true;\n\t  },\n\t  prioritizeCellViewUnmount: function (cellOrId) {\n\t    if (!cellOrId) return false;\n\t    const cid = this._idToCid[cellOrId.id || cellOrId];\n\t    if (!cid) return false;\n\t    const {\n\t      mountedList\n\t    } = this._updates;\n\t    if (!mountedList.has(cid)) return false;\n\t    // Move the view to the head of the unmounted list\n\t    mountedList.moveToHead(cid);\n\t    return true;\n\t  },\n\t  _evalCellVisibility: function (viewLike, isMounted, visibilityCallback) {\n\t    if (!visibilityCallback || !viewLike.DETACHABLE) return true;\n\t    if (this.legacyMode) {\n\t      return visibilityCallback.call(this, viewLike, isMounted, this);\n\t    }\n\t    // The visibility check runs for CellView only.\n\t    if (!viewLike[CELL_VIEW_MARKER] && !viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) return true;\n\t    // The cellView model must be a member of this graph.\n\t    if (viewLike.model.graph !== this.model) {\n\t      // It could have been removed from the graph.\n\t      // If the view was mounted, we keep it mounted.\n\t      return isMounted;\n\t    }\n\t    return visibilityCallback.call(this, viewLike.model, isMounted, this);\n\t  },\n\t  _getCellVisibilityCallback: function (opt) {\n\t    const {\n\t      options\n\t    } = this;\n\t    if (this.legacyMode) {\n\t      const viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n\t      if (typeof viewportFn === 'function') return viewportFn;\n\t    } else {\n\t      const isVisibleFn = 'cellVisibility' in opt ? opt.cellVisibility : options.cellVisibility;\n\t      if (typeof isVisibleFn === 'function') return isVisibleFn;\n\t    }\n\t    return null;\n\t  },\n\t  updateViewsBatch: function (opt) {\n\t    opt || (opt = {});\n\t    var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n\t    var updates = this._updates;\n\t    var updateCount = 0;\n\t    var postponeCount = 0;\n\t    var unmountCount = 0;\n\t    var mountCount = 0;\n\t    var maxPriority = MIN_PRIORITY;\n\t    var empty = true;\n\t    var options = this.options;\n\t    var priorities = updates.priorities;\n\t    const visibilityCb = this._getCellVisibilityCallback(opt);\n\t    var postponeViewFn = options.onViewPostponed;\n\t    if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n\t    var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n\t    main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n\t      var priority = +priorityIndexes[i];\n\t      var priorityUpdates = priorities[priority];\n\t      for (var cid in priorityUpdates) {\n\t        if (updateCount >= batchSize) {\n\t          empty = false;\n\t          break main;\n\t        }\n\t        var view = views[cid];\n\t        if (!view) {\n\t          view = this._viewPlaceholders[cid];\n\t          if (!view) {\n\t            /**\n\t             * This can occur when:\n\t             * - the model is removed and a new model with the same id is added\n\t             * - the view `initialize` method was overridden and the view was not registered\n\t             * - an mvc.View scheduled an update, was removed and paper was not notified\n\t             */\n\t            delete priorityUpdates[cid];\n\t            continue;\n\t          }\n\t        }\n\t        var currentFlag = priorityUpdates[cid];\n\t        if ((currentFlag & this.FLAG_REMOVE) === 0) {\n\t          // We should never check a view for viewport if we are about to remove the view\n\t          const isMounted = !updates.unmountedList.has(cid);\n\t          if (!this._evalCellVisibility(view, isMounted, visibilityCb)) {\n\t            // Unmount View\n\t            if (isMounted) {\n\t              // The view is currently mounted. Hide the view (detach or remove it).\n\t              this.registerUnmountedView(view);\n\t              this._hideView(view);\n\t            } else {\n\t              // The view is not mounted. We can just update the unmounted list.\n\t              // We ADD the current flag to the flag that was already scheduled.\n\t              this._mergeUnmountedViewScheduledUpdates(cid, currentFlag);\n\t            }\n\t            // Delete the current update as it has been processed.\n\t            delete priorityUpdates[cid];\n\t            unmountCount++;\n\t            continue;\n\t          }\n\t          // Mount View\n\t          if (view[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t            view = this._resolveCellViewPlaceholder(view);\n\t            // Newly initialized view needs to be initialized\n\t            currentFlag |= this.getCellViewInitFlag(view);\n\t          }\n\t          if (!isMounted) {\n\t            currentFlag |= this.FLAG_INSERT;\n\t            mountCount++;\n\t          }\n\t          currentFlag |= this.registerMountedView(view);\n\t        } else if (view[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t          // We are trying to remove a placeholder view.\n\t          // This should not occur as the placeholder should have been unregistered\n\t          continue;\n\t        }\n\t        var leftoverFlag = this.updateView(view, currentFlag, opt);\n\t        if (leftoverFlag > 0) {\n\t          // View update has not finished completely\n\t          priorityUpdates[cid] = leftoverFlag;\n\t          if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n\t            postponeCount++;\n\t            empty = false;\n\t            continue;\n\t          }\n\t        }\n\t        if (maxPriority > priority) maxPriority = priority;\n\t        updateCount++;\n\t        delete priorityUpdates[cid];\n\t      }\n\t    }\n\t    return {\n\t      priority: maxPriority,\n\t      updated: updateCount,\n\t      postponed: postponeCount,\n\t      unmounted: unmountCount,\n\t      mounted: mountCount,\n\t      empty: empty\n\t    };\n\t  },\n\t  getCellViewInitFlag: function (cellView) {\n\t    return this.FLAG_INIT | cellView.getFlag(result(cellView, 'initFlag'));\n\t  },\n\t  /**\n\t   * @ignore This method returns an array of cellViewLike objects and therefore\n\t   * is meant for internal/test use only.\n\t   * The view placeholders are not exposed via public API.\n\t  */\n\t  getUnmountedViews: function () {\n\t    const updates = this._updates;\n\t    const unmountedViews = new Array(updates.unmountedList.length);\n\t    const unmountedCids = updates.unmountedList.keys();\n\t    let i = 0;\n\t    for (const cid of unmountedCids) {\n\t      // If the view is a placeholder, it won't be in the global views map\n\t      // If the view is not a cell view, it won't be in the viewPlaceholders map\n\t      unmountedViews[i++] = views[cid] || this._viewPlaceholders[cid];\n\t    }\n\t    return unmountedViews;\n\t  },\n\t  /**\n\t   * @ignore This method returns an array of cellViewLike objects and therefore\n\t   * is meant for internal/test use only.\n\t   * The view placeholders are not exposed via public API.\n\t   */\n\t  getMountedViews: function () {\n\t    const updates = this._updates;\n\t    const mountedViews = new Array(updates.mountedList.length);\n\t    const mountedCids = updates.mountedList.keys();\n\t    let i = 0;\n\t    for (const cid of mountedCids) {\n\t      mountedViews[i++] = views[cid] || this._viewPlaceholders[cid];\n\t    }\n\t    return mountedViews;\n\t  },\n\t  checkUnmountedViews: function (visibilityCb, opt) {\n\t    opt || (opt = {});\n\t    var mountCount = 0;\n\t    if (typeof visibilityCb !== 'function') visibilityCb = null;\n\t    var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n\t    var updates = this._updates;\n\t    var unmountedList = updates.unmountedList;\n\t    for (var i = 0, n = Math.min(unmountedList.length, batchSize); i < n; i++) {\n\t      // stop if there are no more unmounted views\n\t      // this can happen when another view was mounted in the onViewUpdate() callback\n\t      if (unmountedList.length === 0) break;\n\t      const {\n\t        key: cid\n\t      } = unmountedList.peekHead();\n\t      const view = views[cid] || this._viewPlaceholders[cid];\n\t      if (!view) {\n\t        // This should not occur\n\t        // Prevent looping over this invalid cid\n\t        unmountedList.popHead();\n\t        continue;\n\t      }\n\t      if (!this._evalCellVisibility(view, false, visibilityCb)) {\n\t        // Push at the end of all unmounted ids, so this can be check later again\n\t        unmountedList.rotate();\n\t        continue;\n\t      }\n\t      // Remove the view from the unmounted list\n\t      const {\n\t        value: prevFlag\n\t      } = unmountedList.popHead();\n\t      mountCount++;\n\t      const flag = this.registerMountedView(view) | prevFlag;\n\t      if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {\n\t        mounting: true\n\t      });\n\t    }\n\t    return mountCount;\n\t  },\n\t  checkMountedViews: function (visibilityCb, opt) {\n\t    opt || (opt = {});\n\t    var unmountCount = 0;\n\t    if (typeof visibilityCb !== 'function') return unmountCount;\n\t    var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n\t    var updates = this._updates;\n\t    const mountedList = updates.mountedList;\n\t    for (var i = 0, n = Math.min(mountedList.length, batchSize); i < n; i++) {\n\t      const {\n\t        key: cid\n\t      } = mountedList.peekHead();\n\t      const view = views[cid];\n\t      if (!view) {\n\t        // A view (not a cell view) has been removed from the paper.\n\t        // Remove it from the mounted list and continue.\n\t        mountedList.popHead();\n\t        continue;\n\t      }\n\t      if (this._evalCellVisibility(view, true, visibilityCb)) {\n\t        // Push at the end of all mounted ids, so this can be check later again\n\t        mountedList.rotate();\n\t        continue;\n\t      }\n\t      // Remove the view from the mounted list\n\t      mountedList.popHead();\n\t      unmountCount++;\n\t      var flag = this.registerUnmountedView(view);\n\t      if (flag) {\n\t        this._hideView(view);\n\t      }\n\t    }\n\t    return unmountCount;\n\t  },\n\t  checkViewVisibility: function (cellView, opt = {}) {\n\t    const visibilityCb = this._getCellVisibilityCallback(opt);\n\t    const updates = this._updates;\n\t    const {\n\t      mountedList,\n\t      unmountedList\n\t    } = updates;\n\t    const visible = this._evalCellVisibility(cellView, false, visibilityCb);\n\t    let isUnmounted = false;\n\t    let isMounted = false;\n\t    if (mountedList.has(cellView.cid) && !visible) {\n\t      const flag = this.registerUnmountedView(cellView);\n\t      if (flag) this._hideView(cellView);\n\t      mountedList.delete(cellView.cid);\n\t      isUnmounted = true;\n\t    }\n\t    if (!isUnmounted && unmountedList.has(cellView.cid) && visible) {\n\t      const unmountedItem = unmountedList.get(cellView.cid);\n\t      unmountedList.delete(cellView.cid);\n\t      const flag = unmountedItem.value | this.registerMountedView(cellView);\n\t      if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {\n\t        mounting: true\n\t      });\n\t      isMounted = true;\n\t    }\n\t    return {\n\t      mounted: isMounted ? 1 : 0,\n\t      unmounted: isUnmounted ? 1 : 0\n\t    };\n\t  },\n\t  /**\n\t   * @public\n\t   * Update the visibility of a single cell.\n\t   */\n\t  updateCellVisibility: function (cell, opt = {}) {\n\t    const cellViewLike = this._getCellViewLike(cell);\n\t    if (!cellViewLike) return;\n\t    const stats = this.checkViewVisibility(cellViewLike, opt);\n\t    // Note: `unmounted` views are removed immediately\n\t    if (stats.mounted > 0) {\n\t      // Mounting is scheduled. Run the update.\n\t      // Note: the view might be a placeholder.\n\t      this.requireView(cell, opt);\n\t    }\n\t  },\n\t  /**\n\t   * @public\n\t   * Update the visibility of all cells.\n\t   */\n\t  updateCellsVisibility: function (opt = {}) {\n\t    // Check the visibility of all cells and schedule their updates.\n\t    this.scheduleCellsVisibilityUpdate(opt);\n\t    // Perform the scheduled updates while avoiding re-evaluating the visibility.\n\t    const keepCurrentVisibility = (_, isVisible) => isVisible;\n\t    this.updateViews({\n\t      ...opt,\n\t      cellVisibility: keepCurrentVisibility\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * Run visibility checks for all cells and schedule their updates.\n\t   */\n\t  scheduleCellsVisibilityUpdate(opt) {\n\t    const passingOpt = defaults({}, opt, {\n\t      mountBatchSize: Infinity,\n\t      unmountBatchSize: Infinity\n\t    });\n\t    const visibilityCb = this._getCellVisibilityCallback(passingOpt);\n\t    const unmountedCount = this.checkMountedViews(visibilityCb, passingOpt);\n\t    if (unmountedCount > 0) {\n\t      // Do not check views, that have been just unmounted and pushed at the end of the cids array\n\t      var unmountedList = this._updates.unmountedList;\n\t      passingOpt.mountBatchSize = Math.min(unmountedList.length - unmountedCount, passingOpt.mountBatchSize);\n\t    }\n\t    const mountedCount = this.checkUnmountedViews(visibilityCb, passingOpt);\n\t    return {\n\t      mounted: mountedCount,\n\t      unmounted: unmountedCount\n\t    };\n\t  },\n\t  /**\n\t   * @deprecated use `updateCellsVisibility` instead\n\t   * This method will be renamed and made private in the future.\n\t   */\n\t  checkViewport: function (opt) {\n\t    return this.scheduleCellsVisibilityUpdate(opt);\n\t  },\n\t  freeze: function (opt) {\n\t    opt || (opt = {});\n\t    var updates = this._updates;\n\t    var key = opt.key;\n\t    var isFrozen = this.options.frozen;\n\t    var freezeKey = updates.freezeKey;\n\t    if (key && key !== freezeKey) {\n\t      // key passed, but the paper is already freezed with another key\n\t      if (isFrozen && freezeKey) return;\n\t      updates.freezeKey = key;\n\t      updates.keyFrozen = isFrozen;\n\t    }\n\t    this.options.frozen = true;\n\t    var id = updates.id;\n\t    updates.id = null;\n\t    if (!this.legacyMode) {\n\t      // Make sure the `freeze()` method ends the idle state.\n\t      updates.idle = false;\n\t    }\n\t    if (this.isAsync() && id) cancelFrame(id);\n\t  },\n\t  unfreeze: function (opt) {\n\t    opt || (opt = {});\n\t    var updates = this._updates;\n\t    var key = opt.key;\n\t    var freezeKey = updates.freezeKey;\n\t    // key passed, but the paper is already freezed with another key\n\t    if (key && freezeKey && key !== freezeKey) return;\n\t    updates.freezeKey = null;\n\t    // key passed, but the paper is already freezed\n\t    if (key && key === freezeKey && updates.keyFrozen) return;\n\t    updates.idle = false;\n\t    if (this.isAsync()) {\n\t      this.freeze();\n\t      this.updateViewsAsync(opt);\n\t    } else {\n\t      this.updateViews(opt);\n\t    }\n\t    this.options.frozen = updates.keyFrozen = false;\n\t    if (updates.sort) {\n\t      this.sortLayerViews();\n\t      updates.sort = false;\n\t    }\n\t  },\n\t  wakeUp: function () {\n\t    if (!this.isIdle()) return;\n\t    this.unfreeze(this._updates.idle.wakeUpOptions);\n\t  },\n\t  isAsync: function () {\n\t    return !!this.options.async;\n\t  },\n\t  isFrozen: function () {\n\t    return !!this.options.frozen && !this.isIdle();\n\t  },\n\t  isIdle: function () {\n\t    if (this.legacyMode) {\n\t      // Not implemented in the legacy mode.\n\t      return false;\n\t    }\n\t    return !!(this._updates && this._updates.idle);\n\t  },\n\t  isExactSorting: function () {\n\t    return this.options.sorting === sortingTypes.EXACT;\n\t  },\n\t  onRemove: function () {\n\t    this.freeze();\n\t    this._updates.disabled = true;\n\t    //clean up all DOM elements/views to prevent memory leaks\n\t    this.removeViews();\n\t    this._removeLayerViews();\n\t  },\n\t  getComputedSize: function () {\n\t    var options = this.options;\n\t    var w = options.width;\n\t    var h = options.height;\n\t    if (!isNumber(w)) w = this.el.clientWidth;\n\t    if (!isNumber(h)) h = this.el.clientHeight;\n\t    return {\n\t      width: w,\n\t      height: h\n\t    };\n\t  },\n\t  setDimensions: function (width, height, data = {}) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      width: currentWidth,\n\t      height: currentHeight\n\t    } = options;\n\t    const w = width === undefined ? currentWidth : width;\n\t    const h = height === undefined ? currentHeight : height;\n\t    if (currentWidth === w && currentHeight === h) return;\n\t    options.width = w;\n\t    options.height = h;\n\t    this._setDimensions();\n\t    const computedSize = this.getComputedSize();\n\t    this.trigger('resize', computedSize.width, computedSize.height, data);\n\t  },\n\t  _setDimensions: function () {\n\t    const {\n\t      options\n\t    } = this;\n\t    let w = options.width;\n\t    let h = options.height;\n\t    if (isNumber(w)) w = `${Math.round(w)}px`;\n\t    if (isNumber(h)) h = `${Math.round(h)}px`;\n\t    this.$el.css({\n\t      width: w === null ? '' : w,\n\t      height: h === null ? '' : h\n\t    });\n\t  },\n\t  // Expand/shrink the paper to fit the content.\n\t  // Alternatively signature function(opt)\n\t  fitToContent: function (gridWidth, gridHeight, padding, opt) {\n\t    if (isObject(gridWidth)) {\n\t      // first parameter is an option object\n\t      opt = gridWidth;\n\t    } else {\n\t      // Support for a deprecated signature\n\t      opt = assign({\n\t        gridWidth,\n\t        gridHeight,\n\t        padding\n\t      }, opt);\n\t    }\n\t    const {\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    } = this.getFitToContentArea(opt);\n\t    const {\n\t      sx,\n\t      sy\n\t    } = this.scale();\n\t    this.translate(-x * sx, -y * sy, opt);\n\t    this.setDimensions(width * sx, height * sy, opt);\n\t    return new Rect(x, y, width, height);\n\t  },\n\t  getFitToContentArea: function (opt = {}) {\n\t    // Calculate the paper size to accommodate all the graph's elements.\n\n\t    const gridWidth = opt.gridWidth || 1;\n\t    const gridHeight = opt.gridHeight || 1;\n\t    const padding = normalizeSides(opt.padding || 0);\n\t    const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n\t    const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n\t    const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n\t    const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n\t    const newOrigin = opt.allowNewOrigin;\n\t    const area = 'contentArea' in opt ? new Rect(opt.contentArea) : this.getContentArea(opt);\n\t    const {\n\t      sx,\n\t      sy\n\t    } = this.scale();\n\t    area.x *= sx;\n\t    area.y *= sy;\n\t    area.width *= sx;\n\t    area.height *= sy;\n\t    let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n\t    let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n\t    if (!opt.allowNegativeBottomRight) {\n\t      calcWidth = Math.max(calcWidth, 1);\n\t      calcHeight = Math.max(calcHeight, 1);\n\t    }\n\t    calcWidth *= gridWidth;\n\t    calcHeight *= gridHeight;\n\t    let tx = 0;\n\t    if (newOrigin === 'negative' && area.x < 0 || newOrigin === 'positive' && area.x >= 0 || newOrigin === 'any') {\n\t      tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n\t      tx += padding.left;\n\t      calcWidth += tx;\n\t    }\n\t    let ty = 0;\n\t    if (newOrigin === 'negative' && area.y < 0 || newOrigin === 'positive' && area.y >= 0 || newOrigin === 'any') {\n\t      ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n\t      ty += padding.top;\n\t      calcHeight += ty;\n\t    }\n\t    calcWidth += padding.right;\n\t    calcHeight += padding.bottom;\n\n\t    // Make sure the resulting width and height are greater than minimum.\n\t    calcWidth = Math.max(calcWidth, minWidth);\n\t    calcHeight = Math.max(calcHeight, minHeight);\n\n\t    // Make sure the resulting width and height are lesser than maximum.\n\t    calcWidth = Math.min(calcWidth, maxWidth);\n\t    calcHeight = Math.min(calcHeight, maxHeight);\n\t    return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n\t  },\n\t  transformToFitContent: function (opt) {\n\t    opt || (opt = {});\n\t    let contentBBox, contentLocalOrigin;\n\t    if ('contentArea' in opt) {\n\t      const contentArea = opt.contentArea;\n\t      contentBBox = this.localToPaperRect(contentArea);\n\t      contentLocalOrigin = new Point(contentArea);\n\t    } else {\n\t      contentBBox = this.getContentBBox(opt);\n\t      contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n\t    }\n\t    if (!contentBBox.width || !contentBBox.height) return;\n\t    defaults(opt, {\n\t      padding: 0,\n\t      preserveAspectRatio: true,\n\t      scaleGrid: null,\n\t      minScale: 0,\n\t      maxScale: Number.MAX_VALUE,\n\t      verticalAlign: 'top',\n\t      horizontalAlign: 'left'\n\t      //minScaleX\n\t      //minScaleY\n\t      //maxScaleX\n\t      //maxScaleY\n\t      //fittingBBox\n\t    });\n\t    const padding = normalizeSides(opt.padding);\n\t    const minScaleX = opt.minScaleX || opt.minScale;\n\t    const maxScaleX = opt.maxScaleX || opt.maxScale;\n\t    const minScaleY = opt.minScaleY || opt.minScale;\n\t    const maxScaleY = opt.maxScaleY || opt.maxScale;\n\t    let fittingBBox;\n\t    if (opt.fittingBBox) {\n\t      fittingBBox = opt.fittingBBox;\n\t    } else {\n\t      const currentTranslate = this.translate();\n\t      const computedSize = this.getComputedSize();\n\t      fittingBBox = {\n\t        x: currentTranslate.tx,\n\t        y: currentTranslate.ty,\n\t        width: computedSize.width,\n\t        height: computedSize.height\n\t      };\n\t    }\n\t    fittingBBox = new Rect(fittingBBox).moveAndExpand({\n\t      x: padding.left,\n\t      y: padding.top,\n\t      width: -padding.left - padding.right,\n\t      height: -padding.top - padding.bottom\n\t    });\n\t    const ctm = this.matrix();\n\t    const {\n\t      a: sx,\n\t      d: sy,\n\t      e: tx,\n\t      f: ty\n\t    } = ctm;\n\t    let newSx = fittingBBox.width / contentBBox.width * sx;\n\t    let newSy = fittingBBox.height / contentBBox.height * sy;\n\t    if (opt.preserveAspectRatio) {\n\t      newSx = newSy = Math.min(newSx, newSy);\n\t    }\n\n\t    // snap scale to a grid\n\t    if (opt.scaleGrid) {\n\t      const gridSize = opt.scaleGrid;\n\t      newSx = gridSize * Math.floor(newSx / gridSize);\n\t      newSy = gridSize * Math.floor(newSy / gridSize);\n\t    }\n\n\t    // scale min/max boundaries\n\t    newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n\t    newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\t    const scaleDiff = {\n\t      x: newSx / sx,\n\t      y: newSy / sy\n\t    };\n\t    let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;\n\t    let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;\n\t    switch (opt.verticalAlign) {\n\t      case 'middle':\n\t        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n\t        break;\n\t      case 'bottom':\n\t        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n\t        break;\n\t      case 'top':\n\t      default:\n\t        break;\n\t    }\n\t    switch (opt.horizontalAlign) {\n\t      case 'middle':\n\t        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n\t        break;\n\t      case 'right':\n\t        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n\t        break;\n\t      case 'left':\n\t      default:\n\t        break;\n\t    }\n\t    ctm.a = newSx;\n\t    ctm.d = newSy;\n\t    ctm.e = newOx;\n\t    ctm.f = newOy;\n\t    this.matrix(ctm, opt);\n\t  },\n\t  scaleContentToFit: function (opt) {\n\t    this.transformToFitContent(opt);\n\t  },\n\t  // Return the dimensions of the content area in local units (without transformations).\n\t  getContentArea: function (opt) {\n\t    if (opt && opt.useModelGeometry) {\n\t      return this.model.getBBox() || new Rect();\n\t    }\n\t    const graphLayerViews = this.getGraphLayerViews();\n\t    // Return an empty rectangle if there are no layers\n\t    // should not happen in practice\n\t    if (graphLayerViews.length === 0) {\n\t      return new Rect();\n\t    }\n\n\t    // Combine content area rectangles from all layers,\n\t    // considering only graph layer views to exclude non-cell elements (e.g., grid, tools)\n\t    const bbox = Rect.fromRectUnion(...graphLayerViews.map(view => view.vel.getBBox()));\n\t    return bbox;\n\t  },\n\t  // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n\t  getContentBBox: function (opt) {\n\t    return this.localToPaperRect(this.getContentArea(opt));\n\t  },\n\t  // Returns a geometry rectangle representing the entire\n\t  // paper area (coordinates from the left paper border to the right one\n\t  // and the top border to the bottom one).\n\t  getArea: function () {\n\t    return this.paperToLocalRect(this.getComputedSize());\n\t  },\n\t  getRestrictedArea: function (...args) {\n\t    const {\n\t      restrictTranslate\n\t    } = this.options;\n\t    let restrictedArea;\n\t    if (isFunction(restrictTranslate)) {\n\t      // A method returning a bounding box\n\t      restrictedArea = restrictTranslate.apply(this, args);\n\t    } else if (restrictTranslate === true) {\n\t      // The paper area\n\t      restrictedArea = this.getArea();\n\t    } else if (!restrictTranslate) {\n\t      // falsy value\n\t      restrictedArea = null;\n\t    } else {\n\t      // any other value\n\t      restrictedArea = new Rect(restrictTranslate);\n\t    }\n\t    return restrictedArea;\n\t  },\n\t  _resolveCellViewPlaceholder: function (placeholder) {\n\t    const {\n\t      model,\n\t      viewClass,\n\t      cid\n\t    } = placeholder;\n\t    const view = this._initializeCellView(viewClass, model, cid);\n\t    this._registerCellView(view);\n\t    this._unregisterCellViewPlaceholder(placeholder);\n\t    return view;\n\t  },\n\t  _registerCellViewPlaceholder: function (cell, cid = uniqueId('view')) {\n\t    const ViewClass = this._resolveCellViewClass(cell);\n\t    const placeholder = {\n\t      // A tag to identify the placeholder from a CellView.\n\t      [CELL_VIEW_PLACEHOLDER_MARKER]: true,\n\t      cid,\n\t      model: cell,\n\t      DETACHABLE: true,\n\t      viewClass: ViewClass,\n\t      UPDATE_PRIORITY: ViewClass.prototype.UPDATE_PRIORITY\n\t    };\n\t    this._viewPlaceholders[cid] = placeholder;\n\t    return placeholder;\n\t  },\n\t  _registerCellView: function (cellView) {\n\t    cellView.paper = this;\n\t    this._views[cellView.model.id] = cellView;\n\t  },\n\t  _unregisterCellViewPlaceholder: function (placeholder) {\n\t    delete this._viewPlaceholders[placeholder.cid];\n\t  },\n\t  _initializeCellView: function (ViewClass, cell, cid) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      interactive,\n\t      labelsLayer\n\t    } = options;\n\t    return new ViewClass({\n\t      cid,\n\t      model: cell,\n\t      interactive,\n\t      labelsLayer: labelsLayer === true ? paperLayers.LABELS : labelsLayer\n\t    });\n\t  },\n\t  _resolveCellViewClass: function (cell) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      cellViewNamespace\n\t    } = options;\n\t    const type = cell.get('type') + 'View';\n\t    const namespaceViewClass = getByPath(cellViewNamespace, type, '.');\n\t    // A class taken from the paper options.\n\t    let optionalViewClass;\n\t    let defaultViewClass;\n\t    if (cell.isLink()) {\n\t      optionalViewClass = options.linkView;\n\t      defaultViewClass = LinkView;\n\t    } else {\n\t      optionalViewClass = options.elementView;\n\t      defaultViewClass = ElementView;\n\t    }\n\t    // a) the paper options view is a class (deprecated)\n\t    //  1. search the namespace for a view\n\t    //  2. if no view was found, use view from the paper options\n\t    // b) the paper options view is a function\n\t    //  1. call the function from the paper options\n\t    //  2. if no view was return, search the namespace for a view\n\t    //  3. if no view was found, use the default\n\t    return optionalViewClass.prototype instanceof ViewBase ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\t  },\n\t  // Returns a CellView instance or its placeholder for the given cell.\n\t  _getCellViewLike: function (cell) {\n\t    let id;\n\t    if (isString(cell) || isNumber(cell)) {\n\t      // If the cell is a string or number, it is an id of the view.\n\t      id = cell;\n\t    } else if (cell) {\n\t      // If the cell is an object, it should have an id property.\n\t      id = cell.id;\n\t    } else {\n\t      // If the cell is falsy, return null.\n\t      return null;\n\t    }\n\t    const view = this._views[id];\n\t    if (view) return view;\n\n\t    // If the view is not found, it may be a placeholder\n\t    const cid = this._idToCid[id];\n\t    if (cid) {\n\t      return this._viewPlaceholders[cid];\n\t    }\n\t    return null;\n\t  },\n\t  createViewForModel: function (cell, cid) {\n\t    return this._initializeCellView(this._resolveCellViewClass(cell), cell, cid);\n\t  },\n\t  removeView: function (cell) {\n\t    const {\n\t      id\n\t    } = cell;\n\t    const {\n\t      _views,\n\t      _updates\n\t    } = this;\n\t    const view = _views[id];\n\t    if (view) {\n\t      var {\n\t        cid\n\t      } = view;\n\t      const {\n\t        mountedList,\n\t        unmountedList\n\t      } = _updates;\n\t      view.remove();\n\t      delete _views[id];\n\t      delete this._idToCid[id];\n\t      mountedList.delete(cid);\n\t      unmountedList.delete(cid);\n\t    }\n\t    return view;\n\t  },\n\t  renderView: function (cell, opt) {\n\t    const {\n\t      id\n\t    } = cell;\n\t    const views = this._views;\n\t    let view, flag;\n\t    let create = true;\n\t    if (id in views) {\n\t      view = views[id];\n\t      if (view.model === cell) {\n\t        flag = this.FLAG_INSERT;\n\t        create = false;\n\t      } else {\n\t        // The view for this `id` already exist.\n\t        // The cell is a new instance of the model with identical id\n\t        // We simply remove the existing view and create a new one\n\t        this.removeView(cell);\n\t      }\n\t    }\n\t    if (create) {\n\t      const {\n\t        viewManagement\n\t      } = this.options;\n\t      const cid = uniqueId('view');\n\t      this._idToCid[cell.id] = cid;\n\t      if (viewManagement.lazyInitialize) {\n\t        // Register only a placeholder for the view\n\t        view = this._registerCellViewPlaceholder(cell, cid);\n\t        flag = this.registerUnmountedView(view);\n\t      } else {\n\t        // Create a new view instance\n\t        view = this.createViewForModel(cell, cid);\n\t        this._registerCellView(view);\n\t        flag = this.registerUnmountedView(view);\n\t        // The newly created view needs to be initialized\n\t        flag |= this.getCellViewInitFlag(view);\n\t      }\n\t      if (viewManagement.initializeUnmounted) {\n\t        // Save the initialization flags for later and exit early\n\t        this._mergeUnmountedViewScheduledUpdates(cid, flag);\n\t        return view;\n\t      }\n\t    }\n\t    this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n\t    return view;\n\t  },\n\t  // Update the view flags in the `unmountedList` using the bitwise OR operation\n\t  _mergeUnmountedViewScheduledUpdates: function (cid, flag) {\n\t    const {\n\t      unmountedList\n\t    } = this._updates;\n\t    const unmountedItem = unmountedList.get(cid);\n\t    if (unmountedItem) {\n\t      unmountedItem.value |= flag;\n\t    }\n\t  },\n\t  onImageDragStart: function () {\n\t    // This is the only way to prevent image dragging in Firefox that works.\n\t    // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n\t    return false;\n\t  },\n\t  resetViews: function (cells, opt) {\n\t    opt || (opt = {});\n\t    cells || (cells = []);\n\t    // Allows to unfreeze normally while in the idle state using autoFreeze option\n\t    const key = (this.legacyMode ? this.options.autoFreeze : this.isIdle()) ? null : 'reset';\n\t    this._resetUpdates();\n\t    // clearing views removes any event listeners\n\t    this.removeViews();\n\t    this.freeze({\n\t      key\n\t    });\n\t    for (var i = 0, n = cells.length; i < n; i++) {\n\t      this.renderView(cells[i], opt);\n\t    }\n\t    this.unfreeze({\n\t      key\n\t    });\n\t    this.sortLayerViews();\n\t  },\n\t  removeViews: function () {\n\t    // Remove all views and their references from the paper.\n\t    for (const id in this._views) {\n\t      const view = this._views[id];\n\t      if (view) {\n\t        view.remove();\n\t      }\n\t    }\n\t    this._views = {};\n\t    this._viewPlaceholders = {};\n\t    this._idToCid = {};\n\t  },\n\t  sortLayerViews: function () {\n\t    if (!this.isExactSorting()) {\n\t      // noop\n\t      return;\n\t    }\n\t    if (this.isFrozen() || this.isIdle()) {\n\t      // sort views once unfrozen\n\t      this._updates.sort = true;\n\t      return;\n\t    }\n\t    this.sortLayerViewsExact();\n\t  },\n\t  sortLayerViewsExact: function () {\n\t    this.getGraphLayerViews().forEach(view => view.sortExact());\n\t  },\n\t  insertView: function (view, isInitialInsert) {\n\t    // layer can be null if it is added to the graph with 'dry' option\n\t    const layerId = this.model.getCellLayerId(view.model);\n\t    const layerView = this.getLayerView(layerId);\n\t    layerView.insertCellView(view);\n\t    view.onMount(isInitialInsert);\n\t  },\n\t  _hideView: function (viewLike) {\n\t    if (!viewLike || viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t      // A placeholder view was never mounted\n\t      return;\n\t    }\n\t    if (viewLike[CELL_VIEW_MARKER]) {\n\t      this._hideCellView(viewLike);\n\t    } else {\n\t      // A generic view that is not a cell view.\n\t      viewLike.unmount();\n\t    }\n\t  },\n\t  // If `cellVisibility` returns `false`, the view will be hidden using this method.\n\t  _hideCellView: function (cellView) {\n\t    if (this.options.viewManagement.disposeHidden) {\n\t      if (this._disposeCellView(cellView)) return;\n\t    }\n\t    // Detach the view from the paper, but keep it in memory\n\t    this._detachCellView(cellView);\n\t  },\n\t  _disposeCellView: function (cellView) {\n\t    if (HighlighterView.has(cellView) || cellView.hasTools()) {\n\t      // We currently do not dispose views which has a highlighter or tools attached\n\t      // Note: Possible improvement would be to serialize highlighters/tools and\n\t      // restore them on view re-mount.\n\t      return false;\n\t    }\n\t    const cell = cellView.model;\n\t    // Remove the view from the paper and dispose it\n\t    cellView.remove();\n\t    delete this._views[cell.id];\n\t    this._registerCellViewPlaceholder(cell, cellView.cid);\n\t    return true;\n\t  },\n\t  // Dispose (release resources) all hidden views.\n\t  disposeHiddenCellViews: function () {\n\t    // Only cell views can be in the unmounted list (not in the legacy mode).\n\t    if (this.legacyMode) return;\n\t    const unmountedCids = this._updates.unmountedList.keys();\n\t    for (const cid of unmountedCids) {\n\t      const cellView = views[cid];\n\t      cellView && this._disposeCellView(cellView);\n\t    }\n\t  },\n\t  // Detach a view from the paper, but keep it in memory.\n\t  _detachCellView(cellView) {\n\t    cellView.unmount();\n\t    cellView.onDetach();\n\t  },\n\t  // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n\t  // be a selector or a jQuery object.\n\t  findView: function ($el) {\n\t    var el = isString($el) ? this.layers.querySelector($el) : $el instanceof $ ? $el[0] : $el;\n\t    var id = this.findAttribute('model-id', el);\n\t    if (id) return this._views[id];\n\t    return undefined;\n\t  },\n\t  // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n\t  findViewByModel: function (cellOrId) {\n\t    const cellViewLike = this._getCellViewLike(cellOrId);\n\t    if (!cellViewLike) return undefined;\n\t    if (cellViewLike[CELL_VIEW_MARKER]) {\n\t      // If the view is not a placeholder, return it directly\n\t      return cellViewLike;\n\t    }\n\t    // We do not expose placeholder views directly. We resolve them before returning.\n\t    const cellView = this._resolveCellViewPlaceholder(cellViewLike);\n\t    const flag = this.getCellViewInitFlag(cellView);\n\t    if (this.isViewMounted(cellView)) {\n\t      // The view was acting as a placeholder and is already present in the `mounted` list,\n\t      // indicating that its visibility has been checked, but the update hasn't occurred yet.\n\t      // Placeholders are resolved during the update routine. Since we're handling it\n\t      // manually here, we must ensure the view is properly initialized on the next update.\n\t      this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {\n\t        // It's important to run in isolation to avoid triggering the update of\n\t        // connected links\n\t        isolate: true\n\t      });\n\t    } else {\n\t      // Update the flags in the `unmounted` list\n\t      this._mergeUnmountedViewScheduledUpdates(cellView.cid, flag);\n\t    }\n\t    return cellView;\n\t  },\n\t  // Find all views at given point\n\t  findViewsFromPoint: function (p) {\n\t    p = new Point(p);\n\t    var views = this.model.getElements().map(this.findViewByModel, this);\n\t    return views.filter(function (view) {\n\t      return view && view.vel.getBBox({\n\t        target: this.layers\n\t      }).containsPoint(p);\n\t    }, this);\n\t  },\n\t  // Find all views in given area\n\t  findViewsInArea: function (rect, opt) {\n\t    opt = defaults(opt || {}, {\n\t      strict: false\n\t    });\n\t    rect = new Rect(rect);\n\t    var views = this.model.getElements().map(this.findViewByModel, this);\n\t    var method = opt.strict ? 'containsRect' : 'intersect';\n\t    return views.filter(function (view) {\n\t      return view && rect[method](view.vel.getBBox({\n\t        target: this.layers\n\t      }));\n\t    }, this);\n\t  },\n\t  findElementViewsInArea(plainArea, opt) {\n\t    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findElementsInArea(extArea, findOpt), opt);\n\t  },\n\t  findLinkViewsInArea: function (plainArea, opt) {\n\t    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findLinksInArea(extArea, findOpt), opt);\n\t  },\n\t  findCellViewsInArea: function (plainArea, opt) {\n\t    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findCellsInArea(extArea, findOpt), opt);\n\t  },\n\t  findElementViewsAtPoint: function (plainPoint, opt) {\n\t    return this._filterViewsAtPoint(plainPoint, extArea => this.model.findElementsInArea(extArea), opt);\n\t  },\n\t  findLinkViewsAtPoint: function (plainPoint, opt) {\n\t    return this._filterViewsAtPoint(plainPoint, extArea => this.model.findLinksInArea(extArea), opt);\n\t  },\n\t  findCellViewsAtPoint: function (plainPoint, opt) {\n\t    return this._filterViewsAtPoint(plainPoint,\n\t    // Note: we do not want to pass `opt` to `findCellsInArea`\n\t    // because the `strict` option works differently for querying at a point\n\t    extArea => this.model.findCellsInArea(extArea), opt);\n\t  },\n\t  findClosestMagnetToPoint: function (point, options = {}) {\n\t    let minDistance = Number.MAX_SAFE_INTEGER;\n\t    let bestPriority = -Infinity;\n\t    const pointer = new Point(point);\n\t    const radius = options.radius || Number.MAX_SAFE_INTEGER;\n\t    const viewsInArea = this.findCellViewsInArea({\n\t      x: pointer.x - radius,\n\t      y: pointer.y - radius,\n\t      width: 2 * radius,\n\t      height: 2 * radius\n\t    }, options.findInAreaOptions);\n\t    // Enable all connections by default\n\t    const filterFn = typeof options.filter === 'function' ? options.filter : null;\n\t    let closestView = null;\n\t    let closestMagnet = null;\n\n\t    // Note: If snapRadius is smaller than magnet size, views will not be found.\n\t    viewsInArea.forEach(view => {\n\t      const candidates = [];\n\t      const {\n\t        model\n\t      } = view;\n\t      // skip connecting to the element in case '.': { magnet: false } attribute present\n\t      if (view.el.getAttribute('magnet') !== 'false') {\n\t        if (model.isLink()) {\n\t          const connection = view.getConnection();\n\t          candidates.push({\n\t            // find distance from the closest point of a link to pointer coordinates\n\t            priority: 0,\n\t            distance: connection.closestPoint(pointer).squaredDistance(pointer),\n\t            magnet: view.el\n\t          });\n\t        } else {\n\t          candidates.push({\n\t            // Set the priority to the level of nested elements of the model\n\t            // To ensure that the embedded cells get priority over the parent cells\n\t            priority: model.getAncestors().length,\n\t            // find distance from the center of the model to pointer coordinates\n\t            distance: model.getBBox().center().squaredDistance(pointer),\n\t            magnet: view.el\n\t          });\n\t        }\n\t      }\n\t      view.$('[magnet]').toArray().forEach(magnet => {\n\t        const magnetBBox = view.getNodeBBox(magnet);\n\t        let magnetDistance = magnetBBox.pointNearestToPoint(pointer).squaredDistance(pointer);\n\t        if (magnetBBox.containsPoint(pointer)) {\n\t          // Pointer sits inside this magnet.\n\t          // Push its distance far into the negative range so any\n\t          // \"under-pointer\" magnet outranks magnets that are only nearby\n\t          // (positive distance) and every non-magnet candidate.\n\t          // We add the original distance back to keep ordering among\n\t          // overlapping magnets: the one whose border is closest to the\n\t          // pointer (smaller original distance) still wins.\n\t          magnetDistance = -Number.MAX_SAFE_INTEGER + magnetDistance;\n\t        }\n\n\t        // Check if magnet is inside the snap radius.\n\t        if (magnetDistance <= radius * radius) {\n\t          candidates.push({\n\t            // Give magnets priority over other candidates.\n\t            priority: Number.MAX_SAFE_INTEGER,\n\t            distance: magnetDistance,\n\t            magnet\n\t          });\n\t        }\n\t      });\n\t      candidates.forEach(candidate => {\n\t        const {\n\t          magnet,\n\t          distance,\n\t          priority\n\t        } = candidate;\n\t        const isBetterCandidate = priority > bestPriority || priority === bestPriority && distance < minDistance;\n\t        if (isBetterCandidate && (!filterFn || filterFn(view, magnet))) {\n\t          bestPriority = priority;\n\t          minDistance = distance;\n\t          closestView = view;\n\t          closestMagnet = magnet;\n\t        }\n\t      });\n\t    });\n\t    return closestView ? {\n\t      view: closestView,\n\t      magnet: closestMagnet\n\t    } : null;\n\t  },\n\t  _findInExtendedArea: function (area, findCellsFn, opt = {}) {\n\t    const {\n\t      buffer = this.DEFAULT_FIND_BUFFER\n\t    } = opt;\n\t    const extendedArea = new Rect(area).inflate(buffer);\n\t    const cellsInExtendedArea = findCellsFn(extendedArea, opt);\n\t    return cellsInExtendedArea.map(element => this.findViewByModel(element));\n\t  },\n\t  _filterViewsInArea: function (plainArea, findCells, opt = {}) {\n\t    const area = new Rect(plainArea);\n\t    const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n\t    const viewsInArea = viewsInExtendedArea.filter(view => {\n\t      if (!view) return false;\n\t      return view.isInArea(area, opt);\n\t    });\n\t    return viewsInArea;\n\t  },\n\t  _filterViewsAtPoint: function (plainPoint, findCells, opt = {}) {\n\t    const area = new Rect(plainPoint); // zero-size area\n\t    const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n\t    const viewsAtPoint = viewsInExtendedArea.filter(view => {\n\t      if (!view) return false;\n\t      return view.isAtPoint(plainPoint, opt);\n\t    });\n\t    return viewsAtPoint;\n\t  },\n\t  removeTools: function () {\n\t    this.dispatchToolsEvent('remove');\n\t    return this;\n\t  },\n\t  hideTools: function () {\n\t    this.dispatchToolsEvent('hide');\n\t    return this;\n\t  },\n\t  showTools: function () {\n\t    this.dispatchToolsEvent('show');\n\t    return this;\n\t  },\n\t  dispatchToolsEvent: function (event, ...args) {\n\t    if (typeof event !== 'string') return;\n\t    this.trigger('tools:event', event, ...args);\n\t  },\n\t  getModelById: function (id) {\n\t    return this.model.getCell(id);\n\t  },\n\t  snapToGrid: function (x, y) {\n\t    // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n\t    // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n\t    return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n\t  },\n\t  localToPaperPoint: function (x, y) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var localPoint = new Point(x, y);\n\t    var paperPoint = V.transformPoint(localPoint, this.matrix());\n\t    return paperPoint;\n\t  },\n\t  localToPaperRect: function (x, y, width, height) {\n\t    // allow `x` to be a rectangle and rest arguments undefined\n\t    var localRect = new Rect(x, y, width, height);\n\t    var paperRect = V.transformRect(localRect, this.matrix());\n\t    return paperRect;\n\t  },\n\t  paperToLocalPoint: function (x, y) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var paperPoint = new Point(x, y);\n\t    var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n\t    return localPoint;\n\t  },\n\t  paperToLocalRect: function (x, y, width, height) {\n\t    // allow `x` to be a rectangle and rest arguments undefined\n\t    var paperRect = new Rect(x, y, width, height);\n\t    var localRect = V.transformRect(paperRect, this.matrix().inverse());\n\t    return localRect;\n\t  },\n\t  localToClientPoint: function (x, y) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var localPoint = new Point(x, y);\n\t    var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n\t    return clientPoint;\n\t  },\n\t  localToClientRect: function (x, y, width, height) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var localRect = new Rect(x, y, width, height);\n\t    var clientRect = V.transformRect(localRect, this.clientMatrix());\n\t    return clientRect;\n\t  },\n\t  // Transform client coordinates to the paper local coordinates.\n\t  // Useful when you have a mouse event object and you'd like to get coordinates\n\t  // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n\t  // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n\t  clientToLocalPoint: function (x, y) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var clientPoint = new Point(x, y);\n\t    var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n\t    return localPoint;\n\t  },\n\t  clientToLocalRect: function (x, y, width, height) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var clientRect = new Rect(x, y, width, height);\n\t    var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n\t    return localRect;\n\t  },\n\t  localToPagePoint: function (x, y) {\n\t    return this.localToPaperPoint(x, y).offset(this.pageOffset());\n\t  },\n\t  localToPageRect: function (x, y, width, height) {\n\t    return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n\t  },\n\t  pageToLocalPoint: function (x, y) {\n\t    var pagePoint = new Point(x, y);\n\t    var paperPoint = pagePoint.difference(this.pageOffset());\n\t    return this.paperToLocalPoint(paperPoint);\n\t  },\n\t  pageToLocalRect: function (x, y, width, height) {\n\t    var pageOffset = this.pageOffset();\n\t    var paperRect = new Rect(x, y, width, height);\n\t    paperRect.x -= pageOffset.x;\n\t    paperRect.y -= pageOffset.y;\n\t    return this.paperToLocalRect(paperRect);\n\t  },\n\t  clientOffset: function () {\n\t    var clientRect = this.svg.getBoundingClientRect();\n\t    return new Point(clientRect.left, clientRect.top);\n\t  },\n\t  pageOffset: function () {\n\t    return this.clientOffset().offset(window.scrollX, window.scrollY);\n\t  },\n\t  linkAllowed: function (linkView) {\n\t    if (!(linkView instanceof LinkView)) {\n\t      throw new Error('Must provide a linkView.');\n\t    }\n\t    var link = linkView.model;\n\t    var paperOptions = this.options;\n\t    var graph = this.model;\n\t    var ns = graph.constructor.validations;\n\t    if (!paperOptions.multiLinks) {\n\t      if (!ns.multiLinks.call(this, graph, link)) return false;\n\t    }\n\t    if (!paperOptions.linkPinning) {\n\t      // Link pinning is not allowed and the link is not connected to the target.\n\t      if (!ns.linkPinning.call(this, graph, link)) return false;\n\t    }\n\t    if (typeof paperOptions.allowLink === 'function') {\n\t      if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n\t    }\n\t    return true;\n\t  },\n\t  getDefaultLink: function (cellView, magnet) {\n\t    return isFunction(this.options.defaultLink)\n\t    // default link is a function producing link model\n\t    ? this.options.defaultLink.call(this, cellView, magnet)\n\t    // default link is the mvc model\n\t    : this.options.defaultLink.clone();\n\t  },\n\t  // Cell highlighting.\n\t  // ------------------\n\n\t  resolveHighlighter: function (opt = {}) {\n\t    let {\n\t      highlighter: highlighterDef\n\t    } = opt;\n\t    const {\n\t      type\n\t    } = opt;\n\t    const {\n\t      highlighting,\n\t      highlighterNamespace\n\t    } = this.options;\n\n\t    /*\n\t        Expecting opt.highlighter to have the following structure:\n\t        {\n\t            name: 'highlighter-name',\n\t            options: {\n\t                some: 'value'\n\t            }\n\t        }\n\t    */\n\t    if (highlighterDef === undefined) {\n\t      // Is highlighting disabled?\n\t      if (!highlighting) return false;\n\t      // check for built-in types\n\t      if (type) {\n\t        highlighterDef = highlighting[type];\n\t        // Is a specific type highlight disabled?\n\t        if (highlighterDef === false) return false;\n\t      }\n\t      if (!highlighterDef) {\n\t        // Type not defined use default highlight\n\t        highlighterDef = highlighting['default'];\n\t      }\n\t    }\n\n\t    // Do nothing if opt.highlighter is falsy.\n\t    // This allows the case to not highlight cell(s) in certain cases.\n\t    // For example, if you want to NOT highlight when embedding elements\n\t    // or use a custom highlighter.\n\t    if (!highlighterDef) return false;\n\n\t    // Allow specifying a highlighter by name.\n\t    if (isString(highlighterDef)) {\n\t      highlighterDef = {\n\t        name: highlighterDef\n\t      };\n\t    }\n\t    const name = highlighterDef.name;\n\t    const highlighter = highlighterNamespace[name];\n\n\t    // Highlighter validation\n\t    if (!highlighter) {\n\t      throw new Error('Unknown highlighter (\"' + name + '\")');\n\t    }\n\t    if (typeof highlighter.highlight !== 'function') {\n\t      throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n\t    }\n\t    if (typeof highlighter.unhighlight !== 'function') {\n\t      throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n\t    }\n\t    return {\n\t      highlighter,\n\t      options: highlighterDef.options || {},\n\t      name\n\t    };\n\t  },\n\t  onCellHighlight: function (cellView, magnetEl, opt) {\n\t    const highlighterDescriptor = this.resolveHighlighter(opt);\n\t    if (!highlighterDescriptor) return;\n\t    const {\n\t      highlighter,\n\t      options\n\t    } = highlighterDescriptor;\n\t    highlighter.highlight(cellView, magnetEl, options);\n\t  },\n\t  onCellUnhighlight: function (cellView, magnetEl, opt) {\n\t    const highlighterDescriptor = this.resolveHighlighter(opt);\n\t    if (!highlighterDescriptor) return;\n\t    const {\n\t      highlighter,\n\t      options\n\t    } = highlighterDescriptor;\n\t    highlighter.unhighlight(cellView, magnetEl, options);\n\t  },\n\t  // Interaction.\n\t  // ------------\n\n\t  pointerdblclick: function (evt) {\n\t    evt.preventDefault();\n\n\t    // magnetpointerdblclick can stop propagation\n\n\t    evt = normalizeEvent(evt);\n\t    var view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t    if (view) {\n\t      view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\t    } else {\n\t      this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n\t    }\n\t  },\n\t  pointerclick: function (evt) {\n\t    // magnetpointerclick can stop propagation\n\n\t    var data = this.eventData(evt);\n\t    // Trigger event only if mouse has not moved.\n\t    if (data.mousemoved <= this.options.clickThreshold) {\n\t      evt = normalizeEvent(evt);\n\t      var view = this.findView(evt.target);\n\t      if (this.guard(evt, view)) return;\n\t      var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t      if (view) {\n\t        view.pointerclick(evt, localPoint.x, localPoint.y);\n\t      } else {\n\t        this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n\t      }\n\t    }\n\t  },\n\t  contextmenu: function (evt) {\n\t    if (this.options.preventContextMenu) evt.preventDefault();\n\t    if (this.contextMenuFired) {\n\t      this.contextMenuFired = false;\n\t      return;\n\t    }\n\t    evt = normalizeEvent(evt);\n\t    this.contextMenuTrigger(evt);\n\t  },\n\t  contextMenuTrigger: function (evt) {\n\t    var view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t    if (view) {\n\t      view.contextmenu(evt, localPoint.x, localPoint.y);\n\t    } else {\n\t      this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n\t    }\n\t  },\n\t  pointerdown: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    const {\n\t      target,\n\t      button\n\t    } = evt;\n\t    const view = this.findView(target);\n\t    const isContextMenu = button === 2;\n\t    if (view) {\n\t      if (!isContextMenu && this.guard(evt, view)) return;\n\t      const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n\t      if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n\t        // If the target is a form element, we do not want to prevent the default action.\n\t        // For example, we want to be able to select text in a text input or\n\t        // to be able to click on a checkbox.\n\t        evt.preventDefault();\n\t      }\n\t      if (isTargetFormNode) {\n\t        // If the target is a form element, we do not want to start dragging the element.\n\t        // For example, we want to be able to select text by dragging the mouse.\n\t        view.preventDefaultInteraction(evt);\n\t      }\n\n\t      // Custom event\n\t      const eventEvt = this.customEventTrigger(evt, view);\n\t      if (eventEvt) {\n\t        // `onevent` could have stopped propagation\n\t        if (eventEvt.isPropagationStopped()) return;\n\t        evt.data = eventEvt.data;\n\t      }\n\n\t      // Element magnet\n\t      const magnetNode = target.closest('[magnet]');\n\t      if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n\t        const magnetEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n\t          data: evt.data,\n\t          // Originally the event listener was attached to the magnet element.\n\t          currentTarget: magnetNode\n\t        }));\n\t        this.onmagnet(magnetEvt);\n\t        if (magnetEvt.isDefaultPrevented()) {\n\t          evt.preventDefault();\n\t        }\n\t        // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n\t        if (magnetEvt.isPropagationStopped()) {\n\t          // `magnet:pointermove` and `magnet:pointerup` events must be fired\n\t          if (isContextMenu) return;\n\t          this.delegateDragEvents(view, magnetEvt.data);\n\t          return;\n\t        }\n\t        evt.data = magnetEvt.data;\n\t      }\n\t    }\n\t    if (isContextMenu) {\n\t      this.contextMenuFired = true;\n\t      const contextmenuEvt = new $.Event(evt.originalEvent, {\n\t        type: 'contextmenu',\n\t        data: evt.data\n\t      });\n\t      this.contextMenuTrigger(contextmenuEvt);\n\t    } else {\n\t      const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t      if (view) {\n\t        view.pointerdown(evt, localPoint.x, localPoint.y);\n\t      } else {\n\t        if (this.options.preventDefaultBlankAction) {\n\t          evt.preventDefault();\n\t        }\n\t        this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n\t      }\n\t      this.delegateDragEvents(view, evt.data);\n\t    }\n\t  },\n\t  pointermove: function (evt) {\n\t    // mouse moved counter\n\t    var data = this.eventData(evt);\n\t    if (!data.mousemoved) {\n\t      data.mousemoved = 0;\n\t      // Make sure that events like `mouseenter` and `mouseleave` are\n\t      // not triggered while the user is dragging a cellView.\n\t      this.undelegateEvents();\n\t      // Note: the events are undelegated after the first `pointermove` event.\n\t      // Not on `pointerdown` to make sure that `dbltap` is recognized.\n\t    }\n\t    var mousemoved = ++data.mousemoved;\n\t    if (mousemoved <= this.options.moveThreshold) return;\n\t    evt = normalizeEvent(evt);\n\t    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t    let view = data.sourceView;\n\t    if (view) {\n\t      // The view could have been disposed during dragging\n\t      // e.g. dragged outside of the viewport and hidden\n\t      // The model can be removed in previous mousemove event handlers\n\t      view = this.findViewByModel(view.model) || view;\n\t      view.pointermove(evt, localPoint.x, localPoint.y);\n\t    } else {\n\t      this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n\t    }\n\t    this.eventData(evt, data);\n\t  },\n\t  pointerup: function (evt) {\n\t    this.undelegateDocumentEvents();\n\t    var normalizedEvt = normalizeEvent(evt);\n\t    var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\t    let view = this.eventData(evt).sourceView;\n\t    if (view) {\n\t      // The view could have been disposed during dragging\n\t      // e.g. dragged outside of the viewport and hidden\n\t      // The model can be removed in previous mouseup event handlers (e.g. when deleting an element after dragging)\n\t      view = this.findViewByModel(view.model) || view;\n\t      view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n\t    } else {\n\t      this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n\t    }\n\t    if (!normalizedEvt.isPropagationStopped()) {\n\t      this.pointerclick(new $.Event(evt.originalEvent, {\n\t        type: 'click',\n\t        data: evt.data\n\t      }));\n\t    }\n\t    this.delegateEvents();\n\t  },\n\t  mouseover: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    var view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    if (view) {\n\t      view.mouseover(evt);\n\t    } else {\n\t      if (this.el === evt.target) return; // prevent border of paper from triggering this\n\t      this.trigger('blank:mouseover', evt);\n\t    }\n\t  },\n\t  mouseout: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    var view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    if (view) {\n\t      view.mouseout(evt);\n\t    } else {\n\t      if (this.el === evt.target) return; // prevent border of paper from triggering this\n\t      this.trigger('blank:mouseout', evt);\n\t    }\n\t  },\n\t  mouseenter: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    const {\n\t      target,\n\t      // The EventTarget the pointing device entered to\n\t      relatedTarget,\n\t      // The EventTarget the pointing device exited from\n\t      currentTarget // The EventTarget on which the event listener was registered\n\t    } = evt;\n\t    const view = this.findView(target);\n\t    if (this.guard(evt, view)) return;\n\t    const relatedView = this.findView(relatedTarget);\n\t    if (view) {\n\t      if (relatedView === view) {\n\t        // Mouse left a cell tool\n\t        return;\n\t      }\n\t      view.mouseenter(evt);\n\t      if (this.el.contains(relatedTarget)) {\n\t        // The pointer remains inside the paper.\n\t        return;\n\t      }\n\t    }\n\t    if (relatedView) {\n\t      return;\n\t    }\n\t    // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n\t    // (mouseenter method would be fired twice)\n\t    if (currentTarget === this.el) {\n\t      // `paper` (more descriptive), not `blank`\n\t      this.trigger('paper:mouseenter', evt);\n\t    }\n\t  },\n\t  mouseleave: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    const {\n\t      target,\n\t      // The EventTarget the pointing device exited from\n\t      relatedTarget,\n\t      // The EventTarget the pointing device entered to\n\t      currentTarget // The EventTarget on which the event listener was registered\n\t    } = evt;\n\t    const view = this.findView(target);\n\t    if (this.guard(evt, view)) return;\n\t    const relatedView = this.findView(relatedTarget);\n\t    if (view) {\n\t      if (relatedView === view) {\n\t        // Mouse entered a cell tool\n\t        return;\n\t      }\n\t      view.mouseleave(evt);\n\t      if (this.el.contains(relatedTarget)) {\n\t        // The pointer has exited a cellView. The pointer is still inside of the paper.\n\t        return;\n\t      }\n\t    }\n\t    if (relatedView) {\n\t      // The pointer has entered a new cellView\n\t      return;\n\t    }\n\t    // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n\t    // (mouseleave method would be fired twice)\n\t    if (currentTarget === this.el) {\n\t      // There is no cellView under the pointer, nor the blank area of the paper\n\t      this.trigger('paper:mouseleave', evt);\n\t    }\n\t  },\n\t  _processMouseWheelEvtBuf: debounce(function () {\n\t    const {\n\t      event,\n\t      deltas\n\t    } = this._mw_evt_buffer;\n\t    const deltaY = deltas.reduce((acc, deltaY) => acc + cap(deltaY, WHEEL_CAP), 0);\n\t    const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n\t    const {\n\t      x,\n\t      y\n\t    } = this.clientToLocalPoint(event.clientX, event.clientY);\n\t    this.trigger('paper:pinch', event, x, y, scale);\n\t    this._mw_evt_buffer = {\n\t      event: null,\n\t      deltas: []\n\t    };\n\t  }, WHEEL_WAIT_MS, {\n\t    maxWait: WHEEL_WAIT_MS\n\t  }),\n\t  mousewheel: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    const view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    const originalEvent = evt.originalEvent;\n\t    const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n\t    const {\n\t      deltaX,\n\t      deltaY\n\t    } = normalizeWheel(originalEvent);\n\t    const pinchHandlers = this._events['paper:pinch'];\n\n\t    // Touchpad devices will send a fake CTRL press when a pinch is performed\n\t    //\n\t    // We also check if there are any subscribers to paper:pinch event. If there are none,\n\t    // just skip the entire block of code (we don't want to blindly call\n\t    // .preventDefault() if we really don't have to).\n\t    if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n\t      // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n\t      originalEvent.preventDefault();\n\t      this._mw_evt_buffer.event = evt;\n\t      this._mw_evt_buffer.deltas.push(deltaY);\n\t      this._processMouseWheelEvtBuf();\n\t    } else {\n\t      const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n\t      if (view) {\n\t        view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\t      } else {\n\t        this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n\t      }\n\t      this.trigger('paper:pan', evt, deltaX, deltaY);\n\t    }\n\t  },\n\t  onevent: function (evt) {\n\t    var eventNode = evt.currentTarget;\n\t    var eventName = eventNode.getAttribute('event');\n\t    if (eventName) {\n\t      var view = this.findView(eventNode);\n\t      if (view) {\n\t        evt = normalizeEvent(evt);\n\t        if (this.guard(evt, view)) return;\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t        view.onevent(evt, eventName, localPoint.x, localPoint.y);\n\t      }\n\t    }\n\t  },\n\t  magnetEvent: function (evt, handler) {\n\t    var magnetNode = evt.currentTarget;\n\t    var magnetValue = magnetNode.getAttribute('magnet');\n\t    if (magnetValue) {\n\t      var view = this.findView(magnetNode);\n\t      if (view) {\n\t        evt = normalizeEvent(evt);\n\t        if (this.guard(evt, view)) return;\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t        handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n\t      }\n\t    }\n\t  },\n\t  onmagnet: function (evt) {\n\t    if (evt.button === 2) {\n\t      this.contextMenuFired = true;\n\t      this.magnetContextMenuFired = true;\n\t      const contextmenuEvt = new $.Event(evt.originalEvent, {\n\t        type: 'contextmenu',\n\t        data: evt.data,\n\t        currentTarget: evt.currentTarget\n\t      });\n\t      this.magnetContextMenuTrigger(contextmenuEvt);\n\t      if (contextmenuEvt.isPropagationStopped()) {\n\t        evt.stopPropagation();\n\t      }\n\t    } else {\n\t      this.magnetEvent(evt, function (view, evt, _, x, y) {\n\t        view.onmagnet(evt, x, y);\n\t      });\n\t    }\n\t  },\n\t  magnetpointerdblclick: function (evt) {\n\t    this.magnetEvent(evt, function (view, evt, magnet, x, y) {\n\t      view.magnetpointerdblclick(evt, magnet, x, y);\n\t    });\n\t  },\n\t  magnetcontextmenu: function (evt) {\n\t    if (this.options.preventContextMenu) evt.preventDefault();\n\t    if (this.magnetContextMenuFired) {\n\t      this.magnetContextMenuFired = false;\n\t      return;\n\t    }\n\t    this.magnetContextMenuTrigger(evt);\n\t  },\n\t  magnetContextMenuTrigger: function (evt) {\n\t    this.magnetEvent(evt, function (view, evt, magnet, x, y) {\n\t      view.magnetcontextmenu(evt, magnet, x, y);\n\t    });\n\t  },\n\t  onlabel: function (evt) {\n\t    var labelNode = evt.currentTarget;\n\t    var view = this.findView(labelNode);\n\t    if (!view) return;\n\t    evt = normalizeEvent(evt);\n\t    if (this.guard(evt, view)) return;\n\n\t    // Custom event\n\t    const eventEvt = this.customEventTrigger(evt, view, labelNode);\n\t    if (eventEvt) {\n\t      // `onevent` could have stopped propagation\n\t      if (eventEvt.isPropagationStopped()) return;\n\t      evt.data = eventEvt.data;\n\t    }\n\t    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t    view.onlabel(evt, localPoint.x, localPoint.y);\n\t  },\n\t  getPointerArgs(evt) {\n\t    const normalizedEvt = normalizeEvent(evt);\n\t    const {\n\t      x,\n\t      y\n\t    } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\t    return [normalizedEvt, x, y];\n\t  },\n\t  delegateDragEvents: function (view, data) {\n\t    data || (data = {});\n\t    this.eventData({\n\t      data: data\n\t    }, {\n\t      sourceView: view || null,\n\t      mousemoved: 0\n\t    });\n\t    this.delegateDocumentEvents(null, data);\n\t  },\n\t  // Guard the specified event. If the event should be ignored, guard returns `true`.\n\t  // Otherwise, it returns `false`.\n\t  guard: function (evt, view) {\n\t    if (evt.type === 'mousedown' && evt.button === 2) {\n\t      // handled as `contextmenu` type\n\t      return true;\n\t    }\n\t    if (this.options.guard && this.options.guard(evt, view)) {\n\t      return true;\n\t    }\n\t    if (evt.data && evt.data.guarded !== undefined) {\n\t      return evt.data.guarded;\n\t    }\n\t    const {\n\t      target\n\t    } = evt;\n\t    if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n\t      return true;\n\t    }\n\t    if (view && view.model && view.model[CELL_MARKER]) {\n\t      return false;\n\t    }\n\t    if (this.el === target || this.svg.contains(target)) {\n\t      return false;\n\t    }\n\t    return true; // Event guarded. Paper should not react on it in any way.\n\t  },\n\t  setGridSize: function (gridSize) {\n\t    const {\n\t      options\n\t    } = this;\n\t    options.gridSize = gridSize;\n\t    if (options.drawGrid && !options.drawGridSize) {\n\t      // Do not redraw the grid if the `drawGridSize` is set.\n\t      this.getLayerView(paperLayers.GRID).renderGrid();\n\t    }\n\t    return this;\n\t  },\n\t  setGrid: function (drawGrid) {\n\t    this.getLayerView(paperLayers.GRID).setGrid(drawGrid);\n\t    return this;\n\t  },\n\t  updateBackgroundImage: function (opt) {\n\t    opt = opt || {};\n\t    var backgroundPosition = opt.position || 'center';\n\t    var backgroundSize = opt.size || 'auto auto';\n\t    var currentScale = this.scale();\n\t    var currentTranslate = this.translate();\n\n\t    // backgroundPosition\n\t    if (isObject(backgroundPosition)) {\n\t      var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);\n\t      var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);\n\t      backgroundPosition = x + 'px ' + y + 'px';\n\t    }\n\n\t    // backgroundSize\n\t    if (isObject(backgroundSize)) {\n\t      backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n\t      backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n\t    }\n\t    const {\n\t      background\n\t    } = this.childNodes;\n\t    background.style.backgroundSize = backgroundSize;\n\t    background.style.backgroundPosition = backgroundPosition;\n\t  },\n\t  drawBackgroundImage: function (img, opt) {\n\t    // Clear the background image if no image provided\n\t    if (!(img instanceof HTMLImageElement)) {\n\t      this.childNodes.background.style.backgroundImage = '';\n\t      return;\n\t    }\n\t    if (!this._background || this._background.id !== opt.id) {\n\t      // Draw only the last image requested (see drawBackground())\n\t      return;\n\t    }\n\t    opt = opt || {};\n\t    var backgroundImage;\n\t    var backgroundSize = opt.size;\n\t    var backgroundRepeat = opt.repeat || 'no-repeat';\n\t    var backgroundOpacity = opt.opacity || 1;\n\t    var backgroundQuality = Math.abs(opt.quality) || 1;\n\t    var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n\t    if (isFunction(backgroundPattern)) {\n\t      // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n\t      img.width *= backgroundQuality;\n\t      img.height *= backgroundQuality;\n\t      var canvas = backgroundPattern(img, opt);\n\t      if (!(canvas instanceof HTMLCanvasElement)) {\n\t        throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n\t      }\n\t      backgroundImage = canvas.toDataURL('image/png');\n\t      backgroundRepeat = 'repeat';\n\t      if (isObject(backgroundSize)) {\n\t        // recalculate the tile size if an object passed in\n\t        backgroundSize.width *= canvas.width / img.width;\n\t        backgroundSize.height *= canvas.height / img.height;\n\t      } else if (backgroundSize === undefined) {\n\t        // calculate the tile size if no provided\n\t        opt.size = {\n\t          width: canvas.width / backgroundQuality,\n\t          height: canvas.height / backgroundQuality\n\t        };\n\t      }\n\t    } else {\n\t      // backgroundRepeat:\n\t      // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n\t      backgroundImage = img.src;\n\t      if (backgroundSize === undefined) {\n\t        // pass the image size for  the backgroundSize if no size provided\n\t        opt.size = {\n\t          width: img.width,\n\t          height: img.height\n\t        };\n\t      }\n\t    }\n\t    this.childNodes.background.style.opacity = backgroundOpacity;\n\t    this.childNodes.background.style.backgroundRepeat = backgroundRepeat;\n\t    this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;\n\t    this.updateBackgroundImage(opt);\n\t  },\n\t  updateBackgroundColor: function (color) {\n\t    this.$el.css('backgroundColor', color || '');\n\t  },\n\t  drawBackground: function (opt) {\n\t    opt = opt || {};\n\t    this.updateBackgroundColor(opt.color);\n\t    if (opt.image) {\n\t      opt = this._background = cloneDeep(opt);\n\t      guid(opt);\n\t      var img = document.createElement('img');\n\t      img.onload = this.drawBackgroundImage.bind(this, img, opt);\n\t      img.src = opt.image;\n\t    } else {\n\t      this.drawBackgroundImage(null);\n\t      this._background = null;\n\t    }\n\t    return this;\n\t  },\n\t  setInteractivity: function (value) {\n\t    this.options.interactive = value;\n\t    invoke(this._views, 'setInteractivity', value);\n\t  },\n\t  // Paper definitions.\n\t  // ------------------\n\n\t  isDefined: function (defId) {\n\t    return !!this.svg.getElementById(defId);\n\t  },\n\t  defineFilter: function (filter$1) {\n\t    if (!isObject(filter$1)) {\n\t      throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n\t    }\n\t    var filterId = filter$1.id;\n\t    var name = filter$1.name;\n\t    // Generate a hash code from the stringified filter definition. This gives us\n\t    // a unique filter ID for different definitions.\n\t    if (!filterId) {\n\t      filterId = name + this.svg.id + hashCode(JSON.stringify(filter$1));\n\t    }\n\t    // If the filter already exists in the document,\n\t    // we're done and we can just use it (reference it using `url()`).\n\t    // If not, create one.\n\t    if (!this.isDefined(filterId)) {\n\t      var namespace = filter;\n\t      var filterSVGString = namespace[name] && namespace[name](filter$1.args || {});\n\t      if (!filterSVGString) {\n\t        throw new Error('Non-existing filter ' + name);\n\t      }\n\n\t      // SVG <filter/> attributes\n\t      var filterAttrs = assign({\n\t        filterUnits: 'userSpaceOnUse'\n\t      }, filter$1.attrs, {\n\t        id: filterId\n\t      });\n\t      V(filterSVGString, filterAttrs).appendTo(this.defs);\n\t    }\n\t    return filterId;\n\t  },\n\t  defineGradient: function (gradient) {\n\t    if (!isObject(gradient)) {\n\t      throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n\t    }\n\t    const {\n\t      svg,\n\t      defs\n\t    } = this;\n\t    const {\n\t      type,\n\t      // Generate a hash code from the stringified filter definition. This gives us\n\t      // a unique filter ID for different definitions.\n\t      id = type + svg.id + hashCode(JSON.stringify(gradient)),\n\t      stops,\n\t      attrs = {}\n\t    } = gradient;\n\t    // If the gradient already exists in the document,\n\t    // we're done and we can just use it (reference it using `url()`).\n\t    if (this.isDefined(id)) return id;\n\t    // If not, create one.\n\t    const stopVEls = toArray$1(stops).map(({\n\t      offset,\n\t      color,\n\t      opacity\n\t    }) => {\n\t      return V('stop').attr({\n\t        'offset': offset,\n\t        'stop-color': color,\n\t        'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n\t      });\n\t    });\n\t    const gradientVEl = V(type, attrs, stopVEls);\n\t    gradientVEl.id = id;\n\t    gradientVEl.appendTo(defs);\n\t    return id;\n\t  },\n\t  definePattern: function (pattern) {\n\t    if (!isObject(pattern)) {\n\t      throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n\t    }\n\t    const {\n\t      svg,\n\t      defs\n\t    } = this;\n\t    const {\n\t      // Generate a hash code from the stringified filter definition. This gives us\n\t      // a unique filter ID for different definitions.\n\t      id = svg.id + hashCode(JSON.stringify(pattern)),\n\t      markup,\n\t      attrs = {}\n\t    } = pattern;\n\t    if (!markup) {\n\t      throw new TypeError('dia.Paper: definePattern() requires markup.');\n\t    }\n\t    // If the gradient already exists in the document,\n\t    // we're done and we can just use it (reference it using `url()`).\n\t    if (this.isDefined(id)) return id;\n\t    // If not, create one.\n\t    const patternVEl = V('pattern', {\n\t      patternUnits: 'userSpaceOnUse'\n\t    });\n\t    patternVEl.id = id;\n\t    patternVEl.attr(attrs);\n\t    if (typeof markup === 'string') {\n\t      patternVEl.append(V(markup));\n\t    } else {\n\t      const {\n\t        fragment\n\t      } = parseDOMJSON(markup);\n\t      patternVEl.append(fragment);\n\t    }\n\t    patternVEl.appendTo(defs);\n\t    return id;\n\t  },\n\t  defineMarker: function (marker) {\n\t    if (!isObject(marker)) {\n\t      throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n\t    }\n\t    const {\n\t      svg,\n\t      defs\n\t    } = this;\n\t    const {\n\t      // Generate a hash code from the stringified filter definition. This gives us\n\t      // a unique filter ID for different definitions.\n\t      id = svg.id + hashCode(JSON.stringify(marker)),\n\t      // user-provided markup\n\t      // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n\t      markup,\n\t      // user-provided attributes\n\t      // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n\t      // note: `transform` attrs are ignored by browsers\n\t      attrs = {},\n\t      // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n\t      markerUnits = 'userSpaceOnUse'\n\t    } = marker;\n\t    // If the marker already exists in the document,\n\t    // we're done and we can just use it (reference it using `url()`).\n\t    if (this.isDefined(id)) return id;\n\t    // If not, create one.\n\t    const markerVEl = V('marker', {\n\t      orient: 'auto',\n\t      overflow: 'visible',\n\t      markerUnits: markerUnits\n\t    });\n\t    markerVEl.id = id;\n\t    markerVEl.attr(attrs);\n\t    let markerContentVEl;\n\t    if (markup) {\n\t      let markupVEl;\n\t      if (typeof markup === 'string') {\n\t        // Marker object has a `markup` property of type string.\n\t        // - Construct V from the provided string.\n\t        markupVEl = V(markup);\n\t        // `markupVEl` is now either a single VEl, or an array of VEls.\n\t        // - Coerce it to an array.\n\t        markupVEl = Array.isArray(markupVEl) ? markupVEl : [markupVEl];\n\t      } else {\n\t        // Marker object has a `markup` property of type object.\n\t        // - Construct V from the object by parsing it as DOM JSON.\n\t        const {\n\t          fragment\n\t        } = parseDOMJSON(markup);\n\t        markupVEl = V(fragment).children();\n\t      }\n\t      // `markupVEl` is an array with one or more VEls inside.\n\t      // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n\t      if (markupVEl.length > 1) {\n\t        markerContentVEl = V('g').append(markupVEl);\n\t      } else {\n\t        markerContentVEl = markupVEl[0];\n\t      }\n\t    } else {\n\t      // Marker object is a flat structure.\n\t      // - Construct a new V of type `marker.type`.\n\t      const {\n\t        type = 'path'\n\t      } = marker;\n\t      markerContentVEl = V(type);\n\t    }\n\t    // `markerContentVEl` is a single VEl.\n\t    // Assign additional attributes to it (= context attributes + marker attributes):\n\t    // - Attribute values are taken from non-special properties of `marker`.\n\t    const markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n\t    const markerAttrsKeys = Object.keys(markerAttrs);\n\t    markerAttrsKeys.forEach(key => {\n\t      const value = markerAttrs[key];\n\t      const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n\t      if (markupValue == null) {\n\t        // Default logic:\n\t        markerContentVEl.attr(key, value);\n\t      } else {\n\t        // Properties with special logic should be added as cases to this switch block:\n\t        switch (key) {\n\t          case 'transform':\n\t            // - Prepend `transform` to existing value.\n\t            markerContentVEl.attr(key, value + ' ' + markupValue);\n\t            break;\n\t        }\n\t      }\n\t    });\n\t    markerContentVEl.appendTo(markerVEl);\n\t    markerVEl.appendTo(defs);\n\t    return id;\n\t  },\n\t  customEventTrigger: function (evt, view, rootNode = view.el) {\n\t    const eventNode = evt.target.closest('[event]');\n\t    if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {\n\t      const eventEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n\t        data: evt.data,\n\t        // Originally the event listener was attached to the event element.\n\t        currentTarget: eventNode\n\t      }));\n\t      this.onevent(eventEvt);\n\t      if (eventEvt.isDefaultPrevented()) {\n\t        evt.preventDefault();\n\t      }\n\t      return eventEvt;\n\t    }\n\t    return null;\n\t  }\n\t}, {\n\t  sorting: sortingTypes,\n\t  Layers: paperLayers,\n\t  backgroundPatterns,\n\t  gridPatterns\n\t});\n\n\tconst ToolView = View.extend({\n\t  name: null,\n\t  tagName: 'g',\n\t  className: 'tool',\n\t  svgElement: true,\n\t  _visible: true,\n\t  _visibleExplicit: true,\n\t  init: function () {\n\t    var name = this.name;\n\t    if (name) this.vel.attr('data-tool-name', name);\n\t  },\n\t  configure: function (view, toolsView) {\n\t    this.relatedView = view;\n\t    this.paper = view.paper;\n\t    this.parentView = toolsView;\n\t    this.simulateRelatedView(this.el);\n\t    // Delegate events in case the ToolView was removed from the DOM and reused.\n\t    this.delegateEvents();\n\t    return this;\n\t  },\n\t  simulateRelatedView: function (el) {\n\t    if (el) el.setAttribute('model-id', this.relatedView.model.id);\n\t  },\n\t  getName: function () {\n\t    return this.name;\n\t  },\n\t  // Evaluate the visibility of the tool and update the `display` CSS property\n\t  updateVisibility: function () {\n\t    const isVisible = this.computeVisibility();\n\t    this.el.style.display = isVisible ? '' : 'none';\n\t    this._visible = isVisible;\n\t  },\n\t  // Evaluate the visibility of the tool. The method returns `true` if the tool\n\t  // should be visible in the DOM.\n\t  computeVisibility() {\n\t    if (!this.isExplicitlyVisible()) return false;\n\t    const {\n\t      visibility\n\t    } = this.options;\n\t    if (typeof visibility !== 'function') return true;\n\t    return !!visibility.call(this, this.relatedView, this);\n\t  },\n\t  show: function () {\n\t    this._visibleExplicit = true;\n\t    this.updateVisibility();\n\t  },\n\t  hide: function () {\n\t    this._visibleExplicit = false;\n\t    this.updateVisibility();\n\t  },\n\t  // The method returns `false` if the `hide()` method was called on the tool.\n\t  isExplicitlyVisible: function () {\n\t    return !!this._visibleExplicit;\n\t  },\n\t  // The method returns `false` if the tool is not visible (it has `display: none`).\n\t  // This can happen if the `hide()` method was called or the tool is not visible\n\t  // because of the `visibility` option was evaluated to `false`.\n\t  isVisible: function () {\n\t    return !!this._visible;\n\t  },\n\t  isOverlay: function () {\n\t    return !!this.parentView && this.parentView.hasLayer();\n\t  },\n\t  focus: function () {\n\t    var opacity = this.options.focusOpacity;\n\t    if (isFinite(opacity)) this.el.style.opacity = opacity;\n\t    this.parentView.focusTool(this);\n\t  },\n\t  blur: function () {\n\t    this.el.style.opacity = '';\n\t    this.parentView.blurTool(this);\n\t  },\n\t  update: function () {\n\t    // to be overridden\n\t  },\n\t  guard: function (evt) {\n\t    // Let the context-menu event bubble up to the relatedView\n\t    const {\n\t      paper,\n\t      relatedView\n\t    } = this;\n\t    if (!paper || !relatedView) return true;\n\t    return paper.guard(evt, relatedView);\n\t  }\n\t});\n\n\tconst ToolsView = View.extend({\n\t  tagName: 'g',\n\t  className: 'tools',\n\t  svgElement: true,\n\t  tools: null,\n\t  isRendered: false,\n\t  options: {\n\t    tools: null,\n\t    relatedView: null,\n\t    name: null\n\t    // layer?: Paper.Layers.TOOLS\n\t    // z?: number\n\t  },\n\t  configure: function (options) {\n\t    options = assign(this.options, options);\n\t    var tools = options.tools;\n\t    if (!Array.isArray(tools)) return this;\n\t    var relatedView = options.relatedView;\n\t    if (!(relatedView instanceof CellView)) return this;\n\t    var views = this.tools = [];\n\t    for (var i = 0, n = tools.length; i < n; i++) {\n\t      var tool = tools[i];\n\t      if (!(tool instanceof ToolView)) continue;\n\t      tool.configure(relatedView, this);\n\t      this.vel.append(tool.el);\n\t      views.push(tool);\n\t    }\n\t    this.isRendered = false;\n\t    relatedView.requestUpdate(relatedView.getFlag('TOOLS'));\n\t    return this;\n\t  },\n\t  getName: function () {\n\t    return this.options.name;\n\t  },\n\t  update: function (opt) {\n\t    opt || (opt = {});\n\t    const tools = this.tools;\n\t    if (!tools) return this;\n\t    const n = tools.length;\n\t    const wasRendered = this.isRendered;\n\t    for (let i = 0; i < n; i++) {\n\t      const tool = tools[i];\n\t      tool.updateVisibility();\n\t      if (!tool.isVisible()) continue;\n\t      if (this.ensureToolRendered(tools, i) && opt.tool !== tool.cid) {\n\t        tool.update();\n\t      }\n\t    }\n\t    if (!this.isRendered && n > 0) {\n\t      // None of the tools is visible\n\t      // Note: ToolsView with no tools are always mounted\n\t      return this;\n\t    }\n\t    if (!this.isMounted()) {\n\t      this.mount();\n\t    }\n\t    if (!wasRendered) {\n\t      // Make sure tools are visible (if they were hidden and the tool removed)\n\t      this.blurTool();\n\t    }\n\t    return this;\n\t  },\n\t  ensureToolRendered(tools, i) {\n\t    if (!this.isRendered) {\n\t      // There is at least one visible tool\n\t      this.isRendered = Array(tools.length).fill(false);\n\t    }\n\t    if (!this.isRendered[i]) {\n\t      // First update executes render()\n\t      tools[i].render();\n\t      this.isRendered[i] = true;\n\t      return false;\n\t    }\n\t    return true;\n\t  },\n\t  focusTool: function (focusedTool) {\n\t    var tools = this.tools;\n\t    if (!tools) return this;\n\t    for (var i = 0, n = tools.length; i < n; i++) {\n\t      var tool = tools[i];\n\t      if (focusedTool === tool) {\n\t        tool.show();\n\t      } else {\n\t        tool.hide();\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  blurTool: function (blurredTool) {\n\t    var tools = this.tools;\n\t    if (!tools) return this;\n\t    for (var i = 0, n = tools.length; i < n; i++) {\n\t      var tool = tools[i];\n\t      if (tool !== blurredTool && !tool.isExplicitlyVisible()) {\n\t        tool.show();\n\t        // Check if the tool is conditionally visible too\n\t        if (tool.isVisible()) {\n\t          this.ensureToolRendered(tools, i) && tool.update();\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  hide: function () {\n\t    return this.focusTool(null);\n\t  },\n\t  show: function () {\n\t    this.blurTool(null);\n\t    // If this the first time the tools are shown, make sure they are mounted\n\t    if (!this.isMounted()) {\n\t      this.mount();\n\t    }\n\t    return this;\n\t  },\n\t  onRemove: function () {\n\t    var tools = this.tools;\n\t    if (!tools) return this;\n\t    for (var i = 0, n = tools.length; i < n; i++) {\n\t      tools[i].remove();\n\t    }\n\t    this.tools = null;\n\t  },\n\t  getLayer() {\n\t    const {\n\t      layer = Paper.Layers.TOOLS\n\t    } = this.options;\n\t    return layer;\n\t  },\n\t  hasLayer() {\n\t    return !!this.getLayer();\n\t  },\n\t  mount: function () {\n\t    const {\n\t      options,\n\t      el\n\t    } = this;\n\t    const {\n\t      relatedView,\n\t      z\n\t    } = options;\n\t    if (relatedView) {\n\t      if (this.hasLayer()) {\n\t        relatedView.paper.getLayerView(this.getLayer()).insertSortedNode(el, z);\n\t      } else {\n\t        relatedView.el.appendChild(el);\n\t      }\n\t    }\n\t    return this;\n\t  }\n\t});\n\n\tvar index$2 = {\n\t\t__proto__: null,\n\t\tCell: Cell,\n\t\tCellCollection: CellCollection,\n\t\tCellView: CellView,\n\t\tDEFAULT_GRAPH_LAYER_TYPE: DEFAULT_GRAPH_LAYER_TYPE,\n\t\tElement: Element$1,\n\t\tElementView: ElementView,\n\t\tGraph: Graph,\n\t\tGraphLayer: GraphLayer,\n\t\tGraphLayerCollection: GraphLayerCollection,\n\t\tGraphLayerView: GraphLayerView,\n\t\tGridLayerView: GridLayerView,\n\t\tHighlighterView: HighlighterView,\n\t\tLayerView: LayerView,\n\t\tLink: Link$1,\n\t\tLinkView: LinkView,\n\t\tPaper: Paper,\n\t\tToolView: ToolView,\n\t\tToolsView: ToolsView,\n\t\tattributes: attributes,\n\t\tsortingTypes: sortingTypes\n\t};\n\n\t// Vertex Handles\n\tvar VertexHandle = View.extend({\n\t  tagName: 'circle',\n\t  svgElement: true,\n\t  className: 'marker-vertex',\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown',\n\t    dblclick: 'onDoubleClick',\n\t    dbltap: 'onDoubleClick'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  attributes: {\n\t    'r': 6,\n\t    'fill': '#33334F',\n\t    'stroke': '#FFFFFF',\n\t    'stroke-width': 2,\n\t    'cursor': 'move'\n\t  },\n\t  position: function (x, y) {\n\t    const {\n\t      vel,\n\t      options\n\t    } = this;\n\t    const {\n\t      scale\n\t    } = options;\n\t    let matrix = V.createSVGMatrix().translate(x, y);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    vel.transform(matrix, {\n\t      absolute: true\n\t    });\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.options.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    this.options.paper.undelegateEvents();\n\t    this.delegateDocumentEvents(null, evt.data);\n\t    this.trigger('will-change', this, evt);\n\t  },\n\t  onPointerMove: function (evt) {\n\t    this.trigger('changing', this, evt);\n\t  },\n\t  onDoubleClick: function (evt) {\n\t    this.trigger('remove', this, evt);\n\t  },\n\t  onPointerUp: function (evt) {\n\t    this.trigger('changed', this, evt);\n\t    this.undelegateDocumentEvents();\n\t    this.options.paper.delegateEvents();\n\t  }\n\t});\n\tconst Vertices = ToolView.extend({\n\t  name: 'vertices',\n\t  options: {\n\t    handleClass: VertexHandle,\n\t    snapRadius: 20,\n\t    redundancyRemoval: true,\n\t    vertexAdding: true,\n\t    // vertexRemoving: true,\n\t    // vertexMoving: true,\n\t    stopPropagation: true,\n\t    scale: null\n\t  },\n\t  children: [{\n\t    tagName: 'path',\n\t    selector: 'connection',\n\t    className: 'joint-vertices-path',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'stroke': 'transparent',\n\t      'stroke-width': 10,\n\t      'cursor': 'cell'\n\t    }\n\t  }],\n\t  handles: null,\n\t  interactiveLinkNode: null,\n\t  events: {\n\t    'mousedown .joint-vertices-path': 'onPathPointerDown',\n\t    'touchstart .joint-vertices-path': 'onPathPointerDown'\n\t  },\n\t  linkEvents: {\n\t    mousedown: 'onLinkPointerDown',\n\t    touchstart: 'onLinkPointerDown'\n\t  },\n\t  onRender: function () {\n\t    const {\n\t      vertexAdding\n\t    } = this.options;\n\t    if (vertexAdding) {\n\t      const {\n\t        interactiveLinkNode = null\n\t      } = vertexAdding;\n\t      if (interactiveLinkNode) {\n\t        this.delegateLinkEvents(interactiveLinkNode);\n\t      } else {\n\t        this.renderChildren();\n\t        this.updatePath();\n\t      }\n\t    }\n\t    this.resetHandles();\n\t    this.renderHandles();\n\t    return this;\n\t  },\n\t  delegateLinkEvents: function (selector) {\n\t    this.undelegateLinkEvents();\n\t    const el = this.relatedView.findNode(selector);\n\t    if (!el) {\n\t      console.warn(`Interactive link node \"${selector}\" not found.`);\n\t      return;\n\t    }\n\t    el.classList.add('joint-vertices-path');\n\t    this.interactiveLinkNode = el;\n\t    this.delegateElementEvents(el, this.linkEvents);\n\t  },\n\t  undelegateLinkEvents: function () {\n\t    const el = this.interactiveLinkNode;\n\t    if (!el) return;\n\t    this.undelegateElementEvents(el);\n\t    el.classList.remove('joint-vertices-path');\n\t    this.interactiveLinkNode = null;\n\t  },\n\t  update: function () {\n\t    var relatedView = this.relatedView;\n\t    var vertices = relatedView.model.vertices();\n\t    if (vertices.length === this.handles.length) {\n\t      this.updateHandles();\n\t    } else {\n\t      this.resetHandles();\n\t      this.renderHandles();\n\t    }\n\t    if (this.options.vertexAdding) {\n\t      this.updatePath();\n\t    }\n\t    return this;\n\t  },\n\t  resetHandles: function () {\n\t    var handles = this.handles;\n\t    this.handles = [];\n\t    this.stopListening();\n\t    if (!Array.isArray(handles)) return;\n\t    for (var i = 0, n = handles.length; i < n; i++) {\n\t      handles[i].remove();\n\t    }\n\t  },\n\t  renderHandles: function () {\n\t    var relatedView = this.relatedView;\n\t    var vertices = relatedView.model.vertices();\n\t    for (var i = 0, n = vertices.length; i < n; i++) {\n\t      var vertex = vertices[i];\n\t      var handle = new this.options.handleClass({\n\t        index: i,\n\t        paper: this.paper,\n\t        scale: this.options.scale,\n\t        guard: evt => this.guard(evt)\n\t      });\n\t      handle.render();\n\t      handle.position(vertex.x, vertex.y);\n\t      this.simulateRelatedView(handle.el);\n\t      handle.vel.appendTo(this.el);\n\t      this.handles.push(handle);\n\t      this.startHandleListening(handle);\n\t    }\n\t  },\n\t  updateHandles: function () {\n\t    var relatedView = this.relatedView;\n\t    var vertices = relatedView.model.vertices();\n\t    for (var i = 0, n = vertices.length; i < n; i++) {\n\t      var vertex = vertices[i];\n\t      var handle = this.handles[i];\n\t      if (!handle) return;\n\t      handle.position(vertex.x, vertex.y);\n\t    }\n\t  },\n\t  updatePath: function () {\n\t    if (this.interactiveLinkNode) return;\n\t    const connection = this.childNodes.connection;\n\t    if (connection) connection.setAttribute('d', this.relatedView.getSerializedConnection());\n\t  },\n\t  startHandleListening: function (handle) {\n\t    const {\n\t      vertexRemoving = true,\n\t      vertexMoving = true\n\t    } = this.options;\n\t    if (vertexMoving) {\n\t      this.listenTo(handle, 'will-change', this.onHandleWillChange);\n\t      this.listenTo(handle, 'changing', this.onHandleChanging);\n\t      this.listenTo(handle, 'changed', this.onHandleChanged);\n\t    }\n\t    if (vertexRemoving) {\n\t      this.listenTo(handle, 'remove', this.onHandleRemove);\n\t    }\n\t  },\n\t  getNeighborPoints: function (index) {\n\t    var linkView = this.relatedView;\n\t    var vertices = linkView.model.vertices();\n\t    var prev = index > 0 ? vertices[index - 1] : linkView.sourceAnchor;\n\t    var next = index < vertices.length - 1 ? vertices[index + 1] : linkView.targetAnchor;\n\t    return {\n\t      prev: new Point(prev),\n\t      next: new Point(next)\n\t    };\n\t  },\n\t  onHandleWillChange: function (_handle, evt) {\n\t    this.focus();\n\t    const {\n\t      relatedView,\n\t      options\n\t    } = this;\n\t    relatedView.model.startBatch('vertex-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    if (!options.stopPropagation) relatedView.notifyPointerdown(...relatedView.paper.getPointerArgs(evt));\n\t  },\n\t  onHandleChanging: function (handle, evt) {\n\t    const {\n\t      options,\n\t      relatedView: linkView\n\t    } = this;\n\t    var index = handle.options.index;\n\t    var [normalizedEvent, x, y] = linkView.paper.getPointerArgs(evt);\n\t    var vertex = {\n\t      x,\n\t      y\n\t    };\n\t    this.snapVertex(vertex, index);\n\t    linkView.model.vertex(index, vertex, {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    handle.position(vertex.x, vertex.y);\n\t    if (!options.stopPropagation) linkView.notifyPointermove(normalizedEvent, x, y);\n\t  },\n\t  onHandleChanged: function (_handle, evt) {\n\t    const {\n\t      options,\n\t      relatedView: linkView\n\t    } = this;\n\t    if (options.vertexAdding) this.updatePath();\n\t    if (options.redundancyRemoval) {\n\t      const verticesRemoved = linkView.removeRedundantLinearVertices({\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t      if (verticesRemoved) this.render();\n\t    }\n\t    this.blur();\n\t    linkView.model.stopBatch('vertex-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    if (this.eventData(evt).vertexAdded) {\n\t      linkView.model.stopBatch('vertex-add', {\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    }\n\t    const [normalizedEvt, x, y] = linkView.paper.getPointerArgs(evt);\n\t    if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvt, x, y);\n\t    linkView.checkMouseleave(normalizedEvt);\n\t  },\n\t  snapVertex: function (vertex, index) {\n\t    var snapRadius = this.options.snapRadius;\n\t    if (snapRadius > 0) {\n\t      var neighbors = this.getNeighborPoints(index);\n\t      var prev = neighbors.prev;\n\t      var next = neighbors.next;\n\t      if (Math.abs(vertex.x - prev.x) < snapRadius) {\n\t        vertex.x = prev.x;\n\t      } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n\t        vertex.x = next.x;\n\t      }\n\t      if (Math.abs(vertex.y - prev.y) < snapRadius) {\n\t        vertex.y = neighbors.prev.y;\n\t      } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n\t        vertex.y = next.y;\n\t      }\n\t    }\n\t  },\n\t  onHandleRemove: function (handle, evt) {\n\t    var index = handle.options.index;\n\t    var linkView = this.relatedView;\n\t    linkView.model.removeVertex(index, {\n\t      ui: true\n\t    });\n\t    if (this.options.vertexAdding) this.updatePath();\n\t    linkView.checkMouseleave(normalizeEvent(evt));\n\t  },\n\t  onPathPointerDown: function (evt) {\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();\n\t    var relatedView = this.relatedView;\n\t    relatedView.model.startBatch('vertex-add', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    var index = relatedView.getVertexIndex(vertex.x, vertex.y);\n\t    this.snapVertex(vertex, index);\n\t    relatedView.model.insertVertex(index, vertex, {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    this.update();\n\t    var handle = this.handles[index];\n\t    this.eventData(normalizedEvent, {\n\t      vertexAdded: true\n\t    });\n\t    handle.onPointerDown(normalizedEvent);\n\t  },\n\t  onLinkPointerDown: function (evt) {\n\t    this.relatedView.preventDefaultInteraction(evt);\n\t    this.onPathPointerDown(evt);\n\t  },\n\t  onRemove: function () {\n\t    this.resetHandles();\n\t    this.undelegateLinkEvents();\n\t  }\n\t}, {\n\t  VertexHandle: VertexHandle // keep as class property\n\t});\n\n\t/**\n\t * Common helper for getting a cell viewâs bounding box,\n\t * configurable with `useModelGeometry`, `relative`, and `el`.\n\t */\n\tfunction getViewBBox(view, {\n\t  useModelGeometry = false,\n\t  relative = false,\n\t  el = view.el\n\t} = {}) {\n\t  const {\n\t    model\n\t  } = view;\n\t  let bbox;\n\t  if (useModelGeometry) {\n\t    // cell model bbox\n\t    bbox = model.getBBox();\n\t  } else if (model.isLink()) {\n\t    // link view bbox\n\t    bbox = view.getConnection().bbox();\n\t  } else {\n\t    // element view bbox\n\t    bbox = view.getNodeUnrotatedBBox(el);\n\t  }\n\t  if (relative) {\n\t    // Relative to the element position.\n\t    const position = model.position();\n\t    bbox.x -= position.x;\n\t    bbox.y -= position.y;\n\t  }\n\t  return bbox;\n\t}\n\n\t/**\n\t * Retrieves the tool options.\n\t * Automatically overrides `useModelGeometry` and `rotate`\n\t * if the tool is positioned relative to the element.\n\t */\n\tfunction getToolOptions(toolView) {\n\t  // Positioning is relative if the tool is drawn within the element view.\n\t  const relative = !toolView.isOverlay();\n\t  const {\n\t    useModelGeometry,\n\t    rotate,\n\t    ...otherOptions\n\t  } = toolView.options;\n\t  return {\n\t    ...otherOptions,\n\t    useModelGeometry: useModelGeometry || relative,\n\t    rotate: rotate || relative,\n\t    relative\n\t  };\n\t}\n\tfunction getAnchor(coords, view, magnet) {\n\t  // take advantage of an existing logic inside of the\n\t  // pin relative connection strategy\n\t  var end = pinRelative.call(this.paper, {}, view, magnet, coords, this.model);\n\t  return end.anchor;\n\t}\n\tfunction snapAnchor(coords, view, magnet, type, relatedView, toolView) {\n\t  var snapRadius = toolView.options.snapRadius;\n\t  var isSource = type === 'source';\n\t  var refIndex = isSource ? 0 : -1;\n\t  var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? 'target' : 'source');\n\t  if (ref) {\n\t    if (Math.abs(ref.x - coords.x) < snapRadius) coords.x = ref.x;\n\t    if (Math.abs(ref.y - coords.y) < snapRadius) coords.y = ref.y;\n\t  }\n\t  return coords;\n\t}\n\n\tvar SegmentHandle = View.extend({\n\t  tagName: 'g',\n\t  svgElement: true,\n\t  className: 'marker-segment',\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  children: [{\n\t    tagName: 'line',\n\t    selector: 'line',\n\t    attributes: {\n\t      'stroke': '#33334F',\n\t      'stroke-width': 2,\n\t      'fill': 'none',\n\t      'pointer-events': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'handle',\n\t    attributes: {\n\t      'width': 20,\n\t      'height': 8,\n\t      'x': -10,\n\t      'y': -4,\n\t      'rx': 4,\n\t      'ry': 4,\n\t      'fill': '#33334F',\n\t      'stroke': '#FFFFFF',\n\t      'stroke-width': 2\n\t    }\n\t  }],\n\t  onRender: function () {\n\t    this.renderChildren();\n\t  },\n\t  position: function (x, y, angle, view) {\n\t    const {\n\t      scale\n\t    } = this.options;\n\t    let matrix = V.createSVGMatrix().translate(x, y).rotate(angle);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    var handle = this.childNodes.handle;\n\t    handle.setAttribute('transform', V.matrixToTransformString(matrix));\n\t    handle.setAttribute('cursor', angle % 180 === 0 ? 'row-resize' : 'col-resize');\n\t    var viewPoint = view.getClosestPoint(new Point(x, y));\n\t    var line = this.childNodes.line;\n\t    line.setAttribute('x1', x);\n\t    line.setAttribute('y1', y);\n\t    line.setAttribute('x2', viewPoint.x);\n\t    line.setAttribute('y2', viewPoint.y);\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.options.guard(evt)) return;\n\t    this.trigger('change:start', this, evt);\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    this.options.paper.undelegateEvents();\n\t    this.delegateDocumentEvents(null, evt.data);\n\t  },\n\t  onPointerMove: function (evt) {\n\t    this.trigger('changing', this, evt);\n\t  },\n\t  onPointerUp: function (evt) {\n\t    this.undelegateDocumentEvents();\n\t    this.options.paper.delegateEvents();\n\t    this.trigger('change:end', this, evt);\n\t  },\n\t  show: function () {\n\t    this.el.style.display = '';\n\t  },\n\t  hide: function () {\n\t    this.el.style.display = 'none';\n\t  }\n\t});\n\tconst Segments = ToolView.extend({\n\t  name: 'segments',\n\t  precision: .5,\n\t  options: {\n\t    handleClass: SegmentHandle,\n\t    segmentLengthThreshold: 40,\n\t    redundancyRemoval: true,\n\t    anchor: getAnchor,\n\t    snapRadius: 10,\n\t    snapHandle: true,\n\t    stopPropagation: true\n\t  },\n\t  handles: null,\n\t  onRender: function () {\n\t    this.resetHandles();\n\t    var relatedView = this.relatedView;\n\t    var vertices = relatedView.model.vertices();\n\t    vertices.unshift(relatedView.sourcePoint);\n\t    vertices.push(relatedView.targetPoint);\n\t    for (var i = 0, n = vertices.length; i < n - 1; i++) {\n\t      var vertex = vertices[i];\n\t      var nextVertex = vertices[i + 1];\n\t      var handle = this.renderHandle(vertex, nextVertex);\n\t      this.simulateRelatedView(handle.el);\n\t      this.handles.push(handle);\n\t      handle.options.index = i;\n\t    }\n\t    return this;\n\t  },\n\t  renderHandle: function (vertex, nextVertex) {\n\t    var handle = new this.options.handleClass({\n\t      paper: this.paper,\n\t      scale: this.options.scale,\n\t      guard: evt => this.guard(evt)\n\t    });\n\t    handle.render();\n\t    this.updateHandle(handle, vertex, nextVertex);\n\t    handle.vel.appendTo(this.el);\n\t    this.startHandleListening(handle);\n\t    return handle;\n\t  },\n\t  update: function () {\n\t    this.render();\n\t    return this;\n\t  },\n\t  startHandleListening: function (handle) {\n\t    this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n\t    this.listenTo(handle, 'changing', this.onHandleChanging);\n\t    this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n\t  },\n\t  resetHandles: function () {\n\t    var handles = this.handles;\n\t    this.handles = [];\n\t    this.stopListening();\n\t    if (!Array.isArray(handles)) return;\n\t    for (var i = 0, n = handles.length; i < n; i++) {\n\t      handles[i].remove();\n\t    }\n\t  },\n\t  shiftHandleIndexes: function (value) {\n\t    var handles = this.handles;\n\t    for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;\n\t  },\n\t  resetAnchor: function (type, anchor) {\n\t    var relatedModel = this.relatedView.model;\n\t    if (anchor) {\n\t      relatedModel.prop([type, 'anchor'], anchor, {\n\t        rewrite: true,\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    } else {\n\t      relatedModel.removeProp([type, 'anchor'], {\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    }\n\t  },\n\t  snapHandle: function (handle, position, data) {\n\t    var index = handle.options.index;\n\t    var linkView = this.relatedView;\n\t    var link = linkView.model;\n\t    var vertices = link.vertices();\n\t    var axis = handle.options.axis;\n\t    var prev = vertices[index - 2] || data.sourceAnchor;\n\t    var next = vertices[index + 1] || data.targetAnchor;\n\t    var snapRadius = this.options.snapRadius;\n\t    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n\t      position[axis] = prev[axis];\n\t    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n\t      position[axis] = next[axis];\n\t    }\n\t    return position;\n\t  },\n\t  onHandleChanging: function (handle, evt) {\n\t    const {\n\t      options\n\t    } = this;\n\t    var data = this.eventData(evt);\n\t    var relatedView = this.relatedView;\n\t    var paper = relatedView.paper;\n\t    var index = handle.options.index - 1;\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    var position = this.snapHandle(handle, coords.clone(), data);\n\t    var axis = handle.options.axis;\n\t    var offset = this.options.snapHandle ? 0 : coords[axis] - position[axis];\n\t    var link = relatedView.model;\n\t    var vertices = cloneDeep(link.vertices());\n\t    var anchorFn = this.options.anchor;\n\t    if (typeof anchorFn !== 'function') anchorFn = null;\n\t    const handleIndex = handle.options.index;\n\t    const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];\n\t    let indexOffset = 0;\n\n\t    // check if vertex before handle vertex exists\n\t    if (handleIndex - 1 >= 0) {\n\t      const v1 = vertexPoints[handleIndex - 1];\n\t      const v2 = vertexPoints[handleIndex];\n\t      const theta = new Line(v1, v2).vector().theta();\n\n\t      // check only non-orthogonal segments\n\t      if (theta % 90 !== 0) {\n\t        vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n\t        indexOffset++;\n\t        this.shiftHandleIndexes(1);\n\t      }\n\t    }\n\t    var vertex = vertices[index + indexOffset];\n\t    var nextVertex = vertices[index + 1 + indexOffset];\n\n\t    // check if vertex after handle vertex exists\n\t    if (handleIndex + 2 < vertexPoints.length) {\n\t      const v1 = vertexPoints[handleIndex + 1];\n\t      const v2 = vertexPoints[handleIndex + 2];\n\t      const theta = new Line(v1, v2).vector().theta();\n\n\t      // check only non-orthogonal segments\n\t      if (theta % 90 !== 0) {\n\t        const isSingleVertex = data.originalVertices.length === 1;\n\t        const origVIndex = isSingleVertex ? 0 : handleIndex;\n\t        const additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n\t        const nextVIndex = 1 + indexOffset;\n\t        vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n\t      }\n\t    }\n\n\t    // First Segment\n\t    var sourceView = relatedView.sourceView;\n\t    var sourceBBox = relatedView.sourceBBox;\n\t    var changeSourceAnchor = false;\n\t    var deleteSourceAnchor = false;\n\t    if (!vertex) {\n\t      vertex = relatedView.sourceAnchor.toJSON();\n\t      vertex[axis] = position[axis];\n\t      if (sourceBBox.containsPoint(vertex)) {\n\t        vertex[axis] = position[axis];\n\t        changeSourceAnchor = true;\n\t      } else {\n\t        // we left the area of the source magnet for the first time\n\t        vertices.unshift(vertex);\n\t        this.shiftHandleIndexes(1);\n\t        data.firstHandleShifted = true;\n\t        deleteSourceAnchor = true;\n\t      }\n\t    } else if (index === 0) {\n\t      if (sourceBBox.containsPoint(vertex)) {\n\t        vertices.shift();\n\t        this.shiftHandleIndexes(-1);\n\t        changeSourceAnchor = true;\n\t      } else {\n\t        vertex[axis] = position[axis];\n\t        deleteSourceAnchor = true;\n\t      }\n\t    } else {\n\t      vertex[axis] = position[axis];\n\t    }\n\t    if (anchorFn && sourceView) {\n\t      if (changeSourceAnchor) {\n\t        var sourceAnchorPosition = data.sourceAnchor.clone();\n\t        sourceAnchorPosition[axis] = position[axis];\n\t        var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n\t        this.resetAnchor('source', sourceAnchor);\n\t      }\n\t      if (deleteSourceAnchor) {\n\t        this.resetAnchor('source', data.sourceAnchorDef);\n\t      }\n\t    }\n\n\t    // Last segment\n\t    var targetView = relatedView.targetView;\n\t    var targetBBox = relatedView.targetBBox;\n\t    var changeTargetAnchor = false;\n\t    var deleteTargetAnchor = false;\n\t    if (!nextVertex) {\n\t      nextVertex = relatedView.targetAnchor.toJSON();\n\t      nextVertex[axis] = position[axis];\n\t      if (targetBBox.containsPoint(nextVertex)) {\n\t        changeTargetAnchor = true;\n\t      } else {\n\t        // we left the area of the target magnet for the first time\n\t        vertices.push(nextVertex);\n\t        deleteTargetAnchor = true;\n\t      }\n\t    } else if (index === vertices.length - 2) {\n\t      if (targetBBox.containsPoint(nextVertex)) {\n\t        vertices.pop();\n\t        changeTargetAnchor = true;\n\t      } else {\n\t        nextVertex[axis] = position[axis];\n\t        deleteTargetAnchor = true;\n\t      }\n\t    } else {\n\t      nextVertex[axis] = position[axis];\n\t    }\n\t    if (anchorFn && targetView) {\n\t      if (changeTargetAnchor) {\n\t        var targetAnchorPosition = data.targetAnchor.clone();\n\t        targetAnchorPosition[axis] = position[axis];\n\t        var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n\t        this.resetAnchor('target', targetAnchor);\n\t      }\n\t      if (deleteTargetAnchor) {\n\t        this.resetAnchor('target', data.targetAnchorDef);\n\t      }\n\t    }\n\t    if (vertices.some(v => !v)) {\n\t      // This can happen when the link is using a smart routing and the number of\n\t      // vertices is not the same as the number of route points.\n\t      throw new Error('Segments: incompatible router in use');\n\t    }\n\t    link.vertices(vertices, {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    this.updateHandle(handle, vertex, nextVertex, offset);\n\t    if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);\n\t  },\n\t  onHandleChangeStart: function (handle, evt) {\n\t    const {\n\t      options,\n\t      handles,\n\t      relatedView: linkView\n\t    } = this;\n\t    const {\n\t      model,\n\t      paper\n\t    } = linkView;\n\t    var index = handle.options.index;\n\t    if (!Array.isArray(handles)) return;\n\t    for (var i = 0, n = handles.length; i < n; i++) {\n\t      if (i !== index) handles[i].hide();\n\t    }\n\t    this.focus();\n\t    this.eventData(evt, {\n\t      sourceAnchor: linkView.sourceAnchor.clone(),\n\t      targetAnchor: linkView.targetAnchor.clone(),\n\t      sourceAnchorDef: clone$1(model.prop(['source', 'anchor'])),\n\t      targetAnchorDef: clone$1(model.prop(['target', 'anchor'])),\n\t      originalVertices: cloneDeep(model.vertices()),\n\t      firstHandleShifted: false\n\t    });\n\t    model.startBatch('segment-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));\n\t  },\n\t  onHandleChangeEnd: function (_handle, evt) {\n\t    const {\n\t      options,\n\t      relatedView: linkView\n\t    } = this;\n\t    const {\n\t      paper,\n\t      model\n\t    } = linkView;\n\t    if (options.redundancyRemoval) {\n\t      linkView.removeRedundantLinearVertices({\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    }\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    this.render();\n\t    this.blur();\n\t    model.stopBatch('segment-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);\n\t    linkView.checkMouseleave(normalizedEvent);\n\t  },\n\t  updateHandle: function (handle, vertex, nextVertex, offset) {\n\t    var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n\t    var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n\t    if (vertical || horizontal) {\n\t      var segmentLine = new Line(vertex, nextVertex);\n\t      var length = segmentLine.length();\n\t      if (length < this.options.segmentLengthThreshold) {\n\t        handle.hide();\n\t      } else {\n\t        var position = segmentLine.midpoint();\n\t        var axis = vertical ? 'x' : 'y';\n\t        position[axis] += offset || 0;\n\t        var angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n\t        handle.position(position.x, position.y, angle, this.relatedView);\n\t        handle.show();\n\t        handle.options.axis = axis;\n\t      }\n\t    } else {\n\t      handle.hide();\n\t    }\n\t  },\n\t  onRemove: function () {\n\t    this.resetHandles();\n\t  }\n\t}, {\n\t  SegmentHandle: SegmentHandle // keep as class property\n\t});\n\n\t// End Markers\n\tconst Arrowhead = ToolView.extend({\n\t  tagName: 'path',\n\t  xAxisVector: new Point(1, 0),\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  options: {\n\t    scale: null\n\t  },\n\t  onRender: function () {\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    var ratio = this.ratio;\n\t    var view = this.relatedView;\n\t    var tangent = view.getTangentAtRatio(ratio);\n\t    var position, angle;\n\t    if (tangent) {\n\t      position = tangent.start;\n\t      angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;\n\t    } else {\n\t      position = view.getPointAtRatio(ratio);\n\t      angle = 0;\n\t    }\n\t    if (!position) return this;\n\t    var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle);\n\t    const {\n\t      scale\n\t    } = this.options;\n\t    if (scale) matrix = matrix.scale(scale);\n\t    this.vel.transform(matrix, {\n\t      absolute: true\n\t    });\n\t    return this;\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    var relatedView = this.relatedView;\n\t    var paper = relatedView.paper;\n\t    relatedView.model.startBatch('arrowhead-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    relatedView.startArrowheadMove(this.arrowheadType);\n\t    const data = evt.data || (evt.data = {});\n\t    this.delegateDocumentEvents(null, data);\n\t    paper.undelegateEvents();\n\t    this.focus();\n\t    this.el.style.pointerEvents = 'none';\n\t    relatedView.notifyPointerdown(...paper.getPointerArgs(evt));\n\t  },\n\t  onPointerMove: function (evt) {\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);\n\t  },\n\t  onPointerUp: function (evt) {\n\t    this.undelegateDocumentEvents();\n\t    var relatedView = this.relatedView;\n\t    var paper = relatedView.paper;\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    relatedView.pointerup(normalizedEvent, coords.x, coords.y);\n\t    paper.delegateEvents();\n\t    this.blur();\n\t    this.el.style.pointerEvents = '';\n\t    relatedView.model.stopBatch('arrowhead-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  }\n\t});\n\tconst TargetArrowhead = Arrowhead.extend({\n\t  name: 'target-arrowhead',\n\t  ratio: 1,\n\t  arrowheadType: 'target',\n\t  attributes: {\n\t    'd': 'M -10 -8 10 0 -10 8 Z',\n\t    'fill': '#33334F',\n\t    'stroke': '#FFFFFF',\n\t    'stroke-width': 2,\n\t    'cursor': 'move',\n\t    'class': 'target-arrowhead'\n\t  }\n\t});\n\tconst SourceArrowhead = Arrowhead.extend({\n\t  name: 'source-arrowhead',\n\t  ratio: 0,\n\t  arrowheadType: 'source',\n\t  attributes: {\n\t    'd': 'M 10 -8 -10 0 10 8 Z',\n\t    'fill': '#33334F',\n\t    'stroke': '#FFFFFF',\n\t    'stroke-width': 2,\n\t    'cursor': 'move',\n\t    'class': 'source-arrowhead'\n\t  }\n\t});\n\n\tconst Anchor = ToolView.extend({\n\t  tagName: 'g',\n\t  type: null,\n\t  children: [{\n\t    tagName: 'circle',\n\t    selector: 'anchor',\n\t    attributes: {\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'area',\n\t    attributes: {\n\t      'pointer-events': 'none',\n\t      'fill': 'none',\n\t      'stroke': '#33334F',\n\t      'stroke-dasharray': '2,4',\n\t      'rx': 5,\n\t      'ry': 5\n\t    }\n\t  }],\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown',\n\t    dblclick: 'onPointerDblClick',\n\t    dbltap: 'onPointerDblClick'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  options: {\n\t    snap: snapAnchor,\n\t    anchor: getAnchor,\n\t    scale: null,\n\t    resetAnchor: true,\n\t    customAnchorAttributes: {\n\t      'stroke-width': 4,\n\t      'stroke': '#33334F',\n\t      'fill': '#FFFFFF',\n\t      'r': 5\n\t    },\n\t    defaultAnchorAttributes: {\n\t      'stroke-width': 2,\n\t      'stroke': '#FFFFFF',\n\t      'fill': '#33334F',\n\t      'r': 6\n\t    },\n\t    areaPadding: 6,\n\t    snapRadius: 10,\n\t    restrictArea: true,\n\t    redundancyRemoval: true\n\t  },\n\t  onRender: function () {\n\t    this.renderChildren();\n\t    this.toggleArea(false);\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    var type = this.type;\n\t    var relatedView = this.relatedView;\n\t    var view = relatedView.getEndView(type);\n\t    if (view) {\n\t      this.updateAnchor();\n\t      this.updateArea();\n\t      this.el.style.display = '';\n\t    } else {\n\t      this.el.style.display = 'none';\n\t    }\n\t    return this;\n\t  },\n\t  updateAnchor: function () {\n\t    var childNodes = this.childNodes;\n\t    if (!childNodes) return;\n\t    var anchorNode = childNodes.anchor;\n\t    if (!anchorNode) return;\n\t    var relatedView = this.relatedView;\n\t    var type = this.type;\n\t    var position = relatedView.getEndAnchor(type);\n\t    var options = this.options;\n\t    var customAnchor = relatedView.model.prop([type, 'anchor']);\n\t    let transformString = `translate(${position.x},${position.y})`;\n\t    if (options.scale) {\n\t      transformString += ` scale(${options.scale})`;\n\t    }\n\t    anchorNode.setAttribute('transform', transformString);\n\t    var anchorAttributes = customAnchor ? options.customAnchorAttributes : options.defaultAnchorAttributes;\n\t    for (var attrName in anchorAttributes) {\n\t      anchorNode.setAttribute(attrName, anchorAttributes[attrName]);\n\t    }\n\t  },\n\t  updateArea: function () {\n\t    var childNodes = this.childNodes;\n\t    if (!childNodes) return;\n\t    var areaNode = childNodes.area;\n\t    if (!areaNode) return;\n\t    var relatedView = this.relatedView;\n\t    var type = this.type;\n\t    var view = relatedView.getEndView(type);\n\t    var model = view.model;\n\t    var magnet = relatedView.getEndMagnet(type);\n\t    var padding = this.options.areaPadding;\n\t    if (!isFinite(padding)) padding = 0;\n\t    var bbox, angle, center;\n\t    if (view.isNodeConnection(magnet)) {\n\t      bbox = view.getNodeBBox(magnet);\n\t      angle = 0;\n\t      center = bbox.center();\n\t    } else {\n\t      bbox = view.getNodeUnrotatedBBox(magnet);\n\t      angle = model.angle();\n\t      center = bbox.center();\n\t      if (angle) center.rotate(model.getCenter(), -angle);\n\t      // TODO: get the link's magnet rotation into account\n\t    }\n\t    bbox.inflate(padding);\n\t    areaNode.setAttribute('x', -bbox.width / 2);\n\t    areaNode.setAttribute('y', -bbox.height / 2);\n\t    areaNode.setAttribute('width', bbox.width);\n\t    areaNode.setAttribute('height', bbox.height);\n\t    areaNode.setAttribute('transform', 'translate(' + center.x + ',' + center.y + ') rotate(' + angle + ')');\n\t  },\n\t  toggleArea: function (visible) {\n\t    var childNodes = this.childNodes;\n\t    if (!childNodes) return;\n\t    var areaNode = childNodes.area;\n\t    if (!areaNode) return;\n\t    areaNode.style.display = visible ? '' : 'none';\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    this.paper.undelegateEvents();\n\t    this.delegateDocumentEvents();\n\t    this.focus();\n\t    this.toggleArea(this.options.restrictArea);\n\t    this.relatedView.model.startBatch('anchor-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  },\n\t  resetAnchor: function (anchor) {\n\t    var type = this.type;\n\t    var relatedModel = this.relatedView.model;\n\t    if (anchor) {\n\t      relatedModel.prop([type, 'anchor'], anchor, {\n\t        rewrite: true,\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    } else {\n\t      relatedModel.removeProp([type, 'anchor'], {\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    }\n\t  },\n\t  onPointerMove: function (evt) {\n\t    var relatedView = this.relatedView;\n\t    var type = this.type;\n\t    var view = relatedView.getEndView(type);\n\t    var model = view.model;\n\t    var magnet = relatedView.getEndMagnet(type);\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    var snapFn = this.options.snap;\n\t    if (typeof snapFn === 'function') {\n\t      coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);\n\t      coords = new Point(coords);\n\t    }\n\t    if (this.options.restrictArea) {\n\t      if (view.isNodeConnection(magnet)) {\n\t        // snap coords to the link's connection\n\t        var pointAtConnection = view.getClosestPoint(coords);\n\t        if (pointAtConnection) coords = pointAtConnection;\n\t      } else {\n\t        // snap coords within node bbox\n\t        var bbox = view.getNodeUnrotatedBBox(magnet);\n\t        var angle = model.angle();\n\t        var origin = model.getCenter();\n\t        var rotatedCoords = coords.clone().rotate(origin, angle);\n\t        if (!bbox.containsPoint(rotatedCoords)) {\n\t          coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);\n\t        }\n\t      }\n\t    }\n\t    var anchor;\n\t    var anchorFn = this.options.anchor;\n\t    if (typeof anchorFn === 'function') {\n\t      anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);\n\t    }\n\t    this.resetAnchor(anchor);\n\t    this.update();\n\t  },\n\t  onPointerUp: function (evt) {\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    this.paper.delegateEvents();\n\t    this.undelegateDocumentEvents();\n\t    this.blur();\n\t    this.toggleArea(false);\n\t    var linkView = this.relatedView;\n\t    if (this.options.redundancyRemoval) linkView.removeRedundantLinearVertices({\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    linkView.checkMouseleave(normalizedEvent);\n\t    linkView.model.stopBatch('anchor-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  },\n\t  onPointerDblClick: function () {\n\t    var anchor = this.options.resetAnchor;\n\t    if (anchor === false) return; // reset anchor disabled\n\t    if (anchor === true) anchor = null; // remove the current anchor\n\t    this.resetAnchor(cloneDeep(anchor));\n\t    this.update();\n\t  }\n\t});\n\tconst SourceAnchor = Anchor.extend({\n\t  name: 'source-anchor',\n\t  type: 'source'\n\t});\n\tconst TargetAnchor = Anchor.extend({\n\t  name: 'target-anchor',\n\t  type: 'target'\n\t});\n\n\tconst Control = ToolView.extend({\n\t  tagName: 'g',\n\t  children: [{\n\t    tagName: 'circle',\n\t    selector: 'handle',\n\t    attributes: {\n\t      'cursor': 'pointer',\n\t      'stroke-width': 2,\n\t      'stroke': '#FFFFFF',\n\t      'fill': '#33334F',\n\t      'r': 6\n\t    }\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'extras',\n\t    attributes: {\n\t      'pointer-events': 'none',\n\t      'fill': 'none',\n\t      'stroke': '#33334F',\n\t      'stroke-dasharray': '2,4',\n\t      'rx': 5,\n\t      'ry': 5\n\t    }\n\t  }],\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown',\n\t    dblclick: 'onPointerDblClick',\n\t    dbltap: 'onPointerDblClick'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  options: {\n\t    handleAttributes: null,\n\t    selector: 'root',\n\t    padding: 6,\n\t    scale: null\n\t  },\n\t  getPosition: function () {\n\t    // To be overridden\n\t  },\n\t  setPosition: function () {\n\t    // To be overridden\n\t  },\n\t  resetPosition: function () {\n\t    // To be overridden\n\t  },\n\t  onRender: function () {\n\t    this.renderChildren();\n\t    this.toggleExtras(false);\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    const {\n\t      handle,\n\t      extras\n\t    } = this.childNodes;\n\t    if (handle) {\n\t      this.updateHandle(handle);\n\t    } else {\n\t      throw new Error('Control: markup selector `handle` is required');\n\t    }\n\t    if (extras) {\n\t      this.updateExtras(extras);\n\t    }\n\t    return this;\n\t  },\n\t  updateHandle: function (handleNode) {\n\t    const {\n\t      options: {\n\t        handleAttributes\n\t      }\n\t    } = this;\n\t    handleNode.setAttribute('transform', this.getHandleTransformString());\n\t    if (handleAttributes) {\n\t      for (const attrName in handleAttributes) {\n\t        handleNode.setAttribute(attrName, handleAttributes[attrName]);\n\t      }\n\t    }\n\t  },\n\t  getHandleTransformString() {\n\t    const {\n\t      relatedView,\n\t      options\n\t    } = this;\n\t    const {\n\t      scale\n\t    } = options;\n\t    const {\n\t      model\n\t    } = relatedView;\n\t    const relativePos = this.getPosition(relatedView, this);\n\t    const translate = this.isOverlay()\n\t    // The tool is rendered in the coordinate system of the paper\n\t    ? model.getAbsolutePointFromRelative(relativePos)\n\t    // The tool is rendered in the coordinate system of the relatedView\n\t    : relativePos;\n\t    let transformString = `translate(${translate.x},${translate.y})`;\n\t    if (scale) {\n\t      transformString += ` scale(${scale})`;\n\t    }\n\t    return transformString;\n\t  },\n\t  updateExtras: function (extrasNode) {\n\t    const {\n\t      relatedView,\n\t      options\n\t    } = this;\n\t    const {\n\t      selector,\n\t      relative,\n\t      useModelGeometry\n\t    } = getToolOptions(this);\n\t    if (!selector) {\n\t      // Hide the extras if no selector is given.\n\t      this.toggleExtras(false);\n\t      return;\n\t    }\n\t    // Get the size for the extras rectangle and update it.\n\t    let bbox;\n\t    if (useModelGeometry) {\n\t      if (selector !== 'root') {\n\t        // A selector other than null or `root` was provided.\n\t        console.warn('Control: selector will be ignored when `useModelGeometry` is used.');\n\t      }\n\t      bbox = getViewBBox(relatedView, {\n\t        useModelGeometry,\n\t        relative\n\t      });\n\t    } else {\n\t      // The reference node for calculating the bounding box of the extras.\n\t      const el = relatedView.findNode(selector);\n\t      if (!el) throw new Error('Control: invalid selector.');\n\t      bbox = getViewBBox(relatedView, {\n\t        el\n\t      });\n\t    }\n\t    let padding = options.padding;\n\t    if (!isFinite(padding)) padding = 0;\n\t    const model = relatedView.model;\n\t    // With relative positioning, rotation is implicit\n\t    // (the tool rotates along with the element).\n\t    const angle = relative ? 0 : model.angle();\n\t    const center = bbox.center();\n\t    if (angle) center.rotate(model.getCenter(), -angle);\n\t    bbox.inflate(padding);\n\t    extrasNode.setAttribute('x', -bbox.width / 2);\n\t    extrasNode.setAttribute('y', -bbox.height / 2);\n\t    extrasNode.setAttribute('width', bbox.width);\n\t    extrasNode.setAttribute('height', bbox.height);\n\t    extrasNode.setAttribute('transform', `translate(${center.x},${center.y}) rotate(${angle})`);\n\t  },\n\t  toggleExtras: function (visible) {\n\t    const {\n\t      extras\n\t    } = this.childNodes;\n\t    if (!extras) return;\n\t    extras.style.display = visible ? '' : 'none';\n\t  },\n\t  onPointerDown: function (evt) {\n\t    const {\n\t      relatedView,\n\t      paper\n\t    } = this;\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    paper.undelegateEvents();\n\t    this.delegateDocumentEvents();\n\t    this.focus();\n\t    this.toggleExtras(true);\n\t    relatedView.model.startBatch('control-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  },\n\t  onPointerMove: function (evt) {\n\t    const {\n\t      relatedView,\n\t      paper\n\t    } = this;\n\t    const {\n\t      model\n\t    } = relatedView;\n\t    const {\n\t      clientX,\n\t      clientY\n\t    } = normalizeEvent(evt);\n\t    const coords = paper.clientToLocalPoint(clientX, clientY);\n\t    const relativeCoords = model.getRelativePointFromAbsolute(coords);\n\t    this.setPosition(relatedView, relativeCoords, evt);\n\t    this.update();\n\t  },\n\t  onPointerUp: function (_evt) {\n\t    const {\n\t      relatedView,\n\t      paper\n\t    } = this;\n\t    paper.delegateEvents();\n\t    this.undelegateDocumentEvents();\n\t    this.blur();\n\t    this.toggleExtras(false);\n\t    relatedView.model.stopBatch('control-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  },\n\t  onPointerDblClick: function (evt) {\n\t    const {\n\t      relatedView\n\t    } = this;\n\t    this.resetPosition(relatedView, evt);\n\t    this.update();\n\t  }\n\t});\n\n\tconst RotateLabel = Control.extend({\n\t  xAxisVector: new Point(1, 0),\n\t  children() {\n\t    const {\n\t      buttonColor = '#333',\n\t      iconColor = '#fff',\n\t      outlineColor = '#fff'\n\t    } = this.options;\n\t    return [{\n\t      selector: 'handle',\n\t      tagName: 'g',\n\t      attributes: {\n\t        cursor: 'grab'\n\t      },\n\t      children: [{\n\t        tagName: 'circle',\n\t        attributes: {\n\t          r: 10,\n\t          fill: buttonColor,\n\t          stroke: outlineColor\n\t        }\n\t      }, {\n\t        tagName: 'path',\n\t        attributes: {\n\t          d: 'M -5 0 A 5 5 0 1 1 0 5',\n\t          fill: 'transparent',\n\t          stroke: iconColor,\n\t          strokeWidth: 2,\n\t          strokeLinecap: 'round'\n\t        }\n\t      }, {\n\t        tagName: 'path',\n\t        attributes: {\n\t          d: 'M -3 5 L 0 2.5 0 7.5 Z',\n\t          fill: iconColor,\n\t          stroke: iconColor,\n\t          strokeWidth: 1,\n\t          transform: 'rotate(-5, -3, 5)'\n\t        }\n\t      }]\n\t    }];\n\t  },\n\t  getPosition(view) {\n\t    const {\n\t      offset = 0\n\t    } = this.options;\n\t    const {\n\t      x = 0,\n\t      y = 0\n\t    } = typeof offset === 'number' ? {\n\t      x: 0,\n\t      y: offset\n\t    } : offset;\n\t    const label = this.getLabel();\n\t    const labelPosition = this.getLabelPosition(label);\n\t    const coords = view.getLabelCoordinates(labelPosition);\n\t    let {\n\t      angle = 0\n\t    } = labelPosition;\n\t    const {\n\t      args = {}\n\t    } = labelPosition;\n\t    const keepGradient = args.keepGradient;\n\t    if (keepGradient) {\n\t      const tangent = view.getTangentAtRatio(view.getClosestPointRatio(coords));\n\t      if (tangent) {\n\t        // link slope angle\n\t        angle += tangent.vector().vectorAngle(this.xAxisVector) || 0;\n\t      }\n\t    }\n\t    const matrix = new DOMMatrix().translate(coords.x, coords.y).rotate(angle).translate(x, y);\n\t    return new Point(matrix.e, matrix.f);\n\t  },\n\t  // Override the default `computeVisibility` method to hide the tool if the label is not present.\n\t  computeVisibility() {\n\t    const visibility = Control.prototype.computeVisibility.apply(this, arguments);\n\t    return visibility && !!this.getLabel();\n\t  },\n\t  setPosition(view, coordinates) {\n\t    const model = view.model;\n\t    const label = this.getLabel();\n\t    if (!label) return;\n\t    const labelPosition = this.getLabelPosition(label);\n\t    const position = view.getLabelCoordinates(labelPosition);\n\t    const angle = 90 - position.theta(coordinates);\n\t    const index = this.getLabelIndex();\n\t    model.prop(['labels', index, 'position', 'angle'], angle);\n\t  },\n\t  resetPosition(view) {\n\t    const model = view.model;\n\t    const index = this.getLabelIndex();\n\t    model.prop(['labels', index, 'position', 'angle'], 0);\n\t  },\n\t  getLabelIndex() {\n\t    return this.options.labelIndex || 0;\n\t  },\n\t  getLabel() {\n\t    return this.relatedView.model.label(this.getLabelIndex()) || null;\n\t  },\n\t  getLabelPosition(label) {\n\t    const view = this.relatedView;\n\t    const labelPosition = view._normalizeLabelPosition(label.position);\n\t    return view._mergeLabelPositionProperty(labelPosition, view._getDefaultLabelPositionProperty());\n\t  }\n\t});\n\n\tconst Button = ToolView.extend({\n\t  name: 'button',\n\t  events: {\n\t    'mousedown': 'onPointerDown',\n\t    'touchstart': 'onPointerDown'\n\t  },\n\t  options: {\n\t    distance: 0,\n\t    offset: 0,\n\t    scale: null,\n\t    rotate: false\n\t  },\n\t  onRender: function () {\n\t    this.renderChildren(this.options.markup);\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    this.position();\n\t    return this;\n\t  },\n\t  position: function () {\n\t    const {\n\t      vel\n\t    } = this;\n\t    vel.transform(this.getCellMatrix(), {\n\t      absolute: true\n\t    });\n\t  },\n\t  getCellMatrix() {\n\t    return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();\n\t  },\n\t  getElementMatrix() {\n\t    const {\n\t      relatedView: view\n\t    } = this;\n\t    const toolOptions = getToolOptions(this);\n\t    let {\n\t      x = 0,\n\t      y = 0\n\t    } = toolOptions;\n\t    const {\n\t      useModelGeometry,\n\t      offset = {},\n\t      rotate,\n\t      scale,\n\t      relative\n\t    } = toolOptions;\n\t    let bbox = getViewBBox(view, {\n\t      useModelGeometry,\n\t      relative\n\t    });\n\t    const angle = view.model.angle();\n\t    if (!rotate) bbox = bbox.bbox(angle);\n\t    const {\n\t      x: offsetX = 0,\n\t      y: offsetY = 0\n\t    } = offset;\n\t    if (isPercentage(x)) {\n\t      x = parseFloat(x) / 100 * bbox.width;\n\t    } else if (isCalcExpression(x)) {\n\t      x = Number(evalCalcExpression(x, bbox));\n\t    }\n\t    if (isPercentage(y)) {\n\t      y = parseFloat(y) / 100 * bbox.height;\n\t    } else if (isCalcExpression(y)) {\n\t      y = Number(evalCalcExpression(y, bbox));\n\t    }\n\t    let matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\t    // With relative positioning, rotation is implicit\n\t    // (the tool rotates along with the element).\n\t    if (rotate && !relative) matrix = matrix.rotate(angle);\n\t    matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    return matrix;\n\t  },\n\t  getLinkMatrix() {\n\t    const {\n\t      relatedView: view,\n\t      options\n\t    } = this;\n\t    const {\n\t      offset = 0,\n\t      distance: distanceOpt = 0,\n\t      rotate,\n\t      scale\n\t    } = options;\n\t    const distance = typeof distanceOpt === 'function' ? distanceOpt.call(this, view, this) : distanceOpt;\n\t    let tangent, position, angle;\n\t    if (isPercentage(distance)) {\n\t      tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n\t    } else {\n\t      tangent = view.getTangentAtLength(distance);\n\t    }\n\t    if (tangent) {\n\t      position = tangent.start;\n\t      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n\t    } else {\n\t      position = view.getConnection().start;\n\t      angle = 0;\n\t    }\n\t    let matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);\n\t    if (!rotate) matrix = matrix.rotate(-angle);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    return matrix;\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    var actionFn = this.options.action;\n\t    if (typeof actionFn === 'function') {\n\t      actionFn.call(this.relatedView, evt, this.relatedView, this);\n\t    }\n\t  }\n\t});\n\tconst Remove = Button.extend({\n\t  name: 'remove',\n\t  children: [{\n\t    tagName: 'circle',\n\t    selector: 'button',\n\t    attributes: {\n\t      'r': 7,\n\t      'fill': '#FF1D00',\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'icon',\n\t    attributes: {\n\t      'd': 'M -3 -3 3 3 M -3 3 3 -3',\n\t      'fill': 'none',\n\t      'stroke': '#FFFFFF',\n\t      'stroke-width': 2,\n\t      'pointer-events': 'none'\n\t    }\n\t  }],\n\t  options: {\n\t    distance: 60,\n\t    offset: 0,\n\t    action: function (evt, view, tool) {\n\t      view.model.remove({\n\t        ui: true,\n\t        tool: tool.cid\n\t      });\n\t    }\n\t  }\n\t});\n\n\tconst Boundary = ToolView.extend({\n\t  name: 'boundary',\n\t  tagName: 'rect',\n\t  options: {\n\t    padding: 10,\n\t    useModelGeometry: false\n\t  },\n\t  attributes: {\n\t    'fill': 'none',\n\t    'stroke': '#33334F',\n\t    'stroke-width': .5,\n\t    'stroke-dasharray': '5, 5',\n\t    'pointer-events': 'none'\n\t  },\n\t  onRender: function () {\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    const {\n\t      relatedView: view,\n\t      vel\n\t    } = this;\n\t    const {\n\t      useModelGeometry,\n\t      rotate,\n\t      relative,\n\t      padding\n\t    } = getToolOptions(this);\n\t    const normalizedPadding = normalizeSides(padding);\n\t    let bbox = getViewBBox(view, {\n\t      useModelGeometry,\n\t      relative\n\t    }).moveAndExpand({\n\t      x: -normalizedPadding.left,\n\t      y: -normalizedPadding.top,\n\t      width: normalizedPadding.left + normalizedPadding.right,\n\t      height: normalizedPadding.top + normalizedPadding.bottom\n\t    });\n\t    const model = view.model;\n\t    // With relative positioning, rotation is implicit\n\t    // (the tool rotates along with the element).\n\t    if (model.isElement() && !relative) {\n\t      const angle = model.angle();\n\t      if (angle) {\n\t        if (rotate) {\n\t          const origin = model.getCenter();\n\t          vel.rotate(angle, origin.x, origin.y, {\n\t            absolute: true\n\t          });\n\t        } else {\n\t          bbox = bbox.bbox(angle);\n\t        }\n\t      }\n\t    }\n\t    vel.attr(bbox.toJSON());\n\t    return this;\n\t  }\n\t});\n\n\tconst Connect = Button.extend({\n\t  name: 'connect',\n\t  documentEvents: {\n\t    mousemove: 'drag',\n\t    touchmove: 'drag',\n\t    mouseup: 'dragend',\n\t    touchend: 'dragend',\n\t    touchcancel: 'dragend'\n\t  },\n\t  children: [{\n\t    tagName: 'circle',\n\t    selector: 'button',\n\t    attributes: {\n\t      'r': 7,\n\t      'fill': '#333333',\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'icon',\n\t    attributes: {\n\t      'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n\t      'fill': '#FFFFFF',\n\t      'stroke': 'none',\n\t      'stroke-width': 2,\n\t      'pointer-events': 'none'\n\t    }\n\t  }],\n\t  options: {\n\t    distance: 80,\n\t    offset: 0,\n\t    magnet: view => view.el,\n\t    action: (evt, _view, tool) => tool.dragstart(evt)\n\t  },\n\t  getMagnetNode: function () {\n\t    const {\n\t      options,\n\t      relatedView\n\t    } = this;\n\t    const {\n\t      magnet\n\t    } = options;\n\t    let magnetNode;\n\t    switch (typeof magnet) {\n\t      case 'function':\n\t        {\n\t          magnetNode = magnet.call(this, relatedView, this);\n\t          break;\n\t        }\n\t      case 'string':\n\t        {\n\t          magnetNode = relatedView.findNode(magnet);\n\t          break;\n\t        }\n\t      default:\n\t        {\n\t          magnetNode = magnet;\n\t          break;\n\t        }\n\t    }\n\t    if (!magnetNode) magnetNode = relatedView.el;\n\t    if (magnetNode instanceof SVGElement) return magnetNode;\n\t    throw new Error('Connect: magnet must be an SVGElement');\n\t  },\n\t  dragstart: function (evt) {\n\t    const {\n\t      paper,\n\t      relatedView\n\t    } = this;\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    const {\n\t      x,\n\t      y\n\t    } = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);\n\t    paper.undelegateEvents();\n\t    this.delegateDocumentEvents(null, normalizedEvent.data);\n\t    this.focus();\n\t  },\n\t  drag: function (evt) {\n\t    const {\n\t      paper,\n\t      relatedView\n\t    } = this;\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    const {\n\t      x,\n\t      y\n\t    } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    relatedView.dragLink(normalizedEvent, x, y);\n\t  },\n\t  dragend: function (evt) {\n\t    const {\n\t      paper,\n\t      relatedView\n\t    } = this;\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    const {\n\t      x,\n\t      y\n\t    } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    relatedView.dragLinkEnd(normalizedEvent, x, y);\n\t    this.undelegateDocumentEvents();\n\t    paper.delegateEvents();\n\t    this.blur();\n\t    relatedView.checkMouseleave(normalizedEvent);\n\t  }\n\t});\n\n\tconst HoverConnect$1 = Connect.extend({\n\t  name: 'hover-connect',\n\t  defaultMarkup: [{\n\t    tagName: 'circle',\n\t    attributes: {\n\t      'r': 7,\n\t      'fill': '#333333',\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    attributes: {\n\t      'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n\t      'fill': '#FFFFFF',\n\t      'stroke': 'none',\n\t      'stroke-width': 2\n\t    }\n\t  }],\n\t  children() {\n\t    const {\n\t      options,\n\t      defaultMarkup\n\t    } = this;\n\t    return [{\n\t      tagName: 'path',\n\t      selector: 'track',\n\t      attributes: {\n\t        'fill': 'none',\n\t        'stroke': 'transparent',\n\t        'stroke-width': options.trackWidth || 15,\n\t        'cursor': 'pointer'\n\t      }\n\t    }, {\n\t      tagName: 'g',\n\t      selector: 'button',\n\t      attributes: {\n\t        'pointer-events': 'none',\n\t        'display': 'none'\n\t      },\n\t      children: options.markup || defaultMarkup\n\t    }];\n\t  },\n\t  events: Object.assign({\n\t    mousemove: 'onMousemove',\n\t    mouseenter: 'onMouseenter',\n\t    mouseleave: 'onMouseleave'\n\t  }, Connect.prototype.events),\n\t  onRender: function () {\n\t    this.renderChildren();\n\t    this.update();\n\t  },\n\t  trackPath: null,\n\t  update() {\n\t    const {\n\t      childNodes\n\t    } = this;\n\t    this.trackPath = this.getTrackPath();\n\t    Connect.prototype.update.apply(this, arguments);\n\t    childNodes.track.setAttribute('d', this.trackPath.serialize());\n\t  },\n\t  position() {\n\t    const {\n\t      el,\n\t      childNodes\n\t    } = this;\n\t    childNodes.button.setAttribute('transform', V.matrixToTransformString(this.getButtonMatrix()));\n\t    el.setAttribute('transform', V.matrixToTransformString(this.getTrackMatrix()));\n\t  },\n\t  getButtonMatrix() {\n\t    const {\n\t      options,\n\t      trackPath\n\t    } = this;\n\t    const {\n\t      offset = 0,\n\t      distance = 0,\n\t      rotate,\n\t      scale\n\t    } = options;\n\t    let tangent, position, angle;\n\t    if (isPercentage(distance)) {\n\t      tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);\n\t    } else {\n\t      tangent = trackPath.tangentAtLength(distance);\n\t    }\n\t    if (tangent) {\n\t      position = tangent.start;\n\t      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n\t    } else {\n\t      position = trackPath.start;\n\t      angle = 0;\n\t    }\n\t    let matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);\n\t    if (!rotate) matrix = matrix.rotate(-angle);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    return matrix;\n\t  },\n\t  getTrackPath() {\n\t    return this.relatedView.getConnection();\n\t  },\n\t  getTrackMatrix() {\n\t    return V.createSVGMatrix();\n\t  },\n\t  getTrackMatrixAbsolute() {\n\t    return this.getTrackMatrix();\n\t  },\n\t  getTrackRatioFromEvent(evt) {\n\t    const {\n\t      relatedView,\n\t      trackPath\n\t    } = this;\n\t    const localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);\n\t    const trackPoint = V.transformPoint(localPoint, this.getTrackMatrixAbsolute().inverse());\n\t    return trackPath.closestPointLength(trackPoint);\n\t  },\n\t  canShowButton() {\n\t    // Has been the paper events undelegated? If so, we can't show the button.\n\t    // TODO: add a method to the paper to check if the events are delegated.\n\t    return $.event.has(this.paper.el);\n\t  },\n\t  showButton() {\n\t    this.childNodes.button.style.display = 'block';\n\t  },\n\t  hideButton() {\n\t    this.childNodes.button.style.display = '';\n\t  },\n\t  onMousemove(evt) {\n\t    const {\n\t      trackPath\n\t    } = this;\n\t    if (!trackPath) return;\n\t    const {\n\t      options\n\t    } = this;\n\t    options.distance = this.getTrackRatioFromEvent(evt);\n\t    this.position();\n\t  },\n\t  onMouseenter() {\n\t    if (!this.canShowButton()) return;\n\t    this.showButton();\n\t  },\n\t  onMouseleave() {\n\t    this.hideButton();\n\t  }\n\t});\n\n\tvar index$1 = {\n\t\t__proto__: null,\n\t\tBoundary: Boundary,\n\t\tButton: Button,\n\t\tConnect: Connect,\n\t\tControl: Control,\n\t\tHoverConnect: HoverConnect$1,\n\t\tRemove: Remove,\n\t\tRotateLabel: RotateLabel,\n\t\tSegments: Segments,\n\t\tSourceAnchor: SourceAnchor,\n\t\tSourceArrowhead: SourceArrowhead,\n\t\tTargetAnchor: TargetAnchor,\n\t\tTargetArrowhead: TargetArrowhead,\n\t\tVertices: Vertices\n\t};\n\n\tconst HoverConnect = HoverConnect$1.extend({\n\t  getTrackPath() {\n\t    const {\n\t      relatedView: view\n\t    } = this;\n\t    const {\n\t      useModelGeometry,\n\t      relative,\n\t      trackPath: initialTrackPath = 'M 0 0 H calc(w) V calc(h) H 0 Z'\n\t    } = getToolOptions(this);\n\t    let trackPath = initialTrackPath;\n\t    if (typeof trackPath === 'function') {\n\t      trackPath = trackPath.call(this, view);\n\t    }\n\t    if (isCalcExpression(trackPath)) {\n\t      const bbox = getViewBBox(view, {\n\t        useModelGeometry,\n\t        relative\n\t      });\n\t      trackPath = evalCalcExpression(trackPath, bbox);\n\t    }\n\t    return new Path$1(V.normalizePathData(trackPath));\n\t  },\n\t  getTrackMatrix() {\n\t    if (this.isOverlay()) return this.getTrackMatrixAbsolute();\n\t    return V.createSVGMatrix();\n\t  },\n\t  getTrackMatrixAbsolute() {\n\t    const {\n\t      relatedView: view\n\t    } = this;\n\t    const {\n\t      useModelGeometry,\n\t      rotate\n\t    } = getToolOptions(this);\n\t    let bbox = getViewBBox(view, {\n\t      useModelGeometry\n\t    });\n\t    const angle = view.model.angle();\n\t    if (!rotate) bbox = bbox.bbox(angle);\n\t    let matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\t    if (rotate) matrix = matrix.rotate(angle);\n\t    matrix = matrix.translate(-bbox.width / 2, -bbox.height / 2);\n\t    return matrix;\n\t  }\n\t});\n\n\tvar index = {\n\t\t__proto__: null,\n\t\tBoundary: Boundary,\n\t\tButton: Button,\n\t\tConnect: Connect,\n\t\tControl: Control,\n\t\tHoverConnect: HoverConnect,\n\t\tRemove: Remove\n\t};\n\n\tvar version = \"4.2.4\";\n\n\tconst Vectorizer = V;\n\tconst layout$1 = {\n\t  PortLabel,\n\t  Port\n\t};\n\tconst setTheme = function (theme, opt) {\n\t  opt = opt || {};\n\t  invoke(views, 'setTheme', theme, opt);\n\n\t  // Update the default theme on the view prototype.\n\t  View.prototype.defaultTheme = theme;\n\t};\n\n\tconst layout = {\n\t  PortLabel,\n\t  Port\n\t};\n\n\t// export empty namespaces - backward compatibility\n\tconst format = {};\n\tconst ui = {};\n\n\texports.V = V;\n\texports.Vectorizer = Vectorizer;\n\texports.anchors = anchors;\n\texports.config = config$3;\n\texports.connectionPoints = connectionPoints;\n\texports.connectionStrategies = index$3;\n\texports.connectors = connectors;\n\texports.dia = index$2;\n\texports.elementTools = index;\n\texports.env = env;\n\texports.format = format;\n\texports.g = g;\n\texports.highlighters = highlighters;\n\texports.layout = layout;\n\texports.linkAnchors = linkAnchors;\n\texports.linkTools = index$1;\n\texports.mvc = index$4;\n\texports.routers = routers;\n\texports.setTheme = setTheme;\n\texports.shapes = index$5;\n\texports.ui = ui;\n\texports.util = index$6;\n\texports.version = version;\n\n}));\nif (typeof joint !== 'undefined') { var g = joint.g, V = joint.V, Vectorizer = joint.V; }\n\n\n//# sourceURL=webpack://svg-experiment/./node_modules/@joint/core/dist/joint.js?\n}");

/***/ },

/***/ "./node_modules/perfect-freehand/dist/esm/index.mjs"
/*!**********************************************************!*\
  !*** ./node_modules/perfect-freehand/dist/esm/index.mjs ***!
  \**********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ z),\n/* harmony export */   getStroke: () => (/* binding */ R),\n/* harmony export */   getStrokeOutlinePoints: () => (/* binding */ P),\n/* harmony export */   getStrokePoints: () => (/* binding */ L)\n/* harmony export */ });\nconst{PI:e}=Math,t=e+1e-4,n=.5,r=[1,1];function i(e,t,n,r=e=>e){return e*r(.5-t*(.5-n))}const{min:a}=Math;function o(e,t,n){let r=a(1,t/n);return a(1,e+(a(1,1-r)-e)*(r*.275))}function s(e){return[-e[0],-e[1]]}function c(e,t){return[e[0]+t[0],e[1]+t[1]]}function l(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e}function u(e,t){return[e[0]-t[0],e[1]-t[1]]}function d(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e}function f(e,t){return[e[0]*t,e[1]*t]}function p(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e}function m(e,t){return[e[0]/t,e[1]/t]}function h(e){return[e[1],-e[0]]}function g(e,t){let n=t[0];return e[0]=t[1],e[1]=-n,e}function ee(e,t){return e[0]*t[0]+e[1]*t[1]}function _(e,t){return e[0]===t[0]&&e[1]===t[1]}function v(e){return Math.hypot(e[0],e[1])}function y(e,t){let n=e[0]-t[0],r=e[1]-t[1];return n*n+r*r}function b(e){return m(e,v(e))}function x(e,t){return Math.hypot(e[1]-t[1],e[0]-t[0])}function S(e,t,n){let r=Math.sin(n),i=Math.cos(n),a=e[0]-t[0],o=e[1]-t[1],s=a*i-o*r,c=a*r+o*i;return[s+t[0],c+t[1]]}function C(e,t,n,r){let i=Math.sin(r),a=Math.cos(r),o=t[0]-n[0],s=t[1]-n[1],c=o*a-s*i,l=o*i+s*a;return e[0]=c+n[0],e[1]=l+n[1],e}function w(e,t,n){return c(e,f(u(t,e),n))}function te(e,t,n,r){let i=n[0]-t[0],a=n[1]-t[1];return e[0]=t[0]+i*r,e[1]=t[1]+a*r,e}function T(e,t,n){return c(e,f(t,n))}const E=[0,0],D=[0,0],O=[0,0];function k(e,n){let r=T(e,b(h(u(e,c(e,[1,1])))),-n),i=[],a=1/13;for(let n=a;n<=1;n+=a)i.push(S(r,e,t*2*n));return i}function A(e,n,r){let i=[],a=1/r;for(let r=a;r<=1;r+=a)i.push(S(n,e,t*r));return i}function j(e,t,n){let r=u(t,n),i=f(r,.5),a=f(r,.51);return[u(e,i),u(e,a),c(e,a),c(e,i)]}function M(e,n,r,i){let a=[],o=T(e,n,r),s=1/i;for(let n=s;n<1;n+=s)a.push(S(o,e,t*3*n));return a}function ne(e,t,n){return[c(e,f(t,n)),c(e,f(t,n*.99)),u(e,f(t,n*.99)),u(e,f(t,n))]}function N(e,t,n){return e===!1||e===void 0?0:e===!0?Math.max(t,n):e}function re(e,t,n){return e.slice(0,10).reduce((e,r)=>{let i=r.pressure;return t&&(i=o(e,r.distance,n)),(e+i)/2},e[0].pressure)}function P(e,n={}){let{size:r=16,smoothing:a=.5,thinning:f=.5,simulatePressure:m=!0,easing:_=e=>e,start:v={},end:b={},last:x=!1}=n,{cap:S=!0,easing:w=e=>e*(2-e)}=v,{cap:T=!0,easing:P=e=>--e*e*e+1}=b;if(e.length===0||r<=0)return[];let F=e[e.length-1].runningLength,I=N(v.taper,r,F),L=N(b.taper,r,F),R=(r*a)**2,z=[],B=[],V=re(e,m,r),H=i(r,f,e[e.length-1].pressure,_),U,W=e[0].vector,G=e[0].point,K=G,q=G,J=K,Y=!1;for(let n=0;n<e.length;n++){let{pressure:a}=e[n],{point:s,vector:h,distance:v,runningLength:b}=e[n],x=n===e.length-1;if(!x&&F-b<3)continue;f?(m&&(a=o(V,v,r)),H=i(r,f,a,_)):H=r/2,U===void 0&&(U=H);let S=b<I?w(b/I):1,T=F-b<L?P((F-b)/L):1;H=Math.max(.01,H*Math.min(S,T));let k=(x?e[n]:e[n+1]).vector,A=x?1:ee(h,k),j=ee(h,W)<0&&!Y,M=A!==null&&A<0;if(j||M){g(E,W),p(E,E,H);for(let e=0;e<=1;e+=.07692307692307693)d(D,s,E),C(D,D,s,t*e),q=[D[0],D[1]],z.push(q),l(O,s,E),C(O,O,s,t*-e),J=[O[0],O[1]],B.push(J);G=q,K=J,M&&(Y=!0);continue}if(Y=!1,x){g(E,h),p(E,E,H),z.push(u(s,E)),B.push(c(s,E));continue}te(E,k,h,A),g(E,E),p(E,E,H),d(D,s,E),q=[D[0],D[1]],(n<=1||y(G,q)>R)&&(z.push(q),G=q),l(O,s,E),J=[O[0],O[1]],(n<=1||y(K,J)>R)&&(B.push(J),K=J),V=a,W=h}let X=[e[0].point[0],e[0].point[1]],Z=e.length>1?[e[e.length-1].point[0],e[e.length-1].point[1]]:c(e[0].point,[1,1]),Q=[],$=[];if(e.length===1){if(!(I||L)||x)return k(X,U||H)}else{I||L&&e.length===1||(S?Q.push(...A(X,B[0],13)):Q.push(...j(X,z[0],B[0])));let t=h(s(e[e.length-1].vector));L||I&&e.length===1?$.push(Z):T?$.push(...M(Z,t,H,29)):$.push(...ne(Z,t,H))}return z.concat($,B.reverse(),Q)}const F=[0,0];function I(e){return e!=null&&e>=0}function L(e,t={}){let{streamline:i=.5,size:a=16,last:o=!1}=t;if(e.length===0)return[];let s=.15+(1-i)*.85,l=Array.isArray(e[0])?e:e.map(({x:e,y:t,pressure:r=n})=>[e,t,r]);if(l.length===2){let e=l[1];l=l.slice(0,-1);for(let t=1;t<5;t++)l.push(w(l[0],e,t/4))}l.length===1&&(l=[...l,[...c(l[0],r),...l[0].slice(2)]]);let u=[{point:[l[0][0],l[0][1]],pressure:I(l[0][2])?l[0][2]:.25,vector:[...r],distance:0,runningLength:0}],f=!1,p=0,m=u[0],h=l.length-1;for(let e=1;e<l.length;e++){let t=o&&e===h?[l[e][0],l[e][1]]:w(m.point,l[e],s);if(_(m.point,t))continue;let r=x(t,m.point);if(p+=r,e<h&&!f){if(p<a)continue;f=!0}d(F,m.point,t),m={point:t,pressure:I(l[e][2])?l[e][2]:n,vector:b(F),distance:r,runningLength:p},u.push(m)}return u[0].vector=u[1]?.vector||[0,0],u}function R(e,t={}){return P(L(e,t),t)}var z=R;\n//# sourceMappingURL=index.mjs.map\n\n//# sourceURL=webpack://svg-experiment/./node_modules/perfect-freehand/dist/esm/index.mjs?\n}");

/***/ },

/***/ "./src/index.js"
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var perfect_freehand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! perfect-freehand */ \"./node_modules/perfect-freehand/dist/esm/index.mjs\");\n/* harmony import */ var _joint_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @joint/core */ \"./node_modules/@joint/core/dist/joint.js\");\n\r\n\r\nconst { TangentDirections } = _joint_core__WEBPACK_IMPORTED_MODULE_1__.connectors.curve;\r\nconst borderWidth = 4;\r\nconst speciesSize = 100;\r\nconst colors = {\r\n    fg: '#ed2637',\r\n    bg: '#FFFFFF',\r\n    text: '#000000',\r\n    border: '#ed2637',\r\n    link: '#FFFFFF',\r\n    highlight: '#f7a1a8',\r\n};\r\nclass Species extends _joint_core__WEBPACK_IMPORTED_MODULE_1__.dia.Element {\r\n    defaults() {\r\n        return {\r\n            ...super.defaults,\r\n            type: 'Species',\r\n            z: 2,\r\n            size: {\r\n                width: speciesSize,\r\n                height: speciesSize,\r\n            },\r\n            attrs: {\r\n                root: {\r\n                    magnetSelector: 'border',\r\n                },\r\n                border: {\r\n                    fill: colors.bg,\r\n                    stroke: colors.bg,\r\n                    strokeWidth: 2,\r\n                    rx: 'calc(w/2)',\r\n                    ry: 'calc(h/2)',\r\n                    cx: 'calc(w/2)',\r\n                    cy: 'calc(h/2)',\r\n                },\r\n                innerBorder: {\r\n                    fill: colors.bg,\r\n                    stroke: colors.fg,\r\n                    strokeWidth: 4,\r\n                    rx: `calc(w/2 - ${borderWidth})`,\r\n                    ry: `calc(h/2 - ${borderWidth})`,\r\n                    cx: 'calc(w/2)',\r\n                    cy: 'calc(h/2)',\r\n                },\r\n                icon: {\r\n                    width: 'calc(3 * w / 4)',\r\n                    height: 'calc(3 * h / 4)',\r\n                    x: 'calc(w / 8)',\r\n                    y: 'calc(h / 8)',\r\n                },\r\n                labelPath: {\r\n                    d: 'M -10 calc(h/2) A 20 20 0 0 0 calc(w + 10) calc(h / 2)',\r\n                    stroke: 'none',\r\n                    fill: 'none',\r\n                },\r\n                label: {\r\n                    textPath: { selector: 'labelPath' },\r\n                    text: '',\r\n                    fontWeight: 'bold',\r\n                    fontSize: 16,\r\n                    fontFamily: 'sans-serif',\r\n                    fill: colors.text,\r\n                    stroke: colors.bg,\r\n                    strokeWidth: 5,\r\n                    paintOrder: 'stroke',\r\n                    textVerticalAnchor: 'top',\r\n                    textAnchor: 'middle',\r\n                    letterSpacing: 5,\r\n                    // Quarter of the circumference of the circle\r\n                    // 2 * Ï * (r + border) / 4\r\n                    // Moves the anchor of the text to the center of the `labelPath`.\r\n                    x: (2 * Math.PI * (speciesSize / 2 + 10)) / 4,\r\n                },\r\n            },\r\n        };\r\n    }\r\n    preinitialize() {\r\n        this.markup = [\r\n            {\r\n                tagName: 'ellipse',\r\n                selector: 'border',\r\n            },\r\n            {\r\n                tagName: 'ellipse',\r\n                selector: 'innerBorder',\r\n            },\r\n            {\r\n                tagName: 'image',\r\n                selector: 'icon',\r\n            },\r\n            {\r\n                tagName: 'path',\r\n                selector: 'labelPath',\r\n            },\r\n            {\r\n                tagName: 'text',\r\n                selector: 'label',\r\n            },\r\n        ];\r\n    }\r\n}\r\nclass Branch extends _joint_core__WEBPACK_IMPORTED_MODULE_1__.dia.Link {\r\n    defaults() {\r\n        return {\r\n            ...super.defaults,\r\n            type: 'Branch',\r\n            z: 1,\r\n            attrs: {\r\n                line: {\r\n                    // Native SVG Attributes\r\n                    fill: colors.link,\r\n                    stroke: '#000000',\r\n                    strokeWidth: 3,\r\n                    // Custom attributes\r\n                    organicStroke: true,\r\n                    organicStrokeSize: 20,\r\n                    organicStrokeThinning:0,\r\n                },\r\n            },\r\n        };\r\n    }\r\n    preinitialize() {\r\n        this.markup = [\r\n            {\r\n                tagName: 'path',\r\n                selector: 'line',\r\n            },\r\n        ];\r\n        this.defaultLabel = {\r\n            attrs: {\r\n                labelText: {\r\n                    fontSize: 14,\r\n                    fontFamily: 'sans-serif',\r\n                    letterSpacing: 5,\r\n                    fill: colors.text,\r\n                    textAnchor: 'middle',\r\n                    textVerticalAnchor: 'middle',\r\n                },\r\n                labelBackground: {\r\n                    fill: colors.bg,\r\n                    stroke: colors.border,\r\n                    strokeWidth: 3,\r\n                    rx: 4,\r\n                    ry: 4,\r\n                    ref: 'labelText',\r\n                    x: 'calc(x - 10)',\r\n                    y: 'calc(y - 10)',\r\n                    width: 'calc(w + 20)',\r\n                    height: 'calc(h + 20)',\r\n                },\r\n                line: {\r\n                    d: 'M 0 0 Q 0 50 -60 60',\r\n                    fill: 'none',\r\n                    stroke: colors.border,\r\n                    strokeWidth: 2,\r\n                    targetMarker: {\r\n                        type: 'circle',\r\n                        r: 4,\r\n                    },\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.5,\r\n                offset: {\r\n                    x: 70,\r\n                    y: -50,\r\n                },\r\n            },\r\n            markup: [\r\n                {\r\n                    tagName: 'path',\r\n                    selector: 'line',\r\n                },\r\n                {\r\n                    tagName: 'rect',\r\n                    selector: 'labelBackground',\r\n                },\r\n                {\r\n                    tagName: 'text',\r\n                    selector: 'labelText',\r\n                },\r\n            ],\r\n        };\r\n    }\r\n    static attributes = {\r\n        // The `organicStroke` attribute is used to set the `d` attribute of the `<path>` element.\r\n        // It works similarly to the `connection` attribute of JointJS.\r\n        'organic-stroke': {\r\n            set: function (\r\n                _value,\r\n                _refBBox,\r\n                _node,\r\n                attrs\r\n            ) {\r\n                if (!this.model.isLink()) {\r\n                    throw new Error('The `organicStroke` attribute can only be used with links.');\r\n                }\r\n                // The path of the link as returned by the `connector`.\r\n                const path = this.getConnection();\r\n                const segmentSubdivisions = this.getConnectionSubdivisions();\r\n                // Convert polylines to points and add the pressure value to each point.\r\n                const polylines = path.toPolylines({ segmentSubdivisions });\r\n                let points = [];\r\n                polylines.forEach((polyline) => {\r\n                    const maxIndex = polyline.points.length - 1;\r\n                    polyline.points.forEach((point, index) => {\r\n                        points.push([\r\n                            point.x,\r\n                            point.y,\r\n                            organicStyle(index, maxIndex),\r\n                        ]);\r\n                    });\r\n                });\r\n                // Using the `getStroke` function from the `perfect-freehand` library,\r\n                // we get the points that represent the outline of the stroke.\r\n                const outlinePoints = (0,perfect_freehand__WEBPACK_IMPORTED_MODULE_0__.getStroke)(points, {\r\n                    size: attrs['organic-stroke-size'] || 20,\r\n                    thinning: attrs['organic-stroke-thinning'] ?? 0, // <-- read from attrs\r\n                    simulatePressure: false,\r\n                    last: true,\r\n                });\r\n                // How to interpolate the points to get the outline?\r\n                const d = quadraticInterpolation(outlinePoints);\r\n                // The `d` attribute is set on the `node` element.\r\n                return { d };\r\n            },\r\n            unset: 'd'\r\n        },\r\n        // Empty attributes definition to prevent the attribute from being set on the element.\r\n        // They are only meant to be used in the `organicStroke` function.\r\n        'organic-stroke-size': {},\r\n        'organic-stroke-thinning': {}, // <-- new attribute\r\n    };\r\n}\r\n// Stroke Style\r\n// ------------\r\nconst time = (index, maxIndex) => index / maxIndex;\r\n// It gradually decrease the pressure from 1 to 0. This means that the stroke\r\n// will be thinner at the end.\r\nconst organicStyle = (index, maxIndex) => {\r\n    return 1 - time(index, maxIndex);\r\n};\r\n// Points Interpolation\r\n// --------------------\r\nconst average = (a, b) => (a + b) / 2;\r\n// Alternatively, a linear or a cubic interpolation can be used.\r\nfunction quadraticInterpolation(points) {\r\n    const len = points.length;\r\n    if (len < 4) {\r\n        return '';\r\n    }\r\n    let [a, b, c] = points;\r\n    let result = `\r\n    M${a[0].toFixed(2)},${a[1].toFixed(2)}\r\n    Q${b[0].toFixed(2)},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(\r\n        2\r\n    )},${average(b[1], c[1]).toFixed(2)}\r\n    T\r\n`;\r\n    for (let i = 2, max = len - 1; i < max; i++) {\r\n        a = points[i];\r\n        b = points[i + 1];\r\n        result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `;\r\n    }\r\n    result += 'Z';\r\n    return result;\r\n}\r\n// Rotate Tool\r\n// -----------\r\nconst RotateTool = _joint_core__WEBPACK_IMPORTED_MODULE_1__.elementTools.Control.extend({\r\n    children: [\r\n        {\r\n            tagName: 'g',\r\n            selector: 'handle',\r\n            children: [\r\n                {\r\n                    tagName: 'circle',\r\n                    attributes: {\r\n                        r: 15,\r\n                        fill: colors.bg,\r\n                    },\r\n                },\r\n                {\r\n                    tagName: 'image',\r\n                    attributes: {\r\n                        cursor: 'pointer',\r\n                        x: -10,\r\n                        y: -10,\r\n                        width: 20,\r\n                        height: 20,\r\n                        'xlink:href': 'assets/rotate.svg',\r\n                    },\r\n                },\r\n            ],\r\n        },\r\n    ],\r\n    getPosition: function (view) {\r\n        const { model } = view;\r\n        const { width } = model.size();\r\n        return new _joint_core__WEBPACK_IMPORTED_MODULE_1__.g.Point(width, 0);\r\n    },\r\n    setPosition: function (view, coordinates) {\r\n        const { model } = view;\r\n        const { width, height } = model.size();\r\n        const center = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.g.Point(width / 2, height / 2);\r\n        const angle = center.angleBetween(coordinates, this.getPosition(view));\r\n        model.rotate(Math.round(angle));\r\n    },\r\n});\r\n// Application\r\n// -----------\r\nconst shapeNamespace = {\r\n    ..._joint_core__WEBPACK_IMPORTED_MODULE_1__.shapes,\r\n    Species,\r\n    Branch,\r\n};\r\nconst graph = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.dia.Graph({}, { cellNamespace: shapeNamespace });\r\nconst undoStack = [];\r\nconst redoStack = [];\r\nlet isRestoring = false;\r\nlet batchOperations = [];\r\n\r\n// Push meaningful operations during a batch\r\nfunction pushOperation(op) {\r\n    batchOperations.push(op);\r\n}\r\n\r\n// Commit operations after batch:stop\r\ngraph.on('batch:stop', () => {\r\n    if (isRestoring || batchOperations.length === 0) return;\r\n    undoStack.push([...batchOperations]);\r\n    redoStack.length = 0;\r\n    batchOperations = [];\r\n});\r\n\r\n// --- UNDO ---\r\nfunction undo() {\r\n    if (!undoStack.length) return;\r\n    isRestoring = true;\r\n\r\n    const ops = undoStack.pop();\r\n    const reversedOps = [...ops].reverse();\r\n\r\n    reversedOps.forEach(op => {\r\n        // if (op.type === 'snapshot') {\r\n        //     //graph.clear();               // remove all current cells\r\n        //     //graph.fromJSON(op.before);   // restore previous snapshot\r\n        //     restoreFromSnapshot(graph, op.before,shapeNamespace); // restore manually\r\n        //     refreshPaper();\r\n        //     return; // skip other operations\r\n        // }\r\n        switch (op.type) {\r\n            case 'snapshot':\r\n                restoreFromSnapshot(graph, op.before,shapeNamespace); // restore manually\r\n                refreshPaper();\r\n                break;\r\n            case 'addElement': op.element.remove(); break;\r\n            case 'removeElement': graph.addCell(op.element); break;\r\n            case 'moveElement': \r\n                op.element.position(op.from.x, op.from.y);\r\n                break;\r\n            case 'moveAttachment':\r\n                const attUndo = op.element.get('linkAttachment');\r\n                op.element.set('linkAttachment', {\r\n                    ...attUndo,\r\n                    ratio: op.from\r\n                });\r\n                updateRectanglePosition(op.element);\r\n                break;\r\n            case 'addLink':\r\n                op.link.remove(); \r\n                // if(undoStack.length>1){\r\n                //     op.link.remove(); \r\n                // }\r\n                break;\r\n            case 'removeLink': graph.addCell(op.link); break;\r\n            case 'moveVertices': op.link.set('vertices', op.from); break;\r\n            case 'changeLabelText':\r\n                op.cell.label(op.labelIndex, {\r\n                    ...op.cell.get('labels')[op.labelIndex],\r\n                    attrs: { labelText: { text: op.from } },\r\n                });\r\n                break;\r\n            case 'moveLabel':\r\n                op.cell.label(op.labelIndex, {\r\n                    ...op.cell.get('labels')[op.labelIndex],\r\n                    position: op.from,\r\n                });\r\n                break;\r\n            case 'changeSource':\r\n                op.link.set('source', op.from);\r\n                break;\r\n            case 'changeTarget':\r\n                op.link.set('target', op.from);\r\n                break;\r\n\r\n        }\r\n    });\r\n\r\n    redoStack.push(ops);\r\n    isRestoring = false;\r\n}\r\nfunction restoreFromSnapshot(graph, snapshot, shapeNamespace) {\r\n    if (!snapshot || !snapshot.cells) return;\r\n    \r\n    // 1ï¸â£ Clear current graph\r\n    graph.clear();\r\n\r\n    const cellsMap = new Map(); // ID -> cell\r\n\r\n    // 2ï¸â£ Recreate all elements and links\r\n    snapshot.cells.forEach(data => {\r\n        let cell;\r\n\r\n        if (data.type && data.type.includes('link')) {\r\n            // Link\r\n            cell = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.dia.Link(data);\r\n        } else {\r\n            // Element: use correct class from shapeNamespace\r\n            const ElementClass = shapeNamespace[data.type];\r\n            if (!ElementClass) {\r\n                switch (data.type) {\r\n                    case 'standard.Rectangle':\r\n                        cell = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.shapes.standard.Rectangle(data);\r\n                        break;\r\n                    case 'standard.Circle':\r\n                        cell = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.shapes.standard.Circle(data);\r\n                        break;\r\n                    case 'standard.Ellipse':\r\n                        cell = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.shapes.standard.Ellipse(data);\r\n                        break;\r\n                    default:\r\n                        console.warn(`Shape class \"${data.type}\" not found. Using joint.dia.Element as fallback.`);\r\n                        cell = new (ElementClass || _joint_core__WEBPACK_IMPORTED_MODULE_1__.dia.Element)(data);\r\n                }\r\n            }else{\r\n                cell = new ElementClass(data);\r\n            }\r\n            \r\n        }\r\n\r\n        graph.addCell(cell);\r\n        cellsMap.set(data.id, cell);\r\n    });\r\n\r\n    // 3ï¸â£ Restore vertices and labels\r\n    graph.getLinks().forEach(link => {\r\n        const data = snapshot.cells.find(c => c.id === link.id);\r\n        if (!data) return;\r\n\r\n        link.set('vertices', (data.vertices || []).map(v => ({ ...v })));\r\n        link.set('labels', (data.labels || []).map(l => ({ ...l })));\r\n    });\r\n\r\n    // 4ï¸â£ Restore source and target\r\n    graph.getLinks().forEach(link => {\r\n        const data = snapshot.cells.find(c => c.id === link.id);\r\n        if (!data) return;\r\n\r\n        link.set({\r\n            source: { ...data.source },\r\n            target: { ...data.target }\r\n        });\r\n    });\r\n\r\n    // 5ï¸â£ Restore z-index\r\n    graph.getCells().forEach(cell => {\r\n        const data = snapshot.cells.find(c => c.id === cell.id);\r\n        if (data && data.z != null) {\r\n            cell.set('z', data.z);\r\n        }\r\n    });\r\n\r\n    // 6ï¸â£ Reattach child links to parent links\r\n    graph.getLinks().forEach(link => {\r\n        const data = snapshot.cells.find(c => c.id === link.id);\r\n        if (!data) return;\r\n\r\n        const children = snapshot.cells.filter(c => c.source && c.source.id === link.id);\r\n        children.forEach(childData => {\r\n            const child = cellsMap.get(childData.id);\r\n            if (child) {\r\n                child.set('source', { id: link.id, anchor: childData.source.anchor });\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\n// --- REDO ---\r\nfunction redo() {\r\n    if (!redoStack.length) return;\r\n    isRestoring = true;\r\n\r\n    const ops = redoStack.pop();\r\n    ops.forEach(op => {\r\n        // if (op.type === 'snapshot') {\r\n        //     //graph.clear();\r\n        //     //graph.fromJSON(op.after);  // restore snapshot after the operation\r\n        //     restoreFromSnapshot(graph, op.after,shapeNamespace); \r\n        //     refreshPaper();\r\n        //     return;\r\n        // }\r\n        switch (op.type) {\r\n            case 'snapshot':\r\n                restoreFromSnapshot(graph, op.after,shapeNamespace); \r\n                refreshPaper();\r\n                break;\r\n            case 'addElement': graph.addCell(op.element); break;\r\n            case 'removeElement': op.element.remove(); break;\r\n            case 'moveElement': \r\n                op.element.position(op.to.x, op.to.y);\r\n                break;\r\n            case 'moveAttachment':\r\n                const attRedo = op.element.get('linkAttachment');\r\n                op.element.set('linkAttachment', {\r\n                    ...attRedo,\r\n                    ratio: op.to\r\n                });\r\n                updateRectanglePosition(op.element);\r\n                break;\r\n\r\n            case 'addLink': graph.addCell(op.link); break;\r\n            case 'removeLink': op.link.remove(); break;\r\n            case 'moveVertices': op.link.set('vertices', op.to); break;\r\n            case 'changeLabelText':\r\n                op.cell.label(op.labelIndex, {\r\n                    ...op.cell.get('labels')[op.labelIndex],\r\n                    attrs: { labelText: { text: op.to } },\r\n                });\r\n                break;\r\n            case 'moveLabel':\r\n                op.cell.label(op.labelIndex, {\r\n                    ...op.cell.get('labels')[op.labelIndex],\r\n                    position: op.to,\r\n                });\r\n                break;\r\n            case 'changeSource':\r\n                op.link.set('source', op.to);\r\n                break;\r\n            case 'changeTarget':\r\n                op.link.set('target', op.to);\r\n                break;\r\n\r\n        }\r\n    });\r\n\r\n    undoStack.push(ops);\r\n    isRestoring = false;\r\n}\r\n\r\n// --- Keyboard shortcuts ---\r\ndocument.addEventListener('keydown', e => {\r\n    const key = e.key.toLowerCase();\r\n    // Undo\r\n    if ((e.ctrlKey || e.metaKey) && key === 'z' && !e.shiftKey) {\r\n        e.preventDefault();\r\n        undo();\r\n    }\r\n    // Redo\r\n    if ((e.ctrlKey || e.metaKey) && ((key === 'y') || (e.shiftKey && key === 'z'))) {\r\n        e.preventDefault();\r\n        redo();\r\n    }\r\n});\r\n\r\n\r\n// --- Track meaningful operations ---\r\ngraph.on('add', cell => {\r\n    if (isRestoring) return;\r\n    if (cell.isElement()) pushOperation({ type: 'addElement', element: cell });\r\n    if (cell.isLink()) pushOperation({ type: 'addLink', link: cell });\r\n});\r\n\r\ngraph.on('remove', cell => {\r\n    if (isRestoring) return;\r\n    if (cell.isElement()) pushOperation({ type: 'removeElement', element: cell });\r\n    if (cell.isLink()) pushOperation({ type: 'removeLink', link: cell });\r\n});\r\n\r\ngraph.on('change:position', cell => {\r\n    if (isRestoring || !cell.isElement()) return;\r\n    if (cell.get('linkAttachment')) return;\r\n    const prev = cell.previous('position');\r\n    const curr = cell.position();\r\n    if (!prev || (prev.x === curr.x && prev.y === curr.y)) return;\r\n\r\n    pushOperation({\r\n        type: 'moveElement',\r\n        element: cell,\r\n        from: prev,\r\n        to: { ...curr },\r\n    });\r\n});\r\n\r\ngraph.on('change:vertices', link => {\r\n    if (isRestoring) return;\r\n    const prev = link.previous('vertices') || [];\r\n    const curr = link.get('vertices') || [];\r\n    if (JSON.stringify(prev) !== JSON.stringify(curr)) {\r\n        pushOperation({\r\n            type: 'moveVertices',\r\n            link,\r\n            from: prev.map(v => ({ ...v })),\r\n            to: curr.map(v => ({ ...v })),\r\n        });\r\n    }\r\n    graph.getElements().forEach(el => {\r\n        const attachment = el.get('linkAttachment');\r\n        if (attachment && attachment.linkId === link.id) {\r\n            updateRectanglePosition(el);\r\n        }\r\n    });\r\n});\r\ngraph.on('change:labels', link => {\r\n    if (isRestoring || !link.isLink()) return;\r\n\r\n    const prevLabels = link.previous('labels') || [];\r\n    const currLabels = link.get('labels') || [];\r\n\r\n    currLabels.forEach((lbl, i) => {\r\n        const prev = prevLabels[i] || {};\r\n        const curr = lbl || {};\r\n\r\n        // Text change\r\n        const prevText = prev.attrs?.labelText?.text || '';\r\n        const currText = curr.attrs?.labelText?.text || '';\r\n        if (prevText !== currText) {\r\n            pushOperation({\r\n                type: 'changeLabelText',\r\n                cell: link,\r\n                labelIndex: i,\r\n                from: prevText,\r\n                to: currText,\r\n            });\r\n        }\r\n\r\n        // Label position change\r\n        const prevPos = prev.position || {};\r\n        const currPos = curr.position || {};\r\n        if (prevPos.distance !== currPos.distance || prevPos.angle !== currPos.angle) {\r\n            pushOperation({\r\n                type: 'moveLabel',\r\n                cell: link,\r\n                labelIndex: i,\r\n                from: { ...prevPos },\r\n                to: { ...currPos },\r\n            });\r\n        }\r\n    });\r\n});\r\ngraph.on('change:source change:target', function (link) {\r\n\r\n    if (isRestoring || !link.isLink()) return;\r\n\r\n    const prevSource = link.previous('source');\r\n    const currSource = link.get('source');\r\n\r\n    const prevTarget = link.previous('target');\r\n    const currTarget = link.get('target');\r\n\r\n    // Track source anchor move\r\n    if (prevSource && JSON.stringify(prevSource) !== JSON.stringify(currSource)) {\r\n        pushOperation({\r\n            type: 'changeSource',\r\n            link: link,\r\n            from: { ...prevSource },\r\n            to: { ...currSource }\r\n        });\r\n    }\r\n\r\n    // Track target anchor move\r\n    if (prevTarget && JSON.stringify(prevTarget) !== JSON.stringify(currTarget)) {\r\n        pushOperation({\r\n            type: 'changeTarget',\r\n            link: link,\r\n            from: { ...prevTarget },\r\n            to: { ...currTarget }\r\n        });\r\n    }\r\n    graph.getElements().forEach(el => {\r\n        const attachment = el.get('linkAttachment');\r\n        if (attachment && attachment.linkId === link.id) {\r\n            updateRectanglePosition(el);\r\n        }\r\n    });\r\n});\r\n\r\n\r\nconst paper = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.dia.Paper({\r\n    el: document.getElementById('paper'),\r\n    width: '100%',\r\n    height: '100%',\r\n    model: graph,\r\n    frozen: true,\r\n    async: true,\r\n    overflow: true,\r\n    cellViewNamespace: shapeNamespace,\r\n    clickThreshold: 0,\r\n    interactive: {\r\n        labelMove: true,\r\n        linkMove: false,\r\n        stopDelegation: false,\r\n        linkDelete: false,\r\n    },\r\n    snapLabels: true,\r\n    labelsLayer: true,\r\n    background: {\r\n        color: colors.bg,\r\n    },\r\n    defaultConnector: {\r\n        name: 'curve',\r\n        args: {\r\n            sourceDirection: TangentDirections.OUTWARDS,\r\n            targetDirection: TangentDirections.OUTWARDS,\r\n        },\r\n    },\r\n    defaultConnectionPoint: {\r\n        name: 'boundary',\r\n        args: {\r\n            selector: false,\r\n        },\r\n    },\r\n});\r\npaper.el.addEventListener('contextmenu', (evt) => {\r\n    // Stop browser menu immediately\r\n    evt.preventDefault();\r\n    evt.stopPropagation();\r\n    // Find the JointJS view under this event\r\n    const view = paper.findView(evt.target);\r\n    if (!view) return;\r\n    // Only proceed if itâs a link\r\n    if (!view.model.isLink()) return;\r\n    menuOpen = true;\r\n    const toolsView = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.dia.ToolsView({\r\n        tools: [new _joint_core__WEBPACK_IMPORTED_MODULE_1__.linkTools.Vertices()]\r\n    });\r\n    view.addTools(toolsView);\r\n    // Get the vertex index under the mouse\r\n    //const vertexIndex = view.getVertexIndex(evt.target);\r\n    const point = paper.clientToLocalPoint({\r\n        x: evt.clientX,\r\n        y: evt.clientY\r\n    });\r\n    const vertexIndex = getVertexIndexFromMouse(view, paper, evt);\r\n    //if (vertexIndex === -1) return; // Not a vertex\r\n    if (vertexIndex === -1) {\r\n        // ð Right-click on link body\r\n        // showLinkColorMenu({\r\n        //     x: evt.clientX,\r\n        //     y: evt.clientY,\r\n        //     linkView: view\r\n        // });\r\n        const segmentIndex = getNearestSegmentIndex(view, paper, evt);\r\n        if (segmentIndex !== -1) {\r\n            showLinkColorMenu({\r\n                x: evt.clientX,\r\n                y: evt.clientY,\r\n                linkView: view,\r\n                segmentIndex\r\n            });\r\n        }\r\n    } else {\r\n        // Show your custom menu\r\n        showVertexMenu({\r\n            x: evt.clientX,\r\n            y: evt.clientY,\r\n            linkView: view,\r\n            vertexIndex\r\n        });\r\n    }\r\n});\r\nfunction distancePointToSegment(p, a, b) {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    if (dx === 0 && dy === 0) return Math.hypot(p.x - a.x, p.y - a.y);\r\n    const t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / (dx * dx + dy * dy);\r\n    const clampedT = Math.max(0, Math.min(1, t));\r\n    const closestX = a.x + clampedT * dx;\r\n    const closestY = a.y + clampedT * dy;\r\n    return Math.hypot(p.x - closestX, p.y - closestY);\r\n}\r\nfunction getNearestSegmentIndex(linkView, paper, evt, tolerance = 150) {\r\n    const vertices = linkView.model.vertices() || [];\r\n    const points = [linkView.sourcePoint, ...vertices, linkView.targetPoint];\r\n    const mouse = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\r\n    let minDist = Infinity;\r\n    let segmentIndex = -1;\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n        const dist = distancePointToSegment(mouse, points[i], points[i + 1]);\r\n        if (dist < tolerance && dist < minDist) {\r\n            minDist = dist;\r\n            segmentIndex = i;\r\n        }\r\n    }\r\n    return segmentIndex;\r\n}\r\n// === Segment coloring ===\r\n// function colorSegment(linkView, segmentIndex, color) {\r\n//     const originalLink = linkView.model;\r\n//     const vertices = originalLink.vertices() || [];\r\n//     const points = [\r\n//         linkView.sourcePoint,\r\n//         ...vertices,\r\n//         linkView.targetPoint\r\n//     ];\r\n//     const start = points[segmentIndex];\r\n//     const end = points[segmentIndex + 1];\r\n//     const strokeWidth =\r\n//         originalLink.attr('line/organicStrokeSize') ||\r\n//         originalLink.attr('line/stroke-width') ||\r\n//         3;\r\n//     const overlay = new Branch({\r\n//         source: { x: start.x, y: start.y },\r\n//         target: { x: end.x, y: end.y },\r\n//         // // ð´ VERY IMPORTANT\r\n//         // router: null,\r\n//         // connector: { name: 'curve' },\r\n//         // connectionPoint: null,\r\n//         attrs: {\r\n//             line: {\r\n//                 fill:color,\r\n//                 organicStrokeSize:originalLink.attr('line/organicStrokeSize')\r\n//                 // stroke: color,\r\n//                 // 'stroke-width': strokeWidth,\r\n//                 // 'stroke-linecap': 'butt',   // no rounding\r\n//                 // 'stroke-linejoin': 'miter',\r\n//                 //'pointer-events': 'none'   // no interaction padding\r\n//             }\r\n//         }\r\n//     });\r\n//     // overlay.set({\r\n//     //     z: originalLink.get('z') + 1,\r\n//     //     interactive: false   // no tools, no hover\r\n//     // });\r\n//     originalLink.graph.addCell(overlay);\r\n// }\r\nfunction splitLinkWithChildren(linkView, coloredSegmentIndex, color) {\r\n    const graph = linkView.model.graph;\r\n    const original = linkView.model;\r\n    const vertices = original.vertices() || [];\r\n    const points = [\r\n        linkView.sourcePoint,\r\n        ...vertices,\r\n        linkView.targetPoint\r\n    ];\r\n    const source = original.get('source');\r\n    const target = original.get('target');\r\n    const router = original.get('router');\r\n    const connector = original.get('connector');\r\n    const baseLineAttrs = original.attr('line') || {};\r\n    const z = original.get('z') || 1;\r\n    const segments = [];\r\n    const segmentCount = points.length - 1;\r\n    // 1ï¸â£ create segments\r\n    for (let i = 0; i < segmentCount; i++) {\r\n        const link = new Branch({\r\n            source: i === 0\r\n                ? source\r\n                : { x: points[i].x, y: points[i].y },\r\n            target: i === segmentCount - 1\r\n                ? target\r\n                : { x: points[i + 1].x, y: points[i + 1].y },\r\n            router,\r\n            connector,\r\n            attrs: {\r\n                line: {\r\n                    ...baseLineAttrs,\r\n                    ...(i === coloredSegmentIndex ? { fill: color } : {}),\r\n                    ...(i === segmentCount - 1 && baseLineAttrs.organicStrokeThinning > 0\r\n                        ? { organicStrokeThinning: baseLineAttrs.organicStrokeThinning }\r\n                        : {organicStrokeThinning:0,organicStrokeSize:30})\r\n                }\r\n            }\r\n        });\r\n        link.set({ z });\r\n        segments.push(link);\r\n    }\r\n    // 2ï¸â£ find children of original link\r\n    const children = graph.getConnectedLinks(original, { outbound: true });\r\n    // 3ï¸â£ reattach children\r\n    children.forEach(child => {\r\n        const src = child.get('source');\r\n        if (!src.anchor || src.id !== original.id) return;\r\n        const r = src.anchor.args.ratio;\r\n        const segIndex = Math.min(\r\n            segmentCount - 1,\r\n            Math.floor(r * segmentCount)\r\n        );\r\n        const localRatio =\r\n            (r * segmentCount) - segIndex;\r\n        child.set('source', {\r\n            id: segments[segIndex].id,\r\n            anchor: {\r\n                name: 'connectionRatio',\r\n                args: { ratio: localRatio }\r\n            }\r\n        });\r\n    });\r\n    const labels = original.get('labels') || [];\r\n    labels.forEach(label => {\r\n        const d = label.position.distance;\r\n        const segIndex = Math.min(segmentCount - 1, Math.floor(d * segmentCount));\r\n        const localDistance = (d * segmentCount) - segIndex;\r\n        segments[segIndex].appendLabel({\r\n            attrs: label.attrs,\r\n            position: { distance: localDistance, angle: label.position.angle }\r\n        });\r\n    });\r\n    // 4ï¸â£ replace original\r\n    original.remove();\r\n    graph.addCells(segments);\r\n    return segments;\r\n}\r\nfunction getVertexIndexFromMouse(linkView, paper, evt, tolerance = 10) {\r\n    const link = linkView.model;\r\n    const vertices = link.vertices() || [];\r\n    if (!vertices.length) return -1;\r\n    const mousePoint = paper.clientToLocalPoint({\r\n        x: evt.clientX,\r\n        y: evt.clientY\r\n    });\r\n    let minDist = Infinity;\r\n    let closestIndex = -1;\r\n    vertices.forEach((v, index) => {\r\n        const dx = v.x - mousePoint.x;\r\n        const dy = v.y - mousePoint.y;\r\n        const dist = Math.sqrt(dx * dx + dy * dy);\r\n        if (dist < tolerance && dist < minDist) {\r\n            minDist = dist;\r\n            closestIndex = index;\r\n        }\r\n    });\r\n    return closestIndex;\r\n}\r\nconst menuEl = document.getElementById('vertex-menu');\r\nfunction showVertexMenu({ x, y, linkView, vertexIndex }) {\r\n    colorMenu.style.display = 'none';\r\n    const paperRect = paper.el.getBoundingClientRect();\r\n    // Convert viewport coordinates to paper-local coordinates\r\n    const left = x - paperRect.left;\r\n    const top = y - paperRect.top;\r\n    menuEl.style.left = left + 'px';\r\n    menuEl.style.top = top + 'px';\r\n    menuEl.style.display = 'block';\r\n    menuEl.onclick = e => {\r\n        const action = e.target.dataset.action;\r\n        if (!action) return;\r\n        if (action === 'delete') {\r\n            deleteVertex(linkView, vertexIndex);\r\n        }\r\n        menuEl.style.display = 'none';\r\n        menuOpen = false;\r\n    };\r\n}\r\nconst colorMenu = document.getElementById('link-color-menu');\r\nlet activeLinkId = null;\r\nlet activeSegmentIndex = null;\r\nfunction showLinkColorMenu({ x, y, linkView, segmentIndex }) {\r\n    menuEl.style.display = 'none';\r\n    const paperRect = paper.el.getBoundingClientRect();\r\n    // Convert viewport coordinates to paper-local coordinates\r\n    const left = x - paperRect.left;\r\n    const top = y - paperRect.top;\r\n    colorMenu.style.left = left + 'px';\r\n    colorMenu.style.top = top + 'px';\r\n    colorMenu.style.display = 'block';\r\n    activeLinkId = linkView.model.id;\r\n    activeSegmentIndex = segmentIndex;\r\n    colorMenu.onclick = e => {\r\n        if (!activeLinkId) return;\r\n        const link = graph.getCell(activeLinkId);\r\n        const color = e.target.dataset.color;\r\n        if (!link) return;\r\n        const linkView = paper.findViewByModel(link);\r\n        if (!linkView) return;\r\n        if (color){\r\n            executeWithSnapshot(graph, () => {\r\n                splitLinkWithChildren(linkView, activeSegmentIndex, color);\r\n            });\r\n            colorMenu.style.display = 'none';\r\n        }else{\r\n            const action = e.target.dataset.action;\r\n            if (!action) return;\r\n            if (action === 'hide-label') {\r\n                hideAllLinkLabels()\r\n                \r\n            }else if(action === 'show-label') {\r\n                showAllLinkLabels();\r\n            }else if(action==='add-rectangle'){\r\n                insertRectangleOnLink(link,x,y);\r\n            }else if(action==='divide-segment'){                \r\n                executeWithSnapshot(graph, () => {\r\n                    splitLinkAtPointWithRectangle(linkView, x,y);\r\n                });\r\n            }\r\n            colorMenu.style.display = 'none';\r\n        }\r\n        \r\n        menuOpen = false;\r\n    };\r\n}\r\nfunction snapshotGraph(graph) {\r\n    return graph.toJSON({ deep: true }); // full state of graph\r\n}\r\nfunction executeWithSnapshot(graph, fn) {\r\n    const before = snapshotGraph(graph); // capture before state\r\n    isRestoring = true; // ignore add/remove events\r\n    graph.startBatch();\r\n    fn(); // your operation, e.g., splitLinkWithChildren\r\n    graph.stopBatch();\r\n    isRestoring = false;\r\n    const after = snapshotGraph(graph); // capture after state\r\n    undoStack.push([{ type: 'snapshot', before, after }]);\r\n\r\n    // pushOperation([{\r\n    //     type: 'snapshot',\r\n    //     before,\r\n    //     after\r\n    // }]);\r\n    redoStack.length = 0;\r\n}\r\nfunction updateRectanglePosition(rect) {\r\n\r\n      const attachment = rect.get('linkAttachment');\r\n    if (!attachment) return;\r\n\r\n    const link = graph.getCell(attachment.linkId);\r\n    if (!link) return;\r\n\r\n    const linkView = paper.findViewByModel(link);\r\n    if (!linkView) return;\r\n\r\n    const connection = linkView.getConnection();\r\n    const totalLength = connection.length();\r\n    if (!totalLength) return;\r\n\r\n    // ð¹ Use let so ratio can be adjusted\r\n    let ratio = attachment.ratio;\r\n\r\n    // ð¹ Ensure no overlap with other rectangles on same link\r\n    const existingRects = graph.getElements().filter(el => {\r\n        const a = el.get('linkAttachment');\r\n        return a && a.linkId === link.id && el.id !== rect.id;\r\n    });\r\n\r\n    const minDistance = rect.size().width / totalLength; // minimum spacing along link\r\n\r\n    existingRects.forEach(el => {\r\n        const r = el.get('linkAttachment').ratio;\r\n        if (Math.abs(r - ratio) < minDistance) {\r\n            if (ratio < r) ratio = r - minDistance;\r\n            else ratio = r + minDistance;\r\n        }\r\n    });\r\n\r\n    ratio = Math.max(0, Math.min(1, ratio)); // clamp between 0 and 1\r\n\r\n    // ð¹ Store updated ratio\r\n    //rect.set('linkAttachment', { linkId: link.id, ratio });\r\n    if (!isRestoring) {\r\n        rect.set('linkAttachment', { linkId: link.id, ratio });\r\n    } else {\r\n        rect.attributes.linkAttachment = { linkId: link.id, ratio };\r\n    }\r\n\r\n    // ð¹ Get position along link\r\n    const point = connection.pointAt(ratio);\r\n    if (!point) return;\r\n\r\n    // compute tangent manually\r\n    const delta = Math.min(0.01, 1 / totalLength);\r\n    const before = connection.pointAt(Math.max(0, ratio - delta));\r\n    const after  = connection.pointAt(Math.min(1, ratio + delta));\r\n    if (!before || !after) return;\r\n\r\n    const tangent = { x: after.x - before.x, y: after.y - before.y };\r\n    let angle = _joint_core__WEBPACK_IMPORTED_MODULE_1__.g.toDeg(Math.atan2(tangent.y, tangent.x));\r\n    //if (angle > 90 || angle < -90) angle += 180;\r\n    // Smooth angle to prevent flipping\r\n    const prevAngle = rect.rotation || angle;\r\n    if (angle - prevAngle > 90) angle -= 180;\r\n    else if (angle - prevAngle < -90) angle += 180;\r\n\r\n    let curvature = 0;\r\n\r\n    if (before && after) {\r\n        const dx1 = point.x - before.x;\r\n        const dy1 = point.y - before.y;\r\n        const dx2 = after.x - point.x;\r\n        const dy2 = after.y - point.y;\r\n\r\n        const angle1 = Math.atan2(dy1, dx1);\r\n        const angle2 = Math.atan2(dy2, dx2);\r\n\r\n        curvature = Math.abs(angle2 - angle1);\r\n    }\r\n\r\n    // ð¥ Dynamic height based on curvature\r\n    const baseWidth = 60;\r\n    const baseHeight = 30;\r\n\r\n    const dynamicHeight = baseHeight - (curvature * totalLength * 0.1);//baseHeight - (curvature * 40);\r\n// const localLength = Math.sqrt((after.x - before.x)**2 + (after.y - before.y)**2);\r\n// const dynamicHeight = Math.max(12, Math.min(baseHeight, localLength*0.8, baseHeight - curvature*totalLength*0.1));\r\n\r\n    const finalHeight = Math.max(12, dynamicHeight);\r\n\r\n    rect.resize(baseWidth, finalHeight);\r\n\r\n    rect.position(\r\n        point.x - baseWidth / 2,\r\n        point.y - finalHeight / 2\r\n    );\r\n    rect.rotate(angle, true);\r\n}\r\n\r\n\r\n\r\nfunction insertRectangleOnLink(link,x,y) {\r\n    graph.startBatch();\r\n    const linkView = paper.findViewByModel(link);\r\n    if (!linkView) return;\r\n\r\n    const localPoint = paper.clientToLocalPoint({\r\n        x: x,\r\n        y: y\r\n    });\r\n\r\n    const connection = linkView.getConnection();\r\n\r\n    const totalLength = connection.length();\r\n    const closestLength = connection.closestPointLength(localPoint);\r\n    // let ratio = closestLength / totalLength;\r\n    // ratio = Math.max(0, Math.min(1, ratio));\r\n    // ratio = Math.round(ratio * 1000) / 1000; // optional: 0.001 precision\r\n    let ratio = Math.max(0, Math.min(1, closestLength / totalLength));\r\n    const rect = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.shapes.standard.Rectangle({\r\n        size: { width: 40, height: 30 }, // height will auto-adjust\r\n        attrs: {\r\n            body: { fill: '#4c4ed8', stroke: '#000000', strokeWidth: 2, rx: 10, ry: 10 },\r\n            //label: { text: 'Block', fill: '#000000' }\r\n        }\r\n    });\r\n\r\n    // store ratio on element\r\n    rect.set('linkAttachment', {\r\n        linkId: link.id,\r\n        ratio: ratio\r\n    });\r\n\r\n    graph.addCell(rect);\r\n    updateRectanglePosition(rect);\r\n    graph.stopBatch();\r\n}\r\npaper.on('element:pointermove', function(view, evt, x, y) {\r\n    const rect = view.model;\r\n    const attachment = rect.get('linkAttachment');\r\n    if (!attachment) return;\r\n\r\n    const link = graph.getCell(attachment.linkId);\r\n    if (!link) return;\r\n\r\n    const linkView = paper.findViewByModel(link);\r\n    if (!linkView) return;\r\n\r\n    const connection = linkView.getConnection();\r\n\r\n    const totalLength = connection.length();\r\n    const closestLength = connection.closestPointLength({ x, y });\r\n    const ratio = closestLength / totalLength;\r\n\r\n    rect.set('linkAttachment', {\r\n        linkId: attachment.linkId,\r\n        ratio: ratio\r\n    });\r\n\r\n    updateRectanglePosition(rect);\r\n});\r\nconst dragStartPosition = new Map();\r\n\r\npaper.on('element:pointerdown', (view, evt) => {\r\n    const rect = view.model;\r\n    if (!rect.get('linkAttachment')) return;\r\n    // store initial position before drag for undo\r\n    dragStartPosition.set(rect.id, rect.get('linkAttachment').ratio);\r\n});\r\n\r\npaper.on('element:pointerup', (view, evt) => {\r\n    const rect = view.model;\r\n    const attachment = rect.get('linkAttachment');\r\n    if (!attachment) return;\r\n\r\n    const startRatio = dragStartPosition.get(rect.id);\r\n    dragStartPosition.delete(rect.id);\r\n\r\n    const endRatio = rect.get('linkAttachment').ratio;\r\n\r\n    if (startRatio === undefined || startRatio === endRatio) return;\r\n\r\n    pushOperation({\r\n        type: 'moveAttachment',\r\n        element: rect,\r\n        from: startRatio,\r\n        to: endRatio\r\n    });\r\n});\r\n\r\n\r\nfunction splitLinkAtPointWithRectangle(linkView, x,y) {\r\n\r\n    const graph = linkView.model.graph;\r\n    const original = linkView.model;\r\n\r\n    const localPoint = paper.clientToLocalPoint(x, y);\r\n    const connection = linkView.getConnection();\r\n    if (!connection) return;\r\n\r\n    const totalLength = connection.length();\r\n    if (!totalLength) return;\r\n\r\n    const lengthAtPoint = connection.closestPointLength(localPoint);\r\n    let ratio = lengthAtPoint / totalLength;\r\n\r\n    // prevent extreme edge split\r\n    ratio = Math.max(0.001, Math.min(0.999, ratio));\r\n\r\n    const splitPoint = connection.pointAtLength(lengthAtPoint);\r\n    if (!splitPoint) return;\r\n\r\n    const source = original.get('source');\r\n    const target = original.get('target');\r\n    const router = original.get('router');\r\n    const connector = original.get('connector');\r\n    const baseLineAttrs = original.attr('line') || {};\r\n    const z = original.get('z') || 1;\r\n\r\n    // 1ï¸â£ Create rectangle\r\n    const width = 60;\r\n    const height = 30;\r\n    \r\n    const rect = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.shapes.standard.Rectangle();\r\n\r\n    rect.resize(width, height);\r\n\r\n    rect.position(\r\n        localPoint.x - width / 2,\r\n        localPoint.y - height / 2\r\n    );\r\n    rect.attr({\r\n        body: { fill: '#4c4ed8', stroke: '#000000' }\r\n    });\r\n    graph.addCell(rect);\r\n\r\n    const vertices = original.get('vertices') || [];\r\n    const leftVertices = [];\r\n    const rightVertices = [];\r\n\r\n    vertices.forEach(v => {\r\n        const ptLength = connection.closestPointLength(v);\r\n        const ptRatio = ptLength / connection.length();\r\n\r\n        if (ptRatio <= ratio) {\r\n            leftVertices.push({ ...v });\r\n        } else {\r\n            rightVertices.push({ ...v });\r\n        }\r\n    });\r\n\r\n    // 2ï¸â£ Create new links\r\n    const leftLink = new Branch({\r\n        source,\r\n        target: { id: rect.id },\r\n        router,\r\n        connector,\r\n        attrs: { line: { ...baseLineAttrs } }\r\n    });\r\n    leftLink.set('vertices', leftVertices);\r\n    const rightLink = new Branch({\r\n        source: { id: rect.id },\r\n        target,\r\n        router,\r\n        connector,\r\n        attrs: { line: { ...baseLineAttrs } }\r\n    });\r\n    rightLink.set('vertices', rightVertices);\r\n\r\n    leftLink.set({ z });\r\n    rightLink.set({ z });\r\n\r\n    graph.addCells([leftLink, rightLink]);\r\n\r\n    // -----------------------------\r\n    // ð Reattach CHILD LINKS\r\n    // -----------------------------\r\n    const children = graph.getConnectedLinks(original, { outbound: true });\r\n\r\n    children.forEach(child => {\r\n        const src = child.get('source');\r\n        if (!src.anchor || src.id !== original.id) return;\r\n\r\n        const r = src.anchor.args.ratio;\r\n\r\n        if (r <= ratio) {\r\n\r\n            const newRatio = r / ratio;\r\n\r\n            child.set('source', {\r\n                id: leftLink.id,\r\n                anchor: {\r\n                    name: 'connectionRatio',\r\n                    args: { ratio: newRatio }\r\n                }\r\n            });\r\n\r\n        } else {\r\n\r\n            const newRatio = (r - ratio) / (1 - ratio);\r\n\r\n            child.set('source', {\r\n                id: rightLink.id,\r\n                anchor: {\r\n                    name: 'connectionRatio',\r\n                    args: { ratio: newRatio }\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    // -----------------------------\r\n    // ð· Preserve LABELS\r\n    // -----------------------------\r\n    const labels = original.get('labels') || [];\r\n\r\n    labels.forEach(label => {\r\n\r\n        const d = label.position.distance;\r\n\r\n        if (d <= ratio) {\r\n\r\n            const newDistance = d / ratio;\r\n\r\n            leftLink.appendLabel({\r\n                attrs: label.attrs,\r\n                position: {\r\n                    distance: newDistance,\r\n                    angle: label.position.angle\r\n                }\r\n            });\r\n\r\n        } else {\r\n\r\n            const newDistance = (d - ratio) / (1 - ratio);\r\n\r\n            rightLink.appendLabel({\r\n                attrs: label.attrs,\r\n                position: {\r\n                    distance: newDistance,\r\n                    angle: label.position.angle\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    // finally remove original\r\n    original.remove();\r\n\r\n    return { rect, leftLink, rightLink };\r\n}\r\n\r\n\r\nfunction hideAllLinkLabels() {\r\n    graph.getLinks().forEach(link => {\r\n        const labels = link.labels();\r\n\r\n        labels.forEach((label, index) => {\r\n            link.label(index, {\r\n                attrs: {\r\n                    labelText: { display: 'none' },\r\n                    labelBackground: { display: 'none' },\r\n                    line: { display: 'none' },\r\n                }\r\n            });\r\n        });\r\n    });\r\n}\r\nfunction showAllLinkLabels(){\r\n    graph.getLinks().forEach(link => {\r\n        const labels = link.labels();\r\n        labels.forEach((label, index) => {\r\n            link.label(index, {\r\n                attrs: {\r\n                    labelText: { display: 'block' },\r\n                    labelBackground: { display: 'block' },\r\n                    line: { display: 'block' },\r\n                }\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\nfunction colorLinkSharp(linkView, color) {\r\n    linkView.model.attr({\r\n        line: {\r\n            fill: color,\r\n            filter: null               // remove any SVG blur\r\n        }\r\n    });\r\n}\r\nlet menuOpen = false;\r\n// paper.on('blank:pointerdown element:pointerdown', () => {\r\n//     menuEl.style.display = 'none';\r\n//     colorMenu.style.display = 'none';\r\n//     menuOpen = false;\r\n// });\r\nfunction onBlankAndElementdownClick(e) {\r\n    menuEl.style.display = 'none';\r\n    colorMenu.style.display = 'none';\r\n    menuOpen = false;\r\n    activeLabelEditor?.remove();\r\n    activeLabelEditor = null;\r\n}\r\nfunction deleteVertex(linkView, vertexIndex) {\r\n    const link = linkView.model;\r\n    let vertices = link.vertices() || [];\r\n    // Fallback: if vertexIndex is -1 and there is at least 1 vertex, delete the first one\r\n    if (vertexIndex === -1 && vertices.length > 0) {\r\n        vertexIndex = 0;\r\n    }\r\n    if (vertexIndex < 0 || vertexIndex >= vertices.length) {\r\n        return;\r\n    }\r\n    const newVertices = vertices.slice();\r\n    newVertices.splice(vertexIndex, 1);\r\n    link.set('vertices', newVertices);\r\n}\r\n// Move the labels layer to the front so that the labels are not covered\r\n// by the link tools.\r\nconst labelLayerEl = paper.getLayerNode('labels');\r\nlabelLayerEl.parentElement.appendChild(labelLayerEl);\r\n// Events\r\nfunction onPaperLinkMouseEnter(linkView) {\r\n    if (menuOpen) return;\r\n    // Scale the tools based on the width of the link.\r\n    const branchWidth = linkView.model.attr('line/organicStrokeSize') || 5;\r\n    const scale = Math.max(1, Math.min(2, branchWidth / 5));\r\n    const toolsView = new _joint_core__WEBPACK_IMPORTED_MODULE_1__.dia.ToolsView({\r\n        tools: [\r\n            new _joint_core__WEBPACK_IMPORTED_MODULE_1__.linkTools.Vertices({\r\n                snapRadius: 0,              // allow very close placement\r\n                redundancyRemoval: false,   // DO NOT auto-remove\r\n                vertexAdding: true\r\n            }),\r\n            new _joint_core__WEBPACK_IMPORTED_MODULE_1__.linkTools.SourceAnchor({ restrictArea: false, scale }),\r\n            //new joint.linkTools.Remove({ scale }),\r\n        ],\r\n    });\r\n    linkView.addTools(toolsView);\r\n}\r\nfunction onPaperLinkMouseLeave(linkView) {\r\n    if (menuOpen) return; // keep tools visible while menu is open\r\n    linkView.removeTools();\r\n}\r\nfunction onPaperElementPointerclick(elementView) {\r\n    paper.removeTools();\r\n    _joint_core__WEBPACK_IMPORTED_MODULE_1__.highlighters.mask.removeAll(paper);\r\n    _joint_core__WEBPACK_IMPORTED_MODULE_1__.highlighters.mask.add(elementView, 'border', 'node-hgl', {\r\n        attrs: {\r\n            stroke: colors.highlight,\r\n            'stroke-width': 2,\r\n        },\r\n    });\r\n    // elementView.addTools(\r\n    //     new joint.dia.ToolsView({\r\n    //         tools: [\r\n    //             new RotateTool({\r\n    //                 selector: 'border',\r\n    //             }),\r\n    //         ],\r\n    //     })\r\n    // );\r\n}\r\nfunction onBlankPointerclick() {\r\n    paper.removeTools();\r\n    _joint_core__WEBPACK_IMPORTED_MODULE_1__.highlighters.mask.removeAll(paper);\r\n}\r\npaper.on({\r\n    'link:mouseenter': onPaperLinkMouseEnter,\r\n    'link:mouseleave': onPaperLinkMouseLeave,\r\n    'element:pointerclick': onPaperElementPointerclick,\r\n    'blank:pointerclick': onBlankPointerclick,\r\n    'blank:pointerdown': onBlankAndElementdownClick,\r\n    'element:pointerdown': onBlankAndElementdownClick,\r\n});\r\nlet activeLabelEditor = null;\r\nfunction makeLabelEditable(link, labelIndex = 0) {\r\n    if (activeLabelEditor) {\r\n        activeLabelEditor.remove();\r\n        activeLabelEditor = null;\r\n    }\r\n    const label = link.get('labels')?.[labelIndex];\r\n    if (!label) return;\r\n    const linkView = link.findView(paper);\r\n    if (!linkView) return;\r\n    const offset = label.position?.offset || { x: 0, y: 0 };\r\n    const bbox = linkView.getBBox({ useModelGeometry: true });\r\n    const labelX = bbox.x + offset.x;\r\n    const labelY = bbox.y + offset.y;\r\n    // Create a container div for input + buttons\r\n    const container = document.createElement('div');\r\n    container.style.position = 'absolute';\r\n    //container.style.left = `${labelX}px`;\r\n    //container.style.top = `${labelY}px`;\r\n    container.style.display = 'inline-flex';\r\n    container.style.alignItems = 'center';\r\n    container.style.gap = '5px';\r\n    container.style.zIndex = 9999;\r\n    const paperRect = paper.el.getBoundingClientRect();\r\n    container.style.left = `${labelX}px`;\r\n    container.style.top = `${labelY}px`;\r\n    // Stop clicks from propagating to paper\r\n    container.addEventListener('mousedown', e => e.stopPropagation());\r\n    container.addEventListener('click', e => e.stopPropagation());\r\n    activeLabelEditor = container; // ð track active editor\r\n    // Create input\r\n    const input = document.createElement('input');\r\n    input.type = 'text';\r\n    input.value = label.attrs?.labelText?.text || '';\r\n    input.style.fontSize = '14px';\r\n    input.style.fontFamily = 'sans-serif';\r\n    input.style.width = '120px';\r\n    input.style.height = '25px';\r\n    container.appendChild(input);\r\n    // Create Save button\r\n    const saveBtn = document.createElement('button');\r\n    saveBtn.textContent = 'Save';\r\n    saveBtn.style.height = '25px';\r\n    saveBtn.addEventListener('click', () => {\r\n        if (input.value.trim() !== '') {\r\n            graph.startBatch('label-edit');\r\n            link.label(labelIndex, {\r\n                attrs: {\r\n                    labelText: { text: input.value },\r\n                },\r\n            });\r\n            graph.stopBatch('label-edit');\r\n        }\r\n        container.remove();\r\n        activeLabelEditor = null;\r\n    });\r\n    container.appendChild(saveBtn);\r\n    // Create Cancel button\r\n    const cancelBtn = document.createElement('button');\r\n    cancelBtn.textContent = 'Cancel';\r\n    cancelBtn.style.height = '25px';\r\n    cancelBtn.addEventListener('click', () => {\r\n        container.remove();\r\n        activeLabelEditor = null;\r\n    });\r\n    container.appendChild(cancelBtn);\r\n    //document.body.appendChild(container);\r\n    paper.el.appendChild(container);\r\n    input.focus();\r\n    // Optional: handle Enter / Escape keys\r\n    input.addEventListener('keydown', (e) => {\r\n        if (e.key === 'Enter') saveBtn.click();\r\n        if (e.key === 'Escape') cancelBtn.click();\r\n    });\r\n}\r\n// Attach to double-click anywhere on paper\r\npaper.on('link:pointerdblclick', (linkView, evt) => {\r\n    evt.stopPropagation();\r\n    const target = evt.target;\r\n    // â Ignore dblclicks coming from vertices\r\n    if (target.closest('.joint-vertex')) return;\r\n    // â Ignore link path\r\n    if (target.closest('[joint-selector=\"line\"]')) return;\r\n    // â Allow only label text or label background\r\n    const labelText = target.closest('[joint-selector=\"labelText\"]');\r\n    const labelBg = target.closest('[joint-selector=\"labelBackground\"]');\r\n    if (!labelText && !labelBg) return;\r\n    const labelGroup = target.closest('g.label');\r\n    if (!labelGroup) return;\r\n    // ð Read label index\r\n    const labelIndex = parseInt(labelGroup.getAttribute('label-idx'), 10);\r\n    if (Number.isNaN(labelIndex)) return;\r\n    makeLabelEditable(linkView.model, labelIndex);\r\n});\r\n// Species\r\n// -------\r\n//const porifera = new Species({\r\n//    id: 'Porifera',\r\n//    position: { x: 696, y: 552 },\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Porifera',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/porifera.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const cnidaria = new Species({\r\n//    id: 'Cnidaria',\r\n//    position: { x: 264, y: 432 },\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Cnidaria',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/cnidaria.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const cnidaria2 = new Species({\r\n//    id: 'Cnidaria2',\r\n//    position: { x: 330, y: 396 },\r\n//    z: -1,\r\n//    angle: 15,\r\n//    attrs: {\r\n//        icon: {\r\n//            xlinkHref: 'assets/cnidaria2.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const platyhelmintha = new Species({\r\n//    id: 'platyhelmintha',\r\n//    position: { x: 768, y: 400 },\r\n//    angle: -25,\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Platyhelmintha',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/platyhelmintha.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const brachiopoda = new Species({\r\n//    id: 'Brachiopoda',\r\n//    position: { x: 840, y: 248 },\r\n//    angle: -25,\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Brachiopoda',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/brachiopoda.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const annelida = new Species({\r\n//    id: 'Annelida',\r\n//    position: { x: 936, y: 112 },\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Annelida',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/annelida.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const mollusca = new Species({\r\n//    id: 'Mollusca',\r\n//    position: { x: 856, y: 8 },\r\n//    angle: -20,\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Mollusca',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/mollusca.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const tarigrada = new Species({\r\n//    id: 'Tarigrada',\r\n//    position: { x: 560, y: -136 },\r\n//    angle: 15,\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Tarigrada',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/tarigrada.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const arthropoda = new Species({\r\n//    id: 'Arthropoda',\r\n//    position: { x: 784, y: -105 },\r\n//    angle: -45,\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Arthropoda',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/arthropoda.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const nematoda = new Species({\r\n//    id: 'Nematoda',\r\n//    position: { x: 432, y: -56 },\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Nematoda',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/nematoda.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const echinodermata = new Species({\r\n//    id: 'Echinodermata',\r\n//    position: { x: 56, y: 128 },\r\n//    angle: 30,\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Echinodermata',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/echinodermata.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const chordata = new Species({\r\n//    id: 'Chordata',\r\n//    position: { x: 256, y: 8 },\r\n//    angle: 45,\r\n//    attrs: {\r\n//        label: {\r\n//            text: 'Chordata',\r\n//        },\r\n//        icon: {\r\n//            xlinkHref: 'assets/chordata.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const chordata2 = new Species({\r\n//    id: 'Chordata2',\r\n//    position: { x: 290, y: -70 },\r\n//    z: -1,\r\n//    angle: 15,\r\n//    attrs: {\r\n//        icon: {\r\n//            xlinkHref: 'assets/chordata2.svg',\r\n//        },\r\n//    },\r\n//});\r\n//const chordata3 = new Species({\r\n//    id: 'Chordata3',\r\n//    position: { x: 206, y: -60 },\r\n//    z: -1,\r\n//    angle: -20,\r\n//    attrs: {\r\n//        icon: {\r\n//            xlinkHref: 'assets/chordata3.svg',\r\n//        },\r\n//    },\r\n//});\r\n//chordata.embed([chordata2, chordata3]);\r\n//cnidaria.embed([cnidaria2]);\r\n//graph.addCells([\r\n//    porifera,\r\n//    cnidaria,\r\n//    cnidaria2,\r\n//    platyhelmintha,\r\n//    brachiopoda,\r\n//    annelida,\r\n//    mollusca,\r\n//    tarigrada,\r\n//    arthropoda,\r\n//    nematoda,\r\n//    echinodermata,\r\n//    chordata,\r\n//    chordata2,\r\n//    chordata3,\r\n//]);\r\n// Branches\r\n// --------\r\nconst origin = { x: 352, y: -62 };\r\nconst laLink = new Branch({\r\n    source: origin,\r\n    target: { x: 83, y: 213 },\r\n    vertices: [{ x: 352, y: 46 }, { x: 176, y: 104 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'PRCA',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.65,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst lbLink = new Branch({\r\n    source: {\r\n        id: laLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: -30, y: 620 },\r\n    vertices: [{ x: -10, y: 369 }, { x: -70, y: 509 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'MRCA',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst lcLink = new Branch({\r\n    source: {\r\n        id: lbLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 181, y: 611 },\r\n    vertices: [{ x: 72, y: 663 }, { x: 118, y: 614 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'DRCA',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst ldLink = new Branch({\r\n    source: {\r\n        id: lbLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 97, y: 859 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 16,\r\n            organicStrokeThinning: 0.8, \r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'AMARG',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst raLink = new Branch({\r\n    source: {\r\n        id: laLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 0.2 } },\r\n    },\r\n    target: { x: 523, y: 134 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'PLM',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rbLink = new Branch({\r\n    source: {\r\n        id: raLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 675, y: 225 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'PLAD',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rcLink = new Branch({\r\n    source: {\r\n        id: rbLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 933, y: 426 },\r\n    vertices: [{ x: 840, y: 309 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'D1',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rdLink = new Branch({\r\n    source: {\r\n        id: rbLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 832, y: 504 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'MLAD',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst reLink = new Branch({\r\n    source: {\r\n        id: rdLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 0.5 } },\r\n    },\r\n    target: { x: 1019, y: 557 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'D2',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rfLink = new Branch({\r\n    source: {\r\n        id: rdLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 916, y: 764 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 16,\r\n            organicStrokeThinning: 0.8, \r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'DLAD',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rfLink2 = new Branch({\r\n    source: {\r\n        id: rfLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 0.3 } },\r\n    },\r\n    target: { x: 785, y: 757 },\r\n    vertices: [{ x: 836, y: 649 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 13,\r\n            organicStrokeThinning: 0.8, \r\n        },\r\n    },\r\n});\r\nconst rgLink = new Branch({\r\n    source: {\r\n        id: raLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 767, y: 583 },\r\n    vertices: [{ x: 678, y: 388 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'Lat Ramus',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rhLink = new Branch({\r\n    source: {\r\n        id: raLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 468, y: 260 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'PCIRC',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst riLink = new Branch({\r\n    source: {\r\n        id: rhLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 684, y: 622 },\r\n    vertices: [{ x: 525, y: 382 }, { x: 602, y: 468 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: '1st OM',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rjLink = new Branch({\r\n    source: {\r\n        id: rhLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 407, y: 382 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'mCIRC',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rkLink = new Branch({\r\n    source: {\r\n        id: rjLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 584, y: 677 },\r\n    vertices: [{ x: 464, y: 502 }, { x: 532, y: 581 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: '2nd OM',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rlLink = new Branch({\r\n    source: {\r\n        id: rjLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 1 } },\r\n    },\r\n    target: { x: 287, y: 598 },\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: 'dCIRC',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\nconst rmLink = new Branch({\r\n    source: {\r\n        id: rlLink.id,\r\n        anchor: { name: 'connectionRatio', args: { ratio: 0.5 } },\r\n    },\r\n    target: { x: 512, y: 738 },\r\n    vertices: [{ x: 409, y: 627 }],\r\n    attrs: {\r\n        line: {\r\n            organicStrokeSize: 30,\r\n        },\r\n    },\r\n    labels: [\r\n        {\r\n            attrs: {\r\n                labelText: {\r\n                    text: '3rd OM',\r\n                },\r\n            },\r\n            position: {\r\n                distance: 0.45,\r\n                angle: 10,\r\n            },\r\n        },\r\n    ],\r\n});\r\ngraph.addCells([\r\n    laLink,\r\n    lbLink,\r\n    lcLink,\r\n    ldLink,\r\n    raLink,\r\n    rbLink,\r\n    rcLink,\r\n    rdLink,\r\n    reLink,\r\n    rfLink,\r\n    rfLink2,\r\n    rgLink,\r\n    rhLink,\r\n    riLink,\r\n    rjLink,\r\n    rkLink,\r\n    rlLink,\r\n    rmLink\r\n]);\r\n// Fit the content of the paper to the viewport.\r\n// ---------------------------------------------\r\npaper.transformToFitContent({\r\n    horizontalAlign: 'middle',\r\n    verticalAlign: 'middle',\r\n    padding: 50,\r\n    useModelGeometry: true,\r\n});\r\n// function ensureToolsLayerOnTop(paper) {\r\n//     const svg = paper.svg;\r\n//     const toolsLayer = svg.querySelector('.joint-tools-layer');\r\n\r\n//     if (toolsLayer) {\r\n//         svg.appendChild(toolsLayer); // move to end â always on top\r\n//     }\r\n// }\r\n// paper.on('render:done', function () {\r\n//     ensureToolsLayerOnTop(paper);\r\n// });\r\nfunction refreshPaper() {\r\n    if (!paper) return;\r\n\r\n    // Force update of all views\r\n    paper.model.getCells().forEach(cell => {\r\n        const view = paper.findViewByModel(cell);\r\n        if (view) view.update();\r\n    });\r\n}\r\nhideAllLinkLabels();\r\nsetTimeout(() => {\r\n    paper.unfreeze();\r\n}, 0);\r\n\n\n//# sourceURL=webpack://svg-experiment/./src/index.js?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;