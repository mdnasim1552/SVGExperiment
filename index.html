<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>External SVG Click</title>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <style>

        #svgContainer svg {
            width: 300px;
            height: 300px;
            cursor: pointer;
        }
        #mysvg {
            width: 500px;
            height: 500px;
            border: 1px solid #ccc;
            cursor: crosshair;
            background: #fff;
        }
        #colorPickerContainer {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    #colorPicker {
        width: 50px;
        height: 30px;
        border: 1px solid #ccc;
        cursor: pointer;
    }
    </style>
</head>
<body>

<div id="svgContainer"></div>
<div id="colorPickerContainer">
    <label for="colorPicker">Choose color:</label>
    <input type="color" id="colorPicker" value="#555555">
    <span>Current color:</span>
    <div id="currentColor" style="width:30px; height:30px; border:1px solid #ccc; background:#555"></div>
    <label for="strokeWidth">Stroke Width:</label>
    <input type="range" id="strokeWidth" min="0.1" max="3" step="0.1" value="0.4">
    <span id="strokeValue">0.4</span>
    <label for="tool">Tool:</label>
    <select id="tool">
        <option value="pencil">Pencil</option>
        <option value="eraserPaint">Eraser (Paint)</option>
        <option value="eraserRemove">Eraser (Remove)</option>
    </select>
</div>
<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" id="mysvg">

    <g id="paintLayerid" stroke="#555" fill="none"></g>

</svg>
<script>
$(function () {

    // Load external SVG and inject into DOM
    $('#svgContainer').load('icon.svg', function () {

        // Now SVG is inline â†’ jQuery works
       $('#id2').on('click', function () {

            const currentStroke = $(this).attr('stroke');

            $(this).attr(
                'stroke',
                currentStroke === 'yellow' ? 'red' : 'yellow'
            );
        });


    });

    let drawing = false;
    let pathElement;
    let d = '';
    let currentColor = $('#colorPicker').val();
    let currentWidth = parseFloat($('#strokeWidth').val());
    let currentTool = $('#tool').val();
    const svg = $('#mysvg');
    const paintLayer = $('#paintLayerid');
    const allPaths = []; // keep track of all strokes

   // Color picker
    $('#colorPicker').on('input', function() {
        currentColor = $(this).val();
        $('#currentColor').css('background', currentColor);
    });

    // Stroke width slider
    $('#strokeWidth').on('input', function() {
        currentWidth = parseFloat($(this).val());
        $('#strokeValue').text(currentWidth);
    });
    $('#tool').on('change', function() {
            currentTool = $(this).val();
            currentColor=currentTool === 'eraserPaint' ? '#ffffff' : $('#colorPicker').val();
        });

    function getMousePos(evt) {
        const svgRect = svg[0].getBoundingClientRect();
        const scaleX = 32 / svgRect.width;
        const scaleY = 32 / svgRect.height;
        return {
            x: (evt.clientX - svgRect.left) * scaleX,
            y: (evt.clientY - svgRect.top) * scaleY
        };
    }
// Simple hit-test: check if cursor is near path (approximate)
    function isNearPath(pathEl, x, y) {
        const pathLength = pathEl.getTotalLength();
        const step = 1; // smaller step = more precise
        for (let i = 0; i <= pathLength; i += step) {
            const pt = pathEl.getPointAtLength(i);
            const dx = pt.x - x;
            const dy = pt.y - y;
            if (Math.sqrt(dx*dx + dy*dy) < currentWidth*1.5) {
                return true;
            }
        }
        return false;
    }
    svg.on('mousedown', function(evt) {
        const pos = getMousePos(evt);

        if (currentTool === 'pencil' || currentTool === 'eraserPaint') {
            drawing = true;
            d = `M ${pos.x} ${pos.y}`;
            pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
            pathElement.setAttribute('stroke', currentColor);
            pathElement.setAttribute('stroke-width', currentWidth);
            pathElement.setAttribute('stroke-linecap', 'round');
            pathElement.setAttribute('stroke-linejoin', 'round');
            pathElement.setAttribute('fill', 'none');
            pathElement.setAttribute('d', d);
            paintLayer.append(pathElement);
            allPaths.push(pathElement);
        }// eraser: remove paths under cursor
        else if (currentTool === 'eraserRemove') {
            allPaths.forEach((p, index) => {
                if (isNearPath(p, pos.x, pos.y)) {
                    p.remove();
                    allPaths.splice(index,1);
                }
            });
        }
        
    });

    svg.on('mousemove', function(evt) {
        const pos = getMousePos(evt);
        if (drawing && (currentTool === 'pencil' || currentTool === 'eraserPaint')) {
            d += ` L ${pos.x} ${pos.y}`;
            pathElement.setAttribute('d', d);
            pathElement.setAttribute('stroke-width', currentWidth); // update width dynamically
        }
        else if (currentTool === 'eraserRemove' && evt.buttons) { // mouse down + eraser
            allPaths.forEach((p, index) => {
                if (isNearPath(p, pos.x, pos.y)) {
                    p.remove();
                    allPaths.splice(index,1);
                }
            });
        }
    });

    svg.on('mouseup mouseleave', function() {
        drawing = false;
        pathElement = null;
        d = '';
    });

});
</script>

</body>
</html>
